<HTML>

<HEAD>

<TITLE>Help</TITLE>

<STYLE type='text/css'>
PRE.EXAMPLE {background-color: #F1F1F1; padding: 2px; border: 1px solid #D1D1D1; font-family: monospace;}
TABLE.SYNOPSIS {font-family: monospace;}
TABLE.SIMPLE {border: 1px solid #D1D1D1; border-collapse: collapse;}
TD.BORDER {border: 1px solid #D1D1D1; padding: 2px;}
TR.HEADER {background-color: #F1F1F1; font-weight: bold;}
SPAN.MONOSPACE {font-family: monospace;}
TD.QUESTION {font-size: large; font-weight: bold; background-color: #C2C7E2;}
TABLE.FAQ {width:100%; border: 1px solid #D1D1D1; padding: 1px;}
LI.NOINDENT {margin-left: 0px;}
IMG {margin:5px 0px;}
H1.APISYMBOL {background-color:#F1F1F1; color:#326db9;}
H1 {color:#326db9;}
H2 {color:#326db9;}
H3 {color:#326db9;}
H4 {color:#326db9;}
H5 {color:#326db9;}
</STYLE>

</HEAD>

<BODY bgcolor="#FFFFFF" text="#000000">
<A NAME=top></A><HR>

<HR>
<A NAME=Introduction><H1>Introduction</H1></A><P>
 Last revised: 02/05/16<P>
<H1></H1><P>
<H2>What Is the OpenFlight API?</H2><P>
The <I>OpenFlight API</I> is a set of C header files and libraries that provides a 
programming interface to Creator and the OpenFlight database format. The API is divided 
conceptually into four levels: Read, Write, Extensions, and Tools. This document contains 
the reference pages for all levels of the OpenFlight API.  All levels of the API are available 
on the Windows platform. Levels 1, 2 and 3 are available on the Linux platform.<P>
<I>OpenFlight Script</I> is a cross-platform Python Language binding to the C Language OpenFlight API. 
Based on the Python scripting language, OpenFlight Script provides nearly all the functionality of 
the OpenFlight API. If you understand the concepts of the OpenFlight API, you 
will find programming in either the C Language API or OpenFlight Script very similar.<P>
You can use OpenFlight Script to do nearly everything you could otherwise do with the C Language API. 
In general, OpenFlight Script applications run more slowly than comparable tools written 
using the C Language API, so if performance is an issue, consider using the C Language API.<P>
<H2>Audience</H2><P>
This document is written for modelers and programmers who want to write stand-alone applications, 
plug-ins, or scripts using OpenFlight API interfaces.  To use the OpenFlight API, 
and this document, you should be comfortable with the American National Standards Institute 
(ANSI) C programming language and have some understanding of 3D modeling.  Familiarity 
with Presagis modeling tools and the OpenFlight format is helpful, but is not required.<P>
<H2>About This Document</H2><P>
This document provides detailed information on functions included in the OpenFlight API. 
This document is intended to be used in conjunction with the <I>OpenFlight API Developer Guide</I>.<P>
<H2>What can I distribute to others?</H2><P>
Users may develop and share their own content, code, and plug-ins freely at their own 
discretion. The OpenFlight API DLLs used by the applications and plug-ins you develop 
may only be distributed with a signed <I>Amendment to Software License Agreement</I>. 
This agreement includes a description of the intended use of the files, and outlines 
the usage rights.  This agreement (OpenFlight_API_Amendment_to_SLA_Presagis_051109.pdf) 
is included in the documentation folder of the OpenFlight API distribution or can be obtained 
by contacting Presagis for more information e-mail: openflight@presagis.com. Under no 
circumstances are you allowed to distribute the debug version of the OpenFlight 
API DLLs.<P>
<H2>What is not allowed?</H2><P>
Users of the OpenFlight API are not allowed under any circumstances to redistribute 
the header files, sample code, import libraries (.lib files), and documentation (including 
reference document, tutorials and any developers guides associated with the OpenFlight API 
and Presagis Creator software product).<P>
<H2>How to Contact Presagis</H2><P>
Technical Support:<BR> 
creator@presagis.com<BR> 
877 289-5670 (toll free)<BR> 
http://www.presagis.com<BR><P>
Creator Sales:<BR> 
sales@presagis.com<BR> 
http://www.presagis.com<BR><P>
<H2>Use and Disclosure of Data</H2><P>
PROPRIETARY NOTICE: This document, including the information contained herein, 
is confidential and/or proprietary to Presagis Canada Inc. and/or Presagis USA Inc. 
and shall not be reproduced or disclosed in whole or in part, or used for any 
purpose whatsoever without the prior written authorization of Presagis Canada Inc. 
or Presagis USA Inc.<P>
<HR>
<A NAME=OpenFlight_API_Release_Notes><H1>OpenFlight API Release Notes</H1></A><P>
 Last revised: 02/05/16<P>
This section contains the release notes for all versions of the 
OpenFlight API beginning with v2.1 and ending with the current version. 
The release notes are listed here in reverse chronological order (i.e., 
the most recent version first). In addition to version specific release notes, 
there is also a general release notes section here containing information 
applicable to the most current version.<P>
<H1>General</H1><P>
<H2>Visual Studio Compatibility</H2><P>
The OpenFlight API is distributed in the following binary formats for the 
Windows platform:<BR><P>
<TABLE CLASS="SIMPLE">
<P>
<TR CLASS="HEADER">
 
<TD CLASS="BORDER">
 Visual Studio Version </TD>
 
<TD CLASS="BORDER">
 Compiler-Platform </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 Visual Studio 2005 </TD>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">VC8-Win32</SPAN> </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 Visual Studio 2005 </TD>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">VC8-x64</SPAN> </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 Visual Studio 2008 </TD>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">VC9-Win32</SPAN> </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 Visual Studio 2008 </TD>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">VC9-x64</SPAN> </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 Visual Studio 2013 </TD>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">VC12-Win32</SPAN> </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 Visual Studio 2013 </TD>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">VC12-x64</SPAN> </TD>
 
</TR>
<P>
</TABLE>
<P>
If you are developing plug-ins for Creator 15, you should 
install and use <B>VC12-Win32</B> or <B>VC12-x64</B> depending on which version 
of Creator you are using (32 or 64 bit, respectively) so your plug-ins are 
compatible.<BR><P>
If you are developing plug-ins for Creator 14, you should 
install and use <B>VC9-Win32</B> so your plug-ins are compatible.<BR><P>
If you are developing plug-ins for Creator 13 (v5.0), you should 
install and use <B>VC9-Win32</B> so your plug-ins are compatible.<BR><P>
If you are developing plug-ins for Creator v3.4 through v4.2, you should 
install use <B>VC8-Win32</B> so your plug-ins are compatible.<BR><P>
If you are developing stand-alone OpenFlight Scripts, you should 
install <B>VC9-Win32</B> or <B>VC9-x64</B>. The necessary Python binding 
files (.pyd) are only available with these formats. You will also 
need to install Python 2.7.X if you are developing stand-alone scripts. 
You do not need to install Python if you are using OpenFlight script 
exclusively within Creator. 
<BR><P>
If you are developing stand-alone applications, you can install and 
use any format.<P>
Both of the VC9 versions of the OpenFlight API DLLs are dependent on 
VC90 CRT version 9.0.21022.8.  The OpenFlight API installer automatically 
installs the proper Microsoft Visual Studio 2008 (release) redistributable package 
if your computer does not already have it.  The debug version of the CRT should 
be installed on your computer when you apply the proper patches/service packs 
to Visual Studio 2008.<P>
Both of the VC8 versions of the OpenFlight API DLLs are dependent on 
VC80 CRT version 8.0.50727.4053.  The OpenFlight API installer automatically 
installs the proper Microsoft Visual Studio 2005 (release) redistributable package 
if your computer does not already have it.  The debug version of the CRT should 
be installed on your computer when you apply the proper patches/service packs 
to Visual Studio 2005.<P>
When you install the OpenFlight API, you can choose which binary format 
you want or you can choose to install them all. In this way, you can 
have multiple binary formats installed on your computer simultaneously 
and then choose (at runtime) which format to run with.<P>
<H2>Installed Directories</H2><P>
On both Windows and Linux platforms, the OpenFlight API is installed into 
the Presagis Common Directory Organization.  The OpenFlight API files are 
distributed into several subfolders under the root of this organization. 
This root folder is different depending on the platform but the subfolder 
structure below this root is the same for all platforms.<P>
By convention, the environment variable <B>PRESAGIS_OPENFLIGHT_API</B> is used 
to specify the root installation folder of the OpenFlight API.  Additionally, 
environment variables of the form <B>PRESAGIS_OPENFLIGHT_API_version</B> where 
<B>version</B> specifies the major and minor version numbers of the distribution, 
are used to maintain multiple versions of the OpenFlight API simultaneously. 
For example, the environment variable <B>PRESAGIS_OPENFLIGHT_API_15_0</B> would 
correspond to OpenFlight API version 15.<P>
The Windows installer creates these two environment variables automatically.<P>
The Linux installer includes a tcsh script file that you can execute to 
set these environment variables manually.<P>
The following sections describe the subfolders below the OpenFlight 
installation root folder.  Depending on which platform and 
compiler/architecture you choose to install, <SPAN CLASS="MONOSPACE">&ltplatform&gt</SPAN> 
in the following sections will be:<P>
<TABLE CLASS="SIMPLE">
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">&ltempty&gt</SPAN> </TD>
 
<TD CLASS="BORDER">
 if you installed VC12-Win32 or Linux </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">_x64</SPAN> </TD>
 
<TD CLASS="BORDER">
 if you installed VC12-x64 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">_vc9</SPAN> </TD>
 
<TD CLASS="BORDER">
 if you installed VC9-Win32</TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">_vc9_x64</SPAN> </TD>
 
<TD CLASS="BORDER">
 if you installed VC9-x64 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">_vc8</SPAN> </TD>
 
<TD CLASS="BORDER">
 if you installed VC8-Win32 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">_vc8_x64</SPAN> </TD>
 
<TD CLASS="BORDER">
 if you installed VC8-x64 </TD>
 
</TR>
<P>
</TABLE>
<P>
<H3>C source header files</H3><P>
The C source header files are located in: 
<PRE CLASS="EXAMPLE">PRESAGIS_OPENFLIGHT_API/include</PRE><P>
<H3>Link libraries</H3><P>
The link libraries are located in: 
<PRE CLASS="EXAMPLE">PRESAGIS_OPENFLIGHT_API/lib&ltplatform&gt</PRE><P>
where <SPAN CLASS="MONOSPACE">lib&ltplatform&gt</SPAN> is:<P>
<TABLE CLASS="SIMPLE">
<P>
<TR CLASS="HEADER">
 
<TD CLASS="BORDER">
 Link Library Folder </TD>
 
<TD CLASS="BORDER">
 Contents </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">lib</SPAN> </TD>
 
<TD CLASS="BORDER">
 Link libraries for VC12-Win32 or Linux </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">lib_x64</SPAN> </TD>
 
<TD CLASS="BORDER">
 Link libraries for VC12-x64 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">lib_vc9</SPAN> </TD>
 
<TD CLASS="BORDER">
 Link libraries for VC9-Win32 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">lib_vc9_x64</SPAN> </TD>
 
<TD CLASS="BORDER">
 Link libraries for VC9-x64 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">lib_vc8</SPAN> </TD>
 
<TD CLASS="BORDER">
 Link libraries for VC8-Win32 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">lib_vc8_x64</SPAN> </TD>
 
<TD CLASS="BORDER">
 Link libraries for VC8-x64 </TD>
 
</TR>
<P>
</TABLE>
<P>
<H3>Dynamic Link Libraries</H3><P>
Both Debug and Release versions of the dynamic link libraries 
are included. Dynamic link libraries are located in:<BR><P>
<H4>On Windows<P>
<PRE CLASS="EXAMPLE">PRESAGIS_OPENFLIGHT_API/bin&ltplatform&gt</PRE></H4><P>
where <SPAN CLASS="MONOSPACE">bin&ltplatform&gt</SPAN> is:<P>
<TABLE CLASS="SIMPLE">
<P>
 
<TD CLASS="BORDER">
 Dynamic Link Library Folder </TD>
 
<TD CLASS="BORDER">
 Contents </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">bin</SPAN> </TD>
 
<TD CLASS="BORDER">
 Dynamic Link libraries for VC12-Win32 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">bin_x64</SPAN> </TD>
 
<TD CLASS="BORDER">
 Dynamic Link libraries for VC12-x64 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">bin_vc9</SPAN> </TD>
 
<TD CLASS="BORDER">
 Dynamic Link libraries for VC9-Win32 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">bin_vc9_x64</SPAN> </TD>
 
<TD CLASS="BORDER">
 Dynamic Link libraries for VC9-x64 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">bin_vc8</SPAN> </TD>
 
<TD CLASS="BORDER">
 Dynamic Link libraries for VC8-Win32 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">bin_vc8_x64</SPAN> </TD>
 
<TD CLASS="BORDER">
 Dynamic Link libraries for VC8-x64 </TD>
 
</TR>
<P>
</TABLE>
<P>
<H4>On Linux<P>
<PRE CLASS="EXAMPLE">PRESAGIS_OPENFLIGHT_API/lib</PRE></H4><P>
The Dynamic Link Library folders (for both Windows and Linux) contain Debug 
and Release versions in their respective subfolders:<P>
<TABLE CLASS="SIMPLE">
<P>
<TR CLASS="HEADER">
 
<TD CLASS="BORDER">
 Dynamic Link Library Subfolder </TD>
 
<TD CLASS="BORDER">
 Contents </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">debug</SPAN> </TD>
 
<TD CLASS="BORDER">
 Debug dynamic link libraries </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">release</SPAN> </TD>
 
<TD CLASS="BORDER">
 Release dynamic link libraries </TD>
 
</TR>
<P>
</TABLE>
<P>
<H3>Documentation</H3><P>
The documents included with the OpenFlight API include:<P>
<I>OpenFlight API Installation Guide</I><BR> 
<I>OpenFlight API Release Notes</I><BR> 
<I>OpenFlight API Developer Guide</I><BR> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Volume 1 (Read/Write)</I><BR> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Volume 2 (Extensions/Tools)</I><BR> 
<I>OpenFlight API Reference Set</I><BR> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>OpenFlight API Reference</I><BR> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>OpenFlight Data Dictionary</I><BR> 
<I>Amendment to Software License Agreement</I><BR><P>
These files are installed in different locations depending on the platform:<P>
<H4>On Windows</H4><P>
For the Windows platform, the documentation for the OpenFlight API is included 
in the <I>Presagis Documentation Library</I>. The <I>Presagis Documentation Library</I> is 
Compiled HTML Help (CHM) format and includes documentation for all the Presagis 
products you have installed. The <I>Presagis Documentation Library</I> is located at:<P>
<PRE CLASS="EXAMPLE">PRESAGIS_ROOT/docs/Presagis_MS.chm</PRE><P>
where <B>PRESAGIS_ROOT</B> is the root folder where your Presagis products are 
installed. To view the OpenFlight documentation, as well as all Presagis product 
documentation, open this file and browse to the OpenFlight API section 
in the viewer that is displayed.  You can also access the 
<I>Presagis Documentation Library</I> via the Windows Start Menu.<P>
In addition to the CHM versions of these documents, some documents are provided 
in alternative formats:<P>
<I>OpenFlight API Installation Guide</I> and <I>OpenFlight API Release Notes</I> (PDF) - both 
located in: 
<PRE CLASS="EXAMPLE">PRESAGIS_ROOT/docs/</PRE><P>
<I>OpenFlight API Developer Guide</I> (PDF) - located in: 
<PRE CLASS="EXAMPLE">PRESAGIS_OPENFLIGHT_API/docs/developerguide</PRE><P>
<I>OpenFlight API Reference Set</I> (HTML) - located in: 
<PRE CLASS="EXAMPLE">PRESAGIS_OPENFLIGHT_API/docs/reference/OpenFlight_API_Reference_Set.htm</PRE><P>
<H4>On Linux</H4><P>
For the Linux platform, the documentation is located in: 
<PRE CLASS="EXAMPLE">PRESAGIS_OPENFLIGHT_API/docs</PRE><P>
The <I>OpenFlight API Installation Guide</I> and <I>OpenFlight API Release Notes</I> 
are located in the root (docs) folder.<P>
The <I>OpenFlight API Developer Guide</I> (PDF format) is located in the folder: 
<PRE CLASS="EXAMPLE">PRESAGIS_OPENFLIGHT_API/docs/developerguide</PRE><P>
The <I>OpenFlight API Reference Set</I> (HTML format) is located in: 
<PRE CLASS="EXAMPLE">PRESAGIS_OPENFLIGHT_API/docs/reference/OpenFlight_API_Reference_Set.htm</PRE><P>
<H3>Sample Code</H3><P>
Sample code is located in: 
<PRE CLASS="EXAMPLE">PRESAGIS_OPENFLIGHT_API/samples</PRE><P>
with subfolders for the individual kinds of samples:<P>
<TABLE CLASS="SIMPLE">
<P>
<TR>
 
<TD CLASS="BORDER">
 <B>Samples Subfolder</B> </TD>
 
<TD CLASS="BORDER">
 <B>Contents</B> </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">apps</SPAN> </TD>
 
<TD CLASS="BORDER">
 sample stand-alone programs </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">extensions</SPAN> </TD>
 
<TD CLASS="BORDER">
 sample OpenFlight data extensions </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">plugins</SPAN> </TD>
 
<TD CLASS="BORDER">
 sample plug-ins (not included in the Linux distribution) </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">scripts</SPAN> </TD>
 
<TD CLASS="BORDER">
 sample OpenFlight and Creator scripts </TD>
 
</TR>
<P>
</TABLE>
<P>
<H3>Tools</H3><P>
Tools are located in: 
<PRE CLASS="EXAMPLE">PRESAGIS_OPENFLIGHT_API/tools</PRE><P>
There is one single tool located here.  That is <SPAN CLASS="MONOSPACE">ddbuild.exe</SPAN>.  You use this 
program to build OpenFlight Extensions. See the <I>OpenFlight API Developer Guide, Volume 2</I> 
for more information.<P>
<H3>Redistributable OpenFlight API Binaries</H3><P>
If you need to redistribute the OpenFlight API binaries, 
you would redistribute the Release version of the Dynamic 
Link Libraries as described in the previous section. 
Note that under no 
circumstances are you allowed to redistribute the debug 
versions.<P>
<H2>Plug-in Runtime Directory</H2><P>
Plug-ins are loaded in the stand-alone program environment when your program or script 
calls the OpenFlight API function <A HREF=#mgInit>mgInit</A>. <A HREF=#mgInit>mgInit</A> searches for plug-ins in the 
following locations (in the order listed). As soon as a folder is found in 
one of these locations, <A HREF=#mgInit>mgInit</A> stops searching for other locations and 
loads the plug-ins it finds in the first folder found.<P>
<OL>
<P>
<LI CLASS="NOINDENT">
 
The directory (or directories) your program specifies when calling <A HREF=#mgSetPluginFolder>mgSetPluginFolder</A>. If you call 
this function before <A HREF=#mgInit>mgInit</A> to specify one or more directories, the folder(s) 
you specify will be searched for plug-ins. To specify more than one directory, pass a 
semi-colon delimited list of paths to <A HREF=#mgSetPluginFolder>mgSetPluginFolder</A>. 
</LI>
<P>
<LI CLASS="NOINDENT">
 
The directory (or directories) specified by the environmental variable <B>PRESAGIS_OPENFLIGHT_PLUGIN_DIR</B>. 
This environmental variable may specify any accessible directory on your computer or 
may specify multiple directories using a semi-colon to delimit each path. 
</LI>
<P>
<LI CLASS="NOINDENT">
 
A directory named <B>plugins</B> immediately below the directory that contains the executable being run. 
</LI>
<P>
</OL>
<P>
Creator loads plug-ins automatically when it starts. Creator searches for plug-ins in the 
following locations (in the order listed). As soon as a folder is found in one of these 
locations, Creator stops searching for other locations and loads the plug-ins it finds in 
the first folder found.<P>
<OL>
<P>
<LI CLASS="NOINDENT">
 
The directory (or directories) specified by the environmental variable <B>PRESAGIS_CREATOR_PLUGIN_DIR</B>. 
This environmental variable may specify any accessible directory on your computer or 
may specify multiple directories using a semi-colon to delimit each path. 
</LI>
<P>
<LI CLASS="NOINDENT">
 
A directory named <B>plugins</B> in the Creator configuration folder. This folder 
is located at:<P>
<PRE CLASS="EXAMPLE">PRESAGIS_ROOT/Creator/config/plugins</PRE> 
</LI>
<P>
</OL>
<P>
<H2>Visual Studio Project Settings</H2><P>
It is very important that your plug-in module be linked with the correct system 
run-time libraries to match Creator.  In particular, multithreaded DLLs are 
required.  In Visual Studio, open the <B>Project Properties</B> window, 
select the <B>C/C++</B> tab and then select the <B>Code Generation</B> category. 
For <B>Runtime Library</B>, select <B>Multi-threaded Debug DLL</B> for the 
Win32 Debug configuration and <B>Multi-threaded DLL</B> for the Win32 Release 
configuration.<P>
<H2>Deprecated API</H2><P>
Please review the list of deprecated API symbols and functions that 
appear in the <B>Deprecated API</B> section of this reference document. 
For each symbol that appears in this section, an appropriate 
replacement symbol or strategy is also given.  Although deprecated 
API symbols are still supported in the current version of the API, 
they may not be in future releases.  To ensure that code you develop 
using the MultiGen OpenFlight API remains compatible with future 
versions of the API, you should eliminate any deprecated symbols 
from your code.<P>
When you compile code that uses a deprecated symbol, the compiler 
may issue a warning message stating that the symbol is not defined 
or has been deprecated. 
This is expected and is an indication to you that action should be 
taken to replace that symbol as described above.  Note that even 
though the compiler issues this warning message, your program or 
plug-in should link successfully even when it uses a deprecated 
symbol.<P>
<H1>v15.0</H1><P>
This version of the OpenFlight API corresponds to OpenFlight version 16.5.<P>
<H2>Visual Studio Compatibility</H2><P>
The OpenFlight API is distributed in several binary formats for the Windows platform:<BR> 
Visual Studio 2013 (VC12-Win32)<BR> 
Visual Studio 2013 (VC12-x64)<BR> 
Visual Studio 2008 (VC9-Win32)<BR> 
Visual Studio 2008 (VC9-x64)<BR> 
Visual Studio 2005 (VC8-Win32)<BR> 
Visual Studio 2005 (VC8-x64)<BR> 
Support for Visual Studio 6 was terminated<P>
<H2>New Functions</H2><P>
<H3>I/O Functions</H3><P>
<A HREF=#mgIsInitialized>mgIsInitialized</A><BR><P>
<H3>Tool Activation Functions</H3><P>
<A HREF=#mgGetActivationKeyboardFlags>mgGetActivationKeyboardFlags</A><BR><P>
<H2>New Symbols</H2><P>
<A HREF=#MEFV_1650>MEFV_1650</A> for <A HREF=#mgExportDb>mgExportDb</A><P>
<H2>New Fields</H2><P>
The field <B>activateReason</B> was added to the <A HREF=#mgtextactivatecallbackrec>mgtextactivatecallbackrec</A> structure.<P>
<H2>New in the OpenFlight Data Dictionary</H2><P>
The following fields were added to <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltIMaterial>fltIMaterial</A>
 to provide access to the new 
Physical Material Map record in the Extended Material:<BR> 
fltPhysicalMaterialMapEx<BR> 
fltPhysicalMaterialMapExTexture<BR><P>
<H2>Fixes/Enhancements</H2><P>
Enhanced <A HREF=#mgExportDb>mgExportDb</A> to allow you to write the current version of OpenFlight.<P>
Fixed the following functions to work correctly in OpenFlight Script (Python):<BR> 
<A HREF=#mgExtensionFieldGetString>mgExtensionFieldGetString</A><BR> 
<A HREF=#mgExtensionFieldGetXMLString>mgExtensionFieldGetXMLString</A><BR><P>
Fixed <A HREF=#mgwalkfunc>mgwalkfunc</A> functions to propagate exceptions correctly in OpenFlight Script (Python) for:<BR> 
<A HREF=#mgWalk>mgWalk</A><BR> 
<A HREF=#mgWalkEx>mgWalkEx</A><BR> 
<A HREF=#mgWalkRecList>mgWalkRecList</A><BR> 
<A HREF=#mgFind>mgFind</A><BR> 
<A HREF=#mgFindEx>mgFindEx</A><BR> 
<A HREF=#mgIterateRecList>mgIterateRecList</A><BR><P>
Fixed crash in <A HREF=#mgOpenDb>mgOpenDb</A> when OpenFlight file does not contain a Vertex Palette record (opcode 67) but 
references it within a Vertex List record (opcode 72).<P>
Enhanced <A HREF=#mgIsDb>mgIsDb</A> to examine the database file more thoroughly to check if it is an OpenFlight file.<P>
Fixed <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A> to set <A HREF=#MGVI_WINDOWVIEW>MGVI_WINDOWVIEW</A> properly when no graphics view is open.<P>
<H1>v14.0</H1><P>
This version of the OpenFlight API corresponds to OpenFlight version 16.4.<P>
<H2>Loading plug-ins</H2><P>
<H3>Loading plug-ins in stand-alone programs</H3><P>
The way in which plug-ins are located by stand-alone programs has changed.<P>
A new function, <A HREF=#mgSetPluginFolder>mgSetPluginFolder</A>, was added that allows you to specify the 
directory (or directories) from which plug-ins will be loaded into your stand-alone 
program. You must call this function before <A HREF=#mgInit>mgInit</A>. When you do, the folder(s) 
you specify will be searched for plug-ins by <A HREF=#mgInit>mgInit</A>. In this way, 
you can control exactly which plug-ins you want to load into your 
stand-alone program environment. To specify more than one directory, pass 
a semi-colon delimited list of paths to <A HREF=#mgSetPluginFolder>mgSetPluginFolder</A>.<P>
Stand-alone programs no longer use the <B>PRESAGIS_CREATOR_PLUGIN_DIR</B> 
environment variable to locate plug-ins. Instead they use the environment 
variable <B>PRESAGIS_OPENFLIGHT_PLUGIN_DIR</B>. This allows more control 
on systems where both Creator and stand-alone applications are used simultaneously. 
Furthermore, the environment variable <B>PRESAGIS_OPENFLIGHT_PLUGIN_DIR</B> may now 
specify multiple directories, each delimited by a semi-colon.<P>
<H3>Loading plug-ins in Creator</H3><P>
The way in which plug-ins are located by Creator has changed.<P>
Creator still uses the <B>PRESAGIS_CREATOR_PLUGIN_DIR</B> 
environment variable to locate plug-ins. However, the value 
of this environment variable may now specify multiple directories, 
each delimited by a semi-colon.<P>
Creator no longer searches for a folder named <B>plugins</B> immediately below 
the directory that contains the Creator executable. When an alternative plug-in 
folder is desired, use the environment variable <B>PRESAGIS_CREATOR_PLUGIN_DIR</B>.<P>
<H2>New Functions</H2><P>
<H3>Base Functions</H3><P>
<A HREF=#mgSetPluginFolder>mgSetPluginFolder</A><BR><P>
<H3>Editor Context Functions</H3><P>
<A HREF=#mgEditorCancelTool>mgEditorCancelTool</A><P>
<H3>Geometry Functions</H3><P>
<A HREF=#mgCoord3dDistanceSquared>mgCoord3dDistanceSquared</A><BR> 
<A HREF=#mgVectorfSetUnitized>mgVectorfSetUnitized</A><BR> 
<A HREF=#mgVectorfUnitize>mgVectorfUnitize</A><BR> 
<A HREF=#mgVectorfEqual>mgVectorfEqual</A><BR> 
<A HREF=#mgVectordEqual>mgVectordEqual</A><BR><P>
<H3>Preference Functions</H3><P>
<A HREF=#mgSetReadTexturesFlag>mgSetReadTexturesFlag</A><BR> 
<A HREF=#mgSetSaveUnreferencedUVs>mgSetSaveUnreferencedUVs</A><BR><P>
<H3>Structure Functions</H3><P>
<A HREF=#mgIsRelated>mgIsRelated</A><BR> 
<A HREF=#mgCountXform>mgCountXform</A><BR><P>
<H3>Tool Registration Functions</H3><P>
<A HREF=#mgEditorSetCloseDialogFunc>mgEditorSetCloseDialogFunc</A><P>
<H2>New Symbols</H2><P>
<A HREF=#mgcontrolattribute>MCA_TEXTACTIVATEONCHANGED</A> for <A HREF=#mgControlSetAttribute>mgControlSetAttribute</A><BR> 
<A HREF=#MPREFI_TEXTUREPALETTEDIMENSION>MPREFI_TEXTUREPALETTEDIMENSION</A> for <A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A><BR> 
<A HREF=#mgeditorclosedialogfunc>mgeditorclosedialogfunc</A> for <A HREF=#mgEditorSetCloseDialogFunc>mgEditorSetCloseDialogFunc</A><BR> 
<A HREF=#mgclosedialogcallbackrec>mgclosedialogcallbackrec</A> for <A HREF=#mgEditorSetCloseDialogFunc>mgEditorSetCloseDialogFunc</A><P>
<H2>New Tool Attributes for Editor Tools</H2><P>
(see <A HREF=#mgRegisterEditor>mgRegisterEditor</A>)<P>
<A HREF=#MTA_NODIALOGPOSITIONPREFERENCE>MTA_NODIALOGPOSITIONPREFERENCE</A><BR><P>
<H2>New in the OpenFlight Data Dictionary</H2><P>
The following field was added to <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltImage>fltImage</A>
 to 
provide access to Texture Type attribute on <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltImage>fltImage</A>
 records. 
fltImgTextureType<BR><P>
<H2>Fixes/Enhancements</H2><P>
Fixed <A HREF=#mgGetSelectList>mgGetSelectList</A> to provide (via <A HREF=#mgGetNextRecInList>mgGetNextRecInList</A> and <A HREF=#mgGetNthRecInList>mgGetNthRecInList</A>) the 
correct matrix for selected nodes contained below instances and/or external reference nodes.<P>
Fixed <A HREF=#mgSetMatrix>mgSetMatrix</A> to refresh the Creator graphics view and mark the database as modified 
correctly when called from a plug-in or script in Creator to update Transformation record codes.<P>
Fixed <A HREF=#mgReplaceTexture>mgReplaceTexture</A> to return <A HREF=#mgbool>MG_TRUE</A> only if the new texture assigned to 
the texture palette has a different name than the original texture at that index.<P>
Corrected the OpenFlight API Reference page for <A HREF=#mgGetCurrentGridMatrix>mgGetCurrentGridMatrix</A> to correctly 
describe the matrix returned.<P>
Fixed <A HREF=#mgGetTextureSaveName>mgGetTextureSaveName</A> to return correct name when texture file has absolute path.<P>
Fixed <A HREF=#mgWalk>mgWalk</A> to visit extension nodes correctly when extension DLL is not present.<P>
Fixed sample code in <A HREF=#mgPromptDialogFile>mgPromptDialogFile</A> to show correct usage for <A HREF=#MPFA_FLAGS>MPFA_FLAGS</A>.<P>
Fixed the following functions to work correctly in OpenFlight Script (Python):<BR> 
<A HREF=#mgGetMatTextureLayer>mgGetMatTextureLayer</A><BR> 
<A HREF=#mgGetModelingParentMatrix>mgGetModelingParentMatrix</A><BR> 
<A HREF=#mgMeshGetVtxColor>mgMeshGetVtxColor</A><BR> 
<A HREF=#mgMeshGetVtxColorAlpha>mgMeshGetVtxColorAlpha</A><P>
Fixed the following functions to refresh the Light Point Palette window and mark 
the database as modified correctly when called from a plug-in or script in Creator:<BR> 
<A HREF=#mgNewLightPointAppearance>mgNewLightPointAppearance</A><BR> 
<A HREF=#mgNewLightPointAnimation>mgNewLightPointAnimation</A><BR> 
<A HREF=#mgDeleteLightPointAppearance>mgDeleteLightPointAppearance</A><BR> 
<A HREF=#mgDeleteLightPointAnimation>mgDeleteLightPointAnimation</A><BR> 
<A HREF=#mgLightPointAnimationSequenceSet>mgLightPointAnimationSequenceSet</A><P>
Fixed <A HREF=#mgReadColorPalette>mgReadColorPalette</A> to refresh the Color Palette window, redraw the scene and mark 
the database as modified correctly when called from a plug-in or script in Creator.<P>
Corrected the reference page for <A HREF=#mgMeshPrimitiveGetVtxIndexArray>mgMeshPrimitiveGetVtxIndexArray</A> to show 
the correct Python signature.<P>
Corrected the reference page for <A HREF=#MPRIM_QUAD_STRIP>MPRIM_QUAD_STRIP</A> to show 
the correct formula for determining vertices for a quadrilateral strip 
of a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
.<P>
Corrected the reference page for <A HREF=#MPRIM_TRI_STRIP>MPRIM_TRI_STRIP</A> to clarify 
the description on how vertices for a triangle strip are calculated 
for a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
.<P>
Changed the description of the fltPolyTemplate field of the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolyon>fltPolyon</A>
 
node record in the OpenFlight Data Dictionary.<P>
<H2>Constant Qualifiers in Function Declarations</H2><P>
The signatures for several function calls have been modified to include the 
C language 'const' qualifier where appropriate.  In most instances this will 
not affect your existing code.  Following is a list of the affected functions:<P>
<A HREF=#mgNewConstructVertex>mgNewConstructVertex</A><BR> 
<A HREF=#mgSetConstructVertexCoords>mgSetConstructVertexCoords</A><BR> 
<A HREF=#mgNewConstructEdge>mgNewConstructEdge</A><BR> 
<A HREF=#mgSetConstructEdgeCoords>mgSetConstructEdgeCoords</A><BR><P>
In addition the signature of the file locator function <A HREF=#mgfilelocatorfunc>mgfilelocatorfunc</A> has 
also been changed to include the C language 'const' qualifier for the <I>inputFileName</I> 
parameter. If you have defined a file locator function in your application, you will have 
to modify its signature to accommodate this change.<P>
<H1>v5.0</H1><P>
This version of the OpenFlight API corresponds to OpenFlight version 16.4.<P>
<H2>Visual Studio Compatibility</H2><P>
The OpenFlight API is distributed in several binary formats for the Windows platform:<BR> 
Visual Studio 2008 (VC9-Win32)<BR> 
Visual Studio 2008 (VC9-x64) 
Visual Studio 2005 (VC8-Win32)<BR> 
Visual Studio 2005 (VC8-x64)<BR> 
Visual Studio 6 (VC6-Win32)<BR><P>
If you are developing plug-ins for Creator 13 (v5.0) you should use VC9-Win32.<P>
If you are developing plug-ins for Creator v3.4 - v4.2, you should use VC8-Win32.<P>
If you are developing plug-ins for Creator v3.3 or earlier, you should use VC6-Win32.<P>
If you are developing stand-alone applications, you can choose any format.<P>
If you are developing stand-alone OpenFlight Scripts, you should 
install VC9-Win32 or VC9-x64 as the necessary Python binding 
files (.pyd) are only available with these VC9 formats.<P>
The OpenFlight API installer for the Windows platform includes the binary 
files for all platforms.  When you install the OpenFlight API on Windows, 
you can choose which platform you want or you can choose to install them all.<P>
Both of the VC9 versions of the OpenFlight API DLLs are dependent on 
VC90 CRT version 9.0.21022.8.  The OpenFlight API installer automatically 
installs the proper Microsoft Visual Studio 2008 (release) redistributable package if your 
computer does not already have it.  The debug version of the CRT should be installed on 
your computer when you apply the proper patches/service packs to Visual Studio 2008.<P>
Both of the VC8 versions of the OpenFlight API DLLs are dependent on 
VC80 CRT version 8.0.50727.4053.  The OpenFlight API installer automatically 
installs the proper Microsoft Visual Studio 2005 (release) redistributable package if your 
computer does not already have it.  The debug version of the CRT should be installed on 
your computer when you apply the proper patches/service packs to Visual Studio 2005.<P>
<H2>Common Directory Organization</H2><P>
The OpenFlight API is now installed into the updated Presagis Common Directory Organization. 
This structure is slightly different than previous installations and affects the developer 
in the following areas:<P>
Location of link libraries<BR> 
Location of documentation<BR> 
Location of redistributable OpenFlight API binaries<BR> 
Location of ddbuild parser utility<BR><P>
Note that the relocation of the link libraries will cause developers to update their 
Visual Studio Project files and/or makefiles before 
the corresponding application(s) or plug-in(s) can be rebuilt 
with this version of the OpenFlight API.<P>
<H3>Location of link libraries</H3><P>
The subfolder containing the link libraries has been changed to include a platform 
designator:<P>
<PRE CLASS="EXAMPLE">PRESAGIS_OPENFLIGHT_API/lib&ltplatform&gt</PRE><P>
where <SPAN CLASS="MONOSPACE">lib&ltplatform&gt</SPAN> is:<P>
<TABLE CLASS="SIMPLE">
<P>
<TR CLASS="HEADER">
 
<TD CLASS="BORDER">
 Link Library Folder </TD>
 
<TD CLASS="BORDER">
 Contents </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">lib</SPAN> </TD>
 
<TD CLASS="BORDER">
 Link libraries for VC9-Win32 or Linux </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">lib_x64</SPAN> </TD>
 
<TD CLASS="BORDER">
 Link libraries for VC9-x64 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">lib_vc8</SPAN> </TD>
 
<TD CLASS="BORDER">
 Link libraries for VC8-Win32 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">lib_vc8_x64</SPAN> </TD>
 
<TD CLASS="BORDER">
 Link libraries for VC8-x64 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">lib_vc6</SPAN> </TD>
 
<TD CLASS="BORDER">
 Link libraries for VC6-Win32 </TD>
 
</TR>
<P>
</TABLE>
<P>
<H3>Location of dynamic link libraries</H3><P>
The subfolder containing the dynamic link libraries has been changed 
to include a platform designator:<P>
<PRE CLASS="EXAMPLE">PRESAGIS_OPENFLIGHT_API/bin&ltplatform&gt</PRE><P>
where <SPAN CLASS="MONOSPACE">bin&ltplatform&gt</SPAN> is:<P>
<TABLE CLASS="SIMPLE">
<P>
<TR CLASS="HEADER">
 
<TD CLASS="BORDER">
 Dynamic Link Library Folder </TD>
 
<TD CLASS="BORDER">
 Contents </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">bin</SPAN> </TD>
 
<TD CLASS="BORDER">
 Dynamic link libraries for VC9-Win32 or Linux </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">bin_x64</SPAN> </TD>
 
<TD CLASS="BORDER">
 Dynamic link libraries for VC9-x64 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">bin_vc8</SPAN> </TD>
 
<TD CLASS="BORDER">
 Dynamic link libraries for VC8-Win32 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">bin_vc8_x64</SPAN> </TD>
 
<TD CLASS="BORDER">
 Dynamic link libraries for VC8-x64 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">bin_vc6</SPAN> </TD>
 
<TD CLASS="BORDER">
 Dynamic link libraries for VC6-Win32 </TD>
 
</TR>
<P>
</TABLE>
<P>
<H3>Location of documentation</H3><P>
On the Windows platform, the documentation for the OpenFlight API is now included 
in the <I>Presagis Documentation Library</I>. The <I>Presagis Documentation Library</I> 
is Compiled HTML Help (CHM) format and includes documentation for all the Presagis 
products you have installed. The <I>Presagis Documentation Library</I> is located at:<P>
<PRE CLASS="EXAMPLE">PRESAGIS_ROOT/docs/Presagis_MS.chm</PRE><P>
where <B>PRESAGIS_ROOT</B> is the root folder where your Presagis products are 
installed. To view the OpenFlight documentation, as well as all Presagis product 
documentation, open this file and browse to the OpenFlight API section 
in the <I>Presagis Documentation Library</I> viewer that is displayed.  You can also access the 
<I>Presagis Documentation Library</I> via the Windows Start Menu.<P>
On the Linux platform, the documentation is still located in: 
<PRE CLASS="EXAMPLE">PRESAGIS_OPENFLIGHT_API/docs</PRE><P>
<H3>Location of ddbuild parser utility</H3><P>
The ddbuild parser (used to help you create your OpenFlight 
extension plug-ins) is now located in:<P>
<PRE CLASS="EXAMPLE">PRESAGIS_OPENFLIGHT_API/tools</PRE><P>
<H2>OpenFlight API Users Guide</H2><P>
The <I>OpenFlight API Users Guide</I> has been renamed <I>OpenFlight API Developer Guide</I>.<P>
<H2>OpenFlight Script</H2><P>
OpenFlight Script was updated to run with Python 2.7.X. 
To run stand-alone OpenFlight Scripts, a Python 2.7.X installation is required. 
No Python installation is required to run OpenFlight Scripts in Creator.<P>
<H2>New Functions</H2><P>
<H3>Attribute Functions</H3><P>
<A HREF=#mgGetVtxBackColorRGB>mgGetVtxBackColorRGB</A><BR> 
<A HREF=#mgSetVtxBackColorRGB>mgSetVtxBackColorRGB</A><BR><P>
<H3>Editor Context Functions</H3><P>
<A HREF=#mgEditorGetToolActivation>mgEditorGetToolActivation</A><BR><P>
<H3>Geometry Functions</H3><P>
<A HREF=#mgVectordNegate>mgVectordNegate</A><BR> 
<A HREF=#mgVectorfZero>mgVectorfZero</A><BR> 
<A HREF=#mgVectorfXAxis>mgVectorfXAxis</A><BR> 
<A HREF=#mgVectorfNegativeXAxis>mgVectorfNegativeXAxis</A><BR> 
<A HREF=#mgVectorfYAxis>mgVectorfYAxis</A><BR> 
<A HREF=#mgVectorfNegativeYAxis>mgVectorfNegativeYAxis</A><BR> 
<A HREF=#mgVectorfZAxis>mgVectorfZAxis</A><BR> 
<A HREF=#mgVectorfNegativeZAxis>mgVectorfNegativeZAxis</A><BR> 
<A HREF=#mgVectorfCross>mgVectorfCross</A><BR> 
<A HREF=#mgVectorfDot>mgVectorfDot</A><BR> 
<A HREF=#mgVectorfNegate>mgVectorfNegate</A><BR> 
<A HREF=#mgVectorfLerp>mgVectorfLerp</A><BR><P>
<H3>Graphics View Functions</H3><P>
<A HREF=#mgNewPaneLayout>mgNewPaneLayout</A><BR> 
<A HREF=#mgFreePaneLayout>mgFreePaneLayout</A><BR> 
<A HREF=#mgGetPaneLayout>mgGetPaneLayout</A><BR> 
<A HREF=#mgSetPaneLayout>mgSetPaneLayout</A><BR><P>
<H3>I/O Functions</H3><P>
<A HREF=#mgGetDbVersion>mgGetDbVersion</A><BR><P>
<H3>Line Style Functions</H3><P>
<A HREF=#mgGetLineStyle>mgGetLineStyle</A><BR> 
<A HREF=#mgGetLineStyleCount>mgGetLineStyleCount</A><BR> 
<A HREF=#mgGetFirstLineStyle>mgGetFirstLineStyle</A><BR> 
<A HREF=#mgGetNextLineStyle>mgGetNextLineStyle</A><BR> 
<A HREF=#mgNewLineStyle>mgNewLineStyle</A><BR> 
<A HREF=#mgDeleteLineStyle>mgDeleteLineStyle</A><BR> 
<A HREF=#mgGetCurrentLineStyle>mgGetCurrentLineStyle</A><BR> 
<A HREF=#mgSetCurrentLineStyle>mgSetCurrentLineStyle</A><BR><P>
<H3>Online Help Functions</H3><P>
<A HREF=#mgPluginSetHelpContext>mgPluginSetHelpContext</A><P>
<H3>Parameter Block Functions</H3><P>
<A HREF=#mgParamExists>mgParamExists</A><BR> 
<A HREF=#mgParamGetStringAlloc>mgParamGetStringAlloc</A><BR> 
<A HREF=#mgParamGetStringNthAlloc>mgParamGetStringNthAlloc</A><BR><P>
<H3>Structure Functions</H3><P>
<A HREF=#mgNewRecDb>mgNewRecDb</A><BR> 
<A HREF=#mgWalkRecList>mgWalkRecList</A><BR><P>
<H3>Texture Functions</H3><P>
<A HREF=#mgIsTextureInPalette>mgIsTextureInPalette</A><P>
<H2>New Symbols</H2><P>
<A HREF=#MPREFI_MOUSEUPZOOMOUT>MPREFI_MOUSEUPZOOMOUT</A> for <A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A><BR><P>
<H2>Fixes/Enhancements</H2><P>
Fixed <A HREF=#mgMoreDetail>mgMoreDetail</A>, <A HREF=#mgLessDetail>mgLessDetail</A>, to return <A HREF=#mgbool>MG_FALSE</A> properly when called 
on empty database nodes.<P>
Enhanced <A HREF=#mgOpenDb>mgOpenDb</A> to set the initial fltIOn state correctly for nodes below <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltGroup>fltGroup</A>
 
animation nodes.<P>
Enhanced <A HREF=#mgWalk>mgWalk</A> and <A HREF=#mgWalkEx>mgWalkEx</A> to function properly if you delete 
(<A HREF=#mgDelete>mgDelete</A>) the node currently being visited in the <I>postAction</I> function.<P>
Enhanced <A HREF=#mgSetConstructEdgeCoords>mgSetConstructEdgeCoords</A> to allow you to set either endpoint 
coordinate of a construction edge node without having to set both.<P>
Enhanced <A HREF=#mgGetConstructEdgeCoords>mgGetConstructEdgeCoords</A> to allow you to get either endpoint 
coordinate of a construction edge node without having to get both.<P>
Fixed <A HREF=#mgSetTextureTexels>mgSetTextureTexels</A> to function correctly (do nothing) when passed the same texels 
returned by <A HREF=#mgGetTextureTexels>mgGetTextureTexels</A>.<P>
Fixed <A HREF=#mgSelectList>mgSelectList</A> to select edges correctly.<P>
Fixed <A HREF=#mgWalk>mgWalk</A> to walk single vertices correctly.<P>
Fixed <A HREF=#mgCloseDb>mgCloseDb</A> to return <A HREF=#mgbool>MG_FALSE</A> properly when called in Creator on a database 
that is currently open on the Creator desktop.<P>
Fixed <A HREF=#mgSetAttList>mgSetAttList</A> to return the correct number of attributes modified when 
trying to set "read-only" attributes, such as:<BR> 
fltLpSequenceLength<BR> 
fltVRgbMode<BR> 
fltPolyRgbMode<BR> 
fltMappingType<BR> 
fltSwMaxMask<BR> 
fltSwCount<BR> 
fltMeshNumPrimitives<BR> 
fltMeshNumVtx<P>
Fixed <A HREF=#mgSetAttList>mgSetAttList</A> to refresh the Creator graphics view and mark the database as modified 
correctly when called from a plug-in or script in Creator for the Transformation record codes:<BR> 
fltXmGeneral<BR> 
fltXmHeader<BR> 
fltXmPut<BR> 
fltXmRotate<BR> 
fltXmRotateEdge<BR> 
fltXmScale<BR> 
fltXmScaleToPoint<BR> 
fltXmTranslate<P>
Fixed <A HREF=#mgIsTextureIndexInPalette>mgIsTextureIndexInPalette</A> to return correct result when run in Creator in the case 
where texture was not already loaded.<P>
Fixed <A HREF=#mgMostDetail>mgMostDetail</A>, <A HREF=#mgLeastDetail>mgLeastDetail</A>, <A HREF=#mgMoreDetail>mgMoreDetail</A> and <A HREF=#mgLessDetail>mgLessDetail</A> 
to fail properly when node is not a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHeader</A>
 node.<P>
Corrected the OpenFlight API Reference page for <A HREF=#mgGetAttBuf>mgGetAttBuf</A> to state that this function 
is not available for Python.<P>
Corrected the OpenFlight API Reference page for <A HREF=#mgPromptDialogTexture>mgPromptDialogTexture</A> to show correct 
usage for Python.<P>
Corrected the OpenFlight Data Dictionary reference to show correct types for fields:<BR> 
fltLineStyleId<BR> 
fltLineStylePatternMask<P>
<H1>v4.2</H1><P>
This version of the OpenFlight API corresponds to OpenFlight version 16.4.<P>
<H2>Visual Studio Compatibility</H2><P>
The OpenFlight API is distributed in three binary formats 
for the Windows platform; Visual Studio 6 (VC6-Win32), Visual Studio 2005 
(VC8-Win32) and Visual Studio 2005 (VC8-x64).  If you are developing plug-ins 
for Creator v3.4 or later, you must use VC8-Win32 so your plug-ins are 
compatible with Creator.  If you are developing plug-ins for Creator v3.3 or 
earlier, you must use VC6-Win32. If you are developing stand-alone applications, 
you can choose any format.<P>
The OpenFlight API installer for the Windows platform was consolidated for this 
version to contain the binary files for all platforms.  When you install the 
OpenFlight API on Windows, you can choose which platform you want or you can 
choose to install them all.<P>
Both of the VC8 versions of the OpenFlight API DLLs are dependent on 
VC80 CRT version 8.0.50727.4053.  The OpenFlight API installer automatically 
installs the proper Microsoft Visual Studio 2005 (release) redistributable package if your 
computer does not already have it.  The debug version of the CRT should be installed on 
your computer when you apply the proper patches/service packs to Visual Studio 2005.<P>
<H2>OpenFlight API FAQ</H2><P>
A new section, <B>FAQ</B>, was added to the OpenFlight API Reference that contains 
answers to frequently asked questions about the OpenFlight API and OpenFlight Script.<P>
<H2>Access to Creator Tools</H2><P>
The OpenFlight API now allows your plug-in tool or OpenFlight Script to execute tools 
in the Creator modeler environment.  If you develop an editor plug-in tool, you can include 
your tool in this mechanism (allow other plug-ins or scripts to execute your tool).  See 
<A HREF=#mgPluginToolSetDefaultParamBlock>mgPluginToolSetDefaultParamBlock</A> for more information.<P>
<H2>Using OpenFlight Script with your Data Dictionary</H2><P>
The record and field codes you define in your Data Dictionary are now accessible 
in OpenFlight Script.  In the OpenFlight Script editor in Creator, the codes are 
automatically made available to you when writing scripts there.  If you want to access 
your Data Dictionary codes in your stand-alone scripts, you can use the updated <B>ddbuild</B> 
utility to generate a Python module containing your record and field codes.  Your 
stand-alone script, then, will import this module to gain access to your record 
and field codes.<P>
<H2>New Functions</H2><P>
<H3>Editor Context Functions</H3><P>
<A HREF=#mgExecute>mgExecute</A><BR><P>
<H3>Extension Functions</H3><P>
<A HREF=#mgExtensionMakeGUID>mgExtensionMakeGUID</A><BR><P>
<H3>Geometry Functions</H3><P>
<A HREF=#mgCoord3dProjectOnPlane>mgCoord3dProjectOnPlane</A><BR><P>
<H3>I/O Functions</H3><P>
<A HREF=#mgSetDbModified>mgSetDbModified</A><BR><P>
<H3>Parameter Block Functions</H3><P>
<A HREF=#mgNewParamBlock>mgNewParamBlock</A><BR> 
<A HREF=#mgGetParamBlock>mgGetParamBlock</A><BR> 
<A HREF=#mgFreeParamBlock>mgFreeParamBlock</A><BR><P>
<A HREF=#mgParamAddInteger>mgParamAddInteger</A><BR> 
<A HREF=#mgParamAddDouble>mgParamAddDouble</A><BR> 
<A HREF=#mgParamAddDouble2>mgParamAddDouble2</A><BR> 
<A HREF=#mgParamAddDouble3>mgParamAddDouble3</A><BR> 
<A HREF=#mgParamAddFloat>mgParamAddFloat</A><BR> 
<A HREF=#mgParamAddBool>mgParamAddBool</A><BR> 
<A HREF=#mgParamAddString>mgParamAddString</A><BR><P>
<A HREF=#mgParamGetInteger>mgParamGetInteger</A><BR> 
<A HREF=#mgParamGetDouble>mgParamGetDouble</A><BR> 
<A HREF=#mgParamGetDouble2>mgParamGetDouble2</A><BR> 
<A HREF=#mgParamGetDouble3>mgParamGetDouble3</A><BR> 
<A HREF=#mgParamGetFloat>mgParamGetFloat</A><BR> 
<A HREF=#mgParamGetBool>mgParamGetBool</A><BR> 
<A HREF=#mgParamGetString>mgParamGetString</A><BR><P>
<A HREF=#mgParamGetIntegerNth>mgParamGetIntegerNth</A><BR> 
<A HREF=#mgParamGetDoubleNth>mgParamGetDoubleNth</A><BR> 
<A HREF=#mgParamGetDouble2Nth>mgParamGetDouble2Nth</A><BR> 
<A HREF=#mgParamGetDouble3Nth>mgParamGetDouble3Nth</A><BR> 
<A HREF=#mgParamGetFloatNth>mgParamGetFloatNth</A><BR> 
<A HREF=#mgParamGetBoolNth>mgParamGetBoolNth</A><BR> 
<A HREF=#mgParamGetStringNth>mgParamGetStringNth</A><BR><P>
<A HREF=#mgParamSet>mgParamSet</A><BR> 
<A HREF=#mgParamSetInteger>mgParamSetInteger</A><BR> 
<A HREF=#mgParamSetDouble>mgParamSetDouble</A><BR> 
<A HREF=#mgParamSetDouble2>mgParamSetDouble2</A><BR> 
<A HREF=#mgParamSetDouble3>mgParamSetDouble3</A><BR> 
<A HREF=#mgParamSetFloat>mgParamSetFloat</A><BR> 
<A HREF=#mgParamSetBool>mgParamSetBool</A><BR> 
<A HREF=#mgParamSetString>mgParamSetString</A><BR><P>
<A HREF=#mgParamAppend>mgParamAppend</A><BR> 
<A HREF=#mgParamAppendInteger>mgParamAppendInteger</A><BR> 
<A HREF=#mgParamAppendDouble>mgParamAppendDouble</A><BR> 
<A HREF=#mgParamAppendDouble2>mgParamAppendDouble2</A><BR> 
<A HREF=#mgParamAppendDouble3>mgParamAppendDouble3</A><BR> 
<A HREF=#mgParamAppendFloat>mgParamAppendFloat</A><BR> 
<A HREF=#mgParamAppendBool>mgParamAppendBool</A><BR> 
<A HREF=#mgParamAppendString>mgParamAppendString</A><BR><P>
<A HREF=#mgParamSetDimension>mgParamSetDimension</A><BR> 
<A HREF=#mgParamGetDimension>mgParamGetDimension</A><BR> 
<A HREF=#mgParamGetSize>mgParamGetSize</A><BR><P>
<A HREF=#mgParamSetDoubleMinGE>mgParamSetDoubleMinGE</A><BR> 
<A HREF=#mgParamSetDoubleMinGT>mgParamSetDoubleMinGT</A><BR> 
<A HREF=#mgParamSetDoubleMaxLE>mgParamSetDoubleMaxLE</A><BR> 
<A HREF=#mgParamSetDoubleMaxLT>mgParamSetDoubleMaxLT</A><BR><P>
<A HREF=#mgParamSetIntegerMinGE>mgParamSetIntegerMinGE</A><BR> 
<A HREF=#mgParamSetIntegerMinGT>mgParamSetIntegerMinGT</A><BR> 
<A HREF=#mgParamSetIntegerMaxLE>mgParamSetIntegerMaxLE</A><BR> 
<A HREF=#mgParamSetIntegerMaxLT>mgParamSetIntegerMaxLT</A><BR> 
<A HREF=#mgParamSetEnumerant>mgParamSetEnumerant</A><BR><P>
<H3>Preference Functions</H3><P>
<A HREF=#mgModelingPrefSetDouble>mgModelingPrefSetDouble</A><BR> 
<A HREF=#mgModelingPrefSetInteger>mgModelingPrefSetInteger</A><BR><P>
<H3>Tool Registration Functions</H3><P>
<A HREF=#mgPluginToolSetDefaultParamBlock>mgPluginToolSetDefaultParamBlock</A><P>
<H2>New Symbols</H2><P>
<A HREF=#mgnotifierevent>MNOTIFY_DATABASEPRESAVE</A> for <A HREF=#mgRegisterNotifier>mgRegisterNotifier</A><BR><P>
<H2>New Tool Attributes for Editor Tools</H2><P>
(see <A HREF=#mgRegisterEditor>mgRegisterEditor</A>)<P>
<A HREF=#MTA_SCRIPTABLE>MTA_SCRIPTABLE</A><BR><P>
<H2>New in the OpenFlight Data Dictionary</H2><P>
The following fields were added to <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 and <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 to 
provide access to the Creator Primary and Alternate Color indices 
on polygon and mesh nodes:<BR> 
fltPolyCreatorPrimeColor<BR> 
fltPolyCreatorAltColor<BR><P>
The following field was added to <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 to 
provide access to the Creator Color index on vertex nodes<BR> 
fltVCreatorColor<BR><P>
The following fields were added to <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltText>fltText</A>
 to provide access to the 
Creator Primary and Alternate Color indices on text nodes:<BR> 
fltTextCreatorColor<BR> 
fltTextCreatorAltColor<BR><P>
The following field was added to <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLpAppearancePalette>fltLpAppearancePalette</A>
 to provide 
access to the Creator Back Color index on light point 
appearance palette records<BR> 
fltLpCreatorBackColor<BR><P>
The following field was added to several node type records to provide 
access to the comment text (an alternate to <A HREF=#mgGetComment>mgGetComment</A> and <A HREF=#mgSetComment>mgSetComment</A>) 
on those node type records<BR> 
fltComment<BR><P>
<H2>Fixes/Enhancements</H2><P>
Enhanced <A HREF=#mgDelete>mgDelete</A> to delete tag-along extension records. Use <A HREF=#mgGetExtRec>mgGetExtRec</A> 
to get a tag-along extension record attached to a node.<P>
Fixed <A HREF=#mgLightPointAnimationSequenceGet>mgLightPointAnimationSequenceGet</A> to fail properly when node is not a 
light point animation palette node.<P>
Fixed <A HREF=#mgLightPointAnimationSequenceSet>mgLightPointAnimationSequenceSet</A> to fail properly when node is not a 
light point animation palette node.<P>
Fixed <A HREF=#mgGetNextLightPointAnimation>mgGetNextLightPointAnimation</A> to fail properly when node is not a 
light point animation palette node.<P>
Fixed <A HREF=#mgGetNextLightPointAppearance>mgGetNextLightPointAppearance</A> to fail properly when node is not a 
light point appearance palette node.<P>
Fixed <A HREF=#mgShaderGetVertexProgramNth>mgShaderGetVertexProgramNth</A>, <A HREF=#mgShaderGetFragmentProgramNth>mgShaderGetFragmentProgramNth</A>, 
<A HREF=#mgShaderAddVertexProgram>mgShaderAddVertexProgram</A>, <A HREF=#mgShaderAddFragmentProgram>mgShaderAddFragmentProgram</A>, <A HREF=#mgShaderSetVertexProgramNth>mgShaderSetVertexProgramNth</A> 
and <A HREF=#mgShaderSetFragmentProgramNth>mgShaderSetFragmentProgramNth</A> to fail properly when node is not a shader palette node.<P>
Fixed <A HREF=#mgShaderGetVertexProgramNth>mgShaderGetVertexProgramNth</A>, <A HREF=#mgShaderGetFragmentProgramNth>mgShaderGetFragmentProgramNth</A>, 
<A HREF=#mgDeleteShader>mgDeleteShader</A> 
to fail properly if index negative.<P>
Fixed <A HREF=#mgDuplicate>mgDuplicate</A>, <A HREF=#mgDuplicateEx>mgDuplicateEx</A> and <A HREF=#mgDuplicateToDb>mgDuplicateToDb</A> to copy 
group bounding box records.<P>
Fixed <A HREF=#mgDuplicate>mgDuplicate</A>, <A HREF=#mgDuplicateEx>mgDuplicateEx</A> and <A HREF=#mgDuplicateToDb>mgDuplicateToDb</A> to copy 
switch mask names properly.<P>
Fixed <A HREF=#mgGetModelingMode>mgGetModelingMode</A> to return <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 in both vertex and 
edge mode. For edge mode, use <A HREF=#mgIsModelingModeEdge>mgIsModelingModeEdge</A> to differentiate from 
vertex mode.<P>
Fixed <A HREF=#mgSetCurrentMaterial>mgSetCurrentMaterial</A> to return <A HREF=#mgbool>MG_TRUE</A> properly when 
current material is already set to the desired index.<P>
Fixed <A HREF=#mgSetCurrentTexture>mgSetCurrentTexture</A> to return <A HREF=#mgbool>MG_TRUE</A> properly when 
current texture is already set to the desired index.<P>
<H1>v4.1.2</H1><P>
This version of the OpenFlight API corresponds to OpenFlight version 16.4.<P>
No new functions were added for this release.<P>
<H2>Fixes/Enhancements</H2><P>
Fixed <A HREF=#mgReadLightPointFile>mgReadLightPointFile</A> and <A HREF=#mgWriteLightPointFile>mgWriteLightPointFile</A> to include the 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLpAppearancePalette>fltLpNoBackColor</A>
 attribute of the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLpAppearancePalette>fltLpAppearancePalette</A>
 palette 
entries.<P>
<H1>v4.1.1</H1><P>
This version of the OpenFlight API corresponds to OpenFlight version 16.4.<P>
No new functions were added for this release.<P>
<H2>Fixes/Enhancements</H2><P>
Fixed crash in <A HREF=#mgDuplicate>mgDuplicate</A> and <A HREF=#mgDuplicateEx>mgDuplicateEx</A> when duplicated geometry contains 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 nodes.<P>
<H1>v4.1</H1><P>
This version of the OpenFlight API corresponds to OpenFlight version 16.4.<P>
<H2>64 bit support</H2><P>
Levels 1, 2 and 3 of the OpenFlight API were implemented on 64 bit operating systems 
(both Windows and Linux platforms).<P>
<H2>Visual Studio Compatibility</H2><P>
The OpenFlight API is distributed in three binary formats 
for the Windows platform; Visual Studio 6 (VC6-Win32), Visual Studio 2005 
(VC8-Win32) and Visual Studio 2005 (VC8-x64).  Only one distribution can be 
installed at one time on the same computer.  If you are developing plug-ins 
for Creator v3.4 or later, you must use VC8-Win32 so your plug-ins are 
compatible with Creator.  If you are developing plug-ins for Creator v3.3 or 
earlier, you must use VC6-Win32. If you are developing stand-alone applications, 
you can choose any format.<P>
In order to support both 32 and 64 bit versions of the OpenFlight API, the signature 
for <A HREF=#mgMalloc>mgMalloc</A> was changed (cosmetically).  Its single parameter was changed from 
type <B>unsigned int</B> to type <A HREF=#mgsize_t>mgsize_t</A>. 
For 32 bit versions of the OpenFlight API, this type is unsigned 32 bit integer. 
For 64 bit versions of the OpenFlight API, this type is unsigned 64 bit integer.<P>
Note that this will not affect your 32 bit applications or plug-ins.  Since the 
underlying type of this parameter has not changed (for 32 bit versions) your existing 
applications and plug-ins will continue to work without recompilation.  When you do 
recompile, your code will require no changes.<P>
<H2>Debug Dynamic Link Libraries</H2><P>
Starting with this version, both release and debug versions of the dynamic 
link libraries are distributed with the OpenFlight API.<P>
<H2>New Data Types</H2><P>
<A HREF=#mgsize_t>mgsize_t</A><BR> 
<A HREF=#mglistactivatereason>mglistactivatereason</A><BR> 
<A HREF=#mglistactivatecallbackrec>mglistactivatecallbackrec</A><BR><P>
<H2>New Functions</H2><P>
<H3>Attribute Functions</H3><P>
<A HREF=#mgGetConvexHull>mgGetConvexHull</A><BR> 
<A HREF=#mgFreeConvexHull>mgFreeConvexHull</A><BR> 
<A HREF=#mgConvexHullGetTriangleCount>mgConvexHullGetTriangleCount</A><BR> 
<A HREF=#mgConvexHullGetTriangleNth>mgConvexHullGetTriangleNth</A><BR> 
<A HREF=#mgNewConvexHullBuilder>mgNewConvexHullBuilder</A><BR> 
<A HREF=#mgFreeConvexHullBuilder>mgFreeConvexHullBuilder</A><BR> 
<A HREF=#mgConvexHullBuilderExpandCoord3d>mgConvexHullBuilderExpandCoord3d</A><BR> 
<A HREF=#mgConvexHullBuilderClose>mgConvexHullBuilderClose</A><BR> 
<A HREF=#mgGetVtxColorName>mgGetVtxColorName</A><BR> 
<A HREF=#mgSetVtxColorName>mgSetVtxColorName</A><BR><P>
<H3>I/O Functions</H3><P>
<A HREF=#mgGetAbsoluteFilename>mgGetAbsoluteFilename</A><BR><P>
<H3>Preference Functions</H3><P>
<A HREF=#mgPluginPrefDelete>mgPluginPrefDelete</A><BR> 
<A HREF=#mgPluginToolPrefDelete>mgPluginToolPrefDelete</A><BR> 
<A HREF=#mgSetFreezeLODCentersFlag>mgSetFreezeLODCentersFlag</A><BR><P>
<H3>Select List Functions</H3><P>
<A HREF=#mgSelectOneEx>mgSelectOneEx</A><BR><P>
<H3>Tab Ruler Functions</H3><P>
<A HREF=#mgNewTabRuler>mgNewTabRuler</A><BR> 
<A HREF=#mgFreeTabRuler>mgFreeTabRuler</A><BR> 
<A HREF=#mgTabRulerSetOptions>mgTabRulerSetOptions</A><BR> 
<A HREF=#mgTabRulerRangeDrawCallback>mgTabRulerRangeDrawCallback</A><BR> 
<A HREF=#mgTabRulerRangeMouseCallback>mgTabRulerRangeMouseCallback</A><BR> 
<A HREF=#mgTabRulerSetGuiCallback>mgTabRulerSetGuiCallback</A><BR> 
<A HREF=#mgTabRulerSetMouseCallback>mgTabRulerSetMouseCallback</A><BR> 
<A HREF=#mgTabRulerGetTabCount>mgTabRulerGetTabCount</A><BR> 
<A HREF=#mgTabRulerGetTabPosition>mgTabRulerGetTabPosition</A><BR> 
<A HREF=#mgTabRulerSetTabPosition>mgTabRulerSetTabPosition</A><BR> 
<A HREF=#mgTabRulerSetTabFrozen>mgTabRulerSetTabFrozen</A><BR> 
<A HREF=#mgTabRulerNewTab>mgTabRulerNewTab</A><BR> 
<A HREF=#mgTabRulerDeleteTab>mgTabRulerDeleteTab</A><BR> 
<A HREF=#mgTabRulerGetSelectedTab>mgTabRulerGetSelectedTab</A><BR> 
<A HREF=#mgTabRulerSelectTab>mgTabRulerSelectTab</A><BR><P>
<H3>Texture Functions</H3><P>
<A HREF=#mgPurgeTextures>mgPurgeTextures</A> (previously undocumented, now fully supported)<BR> 
<A HREF=#mgReadImageInfo>mgReadImageInfo</A> (added OpenFlight Script version)<BR> 
<A HREF=#mgReadImageGeoInfo>mgReadImageGeoInfo</A> (added OpenFlight Script version)<BR> 
<A HREF=#mgReadImageHeader>mgReadImageHeader</A> (added OpenFlight Script version)<BR><P>
<H2>New Symbols</H2><P>
<A HREF=#MSEL_ALLOWRECURSIVE>MSEL_ALLOWRECURSIVE</A> for <A HREF=#mgSelectOneEx>mgSelectOneEx</A><BR><P>
<A HREF=#mgnotifierevent>MNOTIFY_EXTENSIONCHANGED</A> for <A HREF=#mgRegisterNotifier>mgRegisterNotifier</A><BR><P>
<H2>Fixes/Enhancements</H2><P>
List controls in your plug-in dialogs can now distinguish between "click" 
and "double click" selection.  See <A HREF=#mglistactivatecallbackrec>mglistactivatecallbackrec</A> for more information.<P>
Enhanced <A HREF=#mgDelete>mgDelete</A> to free texture attribute records returned by <A HREF=#mgReadImageAttributes>mgReadImageAttributes</A>.<P>
Fixed <A HREF=#mgExit>mgExit</A> to free all memory allocated by the OpenFlight API between the 
<A HREF=#mgInit>mgInit</A> and <A HREF=#mgExit>mgExit</A> calls.<P>
Enhanced <A HREF=#mgGuiSetToolTip>mgGuiSetToolTip</A> to allow empty string to clear the control tool tip.<P>
Enhanced <A HREF=#mgSetPolyColorName>mgSetPolyColorName</A> and <A HREF=#mgSetPolyAltColorName>mgSetPolyAltColorName</A> to clear the color name 
given a NULL or empty string.<P>
Enhanced 
<A HREF=#mgGetPlane>mgGetPlane</A>, 
<A HREF=#mgGetCoord3d>mgGetCoord3d</A>, 
<A HREF=#mgGetCoord3f>mgGetCoord3f</A>, 
<A HREF=#mgGetMatTextureLayer>mgGetMatTextureLayer</A>, 
<A HREF=#mgGetNormColor>mgGetNormColor</A>, 
<A HREF=#mgGetVector>mgGetVector</A>, 
<A HREF=#mgGetVectord>mgGetVectord</A>, and 
<A HREF=#mgGetPolyNormal>mgGetPolyNormal</A> 
to accept one or more (but not all) NULL addresses in order to specify which components you want to receive.<P>
Fixed <A HREF=#mgExportDb>mgExportDb</A> to function correctly for <A HREF=#MEFV_1630>MEFV_1630</A>.<P>
Fixed <A HREF=#mgUpdateTextureMapping>mgUpdateTextureMapping</A> to return <A HREF=#mgbool>MG_TRUE</A> properly when mapping is updated.<P>
Fixed <A HREF=#mgSetColorIndex>mgSetColorIndex</A> to only set colors on valid palette indices.<P>
Fixed <A HREF=#mgMeshSetVtxColor>mgMeshSetVtxColor</A> to fail properly if color or intensity values out of range.<P>
Fixed <A HREF=#mgCoord2dAngle>mgCoord2dAngle</A> to measure angle between coincident coordinates properly.<P>
Fixed <A HREF=#mgCoord3dAngle>mgCoord3dAngle</A> to measure angle between coincident coordinates properly.<P>
Fixed <A HREF=#mgAttach>mgAttach</A> to fail when node is already attached.<P>
Fixed <A HREF=#mgDetach>mgDetach</A> to fail when node is already detached.<P>
Fixed <A HREF=#mgDetach>mgDetach</A> to properly unlink siblings when used on a transformation record.<P>
Fixed <A HREF=#mgDelete>mgDelete</A> to work properly on a detached transformation record.<P>
Fixed <A HREF=#mgReference>mgReference</A> to fail when node already references another node.<P>
Fixed <A HREF=#mgIsDbUntitled>mgIsDbUntitled</A> to work properly on a detached transformation record.<P>
Fixed <A HREF=#mgNewColorName>mgNewColorName</A> to fail for NULL or empty string name.<P>
Fixed <A HREF=#mgGetTexturePosition>mgGetTexturePosition</A> to fail if texture does not refer to a valid palette entry.<P>
Fixed <A HREF=#mgReplaceTexture>mgReplaceTexture</A> to fail if texture does not refer to a valid palette entry.<P>
Fixed <A HREF=#mgMoveTexture>mgMoveTexture</A> to fail if source texture does not refer to a valid palette entry.<P>
Fixed <A HREF=#mgReadTexturePalette>mgReadTexturePalette</A> to close file handle when done reading texture palette file.<P>
Fixed <A HREF=#mgSendMessage>mgSendMessage</A> to return <A HREF=#mgbool>MG_TRUE</A> properly when messages are enabled.<P>
Fixed <A HREF=#mgSendMessage>mgSendMessage</A> to handle NULL message string properly.<P>
Fixed <A HREF=#mgAddSwitchMask>mgAddSwitchMask</A> to fail properly when node is not a switch node.<P>
Fixed <A HREF=#mgDeleteSwitchMask>mgDeleteSwitchMask</A> to fail properly when node is not a switch node 
or mask number parameter does not specify a valid mask of the switch node.<P>
Fixed <A HREF=#mgGetSwitchBit>mgGetSwitchBit</A> to fail properly when node is not a switch node, 
mask number parameter does not specify a valid mask of the switch node, 
bit number parameter does not specify a valid bit of the mask or 
on parameter is not a valid address.<P>
Fixed <A HREF=#mgGetSwitchMaskCount>mgGetSwitchMaskCount</A> to fail properly when node is not a switch node.<P>
Fixed <A HREF=#mgGetSwitchMaskName>mgGetSwitchMaskName</A> to fail properly when node is not a switch node 
or mask number parameter does not specify a valid mask of the switch node.<P>
Fixed <A HREF=#mgGetSwitchMaskNo>mgGetSwitchMaskNo</A> to fail properly when node is not a switch node or 
mask number parameter is not a valid address.<P>
Fixed <A HREF=#mgInitSwitchMask>mgInitSwitchMask</A> to fail properly when node is not a switch node or 
mask number parameter does not specify a valid mask of the switch node.<P>
Fixed <A HREF=#mgSetSwitchBit>mgSetSwitchBit</A> to fail properly when node is not a switch node, 
mask number parameter does not specify a valid mask of the switch node or 
bit number parameter does not specify a valid bit of the mask.<P>
Fixed <A HREF=#mgSetSwitchMaskName>mgSetSwitchMaskName</A> to fail properly when node is not a switch node 
or mask number parameter does not specify a valid mask of the switch node.<P>
Fixed 
<A HREF=#mgMatrixSetXAxis>mgMatrixSetXAxis</A>, 
<A HREF=#mgMatrixSetYAxis>mgMatrixSetYAxis</A>, 
<A HREF=#mgMatrixSetZAxis>mgMatrixSetZAxis</A>, 
<A HREF=#mgMatrixSetTranslation>mgMatrixSetTranslation</A>, 
<A HREF=#mgMatrixFormReflectX>mgMatrixFormReflectX</A>, 
<A HREF=#mgMatrixFormReflectY>mgMatrixFormReflectY</A>, 
<A HREF=#mgMatrixFormReflectZ>mgMatrixFormReflectZ</A>, 
<A HREF=#mgMatrixFormReflect>mgMatrixFormReflect</A>, 
<A HREF=#mgMatrixFormPitchUp90>mgMatrixFormPitchUp90</A>, 
<A HREF=#mgMatrixFormPitchDown90>mgMatrixFormPitchDown90</A>, 
<A HREF=#mgMatrixFormRollLeft90>mgMatrixFormRollLeft90</A>, 
<A HREF=#mgMatrixFormRollRight90>mgMatrixFormRollRight90</A>, 
<A HREF=#mgMatrixFormYawLeft90>mgMatrixFormYawLeft90</A>, 
<A HREF=#mgMatrixFormYawRight90>mgMatrixFormYawRight90</A>, 
<A HREF=#mgMatrixReflectX>mgMatrixReflectX</A>, 
<A HREF=#mgMatrixReflectY>mgMatrixReflectY</A>, 
<A HREF=#mgMatrixReflectZ>mgMatrixReflectZ</A>, 
<A HREF=#mgMatrixReflect>mgMatrixReflect</A>, 
<A HREF=#mgMatrixPitchDown90>mgMatrixPitchDown90</A>, 
<A HREF=#mgMatrixPitchUp90>mgMatrixPitchUp90</A>, 
<A HREF=#mgMatrixRollLeft90>mgMatrixRollLeft90</A>, 
<A HREF=#mgMatrixRollRight90>mgMatrixRollRight90</A>, 
<A HREF=#mgMatrixYawLeft90>mgMatrixYawLeft90</A>, 
<A HREF=#mgMatrixYawRight90>mgMatrixYawRight90</A>, 
<A HREF=#mgMatrixCompose>mgMatrixCompose</A>, 
<A HREF=#mgMatrixGetTranslation>mgMatrixGetTranslation</A>, 
<A HREF=#mgMatrixGetXAxis>mgMatrixGetXAxis</A>, 
<A HREF=#mgMatrixGetYAxis>mgMatrixGetYAxis</A>, 
<A HREF=#mgMatrixGetZAxis>mgMatrixGetZAxis</A>, 
<A HREF=#mgMatrixFormNormal>mgMatrixFormNormal</A>, 
<A HREF=#mgMatrixTranspose>mgMatrixTranspose</A>, 
<A HREF=#mgMatrixMultiply>mgMatrixMultiply</A>, 
and <A HREF=#mgMatrixCopy>mgMatrixCopy</A> to fail if NULL parameters passed in.<P>
Fixed 
<A HREF=#mgFreeMatrixStack>mgFreeMatrixStack</A>, 
<A HREF=#mgMatrixStackPush>mgMatrixStackPush</A>, 
<A HREF=#mgMatrixStackPop>mgMatrixStackPop</A>, 
<A HREF=#mgMatrixStackLoadIdentity>mgMatrixStackLoadIdentity</A>, 
<A HREF=#mgMatrixStackLoadMatrix>mgMatrixStackLoadMatrix</A>, 
<A HREF=#mgMatrixStackGetMatrix>mgMatrixStackGetMatrix</A>, 
<A HREF=#mgMatrixStackIsIdentity>mgMatrixStackIsIdentity</A>, 
<A HREF=#mgMatrixStackMultiply>mgMatrixStackMultiply</A>, 
<A HREF=#mgMatrixStackScale>mgMatrixStackScale</A>, 
<A HREF=#mgMatrixStackRotate>mgMatrixStackRotate</A>, 
<A HREF=#mgMatrixStackRotateX>mgMatrixStackRotateX</A>, 
<A HREF=#mgMatrixStackRotateY>mgMatrixStackRotateY</A>, 
<A HREF=#mgMatrixStackRotateZ>mgMatrixStackRotateZ</A>, 
and <A HREF=#mgMatrixStackTranslate>mgMatrixStackTranslate</A> to fail if NULL parameters passed in.<P>
Fixed <A HREF=#mgMatrixFormXYZToUV>mgMatrixFormXYZToUV</A> to use the correct texture layer.<P>
Fixed <A HREF=#mgMatrixInvert>mgMatrixInvert</A> to fail properly when matrix or result matrix are NULL.<P>
Fixed <A HREF=#mgMeshGetVtxOffset>mgMeshGetVtxOffset</A> to return correct offset for MMESH_VTXCOLORRGB when 
color RGB values not really present.<P>
Fixed <A HREF=#mgMeshPrimitiveGetVtxIndexArray>mgMeshPrimitiveGetVtxIndexArray</A> to fail properly when index array is NULL.<P>
Fixed 
<A HREF=#mgMeshSetVtxMask>mgMeshSetVtxMask</A>, 
<A HREF=#mgMeshSetVtxCoord>mgMeshSetVtxCoord</A>, 
<A HREF=#mgMeshSetVtxColor>mgMeshSetVtxColor</A>, 
<A HREF=#mgMeshSetVtxColorRGBA>mgMeshSetVtxColorRGBA</A>, 
<A HREF=#mgMeshSetVtxColorRGB>mgMeshSetVtxColorRGB</A>, 
<A HREF=#mgMeshSetVtxColorAlpha>mgMeshSetVtxColorAlpha</A>, 
<A HREF=#mgMeshSetVtxNormal>mgMeshSetVtxNormal</A>, 
<A HREF=#mgMeshSetVtxUV>mgMeshSetVtxUV</A>, 
<A HREF=#mgMeshSetVtxNormal>mgMeshSetVtxNormal</A>, 
<A HREF=#mgMeshSetVtxNormal>mgMeshSetVtxNormal</A>, and 
<A HREF=#mgMeshSetVtxColor>mgMeshSetVtxColor</A> to refresh the Creator graphics view and mark the database as modified 
when called from a plug-in or script in Creator.<P>
Fixed <A HREF=#mgMeshGetVtxCoord>mgMeshGetVtxCoord</A> to fail properly if all three output coordinate component addresses are NULL.<P>
Fixed <A HREF=#mgMeshGetVtxColor>mgMeshGetVtxColor</A> to fail properly if both output addresses are NULL.<P>
Fixed <A HREF=#mgMeshGetVtxColorRGB>mgMeshGetVtxColorRGB</A> to fail properly if all three output addresses are NULL.<P>
Fixed <A HREF=#mgMeshGetVtxColorRGBA>mgMeshGetVtxColorRGBA</A> to fail properly if all four output addresses are NULL.<P>
Fixed <A HREF=#mgMeshGetVtxColorAlpha>mgMeshGetVtxColorAlpha</A> to fail properly if output alpha address is NULL.<P>
Fixed <A HREF=#mgMeshGetVtxNormal>mgMeshGetVtxNormal</A> to fail properly if all three output normal component addresses are NULL.<P>
Fixed <A HREF=#mgMeshGetVtxUV>mgMeshGetVtxUV</A> to fail properly if both output addresses are NULL.<P>
Fixed <A HREF=#mgMeshSetVtxMask>mgMeshSetVtxMask</A> and <A HREF=#mgMeshCreateVtxPool>mgMeshCreateVtxPool</A> to fail properly if 
both MMESH_VTXCOLOR and MMESH_VTXCOLORRGB are specified in the vertex mask.<P>
Fixed <A HREF=#mgSetName>mgSetName</A> to fail properly if called to rename a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 node 
or if the name specified is empty.<P>
Fixed <A HREF=#mgGetPolyNormal>mgGetPolyNormal</A> to fail properly if all three output normal component addresses are NULL.<P>
Fixed <A HREF=#mgGetVtxCoord>mgGetVtxCoord</A> to fail properly if all three output coordinate addresses are NULL.<P>
Fixed <A HREF=#mgGetVtxNormal>mgGetVtxNormal</A> to fail properly if all three output normal component addresses are NULL.<P>
Fixed <A HREF=#mgGetPolyColorRGB>mgGetPolyColorRGB</A> to fail properly if all three output normal component addresses are NULL.<P>
Fixed <A HREF=#mgGetVtxColorRGB>mgGetVtxColorRGB</A> to fail properly if all three output color component addresses are NULL.<P>
Fixed <A HREF=#mgGetVtxColorRGBA>mgGetVtxColorRGBA</A> to fail properly if all four output color component addresses are NULL.<P>
Fixed <A HREF=#mgPtrArrayBSearch>mgPtrArrayBSearch</A> to handle NULL compare function parameter properly,<P>
Fixed <A HREF=#mgPtrArrayBSearch>mgPtrArrayBSearch</A> to fail properly if output position parameter is NULL.<P>
Fixed <A HREF=#mgDeleteSound>mgDeleteSound</A> to return <A HREF=#mgbool>MG_TRUE</A> properly when sound is deleted.<P>
Fixed <A HREF=#mgDeleteSound>mgDeleteSound</A> to fail properly when index is -1.<P>
Fixed 
<A HREF=#mgGetSoundCount>mgGetSoundCount</A>, 
<A HREF=#mgDeleteSound>mgDeleteSound</A>, 
<A HREF=#mgGetFirstSound>mgGetFirstSound</A>, 
<A HREF=#mgNameOfSound>mgNameOfSound</A>, 
<A HREF=#mgIndexOfSound>mgIndexOfSound</A>, 
<A HREF=#mgGetCurrentSound>mgGetCurrentSound</A>, and 
<A HREF=#mgSetCurrentSound>mgSetCurrentSound</A> 
to fail properly if db is not a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHeader</A>
 node.<P>
Fixed 
<A HREF=#mgGetLightSourceCount>mgGetLightSourceCount</A>, 
<A HREF=#mgDeleteLightSource>mgDeleteLightSource</A>, 
<A HREF=#mgIndexOfLightSource>mgIndexOfLightSource</A>, 
<A HREF=#mgNameOfLightSource>mgNameOfLightSource</A>, 
<A HREF=#mgReadLightSourceFile>mgReadLightSourceFile</A>, 
<A HREF=#mgGetCurrentLightSource>mgGetCurrentLightSource</A>, and 
<A HREF=#mgSetCurrentLightSource>mgSetCurrentLightSource</A> 
to fail properly if db is not a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHeader</A>
 node.<P>
Fixed <A HREF=#mgReadMaterialFile>mgReadMaterialFile</A>, <A HREF=#mgWriteMaterialFile>mgWriteMaterialFile</A> and <A HREF=#mgWriteMaterialFileVersion>mgWriteMaterialFileVersion</A> 
to fail properly if db is not a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHeader</A>
 node.<P>
Fixed <A HREF=#mgWriteSoundFile>mgWriteSoundFile</A> to fail properly if db is not a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHeader</A>
 node.<P>
Fixed <A HREF=#mgReadColorPalette>mgReadColorPalette</A> and <A HREF=#mgWriteColorPalette>mgWriteColorPalette</A> to fail properly if db is 
not a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHeader</A>
 node.<P>
Fixed 
<A HREF=#mgSetColorIndex>mgSetColorIndex</A>, 
<A HREF=#mgNewColorName>mgNewColorName</A>, 
<A HREF=#mgDeleteColorName>mgDeleteColorName</A>, 
<A HREF=#mgSetCurrentColorName>mgSetCurrentColorName</A>, 
<A HREF=#mgGetCurrentColorName>mgGetCurrentColorName</A>, 
<A HREF=#mgGetPolyColorName>mgGetPolyColorName</A>, 
<A HREF=#mgGetPolyAltColorName>mgGetPolyAltColorName</A>, 
<A HREF=#mgGetNextColorName>mgGetNextColorName</A>, and 
<A HREF=#mgGetColorNameList>mgGetColorNameList</A> 
to fail properly if db is not a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHeader</A>
 node.<P>
Fixed <A HREF=#mgGetNextColorName>mgGetNextColorName</A> and <A HREF=#mgGetColorNameList>mgGetColorNameList</A> to only get 
color names for valid palette indices.<P>
Fixed <A HREF=#mgDeleteColorName>mgDeleteColorName</A> to return <A HREF=#mgbool>MG_TRUE</A> properly when name is deleted.<P>
Fixed <A HREF=#mgRGB2Index>mgRGB2Index</A> to fail properly if db is not a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHeader</A>
 node.<P>
Fixed 
<A HREF=#mgSetColorIndex>mgSetColorIndex</A>, 
<A HREF=#mgRGB2Index>mgRGB2Index</A>, 
<A HREF=#mgMeshSetVtxColorRGBA>mgMeshSetVtxColorRGBA</A>, 
<A HREF=#mgMeshSetVtxColorRGB>mgMeshSetVtxColorRGB</A>, 
<A HREF=#mgMeshSetVtxColorAlpha>mgMeshSetVtxColorAlpha</A>, 
<A HREF=#mgSetPolyColorRGB>mgSetPolyColorRGB</A>, and 
<A HREF=#mgSetPolyAltColorRGB>mgSetPolyAltColorRGB</A> 
to fail properly if color values are outside valid range (0..255).<P>
Fixed 
<A HREF=#mgSetPolyColorName>mgSetPolyColorName</A>, 
<A HREF=#mgSetPolyAltColorName>mgSetPolyAltColorName</A>, 
<A HREF=#mgGetPolyColorName>mgGetPolyColorName</A>, and 
<A HREF=#mgGetPolyAltColorName>mgGetPolyAltColorName</A> 
to work properly on <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 nodes.<P>
Fixed <A HREF=#mgGetAttList>mgGetAttList</A> to handle NULL attribute addresses properly.<P>
Fixed <A HREF=#mgDeleteShader>mgDeleteShader</A> to work properly.<P>
Corrected the reference page for <A HREF=#mgWalkGetMatrix>mgWalkGetMatrix</A> to show the correct Python signature.<P>
Now that the OpenFlight Script version of <A HREF=#mgReadImageInfo>mgReadImageInfo</A> has been implemented, 
the following functions can be used in OpenFlight Script correctly: 
<A HREF=#mgGetTextureWidth>mgGetTextureWidth</A>, 
<A HREF=#mgGetTextureHeight>mgGetTextureHeight</A>, 
<A HREF=#mgGetTextureType>mgGetTextureType</A>, 
<A HREF=#mgGetTextureSampleSize>mgGetTextureSampleSize</A>, 
<A HREF=#mgGetTextureTiledFlag>mgGetTextureTiledFlag</A>, 
<A HREF=#mgGetTextureMinMax>mgGetTextureMinMax</A>, 
<A HREF=#mgHasTextureTransparentValue>mgHasTextureTransparentValue</A>, 
<A HREF=#mgGetTextureTransparentValue>mgGetTextureTransparentValue</A>, and 
<A HREF=#mgGetTextureSignedFlag>mgGetTextureSignedFlag</A>.<P>
Now that the OpenFlight Script version of <A HREF=#mgReadImageGeoInfo>mgReadImageGeoInfo</A> has been implemented, 
the following functions can be used in OpenFlight Script correctly: 
<A HREF=#mgGetTextureGeoType>mgGetTextureGeoType</A>, 
<A HREF=#mgGetTextureGeoProjection>mgGetTextureGeoProjection</A>, 
<A HREF=#mgGetTextureGeoEarthModel>mgGetTextureGeoEarthModel</A>, 
<A HREF=#mgGetTextureGeoUTMZone>mgGetTextureGeoUTMZone</A>, 
<A HREF=#mgGetTextureGeoUTMHemisphere>mgGetTextureGeoUTMHemisphere</A>, 
<A HREF=#mgGetTextureGeoImageOrigin>mgGetTextureGeoImageOrigin</A>, 
<A HREF=#mgGetTextureGeoNumCtlPts>mgGetTextureGeoNumCtlPts</A>, and 
<A HREF=#mgGetTextureGeoCtlPt>mgGetTextureGeoCtlPt</A>.<P>
<H2>Constant Qualifiers in Function Declarations</H2><P>
The signatures for several function calls have been modified to include the 
C language 'const' qualifier where appropriate.  In most instances this will 
not affect your existing code.  Following is a list of the affected functions:<P>
<A HREF=#mgShowHelpContext>mgShowHelpContext</A><BR> 
<A HREF=#mgGuiSetHelpContext>mgGuiSetHelpContext</A><BR><P>
<H2>Signed vs Unsigned integer Function Declarations</H2><P>
The signatures for the following function calls have been modified to include the 
C language 'unsigned' qualifier for integer type parameters where appropriate. 
In most instances this will not affect your existing code.  Following is a list 
of the affected functions:<P>
<A HREF=#mgDuplicateEx>mgDuplicateEx</A><BR> 
<A HREF=#mgDuplicateToDbEx>mgDuplicateToDbEx</A><BR> 
<A HREF=#mgWalk>mgWalk</A><BR> 
<A HREF=#mgWalkEx>mgWalkEx</A><BR> 
<A HREF=#mgFind>mgFind</A><BR> 
<A HREF=#mgFindEx>mgFindEx</A><BR> 
<A HREF=#mgMessageDialog>mgMessageDialog</A><BR><P>
<H1>v4.0</H1><P>
This version of the OpenFlight API corresponds to OpenFlight version 16.4.<P>
<H2>Visual Studio Compatibility</H2><P>
This version of the OpenFlight API is distributed in two binary formats 
for the Windows platform; Visual Studio 6 (VC6-Win32) and Visual Studio 2005 
(VC8-Win32).  Both distributions cannot be installed simultaneously on the same computer. 
If you are developing plug-ins for Creator v3.4 or later, you must use VC8 so your 
plug-ins are compatible with Creator.  If you are developing plug-ins for Creator v3.3 or 
earlier, you must use VC6-Win32.  If you are developing stand-alone applications, you can 
choose either format.<P>
<H2>New Functions</H2><P>
<H3>Extension Functions</H3><P>
<A HREF=#mgExtensionSiteAdd>mgExtensionSiteAdd</A><BR> 
<A HREF=#mgExtensionSiteGetName>mgExtensionSiteGetName</A><BR> 
<A HREF=#mgExtensionSiteSetName>mgExtensionSiteSetName</A><BR><P>
<A HREF=#mgExtensionFieldAdd>mgExtensionFieldAdd</A><BR> 
<A HREF=#mgExtensionFieldGetName>mgExtensionFieldGetName</A><BR> 
<A HREF=#mgExtensionFieldSetName>mgExtensionFieldSetName</A><BR> 
<A HREF=#mgExtensionFieldGetAttach>mgExtensionFieldGetAttach</A><BR> 
<A HREF=#mgExtensionFieldSetAttach>mgExtensionFieldSetAttach</A><BR> 
<A HREF=#mgExtensionFieldGetType>mgExtensionFieldGetType</A><BR> 
<A HREF=#mgExtensionFieldSetType>mgExtensionFieldSetType</A><BR><P>
<A HREF=#mgExtensionFieldGetInteger>mgExtensionFieldGetInteger</A><BR> 
<A HREF=#mgExtensionFieldSetInteger>mgExtensionFieldSetInteger</A><BR> 
<A HREF=#mgExtensionFieldGetDouble>mgExtensionFieldGetDouble</A><BR> 
<A HREF=#mgExtensionFieldSetDouble>mgExtensionFieldSetDouble</A><BR> 
<A HREF=#mgExtensionFieldGetFloat>mgExtensionFieldGetFloat</A><BR> 
<A HREF=#mgExtensionFieldSetFloat>mgExtensionFieldSetFloat</A><BR> 
<A HREF=#mgExtensionFieldGetBool>mgExtensionFieldGetBool</A><BR> 
<A HREF=#mgExtensionFieldSetBool>mgExtensionFieldSetBool</A><BR> 
<A HREF=#mgExtensionFieldGetString>mgExtensionFieldGetString</A><BR> 
<A HREF=#mgExtensionFieldSetString>mgExtensionFieldSetString</A><BR> 
<A HREF=#mgExtensionFieldGetXMLString>mgExtensionFieldGetXMLString</A><BR> 
<A HREF=#mgExtensionFieldSetXMLString>mgExtensionFieldSetXMLString</A><BR><P>
<A HREF=#mgExtensionFieldDelete>mgExtensionFieldDelete</A><BR> 
<A HREF=#mgExtensionFieldDefined>mgExtensionFieldDefined</A><BR><P>
<H3>Geometry Functions</H3><P>
<A HREF=#mgVectordZero>mgVectordZero</A><BR><P>
<H3>I/O Functions</H3><P>
<A HREF=#mgIsDbOnDesktop>mgIsDbOnDesktop</A><BR> 
<A HREF=#mgIsFileOnDesktop>mgIsFileOnDesktop</A><BR> 
<A HREF=#mgGetDbOnDesktop>mgGetDbOnDesktop</A><BR><P>
<H3>Projection Functions</H3><P>
<A HREF=#mgNewProjection>mgNewProjection</A><BR> 
<A HREF=#mgFreeProjection>mgFreeProjection</A><BR> 
<A HREF=#mgProjectionConvertXYZtoLLE>mgProjectionConvertXYZtoLLE</A><BR> 
<A HREF=#mgProjectionConvertLLEtoXYZ>mgProjectionConvertLLEtoXYZ</A><BR><P>
<H3>Texture Functions</H3><P>
<A HREF=#mgSelectTextureIndex>mgSelectTextureIndex</A><BR> 
<A HREF=#mgDeselectTextureIndex>mgDeselectTextureIndex</A><BR> 
<A HREF=#mgDeselectAllTextures>mgDeselectAllTextures</A><BR> 
<A HREF=#mgGetFirstSelectedTexture>mgGetFirstSelectedTexture</A><BR> 
<A HREF=#mgGetNextSelectedTexture>mgGetNextSelectedTexture</A><BR> 
<A HREF=#mgGetSelectedTextureCount>mgGetSelectedTextureCount</A><BR> 
<A HREF=#mgIsTextureIndexSelected>mgIsTextureIndexSelected</A><BR><P>
<H3>Tool Activation Functions</H3><P>
<A HREF=#mgSetModelingParent>mgSetModelingParent</A><BR> 
<A HREF=#mgSetModelingModeEdge>mgSetModelingModeEdge</A><BR> 
<A HREF=#mgIsModelingModeEdge>mgIsModelingModeEdge</A><BR><P>
<H2>New Symbols</H2><P>
<A HREF=#mgnotifierevent>MNOTIFY_TEXTURESELECTCHANGED</A> for <A HREF=#mgRegisterNotifier>mgRegisterNotifier</A><BR> 
<A HREF=#MEFV_1640>MEFV_1640</A> for <A HREF=#mgExportDb>mgExportDb</A><BR> 
<A HREF=#mgtagtype>MTYPE_XML</A> for <A HREF=#mgtagtype>mgtagtype</A><BR><P>
<H2>Fixes</H2><P>
Fixed <A HREF=#mgReadMaterialFile>mgReadMaterialFile</A>, <A HREF=#mgWriteMaterialFile>mgWriteMaterialFile</A> and <A HREF=#mgWriteMaterialFileVersion>mgWriteMaterialFileVersion</A> 
to return <A HREF=#mgbool>MG_TRUE</A> only when successful.<P>
<H1>v3.5.2</H1><P>
This version of the OpenFlight API corresponds to OpenFlight version 16.3.<P>
The VC8 versions of the OpenFlight API DLLs were corrected to contain 
the proper embedded manifests.  When the OpenFlight API DLLs are loaded 
into memory, the operating system DLL loader uses the embedded manifests 
to resolve dependencies for the OpenFlight API DLLs.  This fix will allow 
the OpenFlight API DLLs to be used in both Debug and Release versions of 
your stand-alone applications. This fix will also enable the VC8 versions 
to be used in OpenFlight Script (Python).<P>
<H1>v3.5.1</H1><P>
This version of the OpenFlight API corresponds to OpenFlight version 16.3.<P>
No new functions were added for this release.<P>
<H1>v3.5</H1><P>
This version of the OpenFlight API corresponds to OpenFlight version 16.3.<P>
<H2>Visual Studio Compatibility</H2><P>
This version of the OpenFlight API is distributed in two binary formats 
for the Windows platform; Visual Studio 6 (VC6-Win32) and Visual Studio 2005 
(VC8-Win32).  Both distributions cannot be installed simultaneously on the same computer. 
If you are developing plug-ins for Creator v3.4 or later, you must use VC8 so your 
plug-ins are compatible with Creator.  If you are developing plug-ins for Creator v3.3 or 
earlier, you must use VC6-Win32.  If you are developing stand-alone applications, you can 
choose either VC6-Win32 or VC8-Win32. 
either format.<P>
<H2>OpenFlight Script</H2><P>
The OpenFlight Script scripting language was introduced.  Based on Python, 
OpenFlight Scripts can be run in either the stand-alone program environment 
or in Creator.  See the <I>OpenFlight API Developer Guide</I> and <I>Creator Help</I>, 
respectively, for more information.<P>
To run stand-alone OpenFlight Scripts, a Python 2.5.X installation is required. 
No Python installation is required to run OpenFlight Scripts in Creator.<P>
<H2>OpenFlight API Installation Root</H2><P>
The OpenFlight API is now installed into the Presagis Common Directory Organization. 
The root of this directory structure is: 
<PRE CLASS="EXAMPLE">c:/presagis</PRE><P>
The directory structure below this root folder has not changed from previous 
installations.  The names of the environment variables created by the installer 
have changed to <B>PRESAGIS_OPENFLIGHT_API</B> and <B>PRESAGIS_OPENFLIGHT_API_version</B>, 
where <B>version</B> specifies the major and minor version numbers of the distribution. 
For OpenFlight API 3.5 the environment variable is <B>PRESAGIS_OPENFLIGHT_API_3_5</B>. 
The values for both these variables are the same.  They specify the root of the 
OpenFlight API installation.<P>
<H2>New Data Types</H2><P>
<A HREF=#mgnodeexpression>mgnodeexpression</A><BR> 
<A HREF=#mgnodeexpressionoperator>mgnodeexpressionoperator</A><BR><P>
<H2>New Functions</H2><P>
<H3>Color Functions</H3><P>
<A HREF=#mgGetColorNameList>mgGetColorNameList</A><BR><P>
<H3>Geometry Functions</H3><P>
<A HREF=#mgCoord2dLerp>mgCoord2dLerp</A><BR> 
<A HREF=#mgCoord3dLerp>mgCoord3dLerp</A><BR> 
<A HREF=#mgVectordLerp>mgVectordLerp</A><BR><P>
<H3>Structure Functions</H3><P>
<A HREF=#mgFind>mgFind</A><BR> 
<A HREF=#mgFindEx>mgFindEx</A><BR> 
<A HREF=#mgEvaluateAsBool>mgEvaluateAsBool</A><BR> 
<A HREF=#mgFreeNodeExpression>mgFreeNodeExpression</A><BR> 
<A HREF=#mgNewNodeExpressionCallback>mgNewNodeExpressionCallback</A><BR> 
<A HREF=#mgNewNodeExpressionDouble>mgNewNodeExpressionDouble</A><BR> 
<A HREF=#mgNewNodeExpressionGetAtt>mgNewNodeExpressionGetAtt</A><BR> 
<A HREF=#mgNewNodeExpressionInteger>mgNewNodeExpressionInteger</A><BR> 
<A HREF=#mgNewNodeExpressionOperator>mgNewNodeExpressionOperator</A><BR> 
<A HREF=#mgnodeexpressionfunc>mgnodeexpressionfunc</A><BR> 
<A HREF=#mgNodeExpressionLoadFromString>mgNodeExpressionLoadFromString</A><BR> 
<A HREF=#mgNodeExpressionSetLeft>mgNodeExpressionSetLeft</A><BR> 
<A HREF=#mgNodeExpressionSetRight>mgNodeExpressionSetRight</A><BR><P>
<H3>Select List Functions</H3><P>
<A HREF=#mgIterateRecList>mgIterateRecList</A><BR> 
<A HREF=#mgAppendRecList>mgAppendRecList</A><BR> 
<A HREF=#mgNewRecList>mgNewRecList</A><BR><P>
<H3>Text Functions</H3><P>
<A HREF=#mgTextAppendString>mgTextAppendString</A><BR> 
<A HREF=#mgTextGetSelectionRange>mgTextGetSelectionRange</A><BR><P>
<H3>General Controls</H3><P>
<A HREF=#mgControlSubclass>mgControlSubclass</A><BR><P>
<H3>Dialog Functions</H3><P>
<A HREF=#mgDialogSubclass>mgDialogSubclass</A><BR><P>
<H3>Editor Context Functions</H3><P>
<A HREF=#mgNewEditorContext>mgNewEditorContext</A><BR><P>
<H2>New Symbols</H2><P>
<A HREF=#MPREFI_SHADEWIRE>MPREFI_SHADEWIRE</A> for <A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A><BR> 
<A HREF=#mgpaletteid>MPID_SHADERPALETTE</A> for <A HREF=#mgShowPalette>mgShowPalette</A><BR><P>
<H2>New Menu Locations for Editor and Viewer Tools</H2><P>
(see <A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A>)<P>
<A HREF=#MMENU_SCRIPTS>MMENU_SCRIPTS</A><BR><P>
<H1>v3.4.1</H1><P>
This version of the OpenFlight API corresponds to OpenFlight version 16.3.<P>
The following functions were inadvertently omitted from the OpenFlight API 
3.4 distribution. They are included with this version of the OpenFlight API.<BR> 
<A HREF=#mgWriteMaterialFileVersion>mgWriteMaterialFileVersion</A><BR> 
<A HREF=#mgReadLightSourceFile>mgReadLightSourceFile</A><BR><P>
<H2>Fixes</H2><P>
Fixed <A HREF=#mgListAddItemData>mgListAddItemData</A> to attach user data to list item properly.<P>
<H1>v3.4</H1><P>
This version of the OpenFlight API corresponds to OpenFlight version 16.3.<P>
<H2>Visual Studio Compatibility</H2><P>
This version of the OpenFlight API is distributed in two binary formats 
for the Windows platform; Visual Studio 6 (VC6-Win32) and Visual Studio 2005 
(VC8-Win32).  Both distributions cannot be installed simultaneously on the same computer. 
If you are developing plug-ins for Creator v3.4 or later, you must use VC8 so your 
plug-ins are compatible with Creator.  If you are developing plug-ins for Creator v3.3 or 
earlier, you must use VC6-Win32.  If you are developing stand-alone applications, you can 
choose either format.<P>
If you are using VC8, you must link your stand-alone application with the 
Release versions of the MicroSoft C Runtime libraries (even in Debug configurations). 
This is necessary because in VC8, it is recommended NOT to mix Debug and Release 
versions of the C Runtime libraries.  Since the OpenFlight API DLLs link against 
the Release versions, so should your application.  In Visual Studio, open 
the <B>Project Properties</B> window, select the <B>C/C++</B> tab and then select the 
<B>Code Generation</B> category.  For <B>Runtime Library</B> field, select 
<B>Multithreaded DLL</B> (/Md) for both Win32 Debug and Release configurations.<P>
<H2>Extended Material Palette Entries</H2><P>
A new kind of material entry has been introduced.  A material palette can now be 
composed of either old (standard) or new (extended) material entries (or a mixture 
of both kinds).  This new extended material entry is composed of several optional 
properties.  These properties are listed below.  This change to the material palette 
affects the format of material palette files saved to disk by <A HREF=#mgWriteMaterialFile>mgWriteMaterialFile</A>. 
While <A HREF=#mgWriteMaterialFile>mgWriteMaterialFile</A> now writes the "new" material palette file format, 
<A HREF=#mgWriteMaterialFileVersion>mgWriteMaterialFileVersion</A> was introduced to write either the "old" or "new" 
format.  Similarly, when saving a material palette file in Creator, you can 
choose to write the "old" or "new" format.  Note that <A HREF=#mgReadMaterialFile>mgReadMaterialFile</A> 
will read either the "old" or "new" material palette file format.<P>
<H3>Material Palette Nodes</H3><P>
The following records were added to <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltIMaterial>fltIMaterial</A>
<BR> 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltAmbientEx>fltAmbientEx</A>
<BR> 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDiffuseEx>fltDiffuseEx</A>
<BR> 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSpecularEx>fltSpecularEx</A>
<BR> 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltEmissiveEx>fltEmissiveEx</A>
<BR> 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltAlphaEx>fltAlphaEx</A>
<BR> 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltBumpMapEx>fltBumpMapEx</A>
<BR> 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltNormalMapEx>fltNormalMapEx</A>
<BR> 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLightMapEx>fltLightMapEx</A>
<BR> 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltShadowMapEx>fltShadowMapEx</A>
<BR> 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltReflectionMapEx>fltReflectionMapEx</A>
<BR><P>
<H2>New Functions</H2><P>
<H3>Attribute Functions</H3><P>
<A HREF=#mgGetMatTextureLayer>mgGetMatTextureLayer</A><BR> 
<A HREF=#mgSetMatTextureLayer>mgSetMatTextureLayer</A><BR> 
<A HREF=#mgSetNameUnique>mgSetNameUnique</A><BR> 
<A HREF=#mgSetPolyCurrentColor>mgSetPolyCurrentColor</A><BR> 
<A HREF=#mgSetPolyCurrentAltColor>mgSetPolyCurrentAltColor</A><BR> 
<A HREF=#mgSetPolyCurrentMaterial>mgSetPolyCurrentMaterial</A><BR> 
<A HREF=#mgSetPolyCurrentShader>mgSetPolyCurrentShader</A><BR> 
<A HREF=#mgSetPolyCurrentTexture>mgSetPolyCurrentTexture</A><BR> 
<A HREF=#mgSetPolyCurrentTextureMapping>mgSetPolyCurrentTextureMapping</A><BR><P>
<H3>Eyepoint Functions</H3><P>
<A HREF=#mgGetSwitchDistance>mgGetSwitchDistance</A><BR> 
<A HREF=#mgSetSwitchDistance>mgSetSwitchDistance</A><BR><P>
<H3>Light Source Functions</H3><P>
<A HREF=#mgReadLightSourceFile>mgReadLightSourceFile</A><BR><P>
<H3>Material Functions</H3><P>
<A HREF=#mgWriteMaterialFileVersion>mgWriteMaterialFileVersion</A><BR><P>
<H3>Select List Functions</H3><P>
<A HREF=#mgIsRecInList>mgIsRecInList</A><BR><P>
<H3>Tool Registration Functions</H3><P>
<A HREF=#mgGetModulePath>mgGetModulePath</A><P>
<H2>New Symbols</H2><P>
<A HREF=#MEFV_1630>MEFV_1630</A> for <A HREF=#mgExportDb>mgExportDb</A> and <A HREF=#mgWriteMaterialFileVersion>mgWriteMaterialFileVersion</A><BR> 
<A HREF=#MEFV_1620>MEFV_1620</A> for <A HREF=#mgExportDb>mgExportDb</A> and <A HREF=#mgWriteMaterialFileVersion>mgWriteMaterialFileVersion</A><BR><P>
For <A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A> and <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>:<BR> 
<A HREF=#MGVI_SKYCOLOR>MGVI_SKYCOLOR</A><BR><P>
<A HREF=#mgnotifierevent>MNOTIFY_DESKTOPINIT</A> for <A HREF=#mgRegisterNotifier>mgRegisterNotifier</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_DESKTOPEXIT</A> for <A HREF=#mgRegisterNotifier>mgRegisterNotifier</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_DATABASEOPENED</A> for <A HREF=#mgRegisterNotifier>mgRegisterNotifier</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_DATABASESAVED</A> for <A HREF=#mgRegisterNotifier>mgRegisterNotifier</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_NODECHANGED</A> for <A HREF=#mgRegisterNotifier>mgRegisterNotifier</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_NODEDELETED</A> for <A HREF=#mgRegisterNotifier>mgRegisterNotifier</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_NODECREATED</A> for <A HREF=#mgRegisterNotifier>mgRegisterNotifier</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_NODEREPARENTED</A> for <A HREF=#mgRegisterNotifier>mgRegisterNotifier</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_COLORPALETTECHANGED</A> for <A HREF=#mgRegisterPaletteNotifier>mgRegisterPaletteNotifier</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_TEXTUREPALETTECHANGED</A> for <A HREF=#mgRegisterPaletteNotifier>mgRegisterPaletteNotifier</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_MATERIALPALETTECHANGED</A> for <A HREF=#mgRegisterPaletteNotifier>mgRegisterPaletteNotifier</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_TEXTUREMAPPINGPALETTECHANGED</A> for <A HREF=#mgRegisterPaletteNotifier>mgRegisterPaletteNotifier</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_LIGHTPOINTAPPEARANCEPALETTECHANGED</A> for <A HREF=#mgRegisterPaletteNotifier>mgRegisterPaletteNotifier</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_LIGHTPOINTANIMATIONPALETTECHANGED</A> for <A HREF=#mgRegisterPaletteNotifier>mgRegisterPaletteNotifier</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_SHADERPALETTECHANGED</A> for <A HREF=#mgRegisterPaletteNotifier>mgRegisterPaletteNotifier</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_SOUNDPALETTECHANGED</A> for <A HREF=#mgRegisterPaletteNotifier>mgRegisterPaletteNotifier</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_LIGHTSOURCEPALETTECHANGED</A> for <A HREF=#mgRegisterPaletteNotifier>mgRegisterPaletteNotifier</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_SWITCHDISTANCECHANGED</A> for <A HREF=#mgRegisterNotifier>mgRegisterNotifier</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_TIMEOFDAYCHANGED</A> for <A HREF=#mgRegisterNotifier>mgRegisterNotifier</A><BR><P>
<H2>New in the OpenFlight Data Dictionary</H2><P>
The following fields were added to <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltIMaterial>fltIMaterial</A>
:<BR> 
fltMatType<BR> 
fltMatShadeModel<BR><P>
<H1>v3.3</H1><P>
This version of the OpenFlight API corresponds to OpenFlight version 16.2.<P>
Levels 1, 2 and 3 of the API were implemented on the Linux platform.<P>
<H2>New Functions</H2><P>
<H3>General Controls</H3><P>
<A HREF=#mgSetFocus>mgSetFocus</A><BR><P>
<H3>Preference Functions</H3><P>
<A HREF=#mgPluginPrefGetBool>mgPluginPrefGetBool</A><BR> 
<A HREF=#mgPluginPrefSetBool>mgPluginPrefSetBool</A><BR> 
<A HREF=#mgPluginToolPrefGetBool>mgPluginToolPrefGetBool</A><BR> 
<A HREF=#mgPluginToolPrefSetBool>mgPluginToolPrefSetBool</A><BR><P>
<H2>New Symbols</H2><P>
For <A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A> and <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>:<BR> 
<A HREF=#MGVI_XRAYMODE>MGVI_XRAYMODE</A><BR> 
<A HREF=#MGVI_DYNAMICBILLBOARDS>MGVI_DYNAMICBILLBOARDS</A><BR> 
<A HREF=#MGVI_DYNAMICTEXTURE>MGVI_DYNAMICTEXTURE</A><BR> 
<A HREF=#MGVI_DYNAMICWIREFRAME>MGVI_DYNAMICWIREFRAME</A><BR><P>
<H1>v3.2.2</H1><P>
This version of the OpenFlight API corresponds to OpenFlight version 16.2.<P>
Significant improvements were made in this distribution in the following areas:<BR> 
Memory leaks fixed relating to Transformation nodes.<BR> 
OpenFlight extensions for palette nodes.<BR> 
UNC file name handling.<BR><P>
<H2>New Symbols</H2><P>
<A HREF=#mgnotifierevent>MNOTIFY_LIGHTPOINTPALETTEIZED</A> for <A HREF=#mgRegisterNotifier>mgRegisterNotifier</A><BR><P>
<H1>v3.2.1</H1><P>
This version of the OpenFlight API corresponds to OpenFlight version 16.2.<P>
The OpenFlight API Reference distributed with OpenFlight API 3.2 was not the 
correct version.  The correct version has been included in this distribution and has 
been updated accordingly with new functions 
for 3.2.1.<P>
<H2>New Functions</H2><P>
<H3>Structure Functions</H3><P>
<A HREF=#mgIsXformEmpty>mgIsXformEmpty</A><BR><P>
<H1>v3.2</H1><P>
This version of the OpenFlight API corresponds to OpenFlight version 16.2.<P>
<H2>Constant Qualifiers in Function Declarations</H2><P>
The signatures for several function calls have been modified to include the 
C language 'const' qualifier where appropriate.  In most instances this will 
not affect your existing code.  Following is a list of the affected functions:<P>
<A HREF=#mgGetRecByName>mgGetRecByName</A><BR> 
<A HREF=#mgSetName>mgSetName</A><BR> 
<A HREF=#mgSetTextString>mgSetTextString</A><BR> 
<A HREF=#mgSetComment>mgSetComment</A><BR> 
<A HREF=#mgSetSwitchMaskName>mgSetSwitchMaskName</A><BR><P>
<A HREF=#mgGuiPutProperty>mgGuiPutProperty</A><BR> 
<A HREF=#mgGuiGetProperty>mgGuiGetProperty</A><BR> 
<A HREF=#mgGuiDeleteProperty>mgGuiDeleteProperty</A><BR><P>
<A HREF=#mgRecPutProperty>mgRecPutProperty</A><BR> 
<A HREF=#mgRecGetProperty>mgRecGetProperty</A><BR> 
<A HREF=#mgRecDeleteProperty>mgRecDeleteProperty</A><BR><P>
<A HREF=#mgPluginToolPrefGetString>mgPluginToolPrefGetString</A><BR><P>
<A HREF=#mgEditorPutProperty>mgEditorPutProperty</A><BR> 
<A HREF=#mgEditorGetProperty>mgEditorGetProperty</A><BR> 
<A HREF=#mgEditorDeleteProperty>mgEditorDeleteProperty</A><BR> 
<A HREF=#mgEditorSetPrompt>mgEditorSetPrompt</A><BR> 
<A HREF=#mgEditorAddUndo>mgEditorAddUndo</A><BR> 
<A HREF=#mgEditorAppendUndo>mgEditorAppendUndo</A><BR> 
<A HREF=#mgEditorAddUndoForCreate>mgEditorAddUndoForCreate</A><BR> 
<A HREF=#mgEditorAppendUndoForCreate>mgEditorAppendUndoForCreate</A><BR> 
<A HREF=#mgEditorAddUndoForDelete>mgEditorAddUndoForDelete</A><BR> 
<A HREF=#mgEditorAppendUndoForDelete>mgEditorAppendUndoForDelete</A><BR> 
<A HREF=#mgEditorAddUndoForMove>mgEditorAddUndoForMove</A><BR> 
<A HREF=#mgEditorAppendUndoForMove>mgEditorAppendUndoForMove</A><BR><P>
<A HREF=#mgPluginPutProperty>mgPluginPutProperty</A><BR> 
<A HREF=#mgPluginGetProperty>mgPluginGetProperty</A><BR> 
<A HREF=#mgPluginDeleteProperty>mgPluginDeleteProperty</A><BR> 
<A HREF=#mgPluginToolPutProperty>mgPluginToolPutProperty</A><BR> 
<A HREF=#mgPluginToolGetProperty>mgPluginToolGetProperty</A><BR> 
<A HREF=#mgPluginToolDeleteProperty>mgPluginToolDeleteProperty</A><BR><P>
<A HREF=#mgNewShader>mgNewShader</A><BR> 
<A HREF=#mgIndexOfShader>mgIndexOfShader</A><BR> 
<A HREF=#mgDeleteShader>mgDeleteShader</A><BR><P>
<A HREF=#mgNewLightPointAppearance>mgNewLightPointAppearance</A><BR> 
<A HREF=#mgIndexOfLightPointAppearance>mgIndexOfLightPointAppearance</A><BR> 
<A HREF=#mgNewLightPointAnimation>mgNewLightPointAnimation</A><BR> 
<A HREF=#mgIndexOfLightPointAnimation>mgIndexOfLightPointAnimation</A><BR> 
<A HREF=#mgReadLightPointFile>mgReadLightPointFile</A><BR> 
<A HREF=#mgWriteLightPointFile>mgWriteLightPointFile</A><BR><P>
<A HREF=#mgNewTextureMapping>mgNewTextureMapping</A><BR> 
<A HREF=#mgIndexOfTextureMapping>mgIndexOfTextureMapping</A><BR> 
<A HREF=#mgDeleteTextureMappingByName>mgDeleteTextureMappingByName</A><BR> 
<A HREF=#mgReadTextureMappingFile>mgReadTextureMappingFile</A><BR> 
<A HREF=#mgWriteTextureMappingFile>mgWriteTextureMappingFile</A><BR><P>
<A HREF=#mgNewMaterial>mgNewMaterial</A><BR> 
<A HREF=#mgIndexOfMaterial>mgIndexOfMaterial</A><BR> 
<A HREF=#mgDeleteMaterialByName>mgDeleteMaterialByName</A><BR> 
<A HREF=#mgReadMaterialFile>mgReadMaterialFile</A><BR> 
<A HREF=#mgWriteMaterialFile>mgWriteMaterialFile</A><BR><P>
<A HREF=#mgNewColorName>mgNewColorName</A><BR> 
<A HREF=#mgGetColorIndexByName>mgGetColorIndexByName</A><BR> 
<A HREF=#mgDeleteColorName>mgDeleteColorName</A><BR> 
<A HREF=#mgReadColorPalette>mgReadColorPalette</A><BR> 
<A HREF=#mgWriteColorPalette>mgWriteColorPalette</A><BR> 
<A HREF=#mgWriteDefaultColorPalette>mgWriteDefaultColorPalette</A><BR> 
<A HREF=#mgSetCurrentColorName>mgSetCurrentColorName</A><BR> 
<A HREF=#mgSetPolyColorName>mgSetPolyColorName</A><BR> 
<A HREF=#mgSetPolyAltColorName>mgSetPolyAltColorName</A><BR><P>
<A HREF=#mgSendMessage>mgSendMessage</A><BR> 
<A HREF=#mgSendStatus>mgSendStatus</A><BR> 
<A HREF=#mgSendWarning>mgSendWarning</A><BR> 
<A HREF=#mgSendError>mgSendError</A><BR><P>
<A HREF=#mgIsDb>mgIsDb</A><BR> 
<A HREF=#mgNewDb>mgNewDb</A><BR> 
<A HREF=#mgOpenDb>mgOpenDb</A><BR> 
<A HREF=#mgSaveAsDb>mgSaveAsDb</A><BR> 
<A HREF=#mgExportDb>mgExportDb</A><BR><P>
<H2>New Data Types</H2><P>
<A HREF=#mgboxd>mgboxd</A><BR><P>
<H2>New Functions</H2><P>
<H3>Attribute Functions</H3><P>
<A HREF=#mgGetBounds>mgGetBounds</A><BR> 
<A HREF=#mgGetBoundsForRecList>mgGetBoundsForRecList</A><BR> 
<A HREF=#mgGetBoundsForSelect>mgGetBoundsForSelect</A><BR> 
<A HREF=#mgIsPolyCoplanar>mgIsPolyCoplanar</A><BR><P>
<H3>List Controls</H3><P>
<A HREF=#mgListAddItemData>mgListAddItemData</A><BR> 
<A HREF=#mgListAppendItemData>mgListAppendItemData</A><BR> 
<A HREF=#mgListSetItemDataAtPos>mgListSetItemDataAtPos</A><BR> 
<A HREF=#mgListGetItemDataAtPos>mgListGetItemDataAtPos</A><BR><P>
<H3>Matrix Functions</H3><P>
<A HREF=#mgMatrixFormXYZToUV>mgMatrixFormXYZToUV</A><BR><P>
<H3>Geometry Functions</H3><P>
<A HREF=#mgMakePlaned>mgMakePlaned</A><BR> 
<A HREF=#mgMakeBox>mgMakeBox</A><BR> 
<A HREF=#mgBoxGetXSize>mgBoxGetXSize</A><BR> 
<A HREF=#mgBoxGetYSize>mgBoxGetYSize</A><BR> 
<A HREF=#mgBoxGetZSize>mgBoxGetZSize</A><BR> 
<A HREF=#mgBoxGetDiagonalSize>mgBoxGetDiagonalSize</A><BR> 
<A HREF=#mgBoxGetCenter>mgBoxGetCenter</A><BR> 
<A HREF=#mgBoxGetCenterBottom>mgBoxGetCenterBottom</A><BR> 
<A HREF=#mgBoxExpandCoord3d>mgBoxExpandCoord3d</A><BR> 
<A HREF=#mgBoxExpandBox>mgBoxExpandBox</A><BR> 
<A HREF=#mgBoxContainsCoord3d>mgBoxContainsCoord3d</A><BR> 
<A HREF=#mgBoxContainsBox>mgBoxContainsBox</A><BR> 
<A HREF=#mgBoxIntersectsBox>mgBoxIntersectsBox</A><BR><P>
<H3>GL Controls</H3><P>
<A HREF=#mgDrawControlNow>mgDrawControlNow</A><BR><P>
<H3>Graphics View Functions</H3><P>
<A HREF=#mgFitOnNode>mgFitOnNode</A><BR> 
<A HREF=#mgFitOnGrid>mgFitOnGrid</A><BR> 
<A HREF=#mgFitOnRecList>mgFitOnRecList</A><BR> 
<A HREF=#mgFitOnSelect>mgFitOnSelect</A><BR> 
<A HREF=#mgResetView>mgResetView</A><BR> 
<A HREF=#mgGraphicsViewSettingGetMatrix>mgGraphicsViewSettingGetMatrix</A><BR> 
<A HREF=#mgGraphicsViewSettingSetMatrix>mgGraphicsViewSettingSetMatrix</A><BR><P>
<H3>List Controls</H3><P>
<A HREF=#mgListAddItemData>mgListAddItemData</A><BR> 
<A HREF=#mgListAppendItemData>mgListAppendItemData</A><BR> 
<A HREF=#mgListSetItemDataAtPos>mgListSetItemDataAtPos</A><BR> 
<A HREF=#mgListGetItemDataAtPos>mgListGetItemDataAtPos</A><BR><P>
<H3>Matrix Functions</H3><P>
<A HREF=#mgMatrixFormXYZToUV>mgMatrixFormXYZToUV</A><BR><P>
<H2>New Symbols</H2><P>
For <A HREF=#mgResourceGetPixmap>mgResourceGetPixmap</A>:<BR> 
<A HREF=#MPIXMAP_NEWFILE>MPIXMAP_NEWFILE</A><BR> 
<A HREF=#MPIXMAP_OPENFILE>MPIXMAP_OPENFILE</A><BR> 
<A HREF=#MPIXMAP_SAVEFILE>MPIXMAP_SAVEFILE</A><BR> 
<A HREF=#MPIXMAP_CUT>MPIXMAP_CUT</A><BR> 
<A HREF=#MPIXMAP_COPY>MPIXMAP_COPY</A><BR> 
<A HREF=#MPIXMAP_PASTE>MPIXMAP_PASTE</A><BR> 
<A HREF=#MPIXMAP_DELETE>MPIXMAP_DELETE</A><BR> 
<A HREF=#MPIXMAP_EDIT>MPIXMAP_EDIT</A><BR> 
<A HREF=#MPIXMAP_TEST>MPIXMAP_TEST</A><BR> 
<A HREF=#MPIXMAP_UNDO>MPIXMAP_UNDO</A><BR> 
<A HREF=#MPIXMAP_REDO>MPIXMAP_REDO</A><BR> 
<A HREF=#MPIXMAP_ROTATEVIEW>MPIXMAP_ROTATEVIEW</A><BR> 
<A HREF=#MPIXMAP_PANVIEW>MPIXMAP_PANVIEW</A><BR> 
<A HREF=#MPIXMAP_ZOOMVIEW>MPIXMAP_ZOOMVIEW</A><BR> 
<A HREF=#MPIXMAP_ARROW>MPIXMAP_ARROW</A><BR> 
<A HREF=#MPIXMAP_FENCE>MPIXMAP_FENCE</A><BR> 
<A HREF=#MPIXMAP_LASSO>MPIXMAP_LASSO</A><BR> 
<A HREF=#MPIXMAP_FITONFENCE>MPIXMAP_FITONFENCE</A><BR><P>
For <A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A> and <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>:<BR> 
<A HREF=#MGVI_DRAWORDER>MGVI_DRAWORDER</A><BR><P>
For <A HREF=#mgGraphicsViewSettingGetMatrix>mgGraphicsViewSettingGetMatrix</A> and <A HREF=#mgGraphicsViewSettingSetMatrix>mgGraphicsViewSettingSetMatrix</A>:<BR> 
<A HREF=#MGVM_PROJECTION>MGVM_PROJECTION</A><BR> 
<A HREF=#MGVM_MODELVIEW>MGVM_MODELVIEW</A><BR> 
<A HREF=#MGVM_MODELVIEWPROJECTION>MGVM_MODELVIEWPROJECTION</A><BR><P>
For <A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A>:<BR> 
<A HREF=#MPREFI_SIZEHANDLES>MPREFI_SIZEHANDLES</A><BR> 
<A HREF=#MPREFI_SCALEHANDLES>MPREFI_SCALEHANDLES</A><BR> 
<A HREF=#MPREFI_HANDLETHICKNESS>MPREFI_HANDLETHICKNESS</A><BR> 
<A HREF=#MPREFI_DRAWHANDLESONTOP>MPREFI_DRAWHANDLESONTOP</A><BR><P>
<A HREF=#MEFV_1610>MEFV_1610</A> for <A HREF=#mgExportDb>mgExportDb</A><BR><P>
<H2>New in the OpenFlight Data Dictionary</H2><P>
<P>
<H3>External Reference Nodes</H3><P>
The following field was exposed in <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXref>fltXref</A>
<BR> 
fltXrefViewAsBox<BR><P>
<H3>Object Nodes</H3><P>
The following field was added to <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltObject>fltObject</A>
<BR> 
fltObjPreserveAtRuntime<BR><P>
<H3>Group Nodes</H3><P>
The following field was added to <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltGroup>fltGroup</A>
<BR> 
fltGrpPreserveAtRuntime<BR><P>
<H1>v3.1</H1><P>
This version of the OpenFlight API corresponds to OpenFlight version 16.1.<P>
<H2>Common Directory Organization</H2><P>
The OpenFlight API is now installed into the updated MultiGen-Paradigm 
Common Directory Organization.  This structure is significantly different 
than previous installations and affects the developer in the following areas:<P>
OpenFlight API installation root<BR> 
Location of C source header files<BR> 
Location of link libraries<BR> 
Location of documentation<BR> 
Location of sample code<BR> 
Location of redistributable OpenFlight API binaries<BR><P>
Note that the relocation of the C source header files 
and link libraries will cause developers to update their 
Visual Studio Project files and/or makefiles before 
the corresponding application(s) or plug-in(s) can be rebuilt 
with this version of the OpenFlight API.<P>
<H3>OpenFlight API Installation Root</H3><P>
The installer now creates two environment variables <B>MPI_LOCATE_OPENFLIGHT_API</B> 
and <B>MPI_LOCATE_OPENFLIGHT_API_version</B>, where <B>version</B> 
specifies the major and minor version numbers of the distribution.  For 
OpenFlight API 3.1 the environment variable is <B>MPI_LOCATE_OPENFLIGHT_API_3_1</B>. 
The values for both these variables are the same.  They specify the root of the 
OpenFlight API installation. The unversioned variable is the same as in previous 
installations.  The new "versioned" variable is intended to better support multiple 
installations of the OpenFlight API to coexist on your computer.<P>
<H3>Location of C source header files</H3><P>
The C source header files have been relocated to: 
<PRE CLASS="EXAMPLE">MPI_LOCATE_OPENFLIGHT_API/include</PRE><P>
<H3>Location of link libraries</H3><P>
The link libraries have been relocated to: 
<PRE CLASS="EXAMPLE">MPI_LOCATE_OPENFLIGHT_API/lib</PRE><P>
<H3>Location of documentation</H3><P>
The documentation has been relocated to: 
<PRE CLASS="EXAMPLE">MPI_LOCATE_OPENFLIGHT_API/docs</PRE><P>
<H3>Location of sample code</H3><P>
The samples have been relocated to: 
<PRE CLASS="EXAMPLE">MPI_LOCATE_OPENFLIGHT_API/samples</PRE><P>
with subfolders for the individual kinds of samples: 
<PRE CLASS="EXAMPLE">/apps - sample stand-alone programs 
/extensions - sample OpenFlight data extensions 
/plugins - sample plug-ins</PRE><P>
<H3>Location of redistributable OpenFlight API binaries</H3><P>
If you need to redistribute the OpenFlight API binaries, 
the dynamic link libraries you will need are located at:<P>
<PRE CLASS="EXAMPLE">MPI_LOCATE_OPENFLIGHT_API/samples/apps/bin</PRE><P>
<H2>New Functions</H2><P>
<H3>Dialog Functions</H3><P>
<A HREF=#mgPromptDialogTexture>mgPromptDialogTexture</A><BR><P>
<H3>General Controls</H3><P>
<A HREF=#mgGuiGetId>mgGuiGetId</A><BR><P>
<H3>Geometry Functions</H3><P>
<A HREF=#mgVectordToCoord3d>mgVectordToCoord3d</A><BR> 
<A HREF=#mgCoord3dToVectord>mgCoord3dToVectord</A><BR> 
<A HREF=#mgVectordXAxis>mgVectordXAxis</A><BR> 
<A HREF=#mgVectordNegativeXAxis>mgVectordNegativeXAxis</A><BR> 
<A HREF=#mgVectordYAxis>mgVectordYAxis</A><BR> 
<A HREF=#mgVectordNegativeYAxis>mgVectordNegativeYAxis</A><BR> 
<A HREF=#mgVectordZAxis>mgVectordZAxis</A><BR> 
<A HREF=#mgVectordNegativeZAxis>mgVectordNegativeZAxis</A><BR> 
<A HREF=#mgCoord3fTransform>mgCoord3fTransform</A><BR> 
<A HREF=#mgVectorfTransform>mgVectorfTransform</A><BR><P>
<H3>Graphics View Functions</H3><P>
<A HREF=#mgSetCurrentGridPoints>mgSetCurrentGridPoints</A><BR> 
<A HREF=#mgGetCurrentGridPoints>mgGetCurrentGridPoints</A><BR><P>
<H3>Image To Geometry Projection Function</H3><P>
<A HREF=#mgImageToXYZMatrix>mgImageToXYZMatrix</A><BR><P>
<H3>Matrix Functions</H3><P>
<A HREF=#mgMatrixEqual>mgMatrixEqual</A><BR><P>
<H3>Preference Functions</H3><P>
<A HREF=#mgSetCompressVertexTableFlag>mgSetCompressVertexTableFlag</A><BR> 
<A HREF=#mgSetAutoUpdatePriorityFlag>mgSetAutoUpdatePriorityFlag</A><BR><P>
<H3>Projection Functions</H3><P>
<A HREF=#mgProject>mgProject</A><BR> 
<A HREF=#mgUnproject>mgUnproject</A><BR><P>
<H3>Select List Functions</H3><P>
<A HREF=#mgIsSelectedEdge>mgIsSelectedEdge</A><BR> 
<A HREF=#mgSelectOneEdge>mgSelectOneEdge</A><BR><P>
<H3>Shader Functions</H3><P>
<A HREF=#mgShaderGetVertexProgramNth>mgShaderGetVertexProgramNth</A><BR> 
<A HREF=#mgShaderGetFragmentProgramNth>mgShaderGetFragmentProgramNth</A><BR> 
<A HREF=#mgShaderAddFragmentProgram>mgShaderAddFragmentProgram</A><BR> 
<A HREF=#mgShaderAddVertexProgram>mgShaderAddVertexProgram</A><BR> 
<A HREF=#mgShaderSetVertexProgramNth>mgShaderSetVertexProgramNth</A><BR> 
<A HREF=#mgShaderSetFragmentProgramNth>mgShaderSetFragmentProgramNth</A><BR> 
<A HREF=#mgShaderDeleteVertexProgramNth>mgShaderDeleteVertexProgramNth</A><BR> 
<A HREF=#mgShaderDeleteFragmentProgramNth>mgShaderDeleteFragmentProgramNth</A><BR><P>
<H3>Texture Functions</H3><P>
<A HREF=#mgSubTextureGetBounds>mgSubTextureGetBounds</A><BR><P>
<H3>Tool Action Functions</H3><P>
<A HREF=#mgPluginToolNewAction>mgPluginToolNewAction</A><BR> 
<A HREF=#mgPluginToolFreeAction>mgPluginToolFreeAction</A><BR> 
<A HREF=#mgPluginToolGetAction>mgPluginToolGetAction</A><BR> 
<A HREF=#mgToolActionGetName>mgToolActionGetName</A><BR> 
<A HREF=#mgToolActionSetShortCut>mgToolActionSetShortCut</A><BR> 
<A HREF=#mgToolActionGetShortCut>mgToolActionGetShortCut</A><BR> 
<A HREF=#mgToolActionGetShortCutString>mgToolActionGetShortCutString</A><BR> 
<A HREF=#mgSetGuiToolAction>mgSetGuiToolAction</A><BR><P>
<H2>New Data Types</H2><P>
<A HREF=#mgprojcoord>mgprojcoord</A><BR> 
<A HREF=#mgtoolaction>mgtoolaction</A><BR> 
<A HREF=#mgkeysequence>mgkeysequence</A><BR> 
<A HREF=#mgkeytype>mgkeytype</A><BR><P>
<H2>New Symbols</H2><P>
<A HREF=#mgmessageseverityenum>MMSG_TIP</A> for <A HREF=#mgSendMessage>mgSendMessage</A><BR> 
<A HREF=#MPREFI_AUTOAPPLYSHADELIT2D>MPREFI_AUTOAPPLYSHADELIT2D</A> for <A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A><BR> 
<A HREF=#MPREFI_AUTOAPPLYSHADELIT3D>MPREFI_AUTOAPPLYSHADELIT3D</A> for <A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A><BR> 
<A HREF=#MPREFI_FLIPDDSIMAGES>MPREFI_FLIPDDSIMAGES</A> for <A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A><BR> 
<A HREF=#MPREFI_SNAPROTATION>MPREFI_SNAPROTATION</A> for <A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A><BR> 
<A HREF=#MPREFI_SNAPHANDLES>MPREFI_SNAPHANDLES</A> for <A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A><BR> 
<A HREF=#MPREFD_SNAPTOANGLE>MPREFD_SNAPTOANGLE</A> for <A HREF=#mgModelingPrefGetDouble>mgModelingPrefGetDouble</A><BR> 
<A HREF=#MEFV_1600>MEFV_1600</A> for <A HREF=#mgExportDb>mgExportDb</A><BR> 
<A HREF=#mgcontrolattribute>MCA_SPINAUTOINCREMENT</A> for <A HREF=#mgControlSetAttribute>mgControlSetAttribute</A><BR><P>
<H2>New Tool Attributes for Editor Tools</H2><P>
(see <A HREF=#mgRegisterEditor>mgRegisterEditor</A>)<P>
<A HREF=#MTA_REPEATABLE>MTA_REPEATABLE</A><BR> 
<A HREF=#MTA_NOHIDESELECTOUTLINE>MTA_NOHIDESELECTOUTLINE</A><BR><P>
<H2>New Palette Locations for Editor and Viewer Tools</H2><P>
(see <A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A>)<P>
<A HREF=#MPAL_DEFORMTOOLS>MPAL_DEFORMTOOLS</A><BR><P>
<H2>New in the OpenFlight Data Dictionary</H2><P>
<P>
<H3>Shader Palette Nodes</H3><P>
The following field was added to <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltShaderPalette>fltShaderPalette</A>
<BR> 
fltShaderNumVertexPrograms<BR> 
fltShaderNumFragmentPrograms<BR><P>
<H3>Texture Mapping Palette Nodes</H3><P>
The following field was added to <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltTextureMapping>fltTextureMapping</A>
<BR> 
fltMappingTransformMatrix<BR><P>
<H1>v3.0</H1><P>
This version of the OpenFlight API corresponds to OpenFlight version 16.0.<P>
<H2>Loading Textures in Stand-Alone Applications</H2><P>
Prior to this version of the API, the texels of textures referenced by a database 
were loaded in memory when you opened the database in stand-alone applications. 
Starting in this version, the texels are not loaded in memory until your application 
explicitly requests them (using functions like mgGetTextureTexels or mgReadImage, for 
example).<P>
<H2>New Functions</H2><P>
<H3>Dialog Functions</H3><P>
<A HREF=#mgHideDialogCallback>mgHideDialogCallback</A><BR> 
<A HREF=#mgDestroyDialogCallback>mgDestroyDialogCallback</A><BR> 
<A HREF=#mgRefreshDialogCallback>mgRefreshDialogCallback</A><BR><P>
<H3>Editor Context Functions</H3><P>
<A HREF=#mgEditorSetSnapFace>mgEditorSetSnapFace</A><BR> 
<A HREF=#mgEditorAddRedo>mgEditorAddRedo</A><BR> 
<A HREF=#mgEditorAddUndoForRedo>mgEditorAddUndoForRedo</A><BR> 
<A HREF=#mgEditorAddUndoForCreate>mgEditorAddUndoForCreate</A><BR> 
<A HREF=#mgEditorAppendUndoForCreate>mgEditorAppendUndoForCreate</A><BR> 
<A HREF=#mgEditorAddUndoForDelete>mgEditorAddUndoForDelete</A><BR> 
<A HREF=#mgEditorAppendUndoForDelete>mgEditorAppendUndoForDelete</A><BR> 
<A HREF=#mgEditorAddUndoForMove>mgEditorAddUndoForMove</A><BR> 
<A HREF=#mgEditorAppendUndoForMove>mgEditorAppendUndoForMove</A><BR> 
<A HREF=#mgEditorGetPluginTool>mgEditorGetPluginTool</A><BR> 
<A HREF=#mgEditorGetProperty>mgEditorGetProperty</A><BR> 
<A HREF=#mgEditorPutProperty>mgEditorPutProperty</A><BR> 
<A HREF=#mgEditorDeleteProperty>mgEditorDeleteProperty</A><BR><P>
<H3>EyePoint Functions</H3><P>
<A HREF=#mgGetEyePointLookAt>mgGetEyePointLookAt</A><BR><P>
<H3>Geometry Functions</H3><P>
<A HREF=#mgCoord2dAdd>mgCoord2dAdd</A><BR> 
<A HREF=#mgCoord2dSubtract>mgCoord2dSubtract</A><BR> 
<A HREF=#mgCoord2dMultiply>mgCoord2dMultiply</A><BR> 
<A HREF=#mgCoord2dDivide>mgCoord2dDivide</A><BR> 
<A HREF=#mgCoord2dNegate>mgCoord2dNegate</A><BR> 
<A HREF=#mgCoord2dDot>mgCoord2dDot</A><BR> 
<A HREF=#mgCoord2dAngle>mgCoord2dAngle</A><BR> 
<A HREF=#mgCoord2dRotateCW>mgCoord2dRotateCW</A><BR> 
<A HREF=#mgCoord2dRotate90CW>mgCoord2dRotate90CW</A><BR> 
<A HREF=#mgCoord2dRotateCCW>mgCoord2dRotateCCW</A><BR> 
<A HREF=#mgCoord2dRotate90CCW>mgCoord2dRotate90CCW</A><BR> 
<A HREF=#mgCoord2dReflectX>mgCoord2dReflectX</A><BR> 
<A HREF=#mgCoord2dReflectY>mgCoord2dReflectY</A><BR> 
<A HREF=#mgCoord2dReflect>mgCoord2dReflect</A><BR> 
<A HREF=#mgCoord2dScalarProject>mgCoord2dScalarProject</A><BR> 
<A HREF=#mgCoord2dVectorProject>mgCoord2dVectorProject</A><BR> 
<A HREF=#mgCoord2dOrthoProject>mgCoord2dOrthoProject</A><BR> 
<A HREF=#mgCoord2dXAxis>mgCoord2dXAxis</A><BR> 
<A HREF=#mgCoord2dNegativeXAxis>mgCoord2dNegativeXAxis</A><BR> 
<A HREF=#mgCoord2dYAxis>mgCoord2dYAxis</A><BR> 
<A HREF=#mgCoord2dNegativeYAxis>mgCoord2dNegativeYAxis</A><BR> 
<A HREF=#mgCoord2dZero>mgCoord2dZero</A><BR> 
<A HREF=#mgCoord2dOne>mgCoord2dOne</A><BR> 
<A HREF=#mgCoord2dNegativeOne>mgCoord2dNegativeOne</A><BR> 
<A HREF=#mgCoord2dLength>mgCoord2dLength</A><BR> 
<A HREF=#mgCoord2dLengthSquared>mgCoord2dLengthSquared</A><BR> 
<A HREF=#mgCoord2dSetUnitized>mgCoord2dSetUnitized</A><BR> 
<A HREF=#mgCoord2dUnitize>mgCoord2dUnitize</A><BR> 
<A HREF=#mgCoord3dAdd>mgCoord3dAdd</A><BR> 
<A HREF=#mgCoord3dSubtract>mgCoord3dSubtract</A><BR> 
<A HREF=#mgCoord3dMultiply>mgCoord3dMultiply</A><BR> 
<A HREF=#mgCoord3dDivide>mgCoord3dDivide</A><BR> 
<A HREF=#mgCoord3dNegate>mgCoord3dNegate</A><BR> 
<A HREF=#mgCoord3dDot>mgCoord3dDot</A><BR> 
<A HREF=#mgCoord3dCross>mgCoord3dCross</A><BR> 
<A HREF=#mgCoord3dAngle>mgCoord3dAngle</A><BR> 
<A HREF=#mgCoord3dPitchDown>mgCoord3dPitchDown</A><BR> 
<A HREF=#mgCoord3dPitchDown90>mgCoord3dPitchDown90</A><BR> 
<A HREF=#mgCoord3dPitchUp>mgCoord3dPitchUp</A><BR> 
<A HREF=#mgCoord3dPitchUp90>mgCoord3dPitchUp90</A><BR> 
<A HREF=#mgCoord3dRollLeft>mgCoord3dRollLeft</A><BR> 
<A HREF=#mgCoord3dRollLeft90>mgCoord3dRollLeft90</A><BR> 
<A HREF=#mgCoord3dRollRight>mgCoord3dRollRight</A><BR> 
<A HREF=#mgCoord3dRollRight90>mgCoord3dRollRight90</A><BR> 
<A HREF=#mgCoord3dYawLeft>mgCoord3dYawLeft</A><BR> 
<A HREF=#mgCoord3dYawLeft90>mgCoord3dYawLeft90</A><BR> 
<A HREF=#mgCoord3dYawRight>mgCoord3dYawRight</A><BR> 
<A HREF=#mgCoord3dYawRight90>mgCoord3dYawRight90</A><BR> 
<A HREF=#mgCoord3dReflectX>mgCoord3dReflectX</A><BR> 
<A HREF=#mgCoord3dReflectY>mgCoord3dReflectY</A><BR> 
<A HREF=#mgCoord3dReflectZ>mgCoord3dReflectZ</A><BR> 
<A HREF=#mgCoord3dReflect>mgCoord3dReflect</A><BR> 
<A HREF=#mgCoord3dScalarProject>mgCoord3dScalarProject</A><BR> 
<A HREF=#mgCoord3dVectorProject>mgCoord3dVectorProject</A><BR> 
<A HREF=#mgCoord3dOrthoProject>mgCoord3dOrthoProject</A><BR> 
<A HREF=#mgCoord3dXAxis>mgCoord3dXAxis</A><BR> 
<A HREF=#mgCoord3dNegativeXAxis>mgCoord3dNegativeXAxis</A><BR> 
<A HREF=#mgCoord3dYAxis>mgCoord3dYAxis</A><BR> 
<A HREF=#mgCoord3dNegativeYAxis>mgCoord3dNegativeYAxis</A><BR> 
<A HREF=#mgCoord3dZAxis>mgCoord3dZAxis</A><BR> 
<A HREF=#mgCoord3dNegativeZAxis>mgCoord3dNegativeZAxis</A><BR> 
<A HREF=#mgCoord3dZero>mgCoord3dZero</A><BR> 
<A HREF=#mgCoord3dOne>mgCoord3dOne</A><BR> 
<A HREF=#mgCoord3dNegativeOne>mgCoord3dNegativeOne</A><BR> 
<A HREF=#mgCoord3dAlmostEqual>mgCoord3dAlmostEqual</A><BR> 
<A HREF=#mgCoord3dEqual>mgCoord3dEqual</A><BR> 
<A HREF=#mgCoord3dLength>mgCoord3dLength</A><BR> 
<A HREF=#mgCoord3dLengthSquared>mgCoord3dLengthSquared</A><BR> 
<A HREF=#mgCoord3dSetUnitized>mgCoord3dSetUnitized</A><BR> 
<A HREF=#mgCoord3dUnitize>mgCoord3dUnitize</A><BR> 
<A HREF=#mgCoord3dTransform>mgCoord3dTransform</A><BR> 
<A HREF=#mgGetTriangleList>mgGetTriangleList</A><BR> 
<A HREF=#mgCoord3fToCoord3d>mgCoord3fToCoord3d</A><BR> 
<A HREF=#mgVectorfToVectord>mgVectorfToVectord</A><BR> 
<A HREF=#mgVectordToVectorf>mgVectordToVectorf</A><BR> 
<A HREF=#mgVectordDot>mgVectordDot</A><BR> 
<A HREF=#mgVectordCross>mgVectordCross</A><BR> 
<A HREF=#mgVectordSetUnitized>mgVectordSetUnitized</A><BR> 
<A HREF=#mgVectordUnitize>mgVectordUnitize</A><BR><P>
<H3>Graphics View Functions</H3><P>
<A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A><BR> 
<A HREF=#mgGraphicsViewSettingGetDouble>mgGraphicsViewSettingGetDouble</A><BR> 
<A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A><BR> 
<A HREF=#mgGraphicsViewSettingSetDouble>mgGraphicsViewSettingSetDouble</A><BR><P>
<H3>I/O Functions</H3><P>
<A HREF=#mgExportDb>mgExportDb</A><BR> 
<A HREF=#mgIsDbModified>mgIsDbModified</A><BR><P>
<H3>License Functions</H3><P>
<A HREF=#mgNewLicense>mgNewLicense</A><BR> 
<A HREF=#mgCheckoutLicense>mgCheckoutLicense</A><BR> 
<A HREF=#mgCheckinLicense>mgCheckinLicense</A><BR> 
<A HREF=#mgFreeLicense>mgFreeLicense</A><BR><P>
<H3>List Controls</H3><P>
<A HREF=#mgListGetTopPos>mgListGetTopPos</A><BR><P>
<H3>Matrix Functions</H3><P>
<A HREF=#mgMatrixGetXAxis>mgMatrixGetXAxis</A><BR> 
<A HREF=#mgMatrixGetYAxis>mgMatrixGetYAxis</A><BR> 
<A HREF=#mgMatrixGetZAxis>mgMatrixGetZAxis</A><BR> 
<A HREF=#mgMatrixGetTranslation>mgMatrixGetTranslation</A><BR> 
<A HREF=#mgMatrixSetXAxis>mgMatrixSetXAxis</A><BR> 
<A HREF=#mgMatrixSetYAxis>mgMatrixSetYAxis</A><BR> 
<A HREF=#mgMatrixSetZAxis>mgMatrixSetZAxis</A><BR> 
<A HREF=#mgMatrixSetTranslation>mgMatrixSetTranslation</A><BR> 
<A HREF=#mgMatrixFormNormal>mgMatrixFormNormal</A><BR> 
<A HREF=#mgMatrixFormReflectX>mgMatrixFormReflectX</A><BR> 
<A HREF=#mgMatrixFormReflectY>mgMatrixFormReflectY</A><BR> 
<A HREF=#mgMatrixFormReflectZ>mgMatrixFormReflectZ</A><BR> 
<A HREF=#mgMatrixFormReflect>mgMatrixFormReflect</A><BR> 
<A HREF=#mgMatrixFormPitchDown90>mgMatrixFormPitchDown90</A><BR> 
<A HREF=#mgMatrixFormPitchUp90>mgMatrixFormPitchUp90</A><BR> 
<A HREF=#mgMatrixFormRollLeft90>mgMatrixFormRollLeft90</A><BR> 
<A HREF=#mgMatrixFormRollRight90>mgMatrixFormRollRight90</A><BR> 
<A HREF=#mgMatrixFormYawLeft90>mgMatrixFormYawLeft90</A><BR> 
<A HREF=#mgMatrixFormYawRight90>mgMatrixFormYawRight90</A><BR> 
<A HREF=#mgMatrixReflectX>mgMatrixReflectX</A><BR> 
<A HREF=#mgMatrixReflectY>mgMatrixReflectY</A><BR> 
<A HREF=#mgMatrixReflectZ>mgMatrixReflectZ</A><BR> 
<A HREF=#mgMatrixReflect>mgMatrixReflect</A><BR> 
<A HREF=#mgMatrixPitchDown90>mgMatrixPitchDown90</A><BR> 
<A HREF=#mgMatrixPitchUp90>mgMatrixPitchUp90</A><BR> 
<A HREF=#mgMatrixRollLeft90>mgMatrixRollLeft90</A><BR> 
<A HREF=#mgMatrixRollRight90>mgMatrixRollRight90</A><BR> 
<A HREF=#mgMatrixYawLeft90>mgMatrixYawLeft90</A><BR> 
<A HREF=#mgMatrixYawRight90>mgMatrixYawRight90</A><BR> 
<A HREF=#mgMatrixCompose>mgMatrixCompose</A><BR> 
<A HREF=#mgMatrixTranspose>mgMatrixTranspose</A><BR> 
<A HREF=#mgMatrixFormXYZToUV>mgMatrixFormXYZToUV</A><BR><P>
<H3>Option Menu Functions</H3><P>
<A HREF=#mgOptionMenuSelectItem>mgOptionMenuSelectItem</A><BR> 
<A HREF=#mgOptionMenuDeleteItem>mgOptionMenuDeleteItem</A><BR> 
<A HREF=#mgOptionMenuDeleteItemAtPos>mgOptionMenuDeleteItemAtPos</A><BR> 
<A HREF=#mgOptionMenuGetItemStringAtPos>mgOptionMenuGetItemStringAtPos</A><BR><P>
<H3>Tool Registration Functions</H3><P>
<A HREF=#mgPluginPutProperty>mgPluginPutProperty</A><BR> 
<A HREF=#mgPluginGetProperty>mgPluginGetProperty</A><BR> 
<A HREF=#mgPluginDeleteProperty>mgPluginDeleteProperty</A><BR><P>
<A HREF=#mgPluginToolPutProperty>mgPluginToolPutProperty</A><BR> 
<A HREF=#mgPluginToolGetProperty>mgPluginToolGetProperty</A><BR> 
<A HREF=#mgPluginToolDeleteProperty>mgPluginToolDeleteProperty</A><BR><P>
<A HREF=#mgPluginToolGetPlugin>mgPluginToolGetPlugin</A><BR> 
<A HREF=#mgPluginToolGetUserData>mgPluginToolGetUserData</A><BR><P>
<H3>Pointer Array/Stack Functions</H3><P>
<A HREF=#mgPtrArrayClear>mgPtrArrayClear</A><BR> 
<A HREF=#mgPtrArraySearch>mgPtrArraySearch</A><BR> 
<A HREF=#mgPtrArrayBSearch>mgPtrArrayBSearch</A><BR><P>
<A HREF=#mgNewPtrStack>mgNewPtrStack</A><BR> 
<A HREF=#mgFreePtrStack>mgFreePtrStack</A><BR> 
<A HREF=#mgPtrStackPush>mgPtrStackPush</A><BR> 
<A HREF=#mgPtrStackPop>mgPtrStackPop</A><BR> 
<A HREF=#mgPtrStackTop>mgPtrStackTop</A><BR> 
<A HREF=#mgPtrStackClear>mgPtrStackClear</A><BR> 
<A HREF=#mgPtrStackLength>mgPtrStackLength</A><BR><P>
<H3>Select List Functions</H3><P>
<A HREF=#mgSelectList>mgSelectList</A><BR><P>
<H3>Shader Functions</H3><P>
<A HREF=#mgGetShader>mgGetShader</A><BR> 
<A HREF=#mgIndexOfShader>mgIndexOfShader</A><BR> 
<A HREF=#mgNameOfShader>mgNameOfShader</A><BR> 
<A HREF=#mgGetShaderCount>mgGetShaderCount</A><BR> 
<A HREF=#mgGetFirstShader>mgGetFirstShader</A><BR> 
<A HREF=#mgGetNextShader>mgGetNextShader</A><BR> 
<A HREF=#mgShaderGetLocatorFunc>mgShaderGetLocatorFunc</A><BR> 
<A HREF=#mgShaderSetLocatorFunc>mgShaderSetLocatorFunc</A><BR> 
<A HREF=#mgNewShader>mgNewShader</A><BR> 
<A HREF=#mgDeleteShader>mgDeleteShader</A><BR> 
<A HREF=#mgDeleteShaderByName>mgDeleteShaderByName</A><BR> 
<A HREF=#mgGetCurrentShader>mgGetCurrentShader</A><BR> 
<A HREF=#mgSetCurrentShader>mgSetCurrentShader</A><BR> 
<A HREF=#mgShaderGetSavePathType>mgShaderGetSavePathType</A><BR> 
<A HREF=#mgShaderSetSavePathType>mgShaderSetSavePathType</A><BR><P>
<H3>Structure Functions</H3><P>
<A HREF=#mgDuplicateEx>mgDuplicateEx</A><BR><P>
<H3>Texture Functions</H3><P>
<A HREF=#mgMoveTexture>mgMoveTexture</A><BR> 
<A HREF=#mgTextureGetSavePathType>mgTextureGetSavePathType</A><BR> 
<A HREF=#mgTextureSetSavePathType>mgTextureSetSavePathType</A><BR><P>
<H2>Light Point API Compatibility</H2><P>
In version 2.6 of the OpenFlight API, the attributes of light point nodes 
(<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLightPoint>fltLightPoint</A>
) were "palette-ized".  This introduced a level of indirection 
on the light node (similar to color, material and texture on <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 and 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 nodes) into two separate palette entries, 
the Light Point Appearance Palette and Light Point Animation Palette, 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLpAppearancePalette>fltLpAppearancePalette</A>
 and <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLpAnimationPalette>fltLpAnimationPalette</A>
, respectively.<P>
Regrettably, this "broke" existing applications that use <A HREF=#mgGetAttList>mgGetAttList</A> 
and <A HREF=#mgSetAttList>mgSetAttList</A> to access attributes directly on light point nodes. 
In order to function correctly, such applications had to be updated to 
first retrieve the appropriate light point palette record referenced by 
a light point node and then use <A HREF=#mgGetAttList>mgGetAttList</A> and <A HREF=#mgSetAttList>mgSetAttList</A> on 
that palette record rather than the light point node directly.<P>
In this version of the OpenFlight API, this situation has been addressed by enhancing 
<A HREF=#mgGetAttList>mgGetAttList</A> and <A HREF=#mgSetAttList>mgSetAttList</A> to allow access to light point palette 
attributes directly from the light point node.  Specifically, if you now call 
<A HREF=#mgSetAttList>mgSetAttList</A> on a light point node specifying any attribute from 
the Light Point Appearance Palette or Light Point Animation Palette, the 
corresponding attribute of the palette entry referenced by the light 
point node will be set. Similarly, if you use <A HREF=#mgGetAttList>mgGetAttList</A> on a light 
point node to get a light point palette attribute, the attribute of the 
palette entry referenced by the light point node will be retrieved.<P>
Note that if you call <A HREF=#mgGetAttList>mgGetAttList</A> or <A HREF=#mgSetAttList>mgSetAttList</A> on a light point 
node to access a palette attribute and the light point node does not yet have 
a palette entry associated, a new palette entry will be created, the corresponding 
index on the light point node will be updated to reference this new palette 
entry and this new palette entry will be accessed.<P>
<H2>Changed Functions</H2><P>
<A HREF=#mgOpenDb>mgOpenDb</A>, <A HREF=#mgCloseDb>mgCloseDb</A>, <A HREF=#mgWriteDb>mgWriteDb</A> and <A HREF=#mgSaveAsDb>mgSaveAsDb</A> can now safely 
be called from plug-ins.  See the documentation on these functions for some 
limitations.<BR><P>
The start function registered by <A HREF=#mgRegisterImporter>mgRegisterImporter</A> is now expected to return 
a meaningful value indicating the success or failure of the import processing.<BR><P>
The dialog displayed by <A HREF=#mgPromptDialogFolder>mgPromptDialogFolder</A> now displays a button labeled 
"New Folder" that when pressed creates a new folder below the currently selected 
folder in the dialog.<P>
In previous versions, the image attribute record returned by the function 
<A HREF=#mgReadImageAttributes>mgReadImageAttributes</A> was never freed, resulting in a memory leak.  In this 
version, this record is now freed when the associated database is closed.<P>
The functions <A HREF=#mgDuplicate>mgDuplicate</A>, <A HREF=#mgDuplicateEx>mgDuplicateEx</A> and <A HREF=#mgDuplicateToDb>mgDuplicateToDb</A> can 
now be used to duplicate transformation records (<B>fltXmTranslate</B>, 
<B>fltXmRotate</B>, <B>fltXmScale</B>, etc).<P>
<H2>New Symbols</H2><P>
<A HREF=#MGMA_WHEEL>MGMA_WHEEL</A> for <A HREF=#mgGLSetMouseFunc>mgGLSetMouseFunc</A><BR><P>
<A HREF=#MPFA_DIALOGID>MPFA_DIALOGID</A> for <A HREF=#mgPromptDialogFile>mgPromptDialogFile</A><BR> 
<A HREF=#MPFA_RESOURCE>MPFA_RESOURCE</A> for <A HREF=#mgPromptDialogFile>mgPromptDialogFile</A><BR> 
<A HREF=#MPFA_DIALOGFUNC>MPFA_DIALOGFUNC</A> for <A HREF=#mgPromptDialogFile>mgPromptDialogFile</A><BR> 
<A HREF=#MPFA_CALLBACKMASK>MPFA_CALLBACKMASK</A> for <A HREF=#mgPromptDialogFile>mgPromptDialogFile</A><BR> 
<A HREF=#MPFA_USERDATA>MPFA_USERDATA</A> for <A HREF=#mgPromptDialogFile>mgPromptDialogFile</A><BR><P>
<A HREF=#MCURS_SPLITH>MCURS_SPLITH</A> for <A HREF=#mgResourceGetCursor>mgResourceGetCursor</A><BR> 
<A HREF=#MCURS_SPLITV>MCURS_SPLITV</A> for <A HREF=#mgResourceGetCursor>mgResourceGetCursor</A><BR><P>
<A HREF=#MWALK_NONESTED>MWALK_NONESTED</A> for <A HREF=#mgWalk>mgWalk</A> and <A HREF=#mgWalkEx>mgWalkEx</A><BR><P>
<A HREF=#mgnotifierevent>MNOTIFY_CURRENTLIGHTSOURCECHANGED</A> for <A HREF=#mgRegisterNotifier>mgRegisterNotifier</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_CURRENTSOUNDCHANGED</A> for <A HREF=#mgRegisterNotifier>mgRegisterNotifier</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_CURRENTSHADERCHANGED</A> for <A HREF=#mgRegisterNotifier>mgRegisterNotifier</A><BR><P>
<H2>New Menu Locations for Editor and Viewer Tools</H2><P>
(see <A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A>)<P>
<A HREF=#MMENU_HELP>MMENU_HELP</A><BR><P>
<H2>New Palette Locations for Editor and Viewer Tools</H2><P>
(see <A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A>)<P>
<A HREF=#MPAL_BOOLEANTOOLS>MPAL_BOOLEANTOOLS</A><BR> 
<A HREF=#MPAL_WIZARDTOOLS>MPAL_WIZARDTOOLS</A><BR> 
<A HREF=#MPAL_CONSTRUCTIONTOOLS>MPAL_CONSTRUCTIONTOOLS</A><BR><P>
<H2>New in the OpenFlight Data Dictionary</H2><P>
You can now define OpenFlight extensions for the following palette types:<BR> 
Light Point Appearance Palette (<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLpAppearancePalette>fltLpAppearancePalette</A>
)<BR> 
Light Point Animation Palette (<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLpAnimationPalette>fltLpAnimationPalette</A>
)<BR> 
Material Palette (<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltFMaterial>fltFMaterial</A>
)<BR> 
Shader Palette (<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltShaderPalette>fltShaderPalette</A>
)<BR> 
Light Source Palette (<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLightSourcePalette>fltLightSourcePalette</A>
)<BR> 
Texture Palette (<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltImage>fltImage</A>
)<BR> 
Texture Mapping Palette (<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltTextureMapping>fltTextureMapping</A>
)<P>
<H3>Polygon Nodes</H3><P>
The following field was added to <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
<BR> 
fltPolyShader<BR><P>
<H3>Mesh Nodes</H3><P>
The following field was added to <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
<BR> 
fltPolyShader<BR><P>
<H3>External Reference Nodes</H3><P>
The following field was added to <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXref>fltXref</A>
<BR> 
fltGcShaderPal<BR><P>
<H3>Shader Palette Nodes</H3><P>
The following palette node was added<BR> 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltShaderPalette>fltShaderPalette</A>
<BR><P>
<H3>Light Point Appearance Palette Nodes</H3><P>
The following field was added to <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLpAppearancePalette>fltLpAppearancePalette</A>
<BR> 
fltLpTexture<BR><P>
<H2>Deprecated API</H2><P>
The following symbols have been deprecated in this version of 
the API. For each symbol that appears in this section, an appropriate 
replacement symbol or strategy is also given.  These deprecated symbols 
are still supported in this version of the OpenFlight API and will likely remain 
supported indefinitely in future versions.  However, it is recommended 
(but not required) that you replace any deprecated symbols in your code 
with the suggested replacements.  This will ensure that code you develop 
using the MultiGen OpenFlight API remains compatible with future versions 
of the API.<P>
In this version, a significant number of new geometry functions were added 
to help users work with 2D and 3D coordinates.  To help distinguish the 
2D and 3D function names (as well as those for vectors) a new naming 
convention has been adopted for all geometry functions.  Several existing 
functions were affected by the new naming convention and for that reason, 
they have been deprecated.  Here is a list of those functions:<BR><P>
<A HREF=#mgAddCoord>mgAddCoord</A> replaced by <A HREF=#mgCoord3dAdd>mgCoord3dAdd</A><BR> 
<A HREF=#mgCoordDif>mgCoordDif</A> replaced by <A HREF=#mgCoord3dSubtract>mgCoord3dSubtract</A><BR> 
<A HREF=#mgCoord3dTof>mgCoord3dTof</A> replaced by <A HREF=#mgCoord3dToCoord3f>mgCoord3dToCoord3f</A><BR> 
<A HREF=#mgCoordsEqual>mgCoordsEqual</A> replaced by <A HREF=#mgCoord3dAlmostEqual>mgCoord3dAlmostEqual</A><BR> 
<A HREF=#mgDistance>mgDistance</A> replaced by <A HREF=#mgCoord3dDistance>mgCoord3dDistance</A><BR> 
<A HREF=#mgVectorCross>mgVectorCross</A> replaced by <A HREF=#mgVectordCross>mgVectordCross</A><BR> 
<A HREF=#mgVectorDot>mgVectorDot</A> replaced by <A HREF=#mgVectordDot>mgVectordDot</A><BR> 
<A HREF=#mgVectorFromLine>mgVectorFromLine</A> replaced by <A HREF=#mgVectordFromLine>mgVectordFromLine</A><BR> 
<A HREF=#mgMoveCoordAlongVectorf>mgMoveCoordAlongVectorf</A> replaced by <A HREF=#mgCoord3dMoveAlongVectorf>mgCoord3dMoveAlongVectorf</A><BR> 
<A HREF=#mgMoveCoordAlongVector>mgMoveCoordAlongVector</A> replaced by <A HREF=#mgCoord3dMoveAlongVectord>mgCoord3dMoveAlongVectord</A><BR> 
<A HREF=#mgTransformCoord>mgTransformCoord</A> replaced by <A HREF=#mgCoord3dTransform>mgCoord3dTransform</A><BR> 
<A HREF=#mgTransformVector>mgTransformVector</A> replaced by <A HREF=#mgVectordTransform>mgVectordTransform</A><BR> 
<A HREF=#mgUnitizeVector>mgUnitizeVector</A> replaced by <A HREF=#mgVectordSetUnitized>mgVectordSetUnitized</A><BR> 
<A HREF=#mgMakeVector>mgMakeVector</A> replaced by <A HREF=#mgMakeVectord>mgMakeVectord</A><BR> 
<A HREF=#mgMakeUnitVector>mgMakeUnitVector</A> replaced by <A HREF=#mgMakeUnitVectord>mgMakeUnitVectord</A><BR> 
<A HREF=#mgVectordTof>mgVectordTof</A> replaced by <A HREF=#mgVectordToVectorf>mgVectordToVectorf</A><BR><P>
In Creator, the Vertex and Edge construction tool boxes were combined 
into one, the Construction tool box.  For that reason, the following 
symbols were deprecated:<BR><P>
<A HREF=#MPAL_EDGETOOLS>MPAL_EDGETOOLS</A> deprecated, use <A HREF=#MPAL_CONSTRUCTIONTOOLS>MPAL_CONSTRUCTIONTOOLS</A><BR> 
<A HREF=#MPAL_VERTEXTOOLS>MPAL_VERTEXTOOLS</A> deprecated, use <A HREF=#MPAL_CONSTRUCTIONTOOLS>MPAL_CONSTRUCTIONTOOLS</A><BR><P>
If you continue to use either of these deprecated symbols when you 
register your plug-in tool, the pixmap for your tool will appear 
in the Construction tool box.<P>
<H1>v2.6.1</H1><P>
This version of the OpenFlight API corresponds to OpenFlight version 15.8.<P>
No new functions were added for this release.  The OpenFlight API 
Reference was updated, however, to correct assorted typographical 
errors, broken links, etc.<P>
<H1>v2.6</H1><P>
This version of the OpenFlight API corresponds to OpenFlight version 15.8.<P>
<H2>Common Directory Organization</H2><P>
The OpenFlight API is now installed into the MultiGen-Paradigm 
Common Directory Organization.  This structure is significantly different 
than previous installations and affects the developer in the following areas:<P>
OpenFlight API installation root<BR> 
Location of C source header files<BR> 
Location of link libraries<BR> 
Location of documentation<BR> 
Location of sample code<BR> 
Location of redistributable OpenFlight API binaries<BR> 
Location of plug-in runtime directory<P>
Note that the relocation of the C source header files 
and link libraries will cause developers to update their 
Visual Studio Project files and/or IRIX makefiles before 
the corresponding application(s) or plug-in(s) can be rebuilt 
with this version of the OpenFlight API.<P>
<H3>OpenFlight API Installation Root</H3><P>
The installer now creates an environment variable <B>MPI_LOCATE_OPENFLIGHT_API</B> 
whose value specifies the root of the OpenFlight API installation.  This 
replaces the environment variable <B>MGAPIDIST</B> used by previous versions.<P>
<H3>Location of C source header files</H3><P>
The C source header files have been relocated to: 
<PRE CLASS="EXAMPLE">MPI_LOCATE_OPENFLIGHT_API/include/openflightapi</PRE><P>
<H3>Location of link libraries</H3><P>
The link libraries have been relocated to: 
<PRE CLASS="EXAMPLE">MPI_LOCATE_OPENFLIGHT_API/lib</PRE><P>
<H3>Location of documentation</H3><P>
The documentation has been relocated to: 
<PRE CLASS="EXAMPLE">MPI_LOCATE_OPENFLIGHT_API/docs/openflightapi</PRE><P>
<H3>Location of sample code</H3><P>
The samples have been relocated to: 
<PRE CLASS="EXAMPLE">MPI_LOCATE_OPENFLIGHT_API/resources/samples/openflightapi</PRE><P>
with subfolders for the individual kinds of samples: 
<PRE CLASS="EXAMPLE">/apps - sample stand-alone programs 
/extensions - sample OpenFlight data extensions 
/plugins - sample plug-ins</PRE><P>
<H3>Location of redistributable OpenFlight API binaries</H3><P>
If you need to redistribute the OpenFlight API binaries, 
the dynamic link libraries you will need are located at:<P>
<PRE CLASS="EXAMPLE">MPI_LOCATE_OPENFLIGHT_API/resources/samples/openflightapi/apps/bin</PRE><P>
<H3>Location of plug-in runtime directory</H3><P>
At start up, Creator and stand-alone OpenFlight API applications 
now use the environment variable <B>MPI_CREATOR_PLUGIN_DIR</B> to locate 
plug-ins.  This replaces the environment variable <B>MGPLUGINDIR</B> used 
by previous versions.<P>
<H2>Light Points</H2><P>
Light Points were changed significantly in this version.  Prior to this 
version, light point attributes were completely contained within the 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLightPoint>fltLightPoint</A>
 node.  Starting with this version, the light point 
attributes have been moved from the light point node into two separate 
palettes.  This introduces a level of indirection (similar to color, 
material and texture on <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 and <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 nodes) 
on the light point node into two separate palette entries.<P>
The new light point palettes include the Light Point Appearance Palette 
and Light Point Animation Palette, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLpAppearancePalette>fltLpAppearancePalette</A>
 and 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLpAnimationPalette>fltLpAnimationPalette</A>
, respectively.  Entries in the Light Point 
Appearance palette describe the visual "appearance" of a light point 
(color, directionality, etc) while entries in the Light Point Animation 
palette describe how a light point behaves (flashes, rotates, etc).<P>
See the Read/Write User&#146s Guide for more information on light points 
in this version.<P>
<H2>New Functions</H2><P>
<H3>Light Point Functions</H3><P>
<A HREF=#mgGetLightPointAppearance>mgGetLightPointAppearance</A><BR> 
<A HREF=#mgIndexOfLightPointAppearance>mgIndexOfLightPointAppearance</A><BR> 
<A HREF=#mgNameOfLightPointAppearance>mgNameOfLightPointAppearance</A><BR> 
<A HREF=#mgGetLightPointAppearanceCount>mgGetLightPointAppearanceCount</A><BR> 
<A HREF=#mgGetFirstLightPointAppearance>mgGetFirstLightPointAppearance</A><BR> 
<A HREF=#mgGetNextLightPointAppearance>mgGetNextLightPointAppearance</A><BR> 
<A HREF=#mgGetLightPointAnimation>mgGetLightPointAnimation</A><BR> 
<A HREF=#mgIndexOfLightPointAnimation>mgIndexOfLightPointAnimation</A><BR> 
<A HREF=#mgNameOfLightPointAnimation>mgNameOfLightPointAnimation</A><BR> 
<A HREF=#mgGetLightPointAnimationCount>mgGetLightPointAnimationCount</A><BR> 
<A HREF=#mgGetFirstLightPointAnimation>mgGetFirstLightPointAnimation</A><BR> 
<A HREF=#mgGetNextLightPointAnimation>mgGetNextLightPointAnimation</A><BR> 
<A HREF=#mgReadLightPointFile>mgReadLightPointFile</A><BR> 
<A HREF=#mgNewLightPointAppearance>mgNewLightPointAppearance</A><BR> 
<A HREF=#mgDeleteLightPointAppearance>mgDeleteLightPointAppearance</A><BR> 
<A HREF=#mgNewLightPointAnimation>mgNewLightPointAnimation</A><BR> 
<A HREF=#mgDeleteLightPointAnimation>mgDeleteLightPointAnimation</A><BR> 
<A HREF=#mgWriteLightPointFile>mgWriteLightPointFile</A><BR> 
<A HREF=#mgGetCurrentLightPointAppearance>mgGetCurrentLightPointAppearance</A><BR> 
<A HREF=#mgSetCurrentLightPointAppearance>mgSetCurrentLightPointAppearance</A><BR> 
<A HREF=#mgGetCurrentLightPointAnimation>mgGetCurrentLightPointAnimation</A><BR> 
<A HREF=#mgSetCurrentLightPointAnimation>mgSetCurrentLightPointAnimation</A><BR> 
<A HREF=#mgLightPointAnimationSequenceGet>mgLightPointAnimationSequenceGet</A><BR> 
<A HREF=#mgLightPointAnimationSequenceSet>mgLightPointAnimationSequenceSet</A><BR><P>
<H3>Attribute Functions</H3><P>
<A HREF=#mgGetVtxColorRGBA>mgGetVtxColorRGBA</A><BR> 
<A HREF=#mgSetVtxColorRGBA>mgSetVtxColorRGBA</A><BR> 
<A HREF=#mgSetPlane>mgSetPlane</A><BR><P>
<H3>Structure Functions</H3><P>
<A HREF=#mgWalkEx>mgWalkEx</A><BR> 
<A HREF=#mgWalkGetMatrix>mgWalkGetMatrix</A><BR> 
<A HREF=#mgValidAttach>mgValidAttach</A><BR><P>
<H3>Tool Activation Functions</H3><P>
<A HREF=#mgGetDefaultModelingParent>mgGetDefaultModelingParent</A><BR><P>
<H3>Matrix Functions</H3><P>
<A HREF=#mgNewMatrix>mgNewMatrix</A><BR> 
<A HREF=#mgFreeMatrix>mgFreeMatrix</A><BR> 
<A HREF=#mgMatrixIdentity>mgMatrixIdentity</A><BR> 
<A HREF=#mgMatrixIsIdentity>mgMatrixIsIdentity</A><BR> 
<A HREF=#mgMatrixInvert>mgMatrixInvert</A><BR> 
<A HREF=#mgMatrixMultiply>mgMatrixMultiply</A><BR> 
<A HREF=#mgMatrixCopy>mgMatrixCopy</A><BR> 
<A HREF=#mgMatrixFormTranslate>mgMatrixFormTranslate</A><BR> 
<A HREF=#mgMatrixFormScale>mgMatrixFormScale</A><BR> 
<A HREF=#mgMatrixFormRotateX>mgMatrixFormRotateX</A><BR> 
<A HREF=#mgMatrixFormRotateY>mgMatrixFormRotateY</A><BR> 
<A HREF=#mgMatrixFormRotateZ>mgMatrixFormRotateZ</A><BR> 
<A HREF=#mgMatrixFormQuadToQuad>mgMatrixFormQuadToQuad</A><BR> 
<A HREF=#mgMatrixTranslate>mgMatrixTranslate</A><BR> 
<A HREF=#mgMatrixScale>mgMatrixScale</A><BR> 
<A HREF=#mgMatrixRotateX>mgMatrixRotateX</A><BR> 
<A HREF=#mgMatrixRotateY>mgMatrixRotateY</A><BR> 
<A HREF=#mgMatrixRotateZ>mgMatrixRotateZ</A><BR><P>
<H3>Matrix Stack Functions</H3><P>
<A HREF=#mgNewMatrixStack>mgNewMatrixStack</A><BR> 
<A HREF=#mgFreeMatrixStack>mgFreeMatrixStack</A><BR> 
<A HREF=#mgMatrixStackPush>mgMatrixStackPush</A><BR> 
<A HREF=#mgMatrixStackPop>mgMatrixStackPop</A><BR> 
<A HREF=#mgMatrixStackLoadIdentity>mgMatrixStackLoadIdentity</A><BR> 
<A HREF=#mgMatrixStackLoadMatrix>mgMatrixStackLoadMatrix</A><BR> 
<A HREF=#mgMatrixStackGetMatrix>mgMatrixStackGetMatrix</A><BR> 
<A HREF=#mgMatrixStackIsIdentity>mgMatrixStackIsIdentity</A><BR> 
<A HREF=#mgMatrixStackMultiply>mgMatrixStackMultiply</A><BR> 
<A HREF=#mgMatrixStackTranslate>mgMatrixStackTranslate</A><BR> 
<A HREF=#mgMatrixStackScale>mgMatrixStackScale</A><BR> 
<A HREF=#mgMatrixStackRotate>mgMatrixStackRotate</A><BR> 
<A HREF=#mgMatrixStackRotateX>mgMatrixStackRotateX</A><BR> 
<A HREF=#mgMatrixStackRotateY>mgMatrixStackRotateY</A><BR> 
<A HREF=#mgMatrixStackRotateZ>mgMatrixStackRotateZ</A><BR> 
<A HREF=#mgMatrixStackTransformCoord>mgMatrixStackTransformCoord</A><BR> 
<A HREF=#mgMatrixStackTransformVector>mgMatrixStackTransformVector</A><BR><P>
<H3>Geometry Functions</H3><P>
<A HREF=#mgMoveCoordAlongVector>mgMoveCoordAlongVector</A><BR> 
<A HREF=#mgMoveCoordAlongVectorf>mgMoveCoordAlongVectorf</A><BR> 
<A HREF=#mgVectorCross>mgVectorCross</A><BR> 
<A HREF=#mgVectorDot>mgVectorDot</A><BR> 
<A HREF=#mgReversePoly>mgReversePoly</A><BR> 
<A HREF=#mgCoordsEqual>mgCoordsEqual</A><BR> 
<A HREF=#mgMakeUnitVector>mgMakeUnitVector</A><BR> 
<A HREF=#mgMakeCoord3d>mgMakeCoord3d</A><BR> 
<A HREF=#mgMakeCoord3f>mgMakeCoord3f</A><BR> 
<A HREF=#mgMakeCoord2d>mgMakeCoord2d</A><BR> 
<A HREF=#mgMakeCoord2i>mgMakeCoord2i</A><BR> 
<A HREF=#mgTransformVector>mgTransformVector</A><BR><P>
<H3>Dialog Functions</H3><P>
<A HREF=#mgShowPalette>mgShowPalette</A><BR><P>
<H3>Text Controls</H3><P>
<A HREF=#mgTextSetFilename>mgTextSetFilename</A><BR><P>
<H3>Pointer Array Functions</H3><P>
<A HREF=#mgPtrArraySort>mgPtrArraySort</A><BR><P>
<H3>Mesh Functions</H3><P>
<A HREF=#mgMeshSetVtxMask>mgMeshSetVtxMask</A><BR> 
<A HREF=#mgMeshGetVtxColorRGBA>mgMeshGetVtxColorRGBA</A><BR> 
<A HREF=#mgMeshGetVtxColorAlpha>mgMeshGetVtxColorAlpha</A><BR> 
<A HREF=#mgMeshSetVtxColorRGBA>mgMeshSetVtxColorRGBA</A><BR> 
<A HREF=#mgMeshSetVtxColorAlpha>mgMeshSetVtxColorAlpha</A><BR><P>
<H3>Switch Functions</H3><P>
<A HREF=#mgGetSwitchMaskName>mgGetSwitchMaskName</A><BR> 
<A HREF=#mgSetSwitchMaskName>mgSetSwitchMaskName</A><BR><P>
<H3>Info Functions</H3><P>
<A HREF=#mgGetOpenFlightVersion>mgGetOpenFlightVersion</A><BR><P>
<H3>Texture Functions</H3><P>
<A HREF=#mgIsTextureIndexInPalette>mgIsTextureIndexInPalette</A><BR><P>
<H3>Preference Functions</H3><P>
<A HREF=#mgSetSaveNonIndexedLightPoints>mgSetSaveNonIndexedLightPoints</A><BR> 
<A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A><BR> 
<A HREF=#mgModelingPrefGetDouble>mgModelingPrefGetDouble</A><BR><P>
<H3>Plugin Registration Functions</H3><P>
<A HREF=#mgGetRegistryString>mgGetRegistryString</A><BR> 
<A HREF=#mgSetRegistryString>mgSetRegistryString</A><BR><P>
<H2>New Data Types</H2><P>
<A HREF=#mgptrarraycomparefunc>mgptrarraycomparefunc</A><BR><P>
<H2>New Symbols</H2><P>
<A HREF=#mgnotifierevent>MNOTIFY_CURRENTTEXTUREMAPPINGCHANGED</A> for <A HREF=#mgRegisterNotifier>mgRegisterNotifier</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_CURRENTLIGHTPOINTAPPEARANCECHANGED</A> for <A HREF=#mgRegisterNotifier>mgRegisterNotifier</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_CURRENTLIGHTPOINTANIMATIONCHANGED</A> for <A HREF=#mgRegisterNotifier>mgRegisterNotifier</A><BR><P>
<A HREF=#mgcontrolattribute>MCA_BOLDFONT</A> for <A HREF=#mgControlSetAttribute>mgControlSetAttribute</A><BR> 
<A HREF=#mgcontrolattribute>MCA_ITALICFONT</A> for <A HREF=#mgControlSetAttribute>mgControlSetAttribute</A><BR> 
<A HREF=#MVERSION_OPENFLIGHT>MVERSION_OPENFLIGHT</A><BR> 
<A HREF=#MWALK_MATRIXSTACK>MWALK_MATRIXSTACK</A> for <A HREF=#mgWalk>mgWalk</A> and <A HREF=#mgWalkEx>mgWalkEx</A><BR><P>
<H2>Sample Plugins</H2><P>
Two new sample plug-ins, <B>dfdtest</B> and <B>walktest</B>, were added to the sample plug-ins 
folder.  The first <B>dfdtest</B> shows you how to use the DFD API in the context of a 
Creator plug-in.  It also shows some interesting OpenGL drawing 
techniques.  The second <B>walktest</B> shows you how to use the new functions 
<A HREF=#mgWalkEx>mgWalkEx</A> and <A HREF=#mgWalkGetMatrix>mgWalkGetMatrix</A>.<P>
The existing plug-in, <B>attrviewer</B>, was updated to include all the new attributes 
added in OpenFlight version 15.8.<P>
<H2>Fixes</H2><P>
Fixed <A HREF=#mgSetAttList>mgSetAttList</A> when used to set fltPolyTexWhite (see <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
).<P>
Fixed <A HREF=#mgGLMaterialIndex>mgGLMaterialIndex</A> to render transparent materials properly.<P>
Fixed <A HREF=#mgGLTextureIndex>mgGLTextureIndex</A> to load a pattern's pixels when necessary.<P>
Fixed <A HREF=#mgWriteDb>mgWriteDb</A> to calculate LOD centers (when applicable) properly.<P>
Fixed <A HREF=#mgPtrArrayAppend>mgPtrArrayAppend</A> to return the proper array length.<P>
Fixed <A HREF=#mgReadTexturePalette>mgReadTexturePalette</A> and <A HREF=#mgCopyTexturePalette>mgCopyTexturePalette</A> to update 
the Texture Palette window properly.<P>
Fixed <A HREF=#mgReadMaterialFile>mgReadMaterialFile</A>, <A HREF=#mgDeleteMaterial>mgDeleteMaterial</A>, <A HREF=#mgDeleteMaterialByName>mgDeleteMaterialByName</A>, 
and <A HREF=#mgNewMaterial>mgNewMaterial</A> to update the Material Palette window properly.<P>
Fixed <A HREF=#mgEditorResetUndo>mgEditorResetUndo</A> to clear the Undo Menu properly when invoked 
from a tool that does not display a dialog.<P>
Fixed <A HREF=#mgInsert>mgInsert</A> to properly insert nested children (subfaces) and 
transformation nodes.<P>
The pick function assigned for editor plug-in tools is now called when the user 
selects nodes in the hierarchy view.<P>
Fixed <A HREF=#mgSelectOne>mgSelectOne</A> to always select a valid transformation path above 
selected node.<P>
<H2>Deprecated API</H2><P>
The following symbols have been deprecated in this version of 
the OpenFlight API. For each symbol that appears in this section, an appropriate 
replacement symbol or strategy is also given.  These deprecated symbols 
are still supported in this version of the OpenFlight API and will likely remain 
supported indefinitely in future versions.  However, it is recommended 
(but not required) that you replace any deprecated symbols in your code 
with the suggested replacements.  This will ensure that code you develop 
using the MultiGen OpenFlight OpenFlight API remains compatible with future versions 
of the API.<P>
<A HREF=#mgVectorMove>mgVectorMove</A> replaced by <A HREF=#mgMoveCoordAlongVectorf>mgMoveCoordAlongVectorf</A><BR> 
<A HREF=#mgCrossProdVector>mgCrossProdVector</A> replaced by <A HREF=#mgVectorCross>mgVectorCross</A><BR> 
<A HREF=#mgDelLightSource>mgDelLightSource</A> replaced by <A HREF=#mgDeleteLightSource>mgDeleteLightSource</A><BR> 
<A HREF=#mgDelSound>mgDelSound</A> replaced by <A HREF=#mgDeleteSound>mgDeleteSound</A><BR> 
<A HREF=#mgDelMaterial>mgDelMaterial</A> replaced by <A HREF=#mgDeleteMaterial>mgDeleteMaterial</A><BR> 
<A HREF=#mgDelMaterialByName>mgDelMaterialByName</A> replaced by <A HREF=#mgDeleteMaterialByName>mgDeleteMaterialByName</A><BR> 
<A HREF=#mgDelTextureMapping>mgDelTextureMapping</A> replaced by <A HREF=#mgDeleteTextureMapping>mgDeleteTextureMapping</A><BR> 
<A HREF=#mgDelTextureMappingByName>mgDelTextureMappingByName</A> replaced by <A HREF=#mgDeleteTextureMappingByName>mgDeleteTextureMappingByName</A><BR> 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLpAttr>fltLpAttr</A>
 replaced by <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLpAppearancePalette>fltLpAppearancePalette</A>
 and <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLpAnimationPalette>fltLpAnimationPalette</A>
<P>
<H2>New in the OpenFlight Data Dictionary</H2><P>
<P>
<H3>Header Nodes</H3><P>
The following fields were added to <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHeader</A>
:<BR> 
fltHdrEarthMinorAxis<BR> 
fltHdrEarthMajorAxis<BR><P>
<H3>LOD Nodes</H3><P>
The following fields were added to <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLod>fltLod</A>
:<BR> 
fltLodSignificantSize<BR><P>
<H3>Group Nodes</H3><P>
The following fields were added to <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltGroup>fltGroup</A>
:<BR> 
fltGrpLoopCount<BR> 
fltGrpLoopDuration<BR> 
fltGrpLastFrameDuration<BR><P>
<H3>Switch Nodes</H3><P>
The following fields were added to <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSwitch>fltSwitch</A>
:<BR> 
Individual masks of Switch Nodes can now be named. 
See <A HREF=#mgGetSwitchMaskName>mgGetSwitchMaskName</A> and <A HREF=#mgSetSwitchMaskName>mgSetSwitchMaskName</A>.<P>
<H3>Polygon Nodes</H3><P>
The following fields were added to <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
:<BR> 
fltPolyRoofline<BR><P>
<H3>Mesh Nodes</H3><P>
The following fields were added to <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
:<BR> 
fltPolyRoofline<BR><P>
<H3>Vertex Nodes</H3><P>
Vertex Nodes now can include alpha color components which is represented by the following new field in <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
<BR> 
fltVAlpha<BR><P>
And the following functions were added to access the vertex alpha color component<BR> 
<A HREF=#mgGetVtxColorRGBA>mgGetVtxColorRGBA</A><BR> 
<A HREF=#mgSetVtxColorRGBA>mgSetVtxColorRGBA</A><BR><P>
<H3>External Reference Nodes</H3><P>
The following field was added to <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXref>fltXref</A>
<BR> 
fltGcLpPal<BR><P>
<H3>Light Point Nodes</H3><P>
The following fields were added to <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLightPoint>fltLightPoint</A>
:<BR> 
fltLpAppearance<BR> 
fltLpAnimation<BR><P>
<H3>Light Point Palette Nodes</H3><P>
The following palette nodes were added<BR> 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLpAppearancePalette>fltLpAppearancePalette</A>
<BR> 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLpAnimationPalette>fltLpAnimationPalette</A>
<BR><P>
<H1>v2.5.1</H1><P>
This version of the OpenFlight API corresponds to OpenFlight version 15.7.<P>
No new functions were added for this release.<P>
<H1>v2.5</H1><P>
This version of the OpenFlight API corresponds to OpenFlight version 15.7.<P>
<H2>OpenFlight API version number</H2><P>
When you call <A HREF=#mgInit>mgInit</A>, it now displays the OpenFlight API version 
number currently loading.  This can help stand-alone program developers 
and users verify that the correct version of the OpenFlight API libraries 
are loading at runtime.  You can disable this as well as other messages 
issued by the OpenFlight API using the function <A HREF=#mgSetMessagesEnabled>mgSetMessagesEnabled</A>.<P>
<H2>Menus in Plugin Dialogs</H2><P>
Menus are now supported within plug-in dialogs. 
See the <I>OpenFlight API Developer Guide, Volume 2</I> for more 
information. Also, see the new supporting functions 
<A HREF=#mgMenuSetState>mgMenuSetState</A> and <A HREF=#mgMenuGetState>mgMenuGetState</A>.<P>
<H2>Mouse Motion Events in GL Controls</H2><P>
GL controls in plug-in dialogs can now receive mouse motion events 
even when a mouse button is not pressed.  This allows a plug-in to 
"monitor" the cursor location as the user moves the mouse 
(without pressing a mouse button) over the GL control.  See 
<A HREF=#mgGLSetMouseFunc>mgGLSetMouseFunc</A>, <A HREF=#MGMA_MOTION>MGMA_MOTION</A>, and <A HREF=#mgglmousemotiondatarec>mgglmousemotiondatarec</A>.<P>
<H2>New Data Types</H2><P>
<A HREF=#mgglmousemotiondatarec>mgglmousemotiondatarec</A><BR> 
<A HREF=#mgcontrolattribute>mgcontrolattribute</A><BR><P>
<H2>New Symbols</H2><P>
<A HREF=#MGMA_MOTION>MGMA_MOTION</A> for <A HREF=#mgGLSetMouseFunc>mgGLSetMouseFunc</A><BR> 
<A HREF=#mgcontrolattribute>MCA_GLBORDERSTYLE</A> for <A HREF=#mgControlSetAttribute>mgControlSetAttribute</A><BR> 
<A HREF=#MGLBS_NONE>MGLBS_NONE</A> for <A HREF=#mgcontrolattribute>MCA_GLBORDERSTYLE</A><BR> 
<A HREF=#MGLBS_SUNKEN>MGLBS_SUNKEN</A> for <A HREF=#mgcontrolattribute>MCA_GLBORDERSTYLE</A><BR> 
<A HREF=#MGLBS_RAISED>MGLBS_RAISED</A> for <A HREF=#mgcontrolattribute>MCA_GLBORDERSTYLE</A><BR> 
<A HREF=#MGLBS_SOLID>MGLBS_SOLID</A> for <A HREF=#mgcontrolattribute>MCA_GLBORDERSTYLE</A><BR><P>
<H2>New Functions</H2><P>
<A HREF=#mgMenuSetState>mgMenuSetState</A><BR> 
<A HREF=#mgMenuGetState>mgMenuGetState</A><BR> 
<A HREF=#mgControlSetAttribute>mgControlSetAttribute</A><BR><P>
<H2>Sample Plugins</H2><P>
A new sample plug-in, called <B>menutest</B>, was added to the <B>sample_plugins</B> 
folder. This plug-in shows you how to add menus to your plug-in tool 
dialogs using the new menu capabilities included in this version 
of the OpenFlight API.<P>
The existing plug-in, <B>attrviewer</B>, was updated to show you how to add 
a custom Windows control (in this case, a tree view control) to 
a plug-in tool dialog.  The example includes how to access native 
Windows GUI constructs through the OpenFlight API.<P>
<H1>v2.4.1</H1><P>
This version of the OpenFlight API corresponds to OpenFlight version 15.7.<P>
<H2>Debugging Plug-ins in the Creator environment</H2><P>
When debugging your plug-in initialization code on Windows, you may 
find that the Creator splash screen occludes your workspace.  To avoid 
this, you can disable the Creator splash screen by setting the environment 
variable <B>MGNOSPLASH</B> to <B>1</B>, <B>TRUE</B>, or <B>true</B> before running 
Creator.  To re-enable 
the splash screen, un-set this environment variable or set it to 
<B>0</B>, <B>FALSE</B>, or <B>false</B>.<P>
Note: After you change an environment variable on the Windows 
platform, you must exit and restart your development environment 
(Visual Studio, etc) before the change you make takes effect in 
your environment.<P>
<H1>v2.4</H1><P>
This version of the OpenFlight API corresponds to OpenFlight version 15.7.<P>
<H2>New Tool Attributes for Editor and Viewer Tools</H2><P>
(see <A HREF=#mgRegisterEditor>mgRegisterEditor</A> and <A HREF=#mgRegisterViewer>mgRegisterViewer</A>)<P>
<A HREF=#MTA_MENUPOSITION>MTA_MENUPOSITION</A><BR> 
<A HREF=#MTA_MENUSUBMENU>MTA_MENUSUBMENU</A><BR><P>
<H2>New Data Types</H2><P>
<A HREF=#mgreclist>mgreclist</A> - formerly <A HREF=#dep_mgselectlist>mgselectlist</A><BR> 
<A HREF=#mgcursorid>mgcursorid</A><BR> 
<A HREF=#mgcursor>mgcursor</A><BR> 
<A HREF=#mgcursorhandle>mgcursorhandle</A><BR> 
<A HREF=#mgptrarray>mgptrarray</A><BR><P>
<H2>New Symbols</H2><P>
<A HREF=#MPRIM_TRI_STRIP>MPRIM_TRI_STRIP</A><BR> 
<A HREF=#MPRIM_TRI_FAN>MPRIM_TRI_FAN</A><BR> 
<A HREF=#MPRIM_QUAD_STRIP>MPRIM_QUAD_STRIP</A><BR> 
<A HREF=#MPRIM_INDEXED_POLY>MPRIM_INDEXED_POLY</A><BR><P>
<A HREF=#MMESH_VTXCOORD>MMESH_VTXCOORD</A><BR> 
<A HREF=#MMESH_VTXCOLOR>MMESH_VTXCOLOR</A><BR> 
<A HREF=#MMESH_VTXCOLORRGB>MMESH_VTXCOLORRGB</A><BR> 
<A HREF=#MMESH_VTXNORMAL>MMESH_VTXNORMAL</A><BR> 
<A HREF=#MMESH_VTXUV0>MMESH_VTXUV0</A><BR> 
<A HREF=#MMESH_VTXUV1>MMESH_VTXUV1</A><BR> 
<A HREF=#MMESH_VTXUV2>MMESH_VTXUV2</A><BR> 
<A HREF=#MMESH_VTXUV3>MMESH_VTXUV3</A><BR> 
<A HREF=#MMESH_VTXUV4>MMESH_VTXUV4</A><BR> 
<A HREF=#MMESH_VTXUV5>MMESH_VTXUV5</A><BR> 
<A HREF=#MMESH_VTXUV6>MMESH_VTXUV6</A><BR> 
<A HREF=#MMESH_VTXUV7>MMESH_VTXUV7</A><BR><P>
<H2>New Functions</H2><P>
<H3>Mesh Functions</H3><P>
<A HREF=#mgMeshGetVtxPool>mgMeshGetVtxPool</A><BR> 
<A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A><BR> 
<A HREF=#mgMeshGetVtxStride>mgMeshGetVtxStride</A><BR> 
<A HREF=#mgMeshGetVtxOffset>mgMeshGetVtxOffset</A><BR> 
<A HREF=#mgMeshPrimitiveGetType>mgMeshPrimitiveGetType</A><BR> 
<A HREF=#mgMeshPrimitiveGetNumVtx>mgMeshPrimitiveGetNumVtx</A><BR> 
<A HREF=#mgMeshPrimitiveGetVtxIndexArray>mgMeshPrimitiveGetVtxIndexArray</A><BR> 
<A HREF=#mgMeshGetVtxCoord>mgMeshGetVtxCoord</A><BR> 
<A HREF=#mgMeshGetVtxColor>mgMeshGetVtxColor</A><BR> 
<A HREF=#mgMeshGetVtxColorRGB>mgMeshGetVtxColorRGB</A><BR> 
<A HREF=#mgMeshGetVtxNormal>mgMeshGetVtxNormal</A><BR> 
<A HREF=#mgMeshGetVtxUV>mgMeshGetVtxUV</A><BR><P>
<A HREF=#mgMeshCreateVtxPool>mgMeshCreateVtxPool</A><BR> 
<A HREF=#mgMeshCreatePrimitives>mgMeshCreatePrimitives</A><BR> 
<A HREF=#mgMeshPrimitiveSetType>mgMeshPrimitiveSetType</A><BR> 
<A HREF=#mgMeshPrimitiveSetVtxIndexArray>mgMeshPrimitiveSetVtxIndexArray</A><BR> 
<A HREF=#mgMeshSetVtxCoord>mgMeshSetVtxCoord</A><BR> 
<A HREF=#mgMeshSetVtxColor>mgMeshSetVtxColor</A><BR> 
<A HREF=#mgMeshSetVtxColorRGB>mgMeshSetVtxColorRGB</A><BR> 
<A HREF=#mgMeshSetVtxNormal>mgMeshSetVtxNormal</A><BR> 
<A HREF=#mgMeshSetVtxUV>mgMeshSetVtxUV</A><BR><P>
<H3>Database/Attribute Functions</H3><P>
<A HREF=#mgIsDbUntitled>mgIsDbUntitled</A><BR><P>
<A HREF=#mgDuplicateToDb>mgDuplicateToDb</A><BR><P>
<A HREF=#mgGetVectord>mgGetVectord</A><BR> 
<A HREF=#mgSetVectord>mgSetVectord</A><BR><P>
<A HREF=#mgGeoCoordCount>mgGeoCoordCount</A><BR><P>
<A HREF=#mgGetTextureSaveName>mgGetTextureSaveName</A><BR><P>
<A HREF=#mgGetConstructList>mgGetConstructList</A><BR><P>
<H3>Texture Functions</H3><P>
<A HREF=#mgSubTextureCount>mgSubTextureCount</A><BR> 
<A HREF=#mgSubTextureGet>mgSubTextureGet</A><BR> 
<A HREF=#mgSubTextureAdd>mgSubTextureAdd</A><BR> 
<A HREF=#mgSubTextureDelete>mgSubTextureDelete</A><BR><P>
<H3>Texture Layer Functions</H3><P>
<A HREF=#mgGetCurrentTextureLayer>mgGetCurrentTextureLayer</A><BR> 
<A HREF=#mgSetCurrentTextureLayer>mgSetCurrentTextureLayer</A><BR><P>
<H3>Dialog/Control Functions</H3><P>
<A HREF=#mgListDeselectItemAtPos>mgListDeselectItemAtPos</A><BR> 
<A HREF=#mgListGetItemStringAtPos>mgListGetItemStringAtPos</A><BR> 
<A HREF=#mgListReplaceItemAtPos>mgListReplaceItemAtPos</A><BR><P>
<A HREF=#mgTextGetDMS>mgTextGetDMS</A><BR> 
<A HREF=#mgTextSetDMS>mgTextSetDMS</A><BR><P>
<A HREF=#mgResourceGetCursor>mgResourceGetCursor</A><BR> 
<A HREF=#mgGetCursorHandle>mgGetCursorHandle</A><BR> 
<A HREF=#mgSetCursor>mgSetCursor</A><BR><P>
<A HREF=#mgGuiSetFixedFont>mgGuiSetFixedFont</A><BR> 
<A HREF=#mgRefreshControl>mgRefreshControl</A><BR><P>
<H3>Convenience Dialog Functions</H3><P>
<A HREF=#mgPromptDialogFile>mgPromptDialogFile</A><BR> 
<A HREF=#mgPromptDialogColor>mgPromptDialogColor</A><BR> 
<A HREF=#mgPromptDialogFolder>mgPromptDialogFolder</A><BR><P>
<H3>Select List Functions</H3><P>
<A HREF=#mgGetSelectList>mgGetSelectList</A> - formerly <A HREF=#mgNewSelectList>mgNewSelectList</A><BR> 
<A HREF=#mgFreeRecList>mgFreeRecList</A> - formerly <A HREF=#mgFreeSelectList>mgFreeSelectList</A><BR> 
<A HREF=#mgResetRecList>mgResetRecList</A> - formerly <A HREF=#mgResetSelectList>mgResetSelectList</A><BR> 
<A HREF=#mgGetNextRecInList>mgGetNextRecInList</A> - formerly <A HREF=#mgGetNextSelected>mgGetNextSelected</A><BR> 
<A HREF=#mgGetNthRecInList>mgGetNthRecInList</A> - formerly <A HREF=#mgGetNthSelected>mgGetNthSelected</A><BR> 
<A HREF=#mgGetRecListCount>mgGetRecListCount</A> - formerly <A HREF=#mgGetSelectListCount>mgGetSelectListCount</A><BR> 
<A HREF=#mgGetRecListLevel>mgGetRecListLevel</A> - formerly <A HREF=#mgGetSelectListLevel>mgGetSelectListLevel</A><BR><P>
<H3>Pointer Array Functions</H3><P>
<A HREF=#mgNewPtrArray>mgNewPtrArray</A><BR> 
<A HREF=#mgFreePtrArray>mgFreePtrArray</A><BR> 
<A HREF=#mgPtrArrayAppend>mgPtrArrayAppend</A><BR> 
<A HREF=#mgPtrArrayInsert>mgPtrArrayInsert</A><BR> 
<A HREF=#mgPtrArrayReplace>mgPtrArrayReplace</A><BR> 
<A HREF=#mgPtrArrayGet>mgPtrArrayGet</A><BR> 
<A HREF=#mgPtrArrayRemove>mgPtrArrayRemove</A><BR> 
<A HREF=#mgPtrArrayLength>mgPtrArrayLength</A><BR><P>
<H2>Changed Functions</H2><P>
<A HREF=#mgSetMessagesEnabled>mgSetMessagesEnabled</A> can now be called before <A HREF=#mgInit>mgInit</A> within 
the stand-alone program environment to control message display 
during the OpenFlight API initialization function.<BR><P>
<H2>New in the OpenFlight Data Dictionary</H2><P>
<P>
<H3>Mesh Nodes</H3><P>
Mesh nodes were introduced (<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
) and include the following fields<BR> 
fltMeshNumPrimitives<BR> 
fltMeshNumVtx<BR><P>
In addition, mesh nodes use the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 attributes.<P>
<H3>MultiTexture</H3><P>
For <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 nodes and <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 nodes:<P>
fltLayerTexture1<BR> 
fltLayerTexture2<BR> 
fltLayerTexture3<BR> 
fltLayerTexture4<BR> 
fltLayerTexture5<BR> 
fltLayerTexture6<BR> 
fltLayerTexture7<BR><P>
fltLayerTexmap1<BR> 
fltLayerTexmap2<BR> 
fltLayerTexmap3<BR> 
fltLayerTexmap4<BR> 
fltLayerTexmap5<BR> 
fltLayerTexmap6<BR> 
fltLayerTexmap7<BR><P>
fltLayerEffect1<BR> 
fltLayerEffect2<BR> 
fltLayerEffect3<BR> 
fltLayerEffect4<BR> 
fltLayerEffect5<BR> 
fltLayerEffect6<BR> 
fltLayerEffect7<BR><P>
fltLayerData1<BR> 
fltLayerData2<BR> 
fltLayerData3<BR> 
fltLayerData4<BR> 
fltLayerData5<BR> 
fltLayerData6<BR> 
fltLayerData7<BR><P>
For <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 nodes:<P>
fltLayerU1<BR> 
fltLayerU2<BR> 
fltLayerU3<BR> 
fltLayerU4<BR> 
fltLayerU5<BR> 
fltLayerU6<BR> 
fltLayerU7<BR><P>
fltLayerV1<BR> 
fltLayerV2<BR> 
fltLayerV3<BR> 
fltLayerV4<BR> 
fltLayerV5<BR> 
fltLayerV6<BR> 
fltLayerV7<BR><P>
<H3>Header Node</H3><P>
The following fields were added to <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHeader</A>
:<BR> 
fltUTMZone<BR> 
fltTerTransX<BR> 
fltTerTransY<BR> 
fltTerTransZ<BR> 
fltDBRadius<BR><P>
<H2>Deprecated API</H2><P>
The following symbols have been deprecated in this version of the 
OpenFlight API. For each symbol that appears in this section, an appropriate 
replacement symbol or strategy is also given.  These deprecated symbols 
are still supported in this version of the API and will likely remain 
supported indefinitely in future versions.  However, it is recommended 
(but not required) that you replace any deprecated symbols in your code 
with the suggested replacements. This will ensure that code you develop 
using the MultiGen OpenFlight API remains compatible with future versions 
of the API.<P>
<A HREF=#dep_mgselectlist>mgselectlist</A> replaced by <A HREF=#mgreclist>mgreclist</A><BR> 
<A HREF=#mgNewSelectList>mgNewSelectList</A> replaced by <A HREF=#mgGetSelectList>mgGetSelectList</A><BR> 
<A HREF=#mgFreeSelectList>mgFreeSelectList</A> replaced by <A HREF=#mgFreeRecList>mgFreeRecList</A><BR> 
<A HREF=#mgResetSelectList>mgResetSelectList</A> replaced by <A HREF=#mgResetRecList>mgResetRecList</A><BR> 
<A HREF=#mgGetNextSelected>mgGetNextSelected</A> replaced by <A HREF=#mgGetNextRecInList>mgGetNextRecInList</A><BR> 
<A HREF=#mgGetNthSelected>mgGetNthSelected</A> replaced by <A HREF=#mgGetNthRecInList>mgGetNthRecInList</A><BR> 
<A HREF=#mgGetSelectListCount>mgGetSelectListCount</A> replaced by <A HREF=#mgGetRecListCount>mgGetRecListCount</A><BR> 
<A HREF=#mgGetSelectListLevel>mgGetSelectListLevel</A> replaced by <A HREF=#mgGetRecListLevel>mgGetRecListLevel</A><BR><P>
<A HREF=#fltHdrFlagVtxNorms>fltHdrFlagVtxNorms</A> replaced by fltHdrSaveVtxNorms<P>
<A HREF=#fltPolyMgTemplate>fltPolyMgTemplate</A> replaced by fltPolyTemplate<BR> 
<A HREF=#fltPolyTexture1>fltPolyTexture1</A> replaced by fltPolyDetailTexture<BR> 
<A HREF=#fltPolyTexmap1>fltPolyTexmap1</A> replaced by fltPolyDetailTexmap<BR> 
<A HREF=#fltCatTexture1>fltCatTexture1</A> replaced by fltCatDetailTexture<BR><P>
<A HREF=#fltPolyFlagNocolor>fltPolyFlagNocolor</A> replaced by fltPolyNoPrimeColor<BR> 
<A HREF=#fltPolyFlagNocolor2>fltPolyFlagNocolor2</A> replaced by fltPolyNoAltColor<BR> 
<A HREF=#fltPolyFlagRgbMode>fltPolyFlagRgbMode</A> replaced by fltPolyRgbMode<BR> 
<A HREF=#fltPolyFlagTerrain>fltPolyFlagTerrain</A> replaced by fltPolyTerrain<BR> 
<A HREF=#fltPolyFlagHidden>fltPolyFlagHidden</A> replaced by fltPolyHidden<BR> 
<A HREF=#fltPolyFlagFootprint>fltPolyFlagFootprint</A> replaced by fltPolyFootprint<BR><P>
<A HREF=#fltObjFlagDay>fltObjFlagDay</A> replaced by fltObjNoDay<BR> 
<A HREF=#fltObjFlagDusk>fltObjFlagDusk</A> replaced by fltObjNoDusk<BR> 
<A HREF=#fltObjFlagNight>fltObjFlagNight</A> replaced by fltObNoNight<BR> 
<A HREF=#fltObjFlagNoillum>fltObjFlagNoillum</A> replaced by fltObjNoIllum<BR> 
<A HREF=#fltObjFlagNoshade>fltObjFlagNoshade</A> replaced by fltObjNoShade<BR> 
<A HREF=#fltObjFlagShadow>fltObjFlagShadow</A> replaced by fltObjShadow<BR><P>
<A HREF=#fltGrpFlagAnimation>fltGrpFlagAnimation</A> replaced by fltGrpAnimation<BR> 
<A HREF=#fltGrpFlagAnimationFB>fltGrpFlagAnimationFB</A> replaced by fltGrpAnimationFB<BR> 
<A HREF=#fltGrpFlagBoxed>fltGrpFlagBoxed</A> replaced by fltGrpBoxed<BR> 
<A HREF=#fltGrpFlagFreezeBox>fltGrpFlagFreezeBox</A> replaced by fltGrpFreezeBox<BR><P>
<A HREF=#fltLodFlagAdditive>fltLodFlagAdditive</A> replaced by fltLodAdditive<BR> 
<A HREF=#fltLodFlagFreezeCenter>fltLodFlagFreezeCenter</A> replaced by fltLodFreezeCenter<BR> 
<A HREF=#fltLodFlagRange>fltLodFlagRange</A> replaced by fltLodUsePrevRange<BR><P>
<A HREF=#fltDofFlagTxtRepeat>fltDofFlagTxtRepeat</A> replaced by fltDofTxtRepeat<BR> 
<A HREF=#fltDofFlagMembrane>fltDofFlagMembrane</A> replaced by fltDofMembrane<BR><P>
<A HREF=#fltDofCurAzim>fltDofCurAzim</A> replaced by fltDofCurXRot<BR> 
<A HREF=#fltDofMinAzim>fltDofMinAzim</A> replaced by fltDofMinXRot<BR> 
<A HREF=#fltDofMaxAzim>fltDofMaxAzim</A> replaced by fltDofMaxXRot<BR> 
<A HREF=#fltDofIncrementAzim>fltDofIncrementAzim</A> replaced by fltDofIncXRot<BR> 
<A HREF=#fltDofFlagAzimLimited>fltDofFlagAzimLimited</A> replaced by fltDofLimitXRot<BR><P>
<A HREF=#fltDofCurIncl>fltDofCurIncl</A> replaced by fltDofCurYRot<BR> 
<A HREF=#fltDofMinIncl>fltDofMinIncl</A> replaced by fltDofMinYRot<BR> 
<A HREF=#fltDofMaxIncl>fltDofMaxIncl</A> replaced by fltDofMaxYRot<BR> 
<A HREF=#fltDofIncrementIncl>fltDofIncrementIncl</A> replaced by fltDofIncYRot<BR> 
<A HREF=#fltDofFlagInclLimited>fltDofFlagInclLimited</A> replaced by fltDofLimitYRot<BR><P>
<A HREF=#fltDofCurTwist>fltDofCurTwist</A> replaced by fltDofCurZRot<BR> 
<A HREF=#fltDofMinTwist>fltDofMinTwist</A> replaced by fltDofMinZRot<BR> 
<A HREF=#fltDofMaxTwist>fltDofMaxTwist</A> replaced by fltDofMaxZRot<BR> 
<A HREF=#fltDofIncrementTwist>fltDofIncrementTwist</A> replaced by fltDofIncZRot<BR> 
<A HREF=#fltDofFlagTwistLimited>fltDofFlagTwistLimited</A> replaced by fltDofLimitZRot<BR><P>
<A HREF=#fltDofIncrementX>fltDofIncrementX</A> replaced by fltDofIncX<BR> 
<A HREF=#fltDofIncrementY>fltDofIncrementY</A> replaced by fltDofIncY<BR> 
<A HREF=#fltDofIncrementZ>fltDofIncrementZ</A> replaced by fltDofIncZ<BR><P>
<A HREF=#fltDofFlagXLimited>fltDofFlagXLimited</A> replaced by fltDofLimitX<BR> 
<A HREF=#fltDofFlagYLimited>fltDofFlagYLimited</A> replaced by fltDofLimitY<BR> 
<A HREF=#fltDofFlagZLimited>fltDofFlagZLimited</A> replaced by fltDofLimitZ<BR><P>
<A HREF=#fltDofIncrementXScale>fltDofIncrementXScale</A> replaced by fltDofIncXScale<BR> 
<A HREF=#fltDofIncrementYScale>fltDofIncrementYScale</A> replaced by fltDofIncYScale<BR> 
<A HREF=#fltDofIncrementZScale>fltDofIncrementZScale</A> replaced by fltDofIncZScale<BR><P>
<A HREF=#fltDofFlagXScaleLimited>fltDofFlagXScaleLimited</A> replaced by fltDofLimitXScale<BR> 
<A HREF=#fltDofFlagYScaleLimited>fltDofFlagYScaleLimited</A> replaced by fltDofLimitYScale<BR> 
<A HREF=#fltDofFlagZScaleLimited>fltDofFlagZScaleLimited</A> replaced by fltDofLimitZScale<BR><P>
<P>
<H1>v2.3</H1><P>
This version of the OpenFlight API corresponds to OpenFlight version 15.6.<P>
The Level 4 API was implemented on the SGI/Irix 
platform.  The OpenFlight API libraries were distributed 
on SGI/Irix using n32 binary format.<P>
<H2>New Functions</H2><P>
<A HREF=#mgGetExtRec>mgGetExtRec</A><P>
<H2>Changed Functions</H2><P>
<A HREF=#mgAttach>mgAttach</A> was modified to support attaching tag-along 
extension records to nodes programmatically.<BR><P>
<H1>v2.2.1</H1><P>
This version of the OpenFlight API corresponds to OpenFlight version 15.6.<P>
<H2>New Functions</H2><P>
<A HREF=#mgTextureGetLocatorFunc>mgTextureGetLocatorFunc</A><BR> 
<A HREF=#mgTextureSetLocatorFunc>mgTextureSetLocatorFunc</A><BR> 
<A HREF=#mgExtRefGetLocatorFunc>mgExtRefGetLocatorFunc</A><BR> 
<A HREF=#mgExtRefSetLocatorFunc>mgExtRefSetLocatorFunc</A><P>
<H2>New Data Types</H2><P>
<A HREF=#mgfilelocatorfunc>mgfilelocatorfunc</A><P>
<H1>v2.2</H1><P>
This version of the OpenFlight API corresponds to OpenFlight version 15.6.<P>
Access to the following OpenFlight node types was added to the 
OpenFlight Data Dictionary:<P>
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltGrid>fltGrid</A>
<BR> 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHelper>fltHelper</A>
<BR> 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSurface>fltSurface</A>
<BR> 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltTorsion>fltTorsion</A>
<BR><P>
<H1>v2.1</H1><P>
This version of the OpenFlight API corresponds to OpenFlight version 15.6.<P>
<H2>Plug-in Runtime Directory</H2><P>
The directory specified by the environment variable <B>MGPLUGINDIR</B> supersedes 
all other plug-in runtime directories searched.  Additionally, once a plug-in 
runtime directory is located, it and all subdirectories below it are recursively 
searched for plug-in modules.  See the <I>OpenFlight API Developer Guide, Volume 2</I> 
for more information.<P>
<H2>Automatic Version Update for Data Extension Records</H2><P>
Padding is no longer required to reserve space for future additions to 
<B>struct</B> definitions.  When the OpenFlight API finds an extension record in a 
database file that is shorter than the current corresponding <B>struct</B> 
definition, the extension record (when it is read into memory) is automatically 
expanded to accommodate for the new fields at the end of the new <B>struct</B> 
definition.  When this happens, the values for these new fields are 
initialized to 0.  See the <I>OpenFlight API Developer Guide, Volume 2</I> 
for more information.<P>
<H2>Changed Functions</H2><P>
<A HREF=#mgIndex2RGB>mgIndex2RGB</A> was changed to return <A HREF=#mgbool>mgbool</A>.<BR> 
<A HREF=#mgRGB2Index>mgRGB2Index</A> was changed to return <A HREF=#mgbool>mgbool</A>.<BR> 
<A HREF=#mgRegisterPostEdit>mgRegisterPostEdit</A> was changed to return <A HREF=#mgstatus>mgstatus</A>.<BR> 
<A HREF=#mgRegisterPreEdit>mgRegisterPreEdit</A> was changed to return <A HREF=#mgstatus>mgstatus</A>.<BR> 
<A HREF=#mgResourceGetPixmap>mgResourceGetPixmap</A> now supports icons in addition to bitmaps on Windows.<BR><P>
<H2>Changes to OpenFlight record/data codes</H2><P>
Typo in <B>fltTxtGetCoordLst</B> was corrected to <B>fltTxtGeoCoordLst</B><P>
<H2>Previously Undocumented Functions</H2><P>
<A HREF=#ddIsField>ddIsField</A><BR> 
<A HREF=#ddIsFieldFollowAll>ddIsFieldFollowAll</A><BR> 
<A HREF=#ddIsFieldFollowPointer>ddIsFieldFollowPointer</A><BR> 
<A HREF=#ddIsFieldFollowInLine>ddIsFieldFollowInLine</A><BR> 
<A HREF=#ddLabelToCode>ddLabelToCode</A><BR> 
<A HREF=#ddNameToCode>ddNameToCode</A><BR><P>
<H2>New Control and Dialog Events</H2><P>
<A HREF=#MGCB_SIZE>MGCB_SIZE</A><BR> 
<A HREF=#MGCB_DRAW>MGCB_DRAW</A><BR><P>
<H2>New Menu Locations for Editor and Viewer Tools</H2><P>
(see <A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A>)<P>
<A HREF=#MMENU_TERRAIN>MMENU_TERRAIN</A><BR> 
<A HREF=#MMENU_ROAD>MMENU_ROAD</A><BR> 
<A HREF=#MMENU_GEOFEATURE>MMENU_GEOFEATURE</A><BR> 
<A HREF=#MMENU_SOUND>MMENU_SOUND</A><BR> 
<A HREF=#MMENU_INSTRUMENTS>MMENU_INSTRUMENTS</A><BR> 
<A HREF=#MMENU_BSP>MMENU_BSP</A><BR><P>
<H2>New Tool Attributes</H2><P>
<A HREF=#MTA_HELPCONTEXT>MTA_HELPCONTEXT</A><BR><P>
<H2>New Data Types</H2><P>
<A HREF=#mgglmousefunc>mgglmousefunc</A><BR> 
<A HREF=#mgglmousedatatype>mgglmousedatatype</A><BR> 
<A HREF=#mgglmouseaction>mgglmouseaction</A><BR> 
<A HREF=#mgglmousedatarec>mgglmousedatarec</A><BR> 
<A HREF=#mgglmousebuttondatarec>mgglmousebuttondatarec</A><BR> 
<A HREF=#mgglmousedoubleclickdatarec>mgglmousedoubleclickdatarec</A><BR> 
<A HREF=#mgguicalldatatype>mgguicalldatatype</A><BR> 
<A HREF=#mgtextactivatecallbackrec>mgtextactivatecallbackrec</A><BR> 
<A HREF=#mgtabruleractivatecallbackrec>mgtabruleractivatecallbackrec</A><BR> 
<A HREF=#mgscaleactivatecallbackrec>mgscaleactivatecallbackrec</A><BR> 
<A HREF=#mggldrawcallbackrec>mggldrawcallbackrec</A><BR> 
<A HREF=#mgdialogsizecallbackrec>mgdialogsizecallbackrec</A><BR> 
<A HREF=#mgtimer>mgtimer</A><BR> 
<A HREF=#mgtimerfunc>mgtimerfunc</A><BR> 
<A HREF=#mgeditorfocusvertexfunc>mgeditorfocusvertexfunc</A><BR> 
<A HREF=#mgcreatefunc>mgcreatefunc</A><BR> 
<A HREF=#mginputdevicestartfunc>mginputdevicestartfunc</A><BR> 
<A HREF=#mginputdevicestopfunc>mginputdevicestopfunc</A><BR> 
<A HREF=#mginputdevicesetinputtypefunc>mginputdevicesetinputtypefunc</A><BR> 
<A HREF=#mginputdevicestartfunc>mginputdevicestartfunc</A><BR> 
<A HREF=#mgdeviceinputdata>mgdeviceinputdata</A><BR> 
<A HREF=#mginputdevice>mginputdevice</A><BR> 
<A HREF=#mggraphicdrawfunc>mggraphicdrawfunc</A><BR> 
<A HREF=#mggraphicviewdata>mggraphicviewdata</A><BR> 
<A HREF=#mggraphicdrawmode>mggraphicdrawmode</A><BR> 
<A HREF=#mghierarchydrawfunc>mghierarchydrawfunc</A><BR> 
<A HREF=#mghierarchyviewdata>mghierarchyviewdata</A><BR> 
<A HREF=#mgglcontext>mgglcontext</A><BR> 
<A HREF=#mghelpcontext>mghelpcontext</A><BR><P>
<H2>New Functions</H2><P>
<H3>Info Functions</H3><P>
<A HREF=#mgGetVersion>mgGetVersion</A><BR><P>
<H3>I/O Functions</H3><P>
<A HREF=#mgIsDb>mgIsDb</A><BR><P>
<H3>Attribute Functions</H3><P>
<A HREF=#mgGetVtxCoord>mgGetVtxCoord</A><BR> 
<A HREF=#mgSetVtxCoord>mgSetVtxCoord</A><BR> 
<A HREF=#mgRemoveVtxNormal>mgRemoveVtxNormal</A><BR><P>
<H3>Input Device Plug-in Tool Class</H3><P>
<A HREF=#mgRegisterInputDevice>mgRegisterInputDevice</A><BR> 
<A HREF=#mgInputDeviceGetHandle>mgInputDeviceGetHandle</A><BR> 
<A HREF=#mgInputDeviceSetVertex>mgInputDeviceSetVertex</A><BR> 
<A HREF=#mgInputDeviceSetPoint>mgInputDeviceSetPoint</A><BR> 
<A HREF=#mgInputDeviceSetButtonStatus>mgInputDeviceSetButtonStatus</A><BR> 
<A HREF=#mgInputDeviceSetDeviceData>mgInputDeviceSetDeviceData</A><BR> 
<A HREF=#mgInputDeviceSendEvent>mgInputDeviceSendEvent</A><BR> 
<A HREF=#mgInputDeviceGetDeviceData>mgInputDeviceGetDeviceData</A><BR> 
<A HREF=#mgInputDeviceGetButtonStatus>mgInputDeviceGetButtonStatus</A><BR><P>
<H3>Image Importer Plug-in Tool Class</H3><P>
Function <A HREF=#mgSetTextureSampleSize>mgSetTextureSampleSize</A> now allows sample sizes of 
8 or 16 bits.<P>
<A HREF=#mgSetTextureMinMax>mgSetTextureMinMax</A><BR> 
<A HREF=#mgSetTextureTransparentValue>mgSetTextureTransparentValue</A><BR> 
<A HREF=#mgSetTextureSignedFlag>mgSetTextureSignedFlag</A><BR> 
<A HREF=#mgSetReadImageGeoInfoFunc>mgSetReadImageGeoInfoFunc</A><BR> 
<A HREF=#mgSetTextureGeoType>mgSetTextureGeoType</A><BR> 
<A HREF=#mgSetTextureGeoProjection>mgSetTextureGeoProjection</A><BR> 
<A HREF=#mgSetTextureGeoEarthModel>mgSetTextureGeoEarthModel</A><BR> 
<A HREF=#mgSetTextureGeoUTMZone>mgSetTextureGeoUTMZone</A><BR> 
<A HREF=#mgSetTextureGeoUTMHemisphere>mgSetTextureGeoUTMHemisphere</A><BR> 
<A HREF=#mgSetTextureGeoImageOrigin>mgSetTextureGeoImageOrigin</A><BR> 
<A HREF=#mgSetTextureGeoNumCtlPts>mgSetTextureGeoNumCtlPts</A><BR> 
<A HREF=#mgSetTextureGeoCtlPt>mgSetTextureGeoCtlPt</A><BR><P>
<H3>Image Geo Coordinate Access</H3><P>
<A HREF=#mgGeoCoordGet>mgGeoCoordGet</A><BR> 
<A HREF=#mgGeoCoordAdd>mgGeoCoordAdd</A><BR> 
<A HREF=#mgGeoCoordDelete>mgGeoCoordDelete</A><BR><P>
<H3>Data Extension Site Functions</H3><P>
<A HREF=#mgRegisterGraphicDraw>mgRegisterGraphicDraw</A><BR> 
<A HREF=#mgRegisterHierarchyDraw>mgRegisterHierarchyDraw</A><BR> 
<A HREF=#mgRegisterCreate>mgRegisterCreate</A><BR><P>
<H3>Image Info Functions</H3><P>
<A HREF=#mgReadImageInfo>mgReadImageInfo</A><BR> 
<A HREF=#mgGetTextureType>mgGetTextureType</A><BR> 
<A HREF=#mgGetTextureWidth>mgGetTextureWidth</A><BR> 
<A HREF=#mgGetTextureHeight>mgGetTextureHeight</A><BR> 
<A HREF=#mgGetTextureSampleSize>mgGetTextureSampleSize</A><BR> 
<A HREF=#mgGetTextureTiledFlag>mgGetTextureTiledFlag</A><BR> 
<A HREF=#mgGetTextureMinMax>mgGetTextureMinMax</A><BR> 
<A HREF=#mgHasTextureTransparentValue>mgHasTextureTransparentValue</A><BR> 
<A HREF=#mgGetTextureTransparentValue>mgGetTextureTransparentValue</A><BR> 
<A HREF=#mgGetTextureSignedFlag>mgGetTextureSignedFlag</A><BR> 
<A HREF=#mgFreeImageInfo>mgFreeImageInfo</A><BR><P>
<H3>Georeferenced Image Info Functions</H3><P>
<A HREF=#mgReadImageGeoInfo>mgReadImageGeoInfo</A><BR> 
<A HREF=#mgGetTextureGeoType>mgGetTextureGeoType</A><BR> 
<A HREF=#mgGetTextureGeoProjection>mgGetTextureGeoProjection</A><BR> 
<A HREF=#mgGetTextureGeoEarthModel>mgGetTextureGeoEarthModel</A><BR> 
<A HREF=#mgGetTextureGeoUTMZone>mgGetTextureGeoUTMZone</A><BR> 
<A HREF=#mgGetTextureGeoUTMHemisphere>mgGetTextureGeoUTMHemisphere</A><BR> 
<A HREF=#mgGetTextureGeoImageOrigin>mgGetTextureGeoImageOrigin</A><BR> 
<A HREF=#mgGetTextureGeoNumCtlPts>mgGetTextureGeoNumCtlPts</A><BR> 
<A HREF=#mgGetTextureGeoCtlPt>mgGetTextureGeoCtlPt</A><BR> 
<A HREF=#mgFreeImageGeoInfo>mgFreeImageGeoInfo</A><BR><P>
<H3>General Controls</H3><P>
<A HREF=#mgGuiSetToolTip>mgGuiSetToolTip</A><BR><P>
<H3>Scale Controls</H3><P>
<A HREF=#mgScaleSetValue>mgScaleSetValue</A><BR> 
<A HREF=#mgScaleGetValue>mgScaleGetValue</A><BR> 
<A HREF=#mgScaleSetMinMax>mgScaleSetMinMax</A><BR> 
<A HREF=#mgScaleGetMinMax>mgScaleGetMinMax</A><BR> 
<A HREF=#mgScaleSetSpinBuddy>mgScaleSetSpinBuddy</A><BR> 
<A HREF=#mgScaleSetTextBuddy>mgScaleSetTextBuddy</A><BR> 
<A HREF=#mgScaleSetSpinIncrement>mgScaleSetSpinIncrement</A><BR> 
<A HREF=#mgScaleSetTextFormat>mgScaleSetTextFormat</A><BR><P>
<H3>Progress Controls</H3><P>
<A HREF=#mgProgressSetValue>mgProgressSetValue</A><BR> 
<A HREF=#mgProgressGetValue>mgProgressGetValue</A><BR> 
<A HREF=#mgProgressStepValue>mgProgressStepValue</A><BR> 
<A HREF=#mgProgressSetMinMax>mgProgressSetMinMax</A><BR> 
<A HREF=#mgProgressGetMinMax>mgProgressGetMinMax</A><BR> 
<A HREF=#mgProgressSetStepIncrement>mgProgressSetStepIncrement</A><BR><P>
<H3>Text Controls</H3><P>
<A HREF=#mgTextSetSpinBuddy>mgTextSetSpinBuddy</A><BR> 
<A HREF=#mgTextSetSpinIncrement>mgTextSetSpinIncrement</A><BR> 
<A HREF=#mgTextSetTextFormat>mgTextSetTextFormat</A><BR><P>
<H3>GL Controls</H3><P>
<A HREF=#mgGLSetMouseFunc>mgGLSetMouseFunc</A><BR> 
<A HREF=#mgDrawControl>mgDrawControl</A><BR><P>
<H3>Online Help</H3><P>
<A HREF=#mgRegisterHelpFile>mgRegisterHelpFile</A><BR> 
<A HREF=#mgGuiSetHelpContext>mgGuiSetHelpContext</A><BR> 
<A HREF=#mgShowHelpContext>mgShowHelpContext</A><BR> 
<A HREF=#MTA_HELPCONTEXT>MTA_HELPCONTEXT</A><BR><P>
<H3>Timers</H3><P>
<A HREF=#mgRegisterTimer>mgRegisterTimer</A><BR> 
<A HREF=#mgUnregisterTimer>mgUnregisterTimer</A><BR><P>
<H3>Sizing and Positioning Controls and Dialogs</H3><P>
<A HREF=#mgGuiGetSize>mgGuiGetSize</A><BR> 
<A HREF=#mgGuiSetSize>mgGuiSetSize</A><BR> 
<A HREF=#mgGuiGetPos>mgGuiGetPos</A><BR> 
<A HREF=#mgGuiSetPos>mgGuiSetPos</A><BR> 
<A HREF=#mgGuiGetViewSize>mgGuiGetViewSize</A><BR> 
<A HREF=#mgDialogSetAttribute>mgDialogSetAttribute</A><BR><P>
<H3>Property Lists for Controls and Dialogs</H3><P>
<A HREF=#mgGuiPutProperty>mgGuiPutProperty</A><BR> 
<A HREF=#mgGuiGetProperty>mgGuiGetProperty</A><BR> 
<A HREF=#mgGuiDeleteProperty>mgGuiDeleteProperty</A><BR><P>
<H3>Focus Vertex Lists</H3><P>
<A HREF=#mgClearFocusVertex>mgClearFocusVertex</A><BR> 
<A HREF=#mgFocusVertexListAddItem>mgFocusVertexListAddItem</A><BR> 
<A HREF=#mgFocusVertexListDeleteAllItems>mgFocusVertexListDeleteAllItems</A><BR> 
<A HREF=#mgFocusVertexListDeleteItem>mgFocusVertexListDeleteItem</A><BR> 
<A HREF=#mgGetFocusVertex>mgGetFocusVertex</A><BR> 
<A HREF=#mgSetFocusVertex>mgSetFocusVertex</A><BR><P>
<H3>Eyepoint Look At</H3><P>
<A HREF=#mgGetCurrentLookAt>mgGetCurrentLookAt</A><BR> 
<A HREF=#mgSetCurrentLookAt>mgSetCurrentLookAt</A><BR><P>
<H3>Texture Mapping Palette</H3><P>
<A HREF=#mgGetTextureMapping>mgGetTextureMapping</A><BR> 
<A HREF=#mgIndexOfTextureMapping>mgIndexOfTextureMapping</A><BR> 
<A HREF=#mgGetTextureMappingCount>mgGetTextureMappingCount</A><BR> 
<A HREF=#mgNewTextureMapping>mgNewTextureMapping</A><BR> 
<A HREF=#mgDelTextureMapping>mgDelTextureMapping</A><BR> 
<A HREF=#mgDelTextureMappingByName>mgDelTextureMappingByName</A><BR> 
<A HREF=#mgReadTextureMappingFile>mgReadTextureMappingFile</A><BR> 
<A HREF=#mgWriteTextureMappingFile>mgWriteTextureMappingFile</A><BR><P>

<HR>
<A NAME=OpenFlight_API_Version><H1>OpenFlight API Version</H1></A><P>
 15.0.0<P>
<HR>
<A NAME=OpenFlight_Format_Version><H1>OpenFlight Format Version</H1></A><P>
 1650<P>
<HR>
<LEFT><A NAME=ddGetAliasCount><H1 CLASS="APISYMBOL">ddGetAliasCount</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddGetAliasCount</B> - gets the number of alias codes defined 
for a record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>ddGetAliasCount</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>rcode</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddGetAliasCount</B> returns the number of alias codes defined 
for a record identified by <I>rcode</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rcode</I></DT><DD>the record code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the alias count if valid, 0 if not valid or no aliases.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=ddGetChildCount><H1 CLASS="APISYMBOL">ddGetChildCount</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddGetChildCount</B> - gets the number of valid child codes for 
a record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>ddGetChildCount</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>rcode</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddGetChildCount</B> returns the number of valid child codes 
defined in the data dictionary for a record identified by <I>rcode</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rcode</I></DT><DD>the record code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the child count if valid, 0 if not valid or no children.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=ddGetDefString><H1 CLASS="APISYMBOL">ddGetDefString</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddGetDefString</B> - gets the default string defined 
for a data code.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>const char* <B>ddGetDefString</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>dcode</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddGetDefString</B> returns the default string set for the 
data associated with <I>dcode</I>.</P></DD><DD><P>Note: Do not free or modify the returned string.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>dcode</I></DT><DD>the data code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the default string if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#ddGetDefVal>ddGetDefVal</A></DD></DL>
<HR>
<LEFT><A NAME=ddGetDefVal><H1 CLASS="APISYMBOL">ddGetDefVal</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddGetDefVal</B> - gets the default value defined for a data code.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>float <B>ddGetDefVal</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>dcode</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddGetDefVal</B> returns the default value set for the 
data associated with <I>dcode</I>.  The value is always stored and 
returned as a single precision floating point number. 
A value of 0.0 is returned if no default value is defined.</P></DD><DD><P>Use <A HREF=#ddIsDefSet>ddIsDefSet</A> to check if there is a default value defined 
for <I>dcode</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>dcode</I></DT><DD>the data code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the default value (cast to float) if found, 0.0 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#ddIsDefSet>ddIsDefSet</A>, <A HREF=#ddGetDefString>ddGetDefString</A></DD></DL>
<HR>
<LEFT><A NAME=ddGetDesc><H1 CLASS="APISYMBOL">ddGetDesc</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddGetDesc</B> - gets the value defined for keyword <B>MSG</B> 
for a record or data code.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>const char* <B>ddGetDesc</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddGetDesc</B> returns the value defined for keyword <B>MSG</B> for the 
specified record or data code, <I>code</I>.</P></DD><DD><P>Note: Do not free or modify the returned string.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>code</I></DT><DD>the record or data code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the keyword value if defined, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=ddGetExtendCode><H1 CLASS="APISYMBOL">ddGetExtendCode</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddGetExtendCode</B> - gets the parent code for a tag-along code.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcode <B>ddGetExtendCode</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddGetExtendCode</B> returns the parent code corresponding to the 
specified record or data code <I>code</I>.  Since a tag-along record or data 
code can only tag-along to one parent, the code returned by this function 
is unique.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>code</I></DT><DD>the tag-along record or data code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the parent code, if found, 0 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=ddGetExtFieldCount><H1 CLASS="APISYMBOL">ddGetExtFieldCount</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddGetExtFieldCount</B> - gets the number of extension attribute codes in a record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>ddGetExtFieldCount</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>rcode</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddGetExtFieldCount</B> returns the number of extension attribute codes in a 
record identified by <I>rcode</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rcode</I></DT><DD>the record code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the attribute count if valid, 0 if not valid or no extension attribute codes.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=ddGetExtFieldNth><H1 CLASS="APISYMBOL">ddGetExtFieldNth</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddGetExtFieldNth</B> - gets the <I>nth</I> extension field code associated 
with a given record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcode <B>ddGetExtFieldNth</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>rcode</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>nth</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddGetExtFieldNth</B> gets the <I>nth</I> extension field code associated with 
the specified record code <I>rcode</I>. The first field code is specified 
by <I>nth</I> equal to 0.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rcode</I></DT><DD>the record code</DD><DT><I>nth</I></DT><DD>the index of extension field code to return</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the <I>nth</I> extension field code if found, 0 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#ddIsField>ddIsField</A></DD></DL>
<HR>
<LEFT><A NAME=ddGetFieldCount><H1 CLASS="APISYMBOL">ddGetFieldCount</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddGetFieldCount</B> - gets the number of attribute codes in a record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>ddGetFieldCount</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>rcode</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddGetFieldCount</B> returns the number of attribute codes in a 
record identified by <I>rcode</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rcode</I></DT><DD>the record code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the attribute count if valid, 0 if not valid or no attribute codes.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=ddGetFieldNth><H1 CLASS="APISYMBOL">ddGetFieldNth</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddGetFieldNth</B> - gets the <I>nth</I> field code associated 
with a given record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcode <B>ddGetFieldNth</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>rcode</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>nth</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddGetFieldNth</B> gets the <I>nth</I> field code associated with 
the specified record code <I>rcode</I>. The first field code is specified 
by <I>nth</I> equal to 0.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rcode</I></DT><DD>the record code</DD><DT><I>nth</I></DT><DD>the index of field code to return</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the <I>nth</I> field code if found, 0 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#ddIsField>ddIsField</A></DD></DL>
<HR>
<LEFT><A NAME=ddGetKey><H1 CLASS="APISYMBOL">ddGetKey</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddGetKey</B> - gets the value defined for keyword <B>KEY</B> 
for a record or data code.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>ddGetKey</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddGetKey</B> returns the value defined for keyword <B>KEY</B> 
for the specified record or data code, <I>code</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>code</I></DT><DD>the record or data code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the keyword value if defined, 0 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=ddGetLabel><H1 CLASS="APISYMBOL">ddGetLabel</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddGetLabel</B> - gets the value defined for keyword <B>LABEL</B> 
for a record or data code.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>const char* <B>ddGetLabel</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddGetLabel</B> returns the value defined for keyword <B>LABEL</B> for the 
specified record or data code, <I>code</I>.</P></DD><DD><P>Note: Do not free or modify the returned string.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>code</I></DT><DD>the record or data code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the keyword value if defined, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=ddGetLength><H1 CLASS="APISYMBOL">ddGetLength</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddGetLength</B> - gets the field length in bytes, 
or a negative number in bits.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>ddGetLength</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddGetLength</B> returns the length of the record or data corresponding 
to the specified code <I>code</I>. If the value returned for a data code is 
negative, the length is represented in bits (rather than bytes).</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>code</I></DT><DD>the record or data code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the length of the field. If the value returned is positive, 
the length is returned in bytes. If the value returned is negative, 
the length is returned in bits.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=ddGetMaxVal><H1 CLASS="APISYMBOL">ddGetMaxVal</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddGetMaxVal</B> - gets the maximum value defined for a data code.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>float <B>ddGetMaxVal</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>dcode</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddGetMaxVal</B> returns the maximum legal value set for the 
data associated with <I>dcode</I>.  The value is always stored and 
returned as a single precision floating point number. 
A value of 0.0 is returned if no maximum value is defined.</P></DD><DD><P>Use <A HREF=#ddIsRangeSet>ddIsRangeSet</A> to check if there is a maximum value defined 
for <I>dcode</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>dcode</I></DT><DD>the data code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the maximum value (cast to float) if found, 0.0 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#ddGetMinVal>ddGetMinVal</A>, <A HREF=#ddIsRangeSet>ddIsRangeSet</A></DD></DL>
<HR>
<LEFT><A NAME=ddGetMinVal><H1 CLASS="APISYMBOL">ddGetMinVal</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddGetMinVal</B> - gets the minimum value defined for a data code.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>float <B>ddGetMinVal</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>dcode</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddGetMinVal</B> returns the minimum legal value set for the 
data associated with <I>dcode</I>.  The value is always stored and 
returned as a single precision floating point number. 
A value of 0.0 is returned if no minimum value is defined.</P></DD><DD><P>Use <A HREF=#ddIsRangeSet>ddIsRangeSet</A> to check if there is a minimum value defined 
for <I>dcode</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>dcode</I></DT><DD>the data code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the minimum value (cast to float) if found, 0.0 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#ddGetMaxVal>ddGetMaxVal</A>, <A HREF=#ddIsRangeSet>ddIsRangeSet</A></DD></DL>
<HR>
<LEFT><A NAME=ddGetMyCode><H1 CLASS="APISYMBOL">ddGetMyCode</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddGetMyCode</B> - gets the local code for a unique code.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcode <B>ddGetMyCode</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddGetMyCode</B> returns the local code corresponding to the 
specified unique code, <I>code</I>.</P></DD><DD><P>Each data extension site defines its own set of record and data codes 
each corresponding to a unique local code. Local codes are only unique 
within a site. The local codes for each site that registers a data 
extension collides with local codes from other sites.  At runtime, unique 
codes are generated by the API for all site's local codes when the data 
extension is registered.  This ensures that unique codes exist for all 
record and data codes registered across all data extensions registered 
in the runtime environment.</P></DD><DD><P>It is recommended that your plug-in refers to record and data codes 
by their unique codes rather than local codes.  This reduces the 
chance for error.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>code</I></DT><DD>the unique code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the local code if found, 0 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgIsCode>mgIsCode</A></DD></DL>
<HR>
<LEFT><A NAME=ddGetName><H1 CLASS="APISYMBOL">ddGetName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddGetName</B> - gets the name of a record or data code.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>const char* <B>ddGetName</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddGetName</B> returns the name defined for the 
specified record or data code, <I>code</I>.</P></DD><DD><P>Note: Do not free or modify the returned string.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>code</I></DT><DD>the record or data code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the name of the record or data if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=ddGetParentCount><H1 CLASS="APISYMBOL">ddGetParentCount</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddGetParentCount</B> - gets the number of legal parent codes 
of a record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>ddGetParentCount</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>rcode</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddGetParentCount</B> returns the number of parent codes of a record 
identified by <I>rcode</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rcode</I></DT><DD>the record code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the parent count if valid, 0 if not valid or no legal parent codes.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=ddGetParentNth><H1 CLASS="APISYMBOL">ddGetParentNth</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddGetParentNth</B> - get the <I>nth</I> legal parent code of a record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcode <B>ddGetParentNth</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>rcode</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>nth</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddGetParentNth</B> returns the <I>nth</I> legal parent code for a record 
identified by <I>rcode</I>.  The first parent code is specified by <I>nth</I> equal 
to 0.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rcode</I></DT><DD>the record code</DD><DT><I>nth</I></DT><DD>the index of parent code to return</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the <I>nth</I> parent code if found, 0 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=ddGetPrefix><H1 CLASS="APISYMBOL">ddGetPrefix</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddGetPrefix</B> - gets the ID prefix of a record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>const char* <B>ddGetPrefix</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>rcode</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddGetPrefix</B> returns the ID prefix associated with a record 
identified by <I>rcode</I>.  This is the prefix that was specified when the 
data extension was registered via <A HREF=#mgRegisterSite>mgRegisterSite</A>.</P></DD><DD><P>Note: Do not free or modify the returned string.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rcode</I></DT><DD>the record code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the prefix string if defined, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=ddGetSiteId><H1 CLASS="APISYMBOL">ddGetSiteId</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddGetSiteId</B> - gets the Site ID of a record or data code.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>const char* <B>ddGetSiteId</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddGetSiteId</B> returns the Site ID associated with a record or 
data code, <I>code</I>.  This is the Site ID that was specified when the 
data extension was registered via <A HREF=#mgRegisterSite>mgRegisterSite</A>.</P></DD><DD><P>Note: Do not free or modify the returned string.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>code</I></DT><DD>the data or record code to check</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the Site ID string if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=ddGetSiteNo><H1 CLASS="APISYMBOL">ddGetSiteNo</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddGetSiteNo</B> - gets the runtime site number of a record or 
data code.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>ddGetSiteNo</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddGetSiteNo</B> returns the runtime site number assigned to the 
data extension site that defined record or data code <I>code</I>.</P></DD><DD><P>Runtime site numbers are assigned by the API and are unique 
only within one invocation of the modeler or standalone application.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>code</I></DT><DD>the data or record code to check</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the runtime site number.  Site number 0 is reserved for 
OpenFlight.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=ddGetTagType><H1 CLASS="APISYMBOL">ddGetTagType</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddGetTagType</B> - gets the data type for a record 
or data code.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgtagtype <B>ddGetTagType</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddGetTagType</B> gets the data type for the specified record 
or data code, <I>code</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>code</I></DT><DD>the record or data code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the data type of the code.  See <A HREF=#mgtagtype>mgtagtype</A> for 
a description of the possible data types returned.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgtagtype>mgtagtype</A></DD></DL>
<HR>
<LEFT><A NAME=ddGetUCode><H1 CLASS="APISYMBOL">ddGetUCode</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddGetUCode</B> - composes a unique code from a local code 
and Site ID.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcode <B>ddGetUCode</B> (</TD><TD>const char*</TD><TD><I>siteId</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>localCode</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddGetUCode</B> returns a unique code from the specified local 
code <I>localCode</I> and Site ID <I>siteId</I>.</P></DD><DD><P>This function is the inverse of <A HREF=#ddGetMyCode>ddGetMyCode</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>siteId</I></DT><DD>the extension site&#146s ID string</DD><DT><I>localCode</I></DT><DD>the extension site&#146s own code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the unique code if valid, 0 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#ddGetMyCode>ddGetMyCode</A></DD></DL>
<HR>
<LEFT><A NAME=ddGetVersion><H1 CLASS="APISYMBOL">ddGetVersion</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddGetVersion</B> - gets the value defined for keyword <B>VERNO</B> 
for a record or data code.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char <B>ddGetVersion</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddGetVersion</B> returns the value defined for keyword <B>VERNO</B> 
for the specified record or data code, <I>code</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>code</I></DT><DD>the record or data code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the keyword value if defined, 0 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=ddIsDcode><H1 CLASS="APISYMBOL">ddIsDcode</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddIsDcode</B> - checks if a code is a data code.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>ddIsDcode</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddIsDcode</B> checks if the specified <I>code</I> corresponds to 
a data field.  A data field code is one defined in the data dictionary 
by <B>dataDef</B>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>code</I></DT><DD>the code to check</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the code is a data field code, otherwise 
<A HREF=#mgbool>MG_FALSE</A>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#ddIsRcode>ddIsRcode</A></DD></DL>
<HR>
<LEFT><A NAME=ddIsDefSet><H1 CLASS="APISYMBOL">ddIsDefSet</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddIsDefSet</B> - checks if a data code has a default 
value defined.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>ddIsDefSet</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>dcode</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddIsDefSet</B> checks if the data associated with <I>dcode</I> has 
a default value defined.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>dcode</I></DT><DD>the data code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if <I>dcode</I> has a default value set, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=ddIsDisplay><H1 CLASS="APISYMBOL">ddIsDisplay</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddIsDisplay</B> - checks if a record or data code is displayable 
in the modeler attribute page.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>ddIsDisplay</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddIsDisplay</B> checks if the record or data identified by <I>code</I> 
is displayable in the attribute page in the modeler.  The value 
for the keyword <B>NODISP</B> controls this attribute.</P></DD><DD><P>By default, record and data codes are displayable.  Use the 
keyword <B>NODISP</B> to override the value for this attribute. 
This keyword is 
not valid for data of type <A HREF=#mgtagtype>MTYPE_FLAG</A> if the <B>ENUM</B> 
attribute is set.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>code</I></DT><DD>the record or data code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if record or data is displayable, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=ddIsEdit><H1 CLASS="APISYMBOL">ddIsEdit</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddIsEdit</B> - checks if a record or data code is editable 
in the modeler attribute page.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>ddIsEdit</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddIsEdit</B> checks if the record or data identified by <I>code</I> 
is editable in the attribute page in the modeler.  The value 
for the keyword <B>NOEDIT</B> controls this attribute.</P></DD><DD><P>By default, record and data codes are editable.  Use the keyword 
<B>NOEDIT</B> to override the value for this attribute.  This keyword is 
not valid for data of type <A HREF=#mgtagtype>MTYPE_FLAG</A> if the <B>ENUM</B> 
attribute is set.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>code</I></DT><DD>the record or data code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if record or data is editable, otherwise 
<A HREF=#mgbool>MG_FALSE</A>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=ddIsEnumSet><H1 CLASS="APISYMBOL">ddIsEnumSet</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddIsEnumSet</B> - checks if the ENUM keyword is set for a 
specific data code.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>ddIsEnumSet</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>dcode</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddIsEnumSet</B> checks if the data associated with <I>dcode</I> is 
a special flag field of an ENUM group.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>dcode</I></DT><DD>the data code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if this is an ENUM flag field, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=ddIsField><H1 CLASS="APISYMBOL">ddIsField</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddIsField</B> - checks if a field code is a valid field 
of a record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>ddIsField</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>rcode</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>fcode</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddIsField</B> checks if the specified field code <I>fcode</I> is a valid 
element contained in the specified record code <I>rcode</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rcode</I></DT><DD>the record code to be searched</DD><DT><I>fcode</I></DT><DD>the field code to be matched</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if <I>fcode</I> is found in the record, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#ddGetFieldNth>ddGetFieldNth</A>, <A HREF=#ddIsFieldFollowInLine>ddIsFieldFollowInLine</A>, <A HREF=#ddIsFieldFollowPointer>ddIsFieldFollowPointer</A>, 
<A HREF=#ddIsFieldFollowAll>ddIsFieldFollowAll</A></DD></DL>
<HR>
<LEFT><A NAME=ddIsFieldFollowAll><H1 CLASS="APISYMBOL">ddIsFieldFollowAll</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddIsFieldFollowAll</B> - checks if a specific code is a 
legal field of a record; search includes the record itself and all 
subsequent records on its record chain.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>ddIsFieldFollowAll</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>rcode</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>fcode</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddIsFieldFollowAll</B> searches all fields of record <I>rcode</I> for 
a match with <I>fcode</I>. If <I>fcode</I> is not found in <I>rcode</I>, 
<B>ddIsFieldFollowAll</B> continues to search for <I>fcode</I>, following the 
attribute list of every in-line record of <I>rcode</I> until either a match 
is found, or until all subsequent in-line records are searched.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rcode</I></DT><DD>the record being searched</DD><DT><I>fcode</I></DT><DD>the field code to match</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if <I>fcode</I> is a legal field of <I>rcode</I>, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#ddIsField>ddIsField</A>, <A HREF=#ddIsFieldFollowInLine>ddIsFieldFollowInLine</A>, <A HREF=#ddIsFieldFollowPointer>ddIsFieldFollowPointer</A></DD></DL>
<HR>
<LEFT><A NAME=ddIsFieldFollowInLine><H1 CLASS="APISYMBOL">ddIsFieldFollowInLine</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddIsFieldFollowInLine</B> - checks if a specific code is a 
legal field of a record; search includes the record itself and all 
subsequent in-line records.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>ddIsFieldFollowInLine</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>rcode</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>fcode</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddIsFieldFollowInLine</B> searches all fields of record <I>rcode</I> 
for a match with <I>fcode</I>. If <I>fcode</I> is not found in <I>rcode</I>, 
<B>ddIsFieldFollowInLine</B> continues the search for <I>fcode</I>, following 
the attribute list of every in-line record of <I>rcode</I> until either a 
match is found, or until all subsequent in-line records are searched.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rcode</I></DT><DD>the record being searched</DD><DT><I>fcode</I></DT><DD>the field code to match</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if <I>fcode</I> is a legal field of <I>rcode</I>, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#ddIsField>ddIsField</A>, <A HREF=#ddIsFieldFollowPointer>ddIsFieldFollowPointer</A>, <A HREF=#ddIsFieldFollowAll>ddIsFieldFollowAll</A></DD></DL>
<HR>
<LEFT><A NAME=ddIsFieldFollowPointer><H1 CLASS="APISYMBOL">ddIsFieldFollowPointer</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddIsFieldFollowPointer</B> - checks if a specific code is a 
legal field of a record. The check includes the record itself and all 
its subsequent in-line records.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>ddIsFieldFollowPointer</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>rcode</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>fcode</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddIsFieldFollowPointer</B> searches all fields of record <I>rcode</I> 
for a match with <I>fcode</I>. If <I>fcode</I> is not found in <I>rcode</I>, 
<B>ddIsFieldFollowPointer</B> continues the search of <I>rcode</I>, following 
every pointer record&#146s attribute list for <I>fcode</I> until either a match 
was found or all subsequent pointer records are searched.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rcode</I></DT><DD>the record being searched</DD><DT><I>fcode</I></DT><DD>the field code to match</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if <I>fcode</I> is a legal field of <I>rcode</I>, 
following the pointer record during the search, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#ddIsField>ddIsField</A>, <A HREF=#ddIsFieldFollowInLine>ddIsFieldFollowInLine</A>, <A HREF=#ddIsFieldFollowAll>ddIsFieldFollowAll</A></DD></DL>
<HR>
<LEFT><A NAME=ddIsFlt><H1 CLASS="APISYMBOL">ddIsFlt</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddIsFlt</B> - checks if a code is an OpenFlight code.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>ddIsFlt</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddIsFlt</B> checks if the record or data code <I>code</I> 
is a non-extended OpenFlight code.</P></DD><DD><P>If the <I>code</I> is valid but is defined by a data extension 
other than OpenFlight, <B>ddIsFlt</B> returns <A HREF=#mgbool>MG_FALSE</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>code</I></DT><DD>the data or record code to check</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if <I>code</I> is an OpenFlight code, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=ddIsLegalXcode><H1 CLASS="APISYMBOL">ddIsLegalXcode</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddIsLegalXcode</B> - checks the tag-along parent and child 
relationship between two codes.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>ddIsLegalXcode</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>parentCode</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddIsLegalXcode</B> checks if <I>code</I> is a legal tag-along 
extension for parent code <I>parentCode</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>parentCode</I></DT><DD>the parent code</DD><DT><I>code</I></DT><DD>the extension code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if <I>code</I> is a legal tag-along extension 
code for parent code <I>parentCode</I>, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=ddIsRangeSet><H1 CLASS="APISYMBOL">ddIsRangeSet</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddIsRangeSet</B> - checks if a data code has a range defined.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>ddIsRangeSet</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>dcode</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddIsRangeSet</B> checks if the data associated with <I>dcode</I> 
has a minimum and/or maximum value defined.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>dcode</I></DT><DD>the data code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if a minimum and/or a maximum value was 
found, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=ddIsRcode><H1 CLASS="APISYMBOL">ddIsRcode</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddIsRcode</B> - checks if a code is a record code.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>ddIsRcode</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddIsRcode</B> checks if the specified <I>code</I> corresponds to 
a record.  A record code is one defined in the data dictionary 
by <B>recordDef</B>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>code</I></DT><DD>the code to check</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the code is a record code, otherwise 
<A HREF=#mgbool>MG_FALSE</A>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#ddIsDcode>ddIsDcode</A></DD></DL>
<HR>
<LEFT><A NAME=ddIsSearch><H1 CLASS="APISYMBOL">ddIsSearch</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddIsSearch</B> - checks if a record or data code is searchable 
in the modeler.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>ddIsSearch</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddIsSearch</B> checks if the record or data identified by <I>code</I> 
is searchable by the attribute search function in the modeler.  The value 
for the keyword <B>NOSEARCH</B> controls this attribute.</P></DD><DD><P>By default, record and data codes are searchable.  Use the keyword 
<B>NOSEARCH</B> to override the value for this attribute.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>code</I></DT><DD>the record or data code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if record or data is searchable, otherwise 
<A HREF=#mgbool>MG_FALSE</A>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=ddLabelToCode><H1 CLASS="APISYMBOL">ddLabelToCode</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddLabelToCode</B> - gets the code of a record or data field with 
a given label.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcode <B>ddLabelToCode</B> (</TD><TD>const char*</TD><TD><I>label</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddLabelToCode</B> gets the code associated with a record or data 
field with the specified label <I>label</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>label</I></DT><DD>the record or data field label</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the code of the record or field if found, 0 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#ddNameToCode>ddNameToCode</A></DD></DL>
<HR>
<LEFT><A NAME=ddNameToCode><H1 CLASS="APISYMBOL">ddNameToCode</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>ddNameToCode</B> - gets the code of a record or data field with 
a given name.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcode <B>ddNameToCode</B> (</TD><TD>const char*</TD><TD><I>name</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>ddNameToCode</B> gets the code associated with a record or data 
field with the specified <I>name</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>name</I></DT><DD>the record or data field name</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the code of the record or field if found, 0 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#ddLabelToCode>ddLabelToCode</A></DD></DL>
<HR>
<LEFT><A NAME=mgAddSwitchMask><H1 CLASS="APISYMBOL">mgAddSwitchMask</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgAddSwitchMask</B> - adds a new mask for a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSwitch>fltSwitch</A>
 node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgAddSwitchMask</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>A <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSwitch>fltSwitch</A>
 node contains at least one mask which is created 
automatically when the switch node is created. <B>mgAddSwitchMask</B> allocates 
a new mask, copies the bit settings of the current mask, and appends the new 
mask to the end of the mask table for the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSwitch>fltSwitch</A>
 node.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSwitch>fltSwitch</A>
 node</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the new mask index if successful, -1 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetSwitchMaskCount>mgGetSwitchMaskCount</A>, 
<A HREF=#mgGetSwitchMaskNo>mgGetSwitchMaskNo</A>, 
<A HREF=#mgGetSwitchBit>mgGetSwitchBit</A>, 
<A HREF=#mgGetSwitchMaskName>mgGetSwitchMaskName</A>, 
<A HREF=#mgDeleteSwitchMask>mgDeleteSwitchMask</A>, 
<A HREF=#mgInitSwitchMask>mgInitSwitchMask</A>, 
<A HREF=#mgSetSwitchBit>mgSetSwitchBit</A>, 
<A HREF=#mgSetSwitchMaskName>mgSetSwitchMaskName</A></DD></DL>
<HR>
<LEFT><A NAME=MGAPIFUNC><H1 CLASS="APISYMBOL">MGAPIFUNC</H1></A></LEFT>
<DL>
<DT><H3>MACRO NAME</H3></DT>
<DD><B>MGAPIFUNC</B> - exports a symbol from an OpenFlight API library module.<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD> <B>MGAPIFUNC</B> ( <TD><A HREF=#></A> <TD><I>type</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>type</I></DT><DD>the return type (for function symbols) or object type 
(for variables) exported by the OpenFlight API.</DD></DL></DD></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a macro used <B>ONLY</B> by the OpenFlight API to export symbols 
(functions or variables) from OpenFlight API library modules. All exported functions 
in the OpenFlight API are declared using this macro in corresponding include files.</P></DD><DD><P>Third party developers should <B>NOT</B> use this macro to declare 
symbols in their plug-in modules or stand-alone applications.  Instead, the 
macro <A HREF=#MGPIDECLARE>MGPIDECLARE</A> macro should be used to export symbols from 
third party developed plug-in modules.</P></DD></DT></DL>
<HR>
<LEFT><A NAME=mgAppend><H1 CLASS="APISYMBOL">mgAppend</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgAppend</B> - appends a node or transformation record onto the database hierarchy.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgAppend</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>parent</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>child</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a parent node record <I>parent</I>, <A HREF=#mgAttach>mgAttach</A> attaches <I>child</I> as the last child 
of <I>parent</I>.</P></DD><DD><P>If <I>child</I> is a node record, the resulting hierarchy has <I>child</I> as the last 
child of <I>parent</I>.  Note that <I>child</I> will retain its original children nodes.  If 
<I>parent</I> and <I>child</I> are both <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 node records, <I>child</I> is attached 
as a nested child of <I>parent</I>.  Otherwise <I>child</I> is attached as a normal child 
of <I>parent</I>.</P></DD><DD><P>If <I>child</I> is a transformation record, <I>child</I> will be the last transformation 
of <I>parent</I>.</P></DD><DD><P>Alternatively, you can use <B>mgAppend</B> to attach a child as the last child of a parent or 
<A HREF=#mgInsert>mgInsert</A> to insert a node after a sibling.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>parent</I></DT><DD>the parent node record</DD><DT><I>child</I></DT><DD>the node or transformation record 
to be linked into the hierarchy</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show the differences when using <A HREF=#mgAttach>mgAttach</A>, 
<B>mgAppend</B>, and <A HREF=#mgInsert>mgInsert</A> to attach new polygons to an object in the database.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">static void MakeNewPolys (mgrec* object)
{
   mgrec* poly1 = mgNewRec (fltPolygon);
   mgrec* poly2 = mgNewRec (fltPolygon);
   mgrec* poly3 = mgNewRec (fltPolygon);
   mgAttach (object, poly1);  // poly1 becomes first child of object
   mgAppend (object, poly2);  // poly2 becomes last child of object
   mgInsert (poly1, poly3);   // poly3 is inserted after poly1
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">def MakeNewPolys (object):
   poly1 = mgNewRec (fltPolygon)
   poly2 = mgNewRec (fltPolygon)
   poly3 = mgNewRec (fltPolygon)
   mgAttach (object, poly1)   # poly1 becomes first child of object
   mgAppend (object, poly2)   # poly2 becomes last child of object
   mgInsert (poly1, poly3)    # poly3 is inserted after poly1</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgAttach>mgAttach</A>, <A HREF=#mgInsert>mgInsert</A>, <A HREF=#mgReference>mgReference</A></DD></DL>
<HR>
<LEFT><A NAME=mgAppendRecList><H1 CLASS="APISYMBOL">mgAppendRecList</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgAppendRecList</B> - appends a node onto a record list.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgAppendRecList</B> (</TD><TD><A HREF=#mgreclist>mgreclist</A></TD><TD><I>recList</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>node</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgAppendRecList</B> appends <I>node</I> onto the end of the 
specified record list <I>recList</I>.</P></DD><DD><P>Nodes in a record list can have an optional matrix associated with 
them.  Set <I>matrix</I> to a valid matrix to do this, otherwise set <I>matrix</I> 
to <A HREF=#MG_NULL>MG_NULL</A>.</P></DD><DD><P>You can retrieve nodes from a record list using <A HREF=#mgGetNextRecInList>mgGetNextRecInList</A> 
or <A HREF=#mgGetNthRecInList>mgGetNthRecInList</A>.  You must call <A HREF=#mgResetRecList>mgResetRecList</A> after appending 
the last node to the list before retrieving nodes from it.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>recList</I></DT><DD>the record list to append to</DD><DT><I>node</I></DT><DD>the record to append onto list</DD><DT><I>matrix</I></DT><DD>the optional matrix to associate to this record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the item was appended successfully, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewRecList>mgNewRecList</A>, <A HREF=#mgGetRecListCount>mgGetRecListCount</A>, <A HREF=#mgIsRecInList>mgIsRecInList</A>, 
<A HREF=#mgResetRecList>mgResetRecList</A>, <A HREF=#mgGetNextRecInList>mgGetNextRecInList</A>, <A HREF=#mgGetNthRecInList>mgGetNthRecInList</A></DD></DL>
<HR>
<LEFT><A NAME=mgAttach><H1 CLASS="APISYMBOL">mgAttach</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgAttach</B> - attaches a node or transformation record into the database hierarchy.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgAttach</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>parent</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>child</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a parent node record <I>parent</I>, <B>mgAttach</B> attaches <I>child</I> as the first child 
of <I>parent</I>.</P></DD><DD><P>If <I>child</I> is a node record, the resulting hierarchy has <I>child</I> as the first 
child of <I>parent</I>.  Note that <I>child</I> will retain its original children nodes.  If 
<I>parent</I> and <I>child</I> are both <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 node records, <I>child</I> is attached 
as a nested child of <I>parent</I>.  Otherwise <I>child</I> is attached as a normal child 
of <I>parent</I>.</P></DD><DD><P>If <I>child</I> is a transformation record, <I>child</I> will be the first transformation 
of <I>parent</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>parent</I></DT><DD>the parent node record</DD><DT><I>child</I></DT><DD>the node or transformation record 
to be linked into the hierarchy</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function fails if <I>rec</I> is already attached in the hierarchy.
</DD></DL><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show the differences when using <B>mgAttach</B>, 
<A HREF=#mgAppend>mgAppend</A>, and <A HREF=#mgInsert>mgInsert</A> to attach new polygons to an object in the database.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">static void MakeNewPolys (mgrec* object)
{
   mgrec* poly1 = mgNewRec (fltPolygon);
   mgrec* poly2 = mgNewRec (fltPolygon);
   mgrec* poly3 = mgNewRec (fltPolygon);
   mgAttach (object, poly1);  // poly1 becomes first child of object
   mgAppend (object, poly2);  // poly2 becomes last child of object
   mgInsert (poly1, poly3);   // poly3 is inserted after poly1
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">def MakeNewPolys (object):
   poly1 = mgNewRec (fltPolygon)
   poly2 = mgNewRec (fltPolygon)
   poly3 = mgNewRec (fltPolygon)
   mgAttach (object, poly1)   # poly1 becomes first child of object
   mgAppend (object, poly2)   # poly2 becomes last child of object
   mgInsert (poly1, poly3)    # poly3 is inserted after poly1</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgAppend>mgAppend</A>, <A HREF=#mgInsert>mgInsert</A>, <A HREF=#mgReference>mgReference</A></DD></DL>
<HR>
<LEFT><A NAME=mgBoxContainsBox><H1 CLASS="APISYMBOL">mgBoxContainsBox</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgBoxContainsBox</B> - determines if a box is contained in 
another box.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgBoxContainsBox</B> (</TD><TD>const <A HREF=#mgboxd>mgboxd*</A></TD><TD><I>box1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgboxd>mgboxd*</A></TD><TD><I>box2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgBoxContainsBox</B> determines if one box, <I>box2</I>, is completely inside 
another box, <I>box2</I>.  If <I>box2</I> lies inside <I>box1</I>, the function 
returns <A HREF=#mgbool>MG_TRUE</A>.  If any part of <I>box2</I> lies outside <I>box1</I>, 
the function returns <A HREF=#mgbool>MG_FALSE</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>box1</I></DT><DD>address of box to check</DD><DT><I>box2</I></DT><DD>address of box to check if inside <I>box1</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if <I>box2</I> lies within <I>box1</I>, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMakeBox>mgMakeBox</A>, <A HREF=#mgBoxExpandCoord3d>mgBoxExpandCoord3d</A>, <A HREF=#mgBoxExpandBox>mgBoxExpandBox</A>, 
<A HREF=#mgBoxContainsCoord3d>mgBoxContainsCoord3d</A>, <A HREF=#mgBoxIntersectsBox>mgBoxIntersectsBox</A>, 
<A HREF=#mgBoxGetXSize>mgBoxGetXSize</A>, <A HREF=#mgBoxGetYSize>mgBoxGetYSize</A>, <A HREF=#mgBoxGetZSize>mgBoxGetZSize</A>, <A HREF=#mgBoxGetDiagonalSize>mgBoxGetDiagonalSize</A>, 
<A HREF=#mgBoxGetCenter>mgBoxGetCenter</A>, <A HREF=#mgBoxGetCenterBottom>mgBoxGetCenterBottom</A></DD></DL>
<HR>
<LEFT><A NAME=mgBoxContainsCoord3d><H1 CLASS="APISYMBOL">mgBoxContainsCoord3d</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgBoxContainsCoord3d</B> - determines if a point is contained in a box.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgBoxContainsCoord3d</B> (</TD><TD>const <A HREF=#mgboxd>mgboxd*</A></TD><TD><I>box</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgBoxContainsCoord3d</B> determines if a coordinate <I>coord</I> is inside or 
outside a <I>box</I>.  If the coordinate lies on or inside the box, the function 
returns <A HREF=#mgbool>MG_TRUE</A>.  If the coordinate lies outside the box, 
the function returns <A HREF=#mgbool>MG_FALSE</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>box</I></DT><DD>address of box to check</DD><DT><I>coord</I></DT><DD>address of coordinate to check</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the coordinate <I>coord</I> lies on or inside 
the box, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMakeBox>mgMakeBox</A>, <A HREF=#mgBoxContainsBox>mgBoxContainsBox</A>, <A HREF=#mgBoxIntersectsBox>mgBoxIntersectsBox</A>, 
<A HREF=#mgBoxExpandCoord3d>mgBoxExpandCoord3d</A>, <A HREF=#mgBoxExpandBox>mgBoxExpandBox</A>, 
<A HREF=#mgBoxGetXSize>mgBoxGetXSize</A>, <A HREF=#mgBoxGetYSize>mgBoxGetYSize</A>, <A HREF=#mgBoxGetZSize>mgBoxGetZSize</A>, <A HREF=#mgBoxGetDiagonalSize>mgBoxGetDiagonalSize</A>, 
<A HREF=#mgBoxGetCenter>mgBoxGetCenter</A>, <A HREF=#mgBoxGetCenterBottom>mgBoxGetCenterBottom</A></DD></DL>
<HR>
<LEFT><A NAME=mgBoxExpandBox><H1 CLASS="APISYMBOL">mgBoxExpandBox</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgBoxExpandBox</B> - expands a box by another box.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgBoxExpandBox</B> (</TD><TD><A HREF=#mgboxd>mgboxd*</A></TD><TD><I>boxToExpand</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgboxd>mgboxd*</A></TD><TD><I>expandByBox</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgBoxExpandBox</B> updates a <I>boxToExpand</I> by another box 
<I>expandByBox</I>.  If any part of <I>expandByBox</I> lies outside of 
<I>boxToExpand</I>, <I>boxToExpand</I> is expanded to contain <I>expandByBox</I> 
and the function returns <A HREF=#mgbool>MG_TRUE</A>.  If <I>expandByBox</I> lies 
completely within <I>boxToExpand</I>, <I>boxToExpand</I> is not expanded and 
the function returns <A HREF=#mgbool>MG_FALSE</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>boxToExpand</I></DT><DD>address of box to expand</DD><DT><I>expandByBox</I></DT><DD>address of box to expand by</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if <I>expandByBox</I> caused <I>boxToExpand</I> 
to expand (all or part of <I>expandByBox</I> was not contained inside <I>boxToExpand</I>), 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMakeBox>mgMakeBox</A>, <A HREF=#mgBoxExpandCoord3d>mgBoxExpandCoord3d</A>, 
<A HREF=#mgBoxContainsCoord3d>mgBoxContainsCoord3d</A>, <A HREF=#mgBoxContainsBox>mgBoxContainsBox</A>, <A HREF=#mgBoxIntersectsBox>mgBoxIntersectsBox</A>, 
<A HREF=#mgBoxGetXSize>mgBoxGetXSize</A>, <A HREF=#mgBoxGetYSize>mgBoxGetYSize</A>, <A HREF=#mgBoxGetZSize>mgBoxGetZSize</A>, <A HREF=#mgBoxGetDiagonalSize>mgBoxGetDiagonalSize</A>, 
<A HREF=#mgBoxGetCenter>mgBoxGetCenter</A>, <A HREF=#mgBoxGetCenterBottom>mgBoxGetCenterBottom</A></DD></DL>
<HR>
<LEFT><A NAME=mgBoxExpandCoord3d><H1 CLASS="APISYMBOL">mgBoxExpandCoord3d</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgBoxExpandCoord3d</B> - expands a box by a specific coordinate.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgBoxExpandCoord3d</B> (</TD><TD><A HREF=#mgboxd>mgboxd*</A></TD><TD><I>box</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>c</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgBoxExpandCoord3d</B> updates a <I>box</I> by a given coordinate <I>c</I>. 
If the coordinate lies outside the box, the box is expanded to contain 
the coordinate and the function returns <A HREF=#mgbool>MG_TRUE</A>. 
If the coordinate lies inside the box, the box is not expanded and the 
function returns <A HREF=#mgbool>MG_FALSE</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>box</I></DT><DD>address of box to expand</DD><DT><I>c</I></DT><DD>address of coordinate to expand box by</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the coordinate <I>c</I> caused the 
box to expand (the coordinate was not contained inside the original box), 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMakeBox>mgMakeBox</A>, <A HREF=#mgBoxExpandBox>mgBoxExpandBox</A>, 
<A HREF=#mgBoxContainsCoord3d>mgBoxContainsCoord3d</A>, <A HREF=#mgBoxContainsBox>mgBoxContainsBox</A>, <A HREF=#mgBoxIntersectsBox>mgBoxIntersectsBox</A>, 
<A HREF=#mgBoxGetXSize>mgBoxGetXSize</A>, <A HREF=#mgBoxGetYSize>mgBoxGetYSize</A>, <A HREF=#mgBoxGetZSize>mgBoxGetZSize</A>, <A HREF=#mgBoxGetDiagonalSize>mgBoxGetDiagonalSize</A>, 
<A HREF=#mgBoxGetCenter>mgBoxGetCenter</A>, <A HREF=#mgBoxGetCenterBottom>mgBoxGetCenterBottom</A></DD></DL>
<HR>
<LEFT><A NAME=mgBoxGetCenter><H1 CLASS="APISYMBOL">mgBoxGetCenter</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgBoxGetCenter</B> - returns the center of a box.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgBoxGetCenter</B> (</TD><TD>const <A HREF=#mgboxd>mgboxd*</A></TD><TD><I>box</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgBoxGetCenter</B> calculates and returns the coordinates of the 
center of a <I>box</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>box</I></DT><DD>address of box to get center for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the coordinates of the center of <I>box</I>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMakeBox>mgMakeBox</A>, <A HREF=#mgBoxExpandCoord3d>mgBoxExpandCoord3d</A>, <A HREF=#mgBoxExpandBox>mgBoxExpandBox</A>, 
<A HREF=#mgBoxContainsCoord3d>mgBoxContainsCoord3d</A>, <A HREF=#mgBoxContainsBox>mgBoxContainsBox</A>, 
<A HREF=#mgBoxGetXSize>mgBoxGetXSize</A>, <A HREF=#mgBoxGetYSize>mgBoxGetYSize</A>, <A HREF=#mgBoxGetZSize>mgBoxGetZSize</A>, 
<A HREF=#mgBoxGetDiagonalSize>mgBoxGetDiagonalSize</A>, <A HREF=#mgBoxGetCenterBottom>mgBoxGetCenterBottom</A></DD></DL>
<HR>
<LEFT><A NAME=mgBoxGetCenterBottom><H1 CLASS="APISYMBOL">mgBoxGetCenterBottom</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgBoxGetCenterBottom</B> - returns the center bottom of a box.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgBoxGetCenterBottom</B> (</TD><TD>const <A HREF=#mgboxd>mgboxd*</A></TD><TD><I>box</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgBoxGetCenterBottom</B> calculates and returns the coordinates of the 
center bottom of a <I>box</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>box</I></DT><DD>address of box to get center bottom for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the coordinates of the center bottom of <I>box</I>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMakeBox>mgMakeBox</A>, <A HREF=#mgBoxExpandCoord3d>mgBoxExpandCoord3d</A>, <A HREF=#mgBoxExpandBox>mgBoxExpandBox</A>, 
<A HREF=#mgBoxContainsCoord3d>mgBoxContainsCoord3d</A>, <A HREF=#mgBoxContainsBox>mgBoxContainsBox</A>, 
<A HREF=#mgBoxGetXSize>mgBoxGetXSize</A>, <A HREF=#mgBoxGetYSize>mgBoxGetYSize</A>, <A HREF=#mgBoxGetZSize>mgBoxGetZSize</A>, 
<A HREF=#mgBoxGetDiagonalSize>mgBoxGetDiagonalSize</A>, <A HREF=#mgBoxGetCenter>mgBoxGetCenter</A></DD></DL>
<HR>
<LEFT><A NAME=mgBoxGetDiagonalSize><H1 CLASS="APISYMBOL">mgBoxGetDiagonalSize</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgBoxGetDiagonalSize</B> - returns the diagonal dimension of a box.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>double <B>mgBoxGetDiagonalSize</B> (</TD><TD>const <A HREF=#mgboxd>mgboxd*</A></TD><TD><I>box</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgBoxGetDiagonalSize</B> calculates and returns the diagonal dimension 
of a <I>box</I>.  This is the distance from the lower left front to the upper 
right back points of the box.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>box</I></DT><DD>address of box to get dimension for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the diagonal dimension of <I>box</I>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMakeBox>mgMakeBox</A>, <A HREF=#mgBoxExpandCoord3d>mgBoxExpandCoord3d</A>, <A HREF=#mgBoxExpandBox>mgBoxExpandBox</A>, 
<A HREF=#mgBoxContainsCoord3d>mgBoxContainsCoord3d</A>, <A HREF=#mgBoxContainsBox>mgBoxContainsBox</A>, 
<A HREF=#mgBoxGetXSize>mgBoxGetXSize</A>, <A HREF=#mgBoxGetYSize>mgBoxGetYSize</A>, <A HREF=#mgBoxGetZSize>mgBoxGetZSize</A>, 
<A HREF=#mgBoxGetCenter>mgBoxGetCenter</A>, <A HREF=#mgBoxGetCenterBottom>mgBoxGetCenterBottom</A></DD></DL>
<HR>
<LEFT><A NAME=mgBoxGetXSize><H1 CLASS="APISYMBOL">mgBoxGetXSize</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgBoxGetXSize</B> - returns the X dimension of a box.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>double <B>mgBoxGetXSize</B> (</TD><TD>const <A HREF=#mgboxd>mgboxd*</A></TD><TD><I>box</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgBoxGetXSize</B> calculates and returns the X dimension of a <I>box</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>box</I></DT><DD>address of box to get dimension for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the X dimension of <I>box</I>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMakeBox>mgMakeBox</A>, <A HREF=#mgBoxExpandCoord3d>mgBoxExpandCoord3d</A>, <A HREF=#mgBoxExpandBox>mgBoxExpandBox</A>, 
<A HREF=#mgBoxContainsCoord3d>mgBoxContainsCoord3d</A>, <A HREF=#mgBoxContainsBox>mgBoxContainsBox</A>, 
<A HREF=#mgBoxGetYSize>mgBoxGetYSize</A>, <A HREF=#mgBoxGetZSize>mgBoxGetZSize</A>, <A HREF=#mgBoxGetDiagonalSize>mgBoxGetDiagonalSize</A>, 
<A HREF=#mgBoxGetCenter>mgBoxGetCenter</A>, <A HREF=#mgBoxGetCenterBottom>mgBoxGetCenterBottom</A></DD></DL>
<HR>
<LEFT><A NAME=mgBoxGetYSize><H1 CLASS="APISYMBOL">mgBoxGetYSize</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgBoxGetYSize</B> - returns the Y dimension of a box.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>double <B>mgBoxGetYSize</B> (</TD><TD>const <A HREF=#mgboxd>mgboxd*</A></TD><TD><I>box</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgBoxGetYSize</B> calculates and returns the Y dimension of a <I>box</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>box</I></DT><DD>address of box to get dimension for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the Y dimension of <I>box</I>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMakeBox>mgMakeBox</A>, <A HREF=#mgBoxExpandCoord3d>mgBoxExpandCoord3d</A>, <A HREF=#mgBoxExpandBox>mgBoxExpandBox</A>, 
<A HREF=#mgBoxContainsCoord3d>mgBoxContainsCoord3d</A>, <A HREF=#mgBoxContainsBox>mgBoxContainsBox</A>, 
<A HREF=#mgBoxGetXSize>mgBoxGetXSize</A>, <A HREF=#mgBoxGetZSize>mgBoxGetZSize</A>, <A HREF=#mgBoxGetDiagonalSize>mgBoxGetDiagonalSize</A>, 
<A HREF=#mgBoxGetCenter>mgBoxGetCenter</A>, <A HREF=#mgBoxGetCenterBottom>mgBoxGetCenterBottom</A></DD></DL>
<HR>
<LEFT><A NAME=mgBoxGetZSize><H1 CLASS="APISYMBOL">mgBoxGetZSize</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgBoxGetZSize</B> - returns the Z dimension of a box.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>double <B>mgBoxGetZSize</B> (</TD><TD>const <A HREF=#mgboxd>mgboxd*</A></TD><TD><I>box</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgBoxGetZSize</B> calculates and returns the Z dimension of a <I>box</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>box</I></DT><DD>address of box to get dimension for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the Z dimension of <I>box</I>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMakeBox>mgMakeBox</A>, <A HREF=#mgBoxExpandCoord3d>mgBoxExpandCoord3d</A>, <A HREF=#mgBoxExpandBox>mgBoxExpandBox</A>, 
<A HREF=#mgBoxContainsCoord3d>mgBoxContainsCoord3d</A>, <A HREF=#mgBoxContainsBox>mgBoxContainsBox</A>, 
<A HREF=#mgBoxGetXSize>mgBoxGetXSize</A>, <A HREF=#mgBoxGetYSize>mgBoxGetYSize</A>, <A HREF=#mgBoxGetDiagonalSize>mgBoxGetDiagonalSize</A>, 
<A HREF=#mgBoxGetCenter>mgBoxGetCenter</A>, <A HREF=#mgBoxGetCenterBottom>mgBoxGetCenterBottom</A></DD></DL>
<HR>
<LEFT><A NAME=mgBoxIntersectsBox><H1 CLASS="APISYMBOL">mgBoxIntersectsBox</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgBoxIntersectsBox</B> - determines if two boxes intersect.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgBoxIntersectsBox</B> (</TD><TD>const <A HREF=#mgboxd>mgboxd*</A></TD><TD><I>box1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgboxd>mgboxd*</A></TD><TD><I>box2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgBoxIntersectsBox</B> determines if two boxes, <I>box1</I> and <I>box2</I> 
intersect.  If they do, the function returns <A HREF=#mgbool>MG_TRUE</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>box1</I></DT><DD>address of first box to check</DD><DT><I>box2</I></DT><DD>address of second box to check</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if <I>box1</I> and <I>box2</I> intersect, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMakeBox>mgMakeBox</A>, <A HREF=#mgBoxExpandCoord3d>mgBoxExpandCoord3d</A>, <A HREF=#mgBoxExpandBox>mgBoxExpandBox</A>, 
<A HREF=#mgBoxContainsCoord3d>mgBoxContainsCoord3d</A>, <A HREF=#mgBoxContainsBox>mgBoxContainsBox</A>, 
<A HREF=#mgBoxGetXSize>mgBoxGetXSize</A>, <A HREF=#mgBoxGetYSize>mgBoxGetYSize</A>, <A HREF=#mgBoxGetZSize>mgBoxGetZSize</A>, <A HREF=#mgBoxGetDiagonalSize>mgBoxGetDiagonalSize</A>, 
<A HREF=#mgBoxGetCenter>mgBoxGetCenter</A>, <A HREF=#mgBoxGetCenterBottom>mgBoxGetCenterBottom</A></DD></DL>
<HR>
<LEFT><A NAME=mgCheckinLicense><H1 CLASS="APISYMBOL">mgCheckinLicense</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCheckinLicense</B> - checks in a license.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgCheckinLicense</B> (</TD><TD><A HREF=#mglicense>mglicense</A></TD><TD><I>license</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCheckinLicense</B> checks in a license created by <A HREF=#mgNewLicense>mgNewLicense</A> 
and previously checked out by <A HREF=#mgCheckoutLicense>mgCheckoutLicense</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>license</I></DT><DD>the license to check in</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success. 
If unsuccessful, value returned will be one of:<BR> 
1 - <I>license</I> is not a valid license or function was called from 
stand-alone program environment.<BR> 
2 - <I>license</I> is not checked out.<BR> 
3 - caller is not authorized to check in <I>license</I>.<BR> 
4 - unknown error in the Creator License Manager.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgCheckoutLicense>mgCheckoutLicense</A>, <A HREF=#mgNewLicense>mgNewLicense</A>, <A HREF=#mgFreeLicense>mgFreeLicense</A></DD></DL>
<HR>
<LEFT><A NAME=mgCheckoutLicense><H1 CLASS="APISYMBOL">mgCheckoutLicense</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCheckoutLicense</B> - attempts to check out a license.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgCheckoutLicense</B> (</TD><TD><A HREF=#mglicense>mglicense</A></TD><TD><I>license</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCheckoutLicense</B> attempts to check out a <I>license</I> created 
by <A HREF=#mgNewLicense>mgNewLicense</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>license</I></DT><DD>the license to check out</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success. 
If unsuccessful, value returned will be one of:<BR> 
1 - <I>license</I> is not a valid license or function was called from 
stand-alone program environment.<BR> 
2 - <I>license</I> could not be checked out. When this is the case, additional 
information will be displayed in the Creator Status Log Window.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgCheckinLicense>mgCheckinLicense</A>, <A HREF=#mgNewLicense>mgNewLicense</A>, <A HREF=#mgFreeLicense>mgFreeLicense</A></DD></DL>
<HR>
<LEFT><A NAME=mgClearCaption><H1 CLASS="APISYMBOL">mgClearCaption</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgClearCaption</B> - clears caption string for a control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgClearCaption</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgClearCaption</B> clears the caption of the specified <I>control</I>. 
This is the equivalent of calling <A HREF=#mgSetCaption>mgSetCaption</A> with an empty string.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the control whose caption will be cleared</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCaption>mgSetCaption</A>, <A HREF=#mgGetCaption>mgGetCaption</A>, <A HREF=#mgSetTitle>mgSetTitle</A>, <A HREF=#mgGetTitle>mgGetTitle</A></DD></DL>
<HR>
<LEFT><A NAME=mgClearFocusVertex><H1 CLASS="APISYMBOL">mgClearFocusVertex</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgClearFocusVertex</B> - clear the current focus vertex.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgClearFocusVertex</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgClearFocusVertex</B> clears the focus vertex for the specified 
editor context, <I>editorContext</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context used to identify 
the database in which the focus vertex 
is to be set</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgEditorSetFocusVertexFunc>mgEditorSetFocusVertexFunc</A>, <A HREF=#mgSetFocusVertex>mgSetFocusVertex</A>, 
<A HREF=#mgGetFocusVertex>mgGetFocusVertex</A></DD></DL>
<HR>
<LEFT><A NAME=mgCloseDb><H1 CLASS="APISYMBOL">mgCloseDb</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCloseDb</B> - closes an OpenFlight database.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgCloseDb</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCloseDb</B> closes the database with the given top node 
of <I>db</I>. This function is the recommended way to close a database as it 
properly deallocates all dynamic memory allocated on behalf of the database.</P></DD><DD><P>Note: If you call this function in Creator, it will fail if <I>db</I> 
is open on the Creator desktop.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgOpenDb>mgOpenDb</A>, <A HREF=#mgWriteDb>mgWriteDb</A></DD></DL>
<HR>
<LEFT><A NAME=mgContainsReadOnly><H1 CLASS="APISYMBOL">mgContainsReadOnly</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgContainsReadOnly</B> - determines if a node or any 
descendants of a node are <B>Read-Only</B>.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgContainsReadOnly</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgContainsReadOnly</B> determines if the node <I>rec</I> or any 
of its descendants are <B>Read-Only</B>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the root node to check</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the node or any of its 
descendants are <B>Read-Only</B>, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=mgControlIdsMatch><H1 CLASS="APISYMBOL">mgControlIdsMatch</H1></A></LEFT>
<DL>
<DT><H3>MACRO NAME</H3></DT>
<DD><B>mgControlIdsMatch</B> - Checks if two control identifiers match.<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgControlIdsMatch</B> (</TD><TD><A HREF=#></A></TD><TD><I>id1</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>id2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns 1 if identifiers match, 0 otherwise.
</DD></DL><DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>id1</I></DT><DD>A control identifier</DD><DT><I>id2</I></DT><DD>Another control identifier</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgStringIdsMatch>mgStringIdsMatch</A>, <A HREF=#mgPixmapIdsMatch>mgPixmapIdsMatch</A>, 
<A HREF=#mgCursorIdsMatch>mgCursorIdsMatch</A></DD></DL>
<HR>
<LEFT><A NAME=mgControlSetAttribute><H1 CLASS="APISYMBOL">mgControlSetAttribute</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgControlSetAttribute</B> - sets the attribute values of a control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgControlSetAttribute</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcontrolattribute>mgcontrolattribute</A></TD><TD><I>controlAttr</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>attrValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgControlSetAttribute</B> sets the specified control attribute <I>controlAttr</I> 
for the <I>control</I> to the specified value <I>attrValue</I>.</P></DD><DD><P>Control attributes define how controls behave in different 
situations.  The control attributes and a brief description of each 
are listed below.  These are the possible values for <I>attribute</I>. 
For more information on the meaning of each attribute, see the description 
of that particular attribute.</P></DD><DD><P>For a complete list of control attributes, see <A HREF=#mgcontrolattribute>mgcontrolattribute</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the control whose attribute is to be set</DD><DT><I>controlAttr</I></DT><DD>the control attribute to set</DD><DT><I>attrValue</I></DT><DD>the value to which the attribute is set</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following examples show how you might use different control attributes:</DT><DT><PRE CLASS="EXAMPLE">// This causes a raised frame to be automatically drawn
// around a GL control within a plug-in dialog.
mggui control;
mgControlSetAttribute (control, MCA_GLBORDERSTYLE, MGLBS_RAISED);

// This causes a text control to display with a bold font
mggui control;
mgControlSetAttribute (control, MCA_BOLDFONT, 1);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetGuiCallback>mgSetGuiCallback</A>, <A HREF=#mgcontrolattribute>mgcontrolattribute</A>, <A HREF=#mgDialogSetAttribute>mgDialogSetAttribute</A></DD></DL>
<HR>
<LEFT><A NAME=mgControlSubclass><H1 CLASS="APISYMBOL">mgControlSubclass</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgControlSubclass</B> - sets the Windows window function for a control<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgControlSubclass</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>gui</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgguiwindowfunc>mgguiwindowfunc</A></TD><TD><I>windowProc</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgControlSubclass</B> allows you to "subclass" the Windows window associated 
with a control in your plug-in dialog.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>gui</I></DT><DD>the control whose window procedure is to be set</DD><DT><I>windowProc</I></DT><DD>the window procedure</DD><DT><I>userData</I></DT><DD>user data to be passed to window procedurewhen it is called</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows how you might subclass a text control Window. 
It includes some common Windows messages that might be sent to the Windows 
window of a text control.</DT><DT><PRE CLASS="EXAMPLE">static int MyWindowFunc (mggui gui, mgcontrolid controlId,
&#32&#32     mgguihandle hWnd, int msg, int wParam, mgsize_t lParam,
&#32&#32     void* windowProc, void* userData)
{
   mydata* myData = (mydata*) userData;
   mgbool handled = MG_FALSE;

   switch (msg) {
   // handle any Windows message intended for edit controls here
   case WM_LBUTTONDBLCLK:
      // handle left moust double click here
      handled = MG_TRUE;
      break;
   case WM_CUT:
      // handle WM_CUT here, etc
      handled = MG_TRUE;
      break;
   case WM_PASTE:
      break;
   default:
      break;
   }
   if (handled == MG_FALSE)
      // our function did not handle the message, call Creator's Window function
      return CallWindowProc ((WNDPROC) windowProc, (HWND) hWnd, msg, wParam, lParam);
   return 0;
}

static void InitControls (mggui dialog, mydata* myData)
{
   mggui textControl = mgFindGuiById ( dialog, IDC_MYTEXT);
   mgControlSubclass (textControl, MyWindowFunc, myData);
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetGuiHandle>mgGetGuiHandle</A>, <A HREF=#mgDialogSubclass>mgDialogSubclass</A></DD></DL>
<HR>
<LEFT><A NAME=mgConvexHullBuilderClose><H1 CLASS="APISYMBOL">mgConvexHullBuilderClose</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgConvexHullBuilderClose</B> - closes a convex hull 
builder and returns the convex hull built.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgconvexhull <B>mgConvexHullBuilderClose</B> (</TD><TD><A HREF=#mgconvexhullbuilder>mgconvexhullbuilder</A></TD><TD><I>hullBuilder</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Use <B>mgConvexHullBuilderClose</B> when you are done adding points 
to the convex hull buider <I>hullBuilder</I>.  <B>mgConvexHullBuilderClose</B> 
closes the convex hull builder and builds and returns the convex hull 
around the set of points you added with <A HREF=#mgConvexHullBuilderExpandCoord3d>mgConvexHullBuilderExpandCoord3d</A>.</P></DD><DD><P>Use the function <A HREF=#mgFreeConvexHull>mgFreeConvexHull</A> to dispose of the convex hull 
object returned when you are through using it.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>hullBuilder</I></DT><DD>the convex hull builder</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the convex hull object if successful, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>See <A HREF=#mgNewConvexHullBuilder>mgNewConvexHullBuilder</A> for an example of how to use a 
convex hull builder.</DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewConvexHullBuilder>mgNewConvexHullBuilder</A>, <A HREF=#mgConvexHullBuilderExpandCoord3d>mgConvexHullBuilderExpandCoord3d</A>, 
<A HREF=#mgFreeConvexHullBuilder>mgFreeConvexHullBuilder</A></DD></DL>
<HR>
<LEFT><A NAME=mgConvexHullBuilderExpandCoord3d><H1 CLASS="APISYMBOL">mgConvexHullBuilderExpandCoord3d</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgConvexHullBuilderExpandCoord3d</B> - adds a 3D point to a 
convex hull builder.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgConvexHullBuilderExpandCoord3d</B> (</TD><TD><A HREF=#mgconvexhullbuilder>mgconvexhullbuilder</A></TD><TD><I>hullBuilder</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>c</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgConvexHullBuilderExpandCoord3d</B> adds a 3D point to the set of 
points used by a convex hull builder object <I>hullBuilder</I> to build a convex 
hull.  The convex hull created will be built around this set of points.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>hullBuilder</I></DT><DD>the convex hull builder</DD><DT><I>c</I></DT><DD>address of coordinate to add</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the point is added sucessfully, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>See <A HREF=#mgNewConvexHullBuilder>mgNewConvexHullBuilder</A> for an example of how to use a 
convex hull builder.</DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewConvexHullBuilder>mgNewConvexHullBuilder</A>, <A HREF=#mgConvexHullBuilderClose>mgConvexHullBuilderClose</A>, 
<A HREF=#mgFreeConvexHullBuilder>mgFreeConvexHullBuilder</A></DD></DL>
<HR>
<LEFT><A NAME=mgConvexHullGetTriangleCount><H1 CLASS="APISYMBOL">mgConvexHullGetTriangleCount</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgConvexHullGetTriangleCount</B> - gets the number of triangles 
comprising a convex hull.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgConvexHullGetTriangleCount</B> (</TD><TD><A HREF=#mgconvexhull>mgconvexhull</A></TD><TD><I>hull</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgConvexHullGetTriangleCount</B> returns the number of triangles 
that are contained in the specified convex <I>hull</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>hull</I></DT><DD>the convex hull</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of triangles in the convex hull.
</DD></DL><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>See <A HREF=#mgGetConvexHull>mgGetConvexHull</A> for an example of how to build and examine 
a convex hull.</DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetConvexHull>mgGetConvexHull</A>, <A HREF=#mgConvexHullGetTriangleNth>mgConvexHullGetTriangleNth</A></DD></DL>
<HR>
<LEFT><A NAME=mgConvexHullGetTriangleNth><H1 CLASS="APISYMBOL">mgConvexHullGetTriangleNth</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgConvexHullGetTriangleNth</B> - gets the nth triangle of 
a convex hull.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgConvexHullGetTriangleNth</B> (</TD><TD><A HREF=#mgconvexhull>mgconvexhull</A></TD><TD><I>hull</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>nth</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgconvexhulltriangle>mgconvexhulltriangle*</A></TD><TD><I>triangle</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, triangle <B>mgConvexHullGetTriangleNth</B> (</TD><TD><A HREF=#mgconvexhull>mgconvexhull</A></TD><TD><I>hull</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgConvexHullGetTriangleNth</B> returns the <I>nth</I> triangle of the 
specified convex <I>hull</I>.  The first triangle is specified by <I>nth</I> 
equal to 1.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>hull</I></DT><DD>the convex hull</DD><DT><I>nth</I></DT><DD>which triangle to get</DD><DT><I>triangle</I></DT><DD>the triangle retrieved</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the triangle was retrieved successfully, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>triangle</DT><DD>If function is successful, this contains the retrieved triangle, 
otherwise this is undefined.</DD></DL></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>See <A HREF=#mgGetConvexHull>mgGetConvexHull</A> for an example of how to build and examine 
a convex hull.</DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetConvexHull>mgGetConvexHull</A>, <A HREF=#mgConvexHullGetTriangleCount>mgConvexHullGetTriangleCount</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord2dAdd><H1 CLASS="APISYMBOL">mgCoord2dAdd</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord2dAdd</B> - calculates the sum of two 2D coordinates.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord2d <B>mgCoord2dAdd</B> (</TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord2dAdd</B> calculates and returns the sum of two 2D double 
precision floating point coordinates, <I>coord1</I> + <I>coord2</I>.</P></DD><DD><P>The original coordinates <I>coord1</I> and <I>coord2</I> are not affected.</P></DD><DD><P>Note: For efficiency, <I>coord1</I> and <I>coord2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord1</I></DT><DD>address of first coordinate to add</DD><DT><I>coord2</I></DT><DD>address of second coordinate to add</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 2D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A>, <A HREF=#mgCoord2dSubtract>mgCoord2dSubtract</A>, <A HREF=#mgCoord2dMultiply>mgCoord2dMultiply</A>, <A HREF=#mgCoord2dDivide>mgCoord2dDivide</A>, 
<A HREF=#mgCoord2dLerp>mgCoord2dLerp</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord2dAngle><H1 CLASS="APISYMBOL">mgCoord2dAngle</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord2dAngle</B> - calculates the angle between two 2D coordinates.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>double <B>mgCoord2dAngle</B> (</TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord2dAngle</B> calculates and returns the angle between two 2D 
double precision floating point coordinates in degrees.</P></DD><DD><P>The original coordinates <I>coord1</I> and <I>coord2</I> are not affected.</P></DD><DD><P>Note: For efficiency, <I>coord1</I> and <I>coord2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord1</I></DT><DD>address of first coordinates, should have a length above zero</DD><DT><I>coord2</I></DT><DD>address of second coordinates, should have a length above zero</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision floating point value between 0.0 and 180.0 
in degrees.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord2dDivide><H1 CLASS="APISYMBOL">mgCoord2dDivide</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord2dDivide</B> - calculates the quotient of 2D coordinates 
and a scalar.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord2d <B>mgCoord2dDivide</B> (</TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>scalar</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord2dDivide</B> calculates and returns the quotient of 2D 
double precision floating point 
coordinates and a double precision scalar, <I>coord</I> / <I>scalar</I>.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates to multiply by <I>scalar</I></DD><DT><I>scalar</I></DT><DD>scalar to divide <I>coord</I> by</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 2D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A>, <A HREF=#mgCoord2dAdd>mgCoord2dAdd</A>, <A HREF=#mgCoord2dSubtract>mgCoord2dSubtract</A>, <A HREF=#mgCoord2dMultiply>mgCoord2dMultiply</A>, 
<A HREF=#mgCoord2dLerp>mgCoord2dLerp</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord2dDot><H1 CLASS="APISYMBOL">mgCoord2dDot</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord2dDot</B> - calculates the dot product of two 2D coordinates.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>double <B>mgCoord2dDot</B> (</TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord2dDot</B> calculates and returns the dot product of two 2D double 
precision floating point coordinates, <I>coord1</I> * <I>coord2</I>.</P></DD><DD><P>The original coordinates <I>coord1</I> and <I>coord2</I> are not affected.</P></DD><DD><P>Note: For efficiency, <I>coord1</I> and <I>coord2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord1</I></DT><DD>address of first coordinates</DD><DT><I>coord2</I></DT><DD>address of second coordinates</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision floating point value.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord2dLength><H1 CLASS="APISYMBOL">mgCoord2dLength</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord2dLength</B> - calculates the length of 2D coordinates.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>double <B>mgCoord2dLength</B> (</TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord2dLength</B> calculates and returns the length of 2D double precision floating point 
coordinates.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision floating point value.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A>, <A HREF=#mgCoord2dLengthSquared>mgCoord2dLengthSquared</A>, <A HREF=#mgCoord2dSetUnitized>mgCoord2dSetUnitized</A>, <A HREF=#mgCoord2dUnitize>mgCoord2dUnitize</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord2dLengthSquared><H1 CLASS="APISYMBOL">mgCoord2dLengthSquared</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord2dLengthSquared</B> - calculates the squared length of 2D coordinates.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>double <B>mgCoord2dLengthSquared</B> (</TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord2dLengthSquared</B> calculates and returns the squared length of 2D double 
precision floating point coordinates.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision floating point value.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A>, <A HREF=#mgCoord2dLength>mgCoord2dLength</A>, <A HREF=#mgCoord2dSetUnitized>mgCoord2dSetUnitized</A>, <A HREF=#mgCoord2dUnitize>mgCoord2dUnitize</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord2dLerp><H1 CLASS="APISYMBOL">mgCoord2dLerp</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord2dLerp</B> - calculates the linear interpoloation between 
two 2D coordinates.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord2d <B>mgCoord2dLerp</B> (</TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord2</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>amount</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord2dLerp</B> calculates and returns the linear interpolation between 
two 2D coordinates <I>coord1</I> and <I>coord2</I>.  The <I>amount</I> parameter is the amount 
to interpolate between the two coordinates where 0.0 is equal to <I>coord1</I>, 
0.1 is very near <I>coord1</I>, 0.5 is half-way in between, etc.  If <I>amount</I> is 
between 0.0 and 1.0, the coordinate returned will lie on the line segment 
between <I>coord1</I> and <I>coord2</I>.</P></DD><DD><P>The original coordinates <I>coord1</I> and <I>coord2</I> are not affected.</P></DD><DD><P>Note: For efficiency, <I>coord1</I> and <I>coord2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord1</I></DT><DD>address of coordinates of first coordinate</DD><DT><I>coord2</I></DT><DD>address of coordinates of second coordinate</DD><DT><I>amount</I></DT><DD>amount to interpolate between 
<I>coord1</I> and <I>coord2</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 2D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A>, <A HREF=#mgCoord2dAdd>mgCoord2dAdd</A>, <A HREF=#mgCoord2dSubtract>mgCoord2dSubtract</A>, <A HREF=#mgCoord2dMultiply>mgCoord2dMultiply</A>, 
<A HREF=#mgCoord2dDivide>mgCoord2dDivide</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord2dMultiply><H1 CLASS="APISYMBOL">mgCoord2dMultiply</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord2dMultiply</B> - calculates the product of 2D coordinates 
and a scalar.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord2d <B>mgCoord2dMultiply</B> (</TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>scalar</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord2dMultiply</B> calculates and returns the product of 2D 
double precision floating point 
coordinates and a double precision scalar, <I>coord</I> * <I>scalar</I>.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord1</I> and <I>coord2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates to multiply by <I>scalar</I></DD><DT><I>scalar</I></DT><DD>scalar to multiply <I>coord</I> by</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 2D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A>, <A HREF=#mgCoord2dAdd>mgCoord2dAdd</A>, <A HREF=#mgCoord2dSubtract>mgCoord2dSubtract</A>, <A HREF=#mgCoord2dDivide>mgCoord2dDivide</A>, 
<A HREF=#mgCoord2dLerp>mgCoord2dLerp</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord2dNegate><H1 CLASS="APISYMBOL">mgCoord2dNegate</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord2dNegate</B> - calculates 2D coordinates multiplied by -1.0.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord2d <B>mgCoord2dNegate</B> (</TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord2dNegate</B> calculates and returns the product of 2D double 
precision floating point coordinates and -1.0.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 2D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord2dNegativeOne><H1 CLASS="APISYMBOL">mgCoord2dNegativeOne</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord2dNegativeOne</B> - returns (-1.0. -1.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgcoord2d <B>mgCoord2dNegativeOne</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord2dNegativeOne</B> returns (-1.0, -1.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (-1.0, -1.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A>, <A HREF=#mgCoord2dXAxis>mgCoord2dXAxis</A>, <A HREF=#mgCoord2dNegativeXAxis>mgCoord2dNegativeXAxis</A>, 
<A HREF=#mgCoord2dYAxis>mgCoord2dYAxis</A>, <A HREF=#mgCoord2dNegativeYAxis>mgCoord2dNegativeYAxis</A>, 
<A HREF=#mgCoord2dZero>mgCoord2dZero</A>, <A HREF=#mgCoord2dOne>mgCoord2dOne</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord2dNegativeXAxis><H1 CLASS="APISYMBOL">mgCoord2dNegativeXAxis</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord2dNegativeXAxis</B> - returns (-1.0, 0.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgcoord2d <B>mgCoord2dNegativeXAxis</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord2dNegativeXAxis</B> returns (-1.0, 0.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (-1.0, 0.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A>, <A HREF=#mgCoord2dXAxis>mgCoord2dXAxis</A>, 
<A HREF=#mgCoord2dYAxis>mgCoord2dYAxis</A>, <A HREF=#mgCoord2dNegativeYAxis>mgCoord2dNegativeYAxis</A>, 
<A HREF=#mgCoord2dZero>mgCoord2dZero</A>, <A HREF=#mgCoord2dOne>mgCoord2dOne</A>, <A HREF=#mgCoord2dNegativeOne>mgCoord2dNegativeOne</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord2dNegativeYAxis><H1 CLASS="APISYMBOL">mgCoord2dNegativeYAxis</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord2dNegativeYAxis</B> - returns (0.0, -1.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgcoord2d <B>mgCoord2dNegativeYAxis</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord2dNegativeYAxis</B> returns (0.0, -1.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (0.0, -1.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A>, <A HREF=#mgCoord2dXAxis>mgCoord2dXAxis</A>, <A HREF=#mgCoord2dNegativeXAxis>mgCoord2dNegativeXAxis</A>, 
<A HREF=#mgCoord2dYAxis>mgCoord2dYAxis</A>, 
<A HREF=#mgCoord2dZero>mgCoord2dZero</A>, <A HREF=#mgCoord2dOne>mgCoord2dOne</A>, <A HREF=#mgCoord2dNegativeOne>mgCoord2dNegativeOne</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord2dOne><H1 CLASS="APISYMBOL">mgCoord2dOne</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord2dOne</B> - returns (1.0, 1.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgcoord2d <B>mgCoord2dOne</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord2dOne</B> returns (1.0, 1.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (1.0, 1.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A>, <A HREF=#mgCoord2dXAxis>mgCoord2dXAxis</A>, <A HREF=#mgCoord2dNegativeXAxis>mgCoord2dNegativeXAxis</A>, 
<A HREF=#mgCoord2dYAxis>mgCoord2dYAxis</A>, <A HREF=#mgCoord2dNegativeYAxis>mgCoord2dNegativeYAxis</A>, 
<A HREF=#mgCoord2dZero>mgCoord2dZero</A>, <A HREF=#mgCoord2dNegativeOne>mgCoord2dNegativeOne</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord2dOrthoProject><H1 CLASS="APISYMBOL">mgCoord2dOrthoProject</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord2dOrthoProject</B> - calculates the orthogonal projection 
of 2D coordinates onto a specified axis.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord2d <B>mgCoord2dOrthoProject</B> (</TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord2dOrthoProject</B> calculates and returns the orthogonal projection 
of 2D double precision floating point coordinates onto a specified axis. 
<I>coord1</I> is projected onto a plane with <I>coord2</I> as its normal. The result 
is always orthogonal to <I>coord2</I>.</P></DD><DD><P>The original coordinates <I>coord1</I> and <I>coord2</I> are not affected.</P></DD><DD><P>Note: For efficiency, <I>coord1</I> and <I>coord2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord1</I></DT><DD>address of coordinates to project</DD><DT><I>coord2</I></DT><DD>address of coordinates of axis to project onto, 
should have a length above zero</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 2D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A>, <A HREF=#mgCoord2dScalarProject>mgCoord2dScalarProject</A>, <A HREF=#mgCoord2dVectorProject>mgCoord2dVectorProject</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord2dReflect><H1 CLASS="APISYMBOL">mgCoord2dReflect</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord2dReflect</B> - calculates 2D coordinates reflected about 
a specified axis.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord2d <B>mgCoord2dReflect</B> (</TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord2dReflect</B> calculates and returns 2D double precision floating 
point coordinates reflected about a specified axis.</P></DD><DD><P>The original coordinates <I>coord1</I> and <I>coord2</I> are not affected.</P></DD><DD><P>Note: For efficiency, <I>coord1</I> and <I>coord2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord1</I></DT><DD>address of coordinates to reflect</DD><DT><I>coord2</I></DT><DD>address of coordinates of axis to reflect about, 
should have a length above zero</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 2D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A>, <A HREF=#mgCoord2dReflectX>mgCoord2dReflectX</A>, <A HREF=#mgCoord2dReflectY>mgCoord2dReflectY</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord2dReflectX><H1 CLASS="APISYMBOL">mgCoord2dReflectX</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord2dReflectX</B> - calculates 2D coordinates reflected 
about the X axis.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord2d <B>mgCoord2dReflectX</B> (</TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord2dReflectX</B> calculates and returns 2D double precision 
floating point coordinates reflected about the X axis.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 2D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A>, <A HREF=#mgCoord2dReflectY>mgCoord2dReflectY</A>, <A HREF=#mgCoord2dReflect>mgCoord2dReflect</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord2dReflectY><H1 CLASS="APISYMBOL">mgCoord2dReflectY</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord2dReflectY</B> - calculates 2D coordinates reflected 
about the Y axis.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord2d <B>mgCoord2dReflectY</B> (</TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord2dReflectY</B> calculates and returns 2D double precision 
floating point coordinates reflected about the Y axis.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 2D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A>, <A HREF=#mgCoord2dReflectX>mgCoord2dReflectX</A>, <A HREF=#mgCoord2dReflect>mgCoord2dReflect</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord2dRotate90CCW><H1 CLASS="APISYMBOL">mgCoord2dRotate90CCW</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord2dRotate90CCW</B> - calculates 2D coordinates rotated 
counterclockwise by 90 degrees.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord2d <B>mgCoord2dRotate90CCW</B> (</TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord2dRotate90CCW</B> calculates and returns 2D double precision 
floating point coordinates rotated counterclockwise by 90 degrees.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 2D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A>, <A HREF=#mgCoord2dRotateCW>mgCoord2dRotateCW</A>, <A HREF=#mgCoord2dRotate90CW>mgCoord2dRotate90CW</A>, 
<A HREF=#mgCoord2dRotateCCW>mgCoord2dRotateCCW</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord2dRotate90CW><H1 CLASS="APISYMBOL">mgCoord2dRotate90CW</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord2dRotate90CW</B> - calculates 2D coordinates rotated 
clockwise by 90 degrees.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord2d <B>mgCoord2dRotate90CW</B> (</TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord2dRotate90CW</B> calculates and returns 2D double precision 
floating point coordinates rotated clockwise by 90 degrees.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 2D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A>, <A HREF=#mgCoord2dRotateCW>mgCoord2dRotateCW</A>, <A HREF=#mgCoord2dRotateCCW>mgCoord2dRotateCCW</A>, 
<A HREF=#mgCoord2dRotate90CCW>mgCoord2dRotate90CCW</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord2dRotateCCW><H1 CLASS="APISYMBOL">mgCoord2dRotateCCW</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord2dRotateCCW</B> - calculates 2D coordinates rotated 
counterclockwise by a specified angle.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord2d <B>mgCoord2dRotateCCW</B> (</TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>degrees</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord2dRotateCCW</B> calculates and returns 2D double precision 
floating point coordinates rotated counterclockwise by a specified angle.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates</DD><DT><I>degrees</I></DT><DD>angle in degrees</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 2D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A>, <A HREF=#mgCoord2dRotateCW>mgCoord2dRotateCW</A>, <A HREF=#mgCoord2dRotate90CW>mgCoord2dRotate90CW</A>, 
<A HREF=#mgCoord2dRotate90CCW>mgCoord2dRotate90CCW</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord2dRotateCW><H1 CLASS="APISYMBOL">mgCoord2dRotateCW</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord2dRotateCW</B> - calculates 2D coordinates rotated 
clockwise by a specified angle.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord2d <B>mgCoord2dRotateCW</B> (</TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>degrees</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord2dRotateCW</B> calculates and returns 2D double precision 
floating point coordinates rotated clockwise by a specified angle.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates</DD><DT><I>degrees</I></DT><DD>angle in degrees</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 2D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A>, <A HREF=#mgCoord2dRotate90CW>mgCoord2dRotate90CW</A>, <A HREF=#mgCoord2dRotateCCW>mgCoord2dRotateCCW</A>, 
<A HREF=#mgCoord2dRotate90CCW>mgCoord2dRotate90CCW</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord2dScalarProject><H1 CLASS="APISYMBOL">mgCoord2dScalarProject</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord2dScalarProject</B> - calculates the scalar projection of 2D 
coordinates onto a specified axis.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>double <B>mgCoord2dScalarProject</B> (</TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord2dScalarProject</B> calculates and returns the scalar projection 
of 2D double precision floating point coordinates onto a specified axis.</P></DD><DD><P>The original coordinates <I>coord1</I> and <I>coord2</I> are not affected.</P></DD><DD><P>Note: For efficiency, <I>coord1</I> and <I>coord2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord1</I></DT><DD>address of coordinates to project</DD><DT><I>coord2</I></DT><DD>address of coordinates of axis to project onto, 
should have a length above zero</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision floating point value.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A>, <A HREF=#mgCoord2dVectorProject>mgCoord2dVectorProject</A>, <A HREF=#mgCoord2dOrthoProject>mgCoord2dOrthoProject</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord2dSetUnitized><H1 CLASS="APISYMBOL">mgCoord2dSetUnitized</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord2dSetUnitized</B> - calculates 2D coordinates scaled 
uniformly to have a length of 1.0.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgCoord2dSetUnitized</B> (</TD><TD><A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord2dSetUnitized</B> calculates and assigns 2D double precision floating point 
coordinates scaled uniformly to have a length of 1.0.</P></DD><DD><P>The original coordinate <I>coord</I> is changed.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates, should have a length above zero</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A>, <A HREF=#mgCoord2dLength>mgCoord2dLength</A>, <A HREF=#mgCoord2dLengthSquared>mgCoord2dLengthSquared</A>, <A HREF=#mgCoord2dUnitize>mgCoord2dUnitize</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord2dSubtract><H1 CLASS="APISYMBOL">mgCoord2dSubtract</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord2dSubtract</B> - calculates the difference of two 
2D coordinates.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord2d <B>mgCoord2dSubtract</B> (</TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord2dSubtract</B> calculates and returns the difference of two 
2D double precision floating point coordinates, <I>coord1</I> - <I>coord2</I>.</P></DD><DD><P>The original coordinates <I>coord1</I> and <I>coord2</I> are not affected.</P></DD><DD><P>Note: For efficiency, <I>coord1</I> and <I>coord2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord1</I></DT><DD>address of coordinate to subtract <I>coord2</I> from</DD><DT><I>coord2</I></DT><DD>address of coordinate to subtract <I>coord1</I> by</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 2D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A>, <A HREF=#mgCoord2dAdd>mgCoord2dAdd</A>, <A HREF=#mgCoord2dMultiply>mgCoord2dMultiply</A>, <A HREF=#mgCoord2dDivide>mgCoord2dDivide</A>, 
<A HREF=#mgCoord2dLerp>mgCoord2dLerp</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord2dUnitize><H1 CLASS="APISYMBOL">mgCoord2dUnitize</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord2dUnitize</B> - calculates 2D coordinates scaled 
uniformly to have a length of 1.0.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord2d <B>mgCoord2dUnitize</B> (</TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord2dUnitize</B> calculates and returns 2D double precision floating point 
coordinates scaled uniformly to have a length of 1.0.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates, should have a length above zero</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 2D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A>, <A HREF=#mgCoord2dLength>mgCoord2dLength</A>, <A HREF=#mgCoord2dLengthSquared>mgCoord2dLengthSquared</A>, <A HREF=#mgCoord2dSetUnitized>mgCoord2dSetUnitized</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord2dVectorProject><H1 CLASS="APISYMBOL">mgCoord2dVectorProject</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord2dVectorProject</B> - calculates the vector projection 
of 2D coordinates onto a specified axis.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord2d <B>mgCoord2dVectorProject</B> (</TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord2d>mgcoord2d*</A></TD><TD><I>coord2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord2dVectorProject</B> calculates and returns the vector projection 
of 2D double precision floating point coordinates onto a specified axis.</P></DD><DD><P>The original coordinates <I>coord1</I> and <I>coord2</I> are not affected.</P></DD><DD><P>Note: For efficiency, <I>coord1</I> and <I>coord2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord1</I></DT><DD>address of coordinates to project</DD><DT><I>coord2</I></DT><DD>address of coordinates of axis to project onto, 
should have a length above zero</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 2D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A>, <A HREF=#mgCoord2dScalarProject>mgCoord2dScalarProject</A>, <A HREF=#mgCoord2dOrthoProject>mgCoord2dOrthoProject</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord2dXAxis><H1 CLASS="APISYMBOL">mgCoord2dXAxis</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord2dXAxis</B> - returns (1.0, 0.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgcoord2d <B>mgCoord2dXAxis</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord2dXAxis</B> returns (1.0, 0.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (1.0, 0.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A>, <A HREF=#mgCoord2dNegativeXAxis>mgCoord2dNegativeXAxis</A>, 
<A HREF=#mgCoord2dYAxis>mgCoord2dYAxis</A>, <A HREF=#mgCoord2dNegativeYAxis>mgCoord2dNegativeYAxis</A>, 
<A HREF=#mgCoord2dZero>mgCoord2dZero</A>, <A HREF=#mgCoord2dOne>mgCoord2dOne</A>, <A HREF=#mgCoord2dNegativeOne>mgCoord2dNegativeOne</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord2dYAxis><H1 CLASS="APISYMBOL">mgCoord2dYAxis</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord2dYAxis</B> - returns (0.0, 1.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgcoord2d <B>mgCoord2dYAxis</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord2dYAxis</B> returns (0.0, 1.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (0.0, 1.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A>, <A HREF=#mgCoord2dXAxis>mgCoord2dXAxis</A>, <A HREF=#mgCoord2dNegativeXAxis>mgCoord2dNegativeXAxis</A>, 
<A HREF=#mgCoord2dNegativeYAxis>mgCoord2dNegativeYAxis</A>, 
<A HREF=#mgCoord2dZero>mgCoord2dZero</A>, <A HREF=#mgCoord2dOne>mgCoord2dOne</A>, <A HREF=#mgCoord2dNegativeOne>mgCoord2dNegativeOne</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord2dZero><H1 CLASS="APISYMBOL">mgCoord2dZero</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord2dZero</B> - returns (0.0, 0.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgcoord2d <B>mgCoord2dZero</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord2dZero</B> returns (0.0, 0.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (0.0, 0.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A>, <A HREF=#mgCoord2dXAxis>mgCoord2dXAxis</A>, <A HREF=#mgCoord2dNegativeXAxis>mgCoord2dNegativeXAxis</A>, 
<A HREF=#mgCoord2dYAxis>mgCoord2dYAxis</A>, <A HREF=#mgCoord2dNegativeYAxis>mgCoord2dNegativeYAxis</A>, 
<A HREF=#mgCoord2dOne>mgCoord2dOne</A>, <A HREF=#mgCoord2dNegativeOne>mgCoord2dNegativeOne</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dAdd><H1 CLASS="APISYMBOL">mgCoord3dAdd</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dAdd</B> - calculates the sum of two 3D coordinates.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dAdd</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dAdd</B> calculates the sum of two 3D double 
precision floating point coordinates, <I>coord1</I> + <I>coord2</I>.</P></DD><DD><P>The original coordinates <I>coord1</I> and <I>coord2</I> are 
not affected.</P></DD><DD><P>Note: For efficiency, <I>coord1</I> and <I>coord2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord1</I></DT><DD>address of first coordinate to add</DD><DT><I>coord2</I></DT><DD>address of second coordinate to add</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgCoord3dSubtract>mgCoord3dSubtract</A>, <A HREF=#mgCoord3dMultiply>mgCoord3dMultiply</A>, <A HREF=#mgCoord3dDivide>mgCoord3dDivide</A>, 
<A HREF=#mgCoord3dLerp>mgCoord3dLerp</A>, <A HREF=#mgCoord3dNegate>mgCoord3dNegate</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dAlmostEqual><H1 CLASS="APISYMBOL">mgCoord3dAlmostEqual</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dAlmostEqual</B> - checks to see if two coordinates are 
equal within a tolerance.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgCoord3dAlmostEqual</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord2</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>tolerance</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dAlmostEqual</B> compares two coordinates, <I>coord1</I> and <I>coord2</I> 
to see if they are equal within a specified <I>tolerance</I>.</P></DD><DD><P>The two coordinates are considered equal if:</P></DD><DD><P>absolute value ((coord1-&gtx - coord2-&gtx) is less than tolerance) AND<BR> 
absolute value ((coord1-&gty - coord2-&gty) is less than tolerance) AND<BR> 
absolute value ((coord1-&gtz - coord2-&gtz) is less than tolerance)<BR></P></DD><DD><P>To compare for exact matches, set <I>tolerance</I> to 0.0 or use function 
<A HREF=#mgCoord3dEqual>mgCoord3dEqual</A>.  This function does not match based on distance.  Doing so, 
in some cases, may yield a more desirable result but is more computationally 
intensive than the simple comparison test used by this function.</P></DD><DD><P>Note: For efficiency, <I>coord1</I> and <I>coord2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord1</I></DT><DD>first coord to check for equality</DD><DT><I>coord2</I></DT><DD>second coord to check for equality</DD><DT><I>tolerance</I></DT><DD>tolerance for equality check</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if <I>coord1</I> and <I>coord2</I> are equal 
within <I>tolerance</I>, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>If you need more precise checking based on the distance between two 
coordinates, you can use the function <A HREF=#mgCoord3dDistance>mgCoord3dDistance</A> to create your own 
equality check as shown here.</DT><DT><PRE CLASS="EXAMPLE">static mgbool CheckEqual (mgcoord3d* c1, mgcoord* c2, double distance)
{
   if (mgCoord3dDistance (c1, c2) &lt distance)
      return MG_TRUE;
   return MG_FALSE;
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgCoord3dEqual>mgCoord3dEqual</A>, <A HREF=#mgCoord3dDistance>mgCoord3dDistance</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dAngle><H1 CLASS="APISYMBOL">mgCoord3dAngle</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dAngle</B> - calculates the angle between two 3D coordinates.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>double <B>mgCoord3dAngle</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dAngle</B> calculates and returns the angle between two 3D double 
precision floating point coordinates in degrees.</P></DD><DD><P>The original coordinates <I>coord1</I> and <I>coord2</I> are not affected.</P></DD><DD><P>Note: For efficiency, <I>coord1</I> and <I>coord2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord1</I></DT><DD>address of first coordinates, should have a length above zero</DD><DT><I>coord2</I></DT><DD>address of second coordinates, should have a length above zero</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision floating point value between 0.0 and 180.0 in degrees.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgCoord3dDot>mgCoord3dDot</A>, <A HREF=#mgCoord3dCross>mgCoord3dCross</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dCross><H1 CLASS="APISYMBOL">mgCoord3dCross</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dCross</B> - calculates the cross product of two 3D coordinates.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dCross</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dCross</B> calculates and returns the cross product of two 3D 
double precision floating point coordinates, <I>coord1</I> x <I>coord2</I>.</P></DD><DD><P>The original coordinates <I>coord1</I> and <I>coord2</I> are not affected.</P></DD><DD><P>Note: For efficiency, <I>coord1</I> and <I>coord2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord1</I></DT><DD>address of first coordinates</DD><DT><I>coord2</I></DT><DD>address of second coordinates</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgCoord3dDot>mgCoord3dDot</A>, <A HREF=#mgCoord3dAngle>mgCoord3dAngle</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dDistance><H1 CLASS="APISYMBOL">mgCoord3dDistance</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dDistance</B> - calculates the distance between two 
3D coordinates.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>double <B>mgCoord3dDistance</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dDistance</B> calculates the distance between two 3D double 
precision floating point coordinates, <I>coord1</I> and <I>coord2</I>.</P></DD><DD><P>The original coordinates <I>coord1</I> and <I>coord2</I> are 
not affected.</P></DD><DD><P>Note: For efficiency, <I>coord1</I> and <I>coord2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord1</I></DT><DD>address of first coordinate</DD><DT><I>coord2</I></DT><DD>address of second coordinate</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision floating point value.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgCoord3dDistanceSquared>mgCoord3dDistanceSquared</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dDistanceSquared><H1 CLASS="APISYMBOL">mgCoord3dDistanceSquared</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dDistanceSquared</B> - calculates the squared distance 
between two 3D coordinates.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>double <B>mgCoord3dDistanceSquared</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dDistanceSquared</B> calculates the squared distance between 
two 3D double precision floating point coordinates, <I>coord1</I> and <I>coord2</I>.</P></DD><DD><P>The original coordinates <I>coord1</I> and <I>coord2</I> are 
not affected.</P></DD><DD><P>Note: For efficiency, <I>coord1</I> and <I>coord2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord1</I></DT><DD>address of first coordinate</DD><DT><I>coord2</I></DT><DD>address of second coordinate</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision floating point value.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgCoord3dDistance>mgCoord3dDistance</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dDivide><H1 CLASS="APISYMBOL">mgCoord3dDivide</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dDivide</B> - calculates the quotient of 3D coordinates 
and a scalar.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dDivide</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>scalar</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dDivide</B> calculates and returns the quotient of 3D double 
precision floating point coordinates and a double precision scalar, 
<I>coord</I> / <I>scalar</I>.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates to multiply by <I>scalar</I></DD><DT><I>scalar</I></DT><DD>scalar to multiply <I>coord</I> by</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgCoord3dAdd>mgCoord3dAdd</A>, <A HREF=#mgCoord3dSubtract>mgCoord3dSubtract</A>, <A HREF=#mgCoord3dMultiply>mgCoord3dMultiply</A>, 
<A HREF=#mgCoord3dLerp>mgCoord3dLerp</A>, <A HREF=#mgCoord3dNegate>mgCoord3dNegate</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dDot><H1 CLASS="APISYMBOL">mgCoord3dDot</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dDot</B> - calculates the dot product of two 3D coordinates.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>double <B>mgCoord3dDot</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dDot</B> calculates and returns the dot product of two 3D double 
precision floating point coordinates, <I>coord1</I> * <I>coord2</I>.</P></DD><DD><P>The original coordinates <I>coord1</I> and <I>coord2</I> are not affected.</P></DD><DD><P>Note: For efficiency, <I>coord1</I> and <I>coord2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord1</I></DT><DD>address of first coordinates</DD><DT><I>coord2</I></DT><DD>address of second coordinates</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision floating point value.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgCoord3dCross>mgCoord3dCross</A>, <A HREF=#mgCoord3dAngle>mgCoord3dAngle</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dEqual><H1 CLASS="APISYMBOL">mgCoord3dEqual</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dEqual</B> - checks to see if two coordinates are 
exactly equal.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgCoord3dEqual</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dEqual</B> compares two coordinates, <I>coord1</I> and <I>coord2</I> 
to see if they are exactly equal.</P></DD><DD><P>Note: For efficiency, <I>coord1</I> and <I>coord2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord1</I></DT><DD>first coord to check for equality</DD><DT><I>coord2</I></DT><DD>second coord to check for equality</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if <I>coord1</I> and <I>coord2</I> are equal, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgCoord3dAlmostEqual>mgCoord3dAlmostEqual</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dLength><H1 CLASS="APISYMBOL">mgCoord3dLength</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dLength</B> - calculates the length of 3D coordinates.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>double <B>mgCoord3dLength</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dLength</B> calculates and returns the length of 3D double precision floating point 
coordinates.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision floating point value.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, 
<A HREF=#mgCoord3dLengthSquared>mgCoord3dLengthSquared</A>, 
<A HREF=#mgCoord3dSetUnitized>mgCoord3dSetUnitized</A>, <A HREF=#mgCoord3dUnitize>mgCoord3dUnitize</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dLengthSquared><H1 CLASS="APISYMBOL">mgCoord3dLengthSquared</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dLengthSquared</B> - calculates the squared length of 3D coordinates.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>double <B>mgCoord3dLengthSquared</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dLengthSquared</B> calculates and returns the squared length of 3D double 
precision floating point coordinates.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision floating point value.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, 
<A HREF=#mgCoord3dLength>mgCoord3dLength</A>, 
<A HREF=#mgCoord3dSetUnitized>mgCoord3dSetUnitized</A>, <A HREF=#mgCoord3dUnitize>mgCoord3dUnitize</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dLerp><H1 CLASS="APISYMBOL">mgCoord3dLerp</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dLerp</B> - calculates the linear interpoloation between 
two 3D coordinates.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dLerp</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord2</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>amount</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dLerp</B> calculates and returns the linear interpolation between 
two 3D coordinates <I>coord1</I> and <I>coord2</I>.  The <I>amount</I> parameter is the amount 
to interpolate between the two coordinates where 0.0 is equal to <I>coord1</I>, 
0.1 is very near <I>coord1</I>, 0.5 is half-way in between, etc.  If <I>amount</I> is 
between 0.0 and 1.0, the coordinate returned will lie on the line segment 
between <I>coord1</I> and <I>coord2</I>.</P></DD><DD><P>The original coordinates <I>coord1</I> and <I>coord2</I> are not affected.</P></DD><DD><P>Note: For efficiency, <I>coord1</I> and <I>coord2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord1</I></DT><DD>address of coordinates of first coordinate</DD><DT><I>coord2</I></DT><DD>address of coordinates of second coordinate</DD><DT><I>amount</I></DT><DD>amount to interpolate between 
<I>coord1</I> and <I>coord2</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgCoord3dAdd>mgCoord3dAdd</A>, <A HREF=#mgCoord3dSubtract>mgCoord3dSubtract</A>, <A HREF=#mgCoord3dMultiply>mgCoord3dMultiply</A>, 
<A HREF=#mgCoord3dDivide>mgCoord3dDivide</A>, <A HREF=#mgCoord3dNegate>mgCoord3dNegate</A>,</DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dMoveAlongVectord><H1 CLASS="APISYMBOL">mgCoord3dMoveAlongVectord</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dMoveAlongVectord</B> - calculates the position of a 
3D coordinate translated along a double precision vector a given distance.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dMoveAlongVectord</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgvectord>mgvectord*</A></TD><TD><I>vec</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>distance</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dMoveAlongVectord</B> calculates and returns the position of the 
specified 3D coordinate, <I>coord</I>, translated the specified distance, 
<I>distance</I>, in the direction specified by the double precision 
floating point vector <I>vec</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of 3D coordinate to move</DD><DT><I>vec</I></DT><DD>address of vector along which <I>coord</I> 
is to be moved</DD><DT><I>distance</I></DT><DD>distance along <I>vector</I> that <I>coord</I> 
is to be moved</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgCoord3dMoveAlongVectorf>mgCoord3dMoveAlongVectorf</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dMoveAlongVectorf><H1 CLASS="APISYMBOL">mgCoord3dMoveAlongVectorf</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dMoveAlongVectorf</B> - calculates the position of a 
3D coordinate translated along a single precision vector a given distance.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dMoveAlongVectorf</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgvectorf>mgvectorf*</A></TD><TD><I>vec</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>distance</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dMoveAlongVectorf</B> calculates and returns the position of the 
specified 3D coordinate, <I>coord</I>, translated the specified distance, 
<I>distance</I>, in the direction specified by the single precision 
floating point vector <I>vec</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of 3D coordinate to move</DD><DT><I>vec</I></DT><DD>address of vector along which <I>coord</I> 
is to be moved</DD><DT><I>distance</I></DT><DD>distance along <I>vector</I> that <I>coord</I> 
is to be moved</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgCoord3dMoveAlongVectord>mgCoord3dMoveAlongVectord</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dMultiply><H1 CLASS="APISYMBOL">mgCoord3dMultiply</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dMultiply</B> - calculates the product of 3D coordinates 
and a scalar.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dMultiply</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>scalar</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dMultiply</B> calculates and returns the product of 3D double 
precision floating point coordinates and a double precision scalar, 
<I>coord</I> * <I>scalar</I>.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates to multiply by <I>scalar</I></DD><DT><I>scalar</I></DT><DD>scalar to multiply <I>coord</I> by</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgCoord3dAdd>mgCoord3dAdd</A>, <A HREF=#mgCoord3dSubtract>mgCoord3dSubtract</A>, <A HREF=#mgCoord3dDivide>mgCoord3dDivide</A>, 
<A HREF=#mgCoord3dLerp>mgCoord3dLerp</A>, <A HREF=#mgCoord3dNegate>mgCoord3dNegate</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dNegate><H1 CLASS="APISYMBOL">mgCoord3dNegate</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dNegate</B> - calculates 3D coordinates multiplied by -1.0.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dNegate</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dNegate</B> calculates and returns the product of 3D double precision floating point 
coordinates and -1.0.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, 
<A HREF=#mgCoord3dAdd>mgCoord3dAdd</A>, <A HREF=#mgCoord3dSubtract>mgCoord3dSubtract</A>, <A HREF=#mgCoord3dMultiply>mgCoord3dMultiply</A>, <A HREF=#mgCoord3dDivide>mgCoord3dDivide</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dNegativeOne><H1 CLASS="APISYMBOL">mgCoord3dNegativeOne</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dNegativeOne</B> - returns (-1.0. -1.0, -1.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgcoord3d <B>mgCoord3dNegativeOne</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dNegativeOne</B> returns (-1.0, -1.0, -1.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (-1.0, -1.0, -1.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A> 
<A HREF=#mgCoord3dXAxis>mgCoord3dXAxis</A>, <A HREF=#mgCoord3dNegativeXAxis>mgCoord3dNegativeXAxis</A>, 
<A HREF=#mgCoord3dYAxis>mgCoord3dYAxis</A>, <A HREF=#mgCoord3dNegativeYAxis>mgCoord3dNegativeYAxis</A>, 
<A HREF=#mgCoord3dZAxis>mgCoord3dZAxis</A>, <A HREF=#mgCoord3dNegativeZAxis>mgCoord3dNegativeZAxis</A>, 
<A HREF=#mgCoord3dZero>mgCoord3dZero</A>, <A HREF=#mgCoord3dOne>mgCoord3dOne</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dNegativeXAxis><H1 CLASS="APISYMBOL">mgCoord3dNegativeXAxis</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dNegativeXAxis</B> - returns (-1.0, 0.0, 0.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgcoord3d <B>mgCoord3dNegativeXAxis</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dNegativeXAxis</B> returns (-1.0, 0.0, 0.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (-1.0, 0.0, 0.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, 
<A HREF=#mgCoord3dXAxis>mgCoord3dXAxis</A>, 
<A HREF=#mgCoord3dYAxis>mgCoord3dYAxis</A>, <A HREF=#mgCoord3dNegativeYAxis>mgCoord3dNegativeYAxis</A>, 
<A HREF=#mgCoord3dZAxis>mgCoord3dZAxis</A>, <A HREF=#mgCoord3dNegativeZAxis>mgCoord3dNegativeZAxis</A>, 
<A HREF=#mgCoord3dZero>mgCoord3dZero</A>, <A HREF=#mgCoord3dOne>mgCoord3dOne</A>, <A HREF=#mgCoord3dNegativeOne>mgCoord3dNegativeOne</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dNegativeYAxis><H1 CLASS="APISYMBOL">mgCoord3dNegativeYAxis</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dNegativeYAxis</B> - returns (0.0, -1.0, 0.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgcoord3d <B>mgCoord3dNegativeYAxis</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dNegativeYAxis</B> returns (0.0, -1.0, 0.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (0.0, -1.0, 0.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A> 
<A HREF=#mgCoord3dXAxis>mgCoord3dXAxis</A>, <A HREF=#mgCoord3dNegativeXAxis>mgCoord3dNegativeXAxis</A>, 
<A HREF=#mgCoord3dYAxis>mgCoord3dYAxis</A>, 
<A HREF=#mgCoord3dZAxis>mgCoord3dZAxis</A>, <A HREF=#mgCoord3dNegativeZAxis>mgCoord3dNegativeZAxis</A>, 
<A HREF=#mgCoord3dZero>mgCoord3dZero</A>, <A HREF=#mgCoord3dOne>mgCoord3dOne</A>, <A HREF=#mgCoord3dNegativeOne>mgCoord3dNegativeOne</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dNegativeZAxis><H1 CLASS="APISYMBOL">mgCoord3dNegativeZAxis</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dNegativeZAxis</B> - returns (0.0, 0.0, -1.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgcoord3d <B>mgCoord3dNegativeZAxis</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dNegativeZAxis</B> returns (0.0, 0.0, -1.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (0.0, 0.0, -1.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A> 
<A HREF=#mgCoord3dXAxis>mgCoord3dXAxis</A>, <A HREF=#mgCoord3dNegativeXAxis>mgCoord3dNegativeXAxis</A>, 
<A HREF=#mgCoord3dYAxis>mgCoord3dYAxis</A>, <A HREF=#mgCoord3dNegativeYAxis>mgCoord3dNegativeYAxis</A>, 
<A HREF=#mgCoord3dZAxis>mgCoord3dZAxis</A>, 
<A HREF=#mgCoord3dZero>mgCoord3dZero</A>, <A HREF=#mgCoord3dOne>mgCoord3dOne</A>, <A HREF=#mgCoord3dNegativeOne>mgCoord3dNegativeOne</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dOne><H1 CLASS="APISYMBOL">mgCoord3dOne</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dOne</B> - returns (1.0, 1.0, 1.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgcoord3d <B>mgCoord3dOne</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dOne</B> returns (1.0, 1.0, 1.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (1.0, 1.0, 1.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A> 
<A HREF=#mgCoord3dXAxis>mgCoord3dXAxis</A>, <A HREF=#mgCoord3dNegativeXAxis>mgCoord3dNegativeXAxis</A>, 
<A HREF=#mgCoord3dYAxis>mgCoord3dYAxis</A>, <A HREF=#mgCoord3dNegativeYAxis>mgCoord3dNegativeYAxis</A>, 
<A HREF=#mgCoord3dZAxis>mgCoord3dZAxis</A>, <A HREF=#mgCoord3dNegativeZAxis>mgCoord3dNegativeZAxis</A>, 
<A HREF=#mgCoord3dZero>mgCoord3dZero</A>, <A HREF=#mgCoord3dNegativeOne>mgCoord3dNegativeOne</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dOrthoProject><H1 CLASS="APISYMBOL">mgCoord3dOrthoProject</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dOrthoProject</B> - calculates the orthogonal projection 
of 3D coordinates onto a specified axis.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dOrthoProject</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dOrthoProject</B> calculates and returns the orthogonal projection 
of 3D double precision floating point coordinates onto a specified axis. 
<I>coord1</I> is projected onto a plane with <I>coord2</I> as its normal. The result 
is always orthogonal to <I>coord2</I>.</P></DD><DD><P>The original coordinates <I>coord1</I> and <I>coord2</I> are not affected.</P></DD><DD><P>Note: For efficiency, <I>coord1</I> and <I>coord2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord1</I></DT><DD>address of coordinates to project</DD><DT><I>coord2</I></DT><DD>address of coordinates of axis to project onto, 
should have a length above zero</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgCoord3dScalarProject>mgCoord3dScalarProject</A>, <A HREF=#mgCoord3dVectorProject>mgCoord3dVectorProject</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dPitchDown><H1 CLASS="APISYMBOL">mgCoord3dPitchDown</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dPitchDown</B> - calculates 3D coordinates pitched down 
by a specified angle.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dPitchDown</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>degrees</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dPitchDown</B> calculates and returns the 3D double precision 
floating point coordinates pitched down by a specified angle.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates</DD><DT><I>degrees</I></DT><DD>angle in degrees</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgCoord3dPitchDown90>mgCoord3dPitchDown90</A>, 
<A HREF=#mgCoord3dPitchUp>mgCoord3dPitchUp</A>, <A HREF=#mgCoord3dPitchUp90>mgCoord3dPitchUp90</A>, <A HREF=#mgCoord3dReflectX>mgCoord3dReflectX</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dPitchDown90><H1 CLASS="APISYMBOL">mgCoord3dPitchDown90</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dPitchDown90</B> - calculates 3D coordinates pitched 
down by 90 degrees.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dPitchDown90</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dPitchDown90</B> calculates and returns the 3D double precision 
floating point coordinates pitched down by 90 degrees.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgCoord3dPitchDown>mgCoord3dPitchDown</A>, 
<A HREF=#mgCoord3dPitchUp>mgCoord3dPitchUp</A>, <A HREF=#mgCoord3dPitchUp90>mgCoord3dPitchUp90</A>, <A HREF=#mgCoord3dReflectX>mgCoord3dReflectX</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dPitchUp><H1 CLASS="APISYMBOL">mgCoord3dPitchUp</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dPitchUp</B> - calculates 3D coordinates pitched up 
by a specified angle.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dPitchUp</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>degrees</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dPitchUp</B> calculates and returns the 3D double precision 
floating point coordinates pitched up by a specified angle.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates</DD><DT><I>degrees</I></DT><DD>angle in degrees</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgCoord3dPitchDown>mgCoord3dPitchDown</A>, <A HREF=#mgCoord3dPitchDown90>mgCoord3dPitchDown90</A>, 
<A HREF=#mgCoord3dPitchUp90>mgCoord3dPitchUp90</A>, <A HREF=#mgCoord3dReflectX>mgCoord3dReflectX</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dPitchUp90><H1 CLASS="APISYMBOL">mgCoord3dPitchUp90</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dPitchUp90</B> - calculates 3D coordinates pitched up 
by 90 degrees.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dPitchUp90</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dPitchUp90</B> calculates and returns the 3D double precision 
floating point coordinates pitched up by 90 degrees.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgCoord3dPitchDown>mgCoord3dPitchDown</A>, <A HREF=#mgCoord3dPitchDown90>mgCoord3dPitchDown90</A>, 
<A HREF=#mgCoord3dPitchUp>mgCoord3dPitchUp</A>, <A HREF=#mgCoord3dReflectX>mgCoord3dReflectX</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dProjectOnPlane><H1 CLASS="APISYMBOL">mgCoord3dProjectOnPlane</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dProjectOnPlane</B> - calculates the position of a 
3D coordinate projected onto a plane.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dProjectOnPlane</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgplaned>mgplaned*</A></TD><TD><I>plane</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dProjectOnPlane</B> calculates and returns the position of the 
specified 3D coordinate, <I>coord</I>, projected onto the specified <I>plane</I>. 
This projected position represents the closest coordinate on <I>plane</I> to 
<I>coord</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of 3D coordinate to project</DD><DT><I>plane</I></DT><DD>address of plane that <I>coord</I> 
will be projected onto</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision floating point coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgplaned>mgplaned</A>, <A HREF=#mgMakePlaned>mgMakePlaned</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dReflect><H1 CLASS="APISYMBOL">mgCoord3dReflect</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dReflect</B> - calculates 3D coordinates reflected about 
a specified axis.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dReflect</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dReflect</B> calculates and returns 3D double precision floating point 
coordinates reflected about a specified axis or rotated 180 degrees about that axis.</P></DD><DD><P>The original coordinates <I>coord1</I> and <I>coord2</I> are not affected.</P></DD><DD><P>Note: For efficiency, <I>coord1</I> and <I>coord2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord1</I></DT><DD>address of coordinates to reflect</DD><DT><I>coord2</I></DT><DD>address of coordinates of axis to reflect about, 
should have a length above zero</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgCoord3dReflectX>mgCoord3dReflectX</A>, <A HREF=#mgCoord3dReflectY>mgCoord3dReflectY</A>, <A HREF=#mgCoord3dReflectZ>mgCoord3dReflectZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dReflectX><H1 CLASS="APISYMBOL">mgCoord3dReflectX</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dReflectX</B> - calculates 3D coordinates reflected about the X axis.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dReflectX</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dReflectX</B> calculates and returns 3D double precision floating point 
coordinates reflected about the X axis or pitched 180 degrees.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgCoord3dReflectY>mgCoord3dReflectY</A>, <A HREF=#mgCoord3dReflectZ>mgCoord3dReflectZ</A>, <A HREF=#mgCoord3dReflect>mgCoord3dReflect</A>, 
<A HREF=#mgCoord3dPitchDown>mgCoord3dPitchDown</A>, <A HREF=#mgCoord3dPitchDown90>mgCoord3dPitchDown90</A>, 
<A HREF=#mgCoord3dPitchUp>mgCoord3dPitchUp</A>, <A HREF=#mgCoord3dPitchUp90>mgCoord3dPitchUp90</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dReflectY><H1 CLASS="APISYMBOL">mgCoord3dReflectY</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dReflectY</B> - calculates 3D coordinates reflected about 
the Y axis.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dReflectY</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dReflectY</B> calculates and returns 3D double precision floating 
point coordinates reflected about the Y axis or rolled 180 degrees.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgCoord3dReflectX>mgCoord3dReflectX</A>, <A HREF=#mgCoord3dReflectZ>mgCoord3dReflectZ</A>, <A HREF=#mgCoord3dReflect>mgCoord3dReflect</A>, 
<A HREF=#mgCoord3dRollLeft>mgCoord3dRollLeft</A>, <A HREF=#mgCoord3dRollLeft90>mgCoord3dRollLeft90</A>, 
<A HREF=#mgCoord3dRollRight>mgCoord3dRollRight</A>, <A HREF=#mgCoord3dRollRight90>mgCoord3dRollRight90</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dReflectZ><H1 CLASS="APISYMBOL">mgCoord3dReflectZ</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dReflectZ</B> - calculates 3D coordinates reflected about 
the Z axis.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dReflectZ</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dReflectZ</B> calculates and returns 3D double precision floating 
point coordinates reflected about the Z axis or yawed 180 degrees.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgCoord3dReflectX>mgCoord3dReflectX</A>, <A HREF=#mgCoord3dReflectY>mgCoord3dReflectY</A>, <A HREF=#mgCoord3dReflect>mgCoord3dReflect</A>, 
<A HREF=#mgCoord3dYawLeft>mgCoord3dYawLeft</A>, <A HREF=#mgCoord3dYawLeft90>mgCoord3dYawLeft90</A>, 
<A HREF=#mgCoord3dYawRight>mgCoord3dYawRight</A>, <A HREF=#mgCoord3dYawRight90>mgCoord3dYawRight90</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dRollLeft><H1 CLASS="APISYMBOL">mgCoord3dRollLeft</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dRollLeft</B> - calculates 3D coordinates rolled left by a specified angle.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dRollLeft</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>degrees</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dRollLeft</B> calculates and returns the 3D double precision floating point 
coordinates rolled left by a specified angle.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates</DD><DT><I>degrees</I></DT><DD>angle in degrees</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgCoord3dRollLeft90>mgCoord3dRollLeft90</A>, 
<A HREF=#mgCoord3dRollRight>mgCoord3dRollRight</A>, <A HREF=#mgCoord3dRollRight90>mgCoord3dRollRight90</A>, <A HREF=#mgCoord3dReflectY>mgCoord3dReflectY</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dRollLeft90><H1 CLASS="APISYMBOL">mgCoord3dRollLeft90</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dRollLeft90</B> - calculates 3D coordinates rolled left by 90 degrees.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dRollLeft90</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dRollLeft90</B> calculates and returns the 3D double precision floating point 
coordinates rolled left by 90 degrees.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgCoord3dRollLeft>mgCoord3dRollLeft</A> 
<A HREF=#mgCoord3dRollRight>mgCoord3dRollRight</A>, <A HREF=#mgCoord3dRollRight90>mgCoord3dRollRight90</A>, <A HREF=#mgCoord3dReflectY>mgCoord3dReflectY</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dRollRight><H1 CLASS="APISYMBOL">mgCoord3dRollRight</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dRollRight</B> - calculates 3D coordinates rolled right by a specified angle.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dRollRight</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>degrees</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dRollRight</B> calculates and returns the 3D double precision floating point 
coordinates rolled right by a specified angle.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates</DD><DT><I>degrees</I></DT><DD>angle in degrees</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgCoord3dRollLeft>mgCoord3dRollLeft</A>, <A HREF=#mgCoord3dRollLeft90>mgCoord3dRollLeft90</A>, 
<A HREF=#mgCoord3dRollRight90>mgCoord3dRollRight90</A>, <A HREF=#mgCoord3dReflectY>mgCoord3dReflectY</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dRollRight90><H1 CLASS="APISYMBOL">mgCoord3dRollRight90</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dRollRight90</B> - calculates 3D coordinates rolled right by 90 degrees.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dRollRight90</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dRollRight90</B> calculates and returns the 3D double precision floating point 
coordinates rolled right by 90 degrees.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgCoord3dRollLeft>mgCoord3dRollLeft</A>, <A HREF=#mgCoord3dRollLeft90>mgCoord3dRollLeft90</A>, 
<A HREF=#mgCoord3dRollRight>mgCoord3dRollRight</A>, <A HREF=#mgCoord3dReflectY>mgCoord3dReflectY</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dScalarProject><H1 CLASS="APISYMBOL">mgCoord3dScalarProject</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dScalarProject</B> - calculates the scalar projection of 
3D coordinates onto a specified axis.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>double <B>mgCoord3dScalarProject</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dScalarProject</B> calculates and returns the scalar projection 
of 3D double precision floating point coordinates onto a specified axis.</P></DD><DD><P>The original coordinates <I>coord1</I> and <I>coord2</I> are not affected.</P></DD><DD><P>Note: For efficiency, <I>coord1</I> and <I>coord2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord1</I></DT><DD>address of coordinates to project</DD><DT><I>coord2</I></DT><DD>address of coordinates of axis to project onto, 
should have a length above zero</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision floating point value.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgCoord3dVectorProject>mgCoord3dVectorProject</A>, <A HREF=#mgCoord3dOrthoProject>mgCoord3dOrthoProject</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dSetUnitized><H1 CLASS="APISYMBOL">mgCoord3dSetUnitized</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dSetUnitized</B> - calculates 3D coordinates scaled 
uniformly to have a length of 1.0.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgCoord3dSetUnitized</B> (</TD><TD><A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dSetUnitized</B> calculates and assigns 3D double precision floating point 
coordinates scaled uniformly to have a length of 1.0.</P></DD><DD><P>The original coordinate <I>coord</I> is changed.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates, should have a length above zero</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, 
<A HREF=#mgCoord3dLength>mgCoord3dLength</A>, <A HREF=#mgCoord3dLengthSquared>mgCoord3dLengthSquared</A>, 
<A HREF=#mgCoord3dUnitize>mgCoord3dUnitize</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dSubtract><H1 CLASS="APISYMBOL">mgCoord3dSubtract</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dSubtract</B> - calculates the difference of 
two 3D coordinates.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dSubtract</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dSubtract</B> calculates the difference of two 3D double 
precision floating point coordinates, <I>coord1</I> - <I>coord2</I>.</P></DD><DD><P>Note: For efficiency, <I>coord1</I> and <I>coord2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord1</I></DT><DD>address of coordinate from which <I>coord2</I> 
is subtracted</DD><DT><I>coord2</I></DT><DD>address of coordinate that is subracted 
<I>coord1</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgCoord3dAdd>mgCoord3dAdd</A>, <A HREF=#mgCoord3dMultiply>mgCoord3dMultiply</A>, <A HREF=#mgCoord3dDivide>mgCoord3dDivide</A>, 
<A HREF=#mgCoord3dLerp>mgCoord3dLerp</A>, <A HREF=#mgCoord3dNegate>mgCoord3dNegate</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dToCoord3f><H1 CLASS="APISYMBOL">mgCoord3dToCoord3f</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dToCoord3f</B> - converts a 3D coordinate from double 
to single precision floating point.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3f <B>mgCoord3dToCoord3f</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dToCoord3f</B> converts the specified 3D double precision 
floating point coordinate to a 3D single precision floating point coordinate.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of double precision 3D coordinate to convert</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a single precision coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3f>mgcoord3f</A>, <A HREF=#mgcoord3d>mgcoord3d</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dToVectord><H1 CLASS="APISYMBOL">mgCoord3dToVectord</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dToVectord</B> - converts a 3D double precision 
floating point coordinate to a double precision floating point vector.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgvectord <B>mgCoord3dToVectord</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dToVectord</B> converts the specified 3D double precision 
floating point coordinate <I>coord</I> to a double precision floating point vector.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of 3D coordinate to convert</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision floating point vector.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgVectorfToVectord>mgVectorfToVectord</A>, <A HREF=#mgVectordToVectorf>mgVectordToVectorf</A>, <A HREF=#mgVectordToCoord3d>mgVectordToCoord3d</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dTransform><H1 CLASS="APISYMBOL">mgCoord3dTransform</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dTransform</B> - transforms a double precision 
coordinate using a specified matrix.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dTransform</B> (</TD><TD>const <A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dTransform</B> applies the specified <I>matrix</I> to the 
specified 3D double precision floating point coordinate <I>coord</I> and 
returns the resulting coordinate.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>matrix</I> and <I>coord</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to apply to <I>coord</I></DD><DT><I>coord</I></DT><DD>coordinate to transform</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the transformed double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgmatrix>mgmatrix</A>, <A HREF=#mgCoord3fTransform>mgCoord3fTransform</A> 
<A HREF=#mgVectordTransform>mgVectordTransform</A>, <A HREF=#mgVectorfTransform>mgVectorfTransform</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dUnitize><H1 CLASS="APISYMBOL">mgCoord3dUnitize</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dUnitize</B> - calculates 3D coordinates scaled 
uniformly to have a length of 1.0.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dUnitize</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dUnitize</B> calculates and returns 3D double precision floating point 
coordinates scaled uniformly to have a length of 1.0.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates, should have a length above zero</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, 
<A HREF=#mgCoord3dLength>mgCoord3dLength</A>, <A HREF=#mgCoord3dLengthSquared>mgCoord3dLengthSquared</A>, 
<A HREF=#mgCoord3dSetUnitized>mgCoord3dSetUnitized</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dVectorProject><H1 CLASS="APISYMBOL">mgCoord3dVectorProject</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dVectorProject</B> - calculates the vector projection of 
3D coordinates onto a specified axis.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dVectorProject</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dVectorProject</B> calculates and returns the vector projection 
of 3D double precision floating point coordinates onto a specified axis.</P></DD><DD><P>The original coordinates <I>coord1</I> and <I>coord2</I> are not affected.</P></DD><DD><P>Note: For efficiency, <I>coord1</I> and <I>coord2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord1</I></DT><DD>address of coordinates to project</DD><DT><I>coord2</I></DT><DD>address of coordinates of axis to project onto, 
should have a length above zero</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgCoord3dScalarProject>mgCoord3dScalarProject</A>, <A HREF=#mgCoord3dOrthoProject>mgCoord3dOrthoProject</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dXAxis><H1 CLASS="APISYMBOL">mgCoord3dXAxis</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dXAxis</B> - returns (1.0, 0.0, 0.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgcoord3d <B>mgCoord3dXAxis</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dXAxis</B> returns (1.0, 0.0, 0.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (1.0, 0.0, 0.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, 
<A HREF=#mgCoord3dNegativeXAxis>mgCoord3dNegativeXAxis</A>, 
<A HREF=#mgCoord3dYAxis>mgCoord3dYAxis</A>, <A HREF=#mgCoord3dNegativeYAxis>mgCoord3dNegativeYAxis</A>, 
<A HREF=#mgCoord3dZAxis>mgCoord3dZAxis</A>, <A HREF=#mgCoord3dNegativeZAxis>mgCoord3dNegativeZAxis</A>, 
<A HREF=#mgCoord3dZero>mgCoord3dZero</A>, <A HREF=#mgCoord3dOne>mgCoord3dOne</A>, <A HREF=#mgCoord3dNegativeOne>mgCoord3dNegativeOne</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dYawLeft><H1 CLASS="APISYMBOL">mgCoord3dYawLeft</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dYawLeft</B> - calculates 3D coordinates yawed left by a specified angle.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dYawLeft</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>degrees</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dYawLeft</B> calculates and returns the 3D double precision floating point 
coordinates yawed left by a specified angle.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates</DD><DT><I>degrees</I></DT><DD>angle in degrees</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgCoord3dYawLeft90>mgCoord3dYawLeft90</A>, 
<A HREF=#mgCoord3dYawRight>mgCoord3dYawRight</A>, <A HREF=#mgCoord3dYawRight90>mgCoord3dYawRight90</A>, <A HREF=#mgCoord3dReflectZ>mgCoord3dReflectZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dYawLeft90><H1 CLASS="APISYMBOL">mgCoord3dYawLeft90</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dYawLeft90</B> - calculates 3D coordinates yawed left by 90 degrees.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dYawLeft90</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dYawLeft90</B> calculates and returns the 3D double precision floating point 
coordinates yawed left by 90 degrees.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgCoord3dYawLeft>mgCoord3dYawLeft</A>, 
<A HREF=#mgCoord3dYawRight>mgCoord3dYawRight</A>, <A HREF=#mgCoord3dYawRight90>mgCoord3dYawRight90</A>, <A HREF=#mgCoord3dReflectZ>mgCoord3dReflectZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dYawRight><H1 CLASS="APISYMBOL">mgCoord3dYawRight</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dYawRight</B> - calculates 3D coordinates yawed right by a specified angle.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dYawRight</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>degrees</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dYawRight</B> calculates and returns the 3D double precision floating point 
coordinates yawed right by a specified angle.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates</DD><DT><I>degrees</I></DT><DD>angle in degrees</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgCoord3dYawLeft>mgCoord3dYawLeft</A>, <A HREF=#mgCoord3dYawLeft90>mgCoord3dYawLeft90</A>, 
<A HREF=#mgCoord3dYawRight90>mgCoord3dYawRight90</A>, <A HREF=#mgCoord3dReflectZ>mgCoord3dReflectZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dYawRight90><H1 CLASS="APISYMBOL">mgCoord3dYawRight90</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dYawRight90</B> - calculates 3D coordinates yawed right by 90 degrees.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3dYawRight90</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dYawRight90</B> calculates and returns the 3D double precision floating point 
coordinates yawed right by 90 degrees.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of coordinates</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgCoord3dYawLeft>mgCoord3dYawLeft</A>, <A HREF=#mgCoord3dYawLeft90>mgCoord3dYawLeft90</A>, 
<A HREF=#mgCoord3dYawRight>mgCoord3dYawRight</A>, <A HREF=#mgCoord3dReflectZ>mgCoord3dReflectZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dYAxis><H1 CLASS="APISYMBOL">mgCoord3dYAxis</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dYAxis</B> - returns (0.0, 1.0, 0.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgcoord3d <B>mgCoord3dYAxis</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dYAxis</B> returns (0.0, 1.0, 0.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (0.0, 1.0, 0.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A> 
<A HREF=#mgCoord3dXAxis>mgCoord3dXAxis</A>, <A HREF=#mgCoord3dNegativeXAxis>mgCoord3dNegativeXAxis</A>, 
<A HREF=#mgCoord3dNegativeYAxis>mgCoord3dNegativeYAxis</A>, 
<A HREF=#mgCoord3dZAxis>mgCoord3dZAxis</A>, <A HREF=#mgCoord3dNegativeZAxis>mgCoord3dNegativeZAxis</A>, 
<A HREF=#mgCoord3dZero>mgCoord3dZero</A>, <A HREF=#mgCoord3dOne>mgCoord3dOne</A>, <A HREF=#mgCoord3dNegativeOne>mgCoord3dNegativeOne</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dZAxis><H1 CLASS="APISYMBOL">mgCoord3dZAxis</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dZAxis</B> - returns (0.0, 0.0, 1.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgcoord3d <B>mgCoord3dZAxis</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dZAxis</B> returns (0.0, 0.0, 1.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (0.0, 0.0, 1.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A> 
<A HREF=#mgCoord3dXAxis>mgCoord3dXAxis</A>, <A HREF=#mgCoord3dNegativeXAxis>mgCoord3dNegativeXAxis</A>, 
<A HREF=#mgCoord3dYAxis>mgCoord3dYAxis</A>, <A HREF=#mgCoord3dNegativeYAxis>mgCoord3dNegativeYAxis</A>, 
<A HREF=#mgCoord3dNegativeZAxis>mgCoord3dNegativeZAxis</A>, 
<A HREF=#mgCoord3dZero>mgCoord3dZero</A>, <A HREF=#mgCoord3dOne>mgCoord3dOne</A>, <A HREF=#mgCoord3dNegativeOne>mgCoord3dNegativeOne</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3dZero><H1 CLASS="APISYMBOL">mgCoord3dZero</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3dZero</B> - returns (0.0, 0.0, 0.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgcoord3d <B>mgCoord3dZero</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3dZero</B> returns (0.0, 0.0, 0.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (0.0, 0.0, 0.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A> 
<A HREF=#mgCoord3dXAxis>mgCoord3dXAxis</A>, <A HREF=#mgCoord3dNegativeXAxis>mgCoord3dNegativeXAxis</A>, 
<A HREF=#mgCoord3dYAxis>mgCoord3dYAxis</A>, <A HREF=#mgCoord3dNegativeYAxis>mgCoord3dNegativeYAxis</A>, 
<A HREF=#mgCoord3dZAxis>mgCoord3dZAxis</A>, <A HREF=#mgCoord3dNegativeZAxis>mgCoord3dNegativeZAxis</A>, 
<A HREF=#mgCoord3dOne>mgCoord3dOne</A>, <A HREF=#mgCoord3dNegativeOne>mgCoord3dNegativeOne</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3fToCoord3d><H1 CLASS="APISYMBOL">mgCoord3fToCoord3d</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3fToCoord3d</B> - converts a 3D coordinate from single 
to double precision floating point.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3fToCoord3d</B> (</TD><TD>const <A HREF=#mgcoord3f>mgcoord3f*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3fToCoord3d</B> converts the specified 3D single precision 
floating point coordinate to a 3D double precision floating point coordinate.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>address of single precision 3D coordinate to convert</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a single precision coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3f>mgcoord3f</A>, <A HREF=#mgcoord3d>mgcoord3d</A></DD></DL>
<HR>
<LEFT><A NAME=mgCoord3fTransform><H1 CLASS="APISYMBOL">mgCoord3fTransform</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCoord3fTransform</B> - transforms a single precision 
coordinate using a specified matrix.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgCoord3fTransform</B> (</TD><TD>const <A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3f>mgcoord3f*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCoord3fTransform</B> applies the specified <I>matrix</I> to the 
specified 3D single precision floating point coordinate <I>coord</I> and 
returns the resulting coordinate.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>matrix</I> and <I>coord</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to apply to <I>coord</I></DD><DT><I>coord</I></DT><DD>coordinate to transform</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the transformed single precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgmatrix>mgmatrix</A>, <A HREF=#mgCoord3dTransform>mgCoord3dTransform</A>, 
<A HREF=#mgVectordTransform>mgVectordTransform</A>, <A HREF=#mgVectorfTransform>mgVectorfTransform</A></DD></DL>
<HR>
<LEFT><A NAME=mgCopyEyePoint><H1 CLASS="APISYMBOL">mgCopyEyePoint</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCopyEyePoint</B> - copies from one eyepoint record to another.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgCopyEyePoint</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>to</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>from</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCopyEyePoint</B> copies all the eyepoint attributes from <I>from</I> to 
<I>to</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>to</I></DT><DD>the original <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltEyePoint>fltEyePoint</A>
 record</DD><DT><I>from</I></DT><DD>the new <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltEyePoint>fltEyePoint</A>
 record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<HR>
<LEFT><A NAME=mgCopyTexture><H1 CLASS="APISYMBOL">mgCopyTexture</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCopyTexture</B> - makes a copy of a texture palette entry.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgCopyTexture</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>dstDb</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>srcDb</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>newTextureName</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>srcIndex</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCopyTexture</B> makes a new texture palette entry from a source database 
<I>srcDb</I>, and index <I>srcIndex</I>, and loads it in the destination database&#146s 
<I>dstDb</I> texture palette using the first available index and the given 
texture name <I>newTextureName</I>.</P></DD><DD><P>The texture can be copied from one database to another, or it can be 
copied to a new index in the same database by specifying the same database 
for <I>dstDb</I> and <I>srcDb</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>dstDb</I></DT><DD>the destination database node</DD><DT><I>srcDb</I></DT><DD>the source database node</DD><DT><I>newTextureName</I></DT><DD>the name of the new entry (the copy)</DD><DT><I>srcIndex</I></DT><DD>the index of the texture palette entry 
to be copied</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the index of the new entry.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgCopyTexturePalette>mgCopyTexturePalette</A></DD></DL>
<HR>
<LEFT><A NAME=mgCopyTexturePalette><H1 CLASS="APISYMBOL">mgCopyTexturePalette</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCopyTexturePalette</B> - copies a texture palette from one 
database to another.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgCopyTexturePalette</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>dstDb</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>srcDb</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCopyTexturePalette</B> copies the texture palette of one database, 
<I>srcDb</I> to another database <I>dstDb</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>dstDb</I></DT><DD>the database to copy the palette to</DD><DT><I>srcDb</I></DT><DD>the database to copy the palette from</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgCopyTexture>mgCopyTexture</A></DD></DL>
<HR>
<LEFT><A NAME=mgCountAttrChild><H1 CLASS="APISYMBOL">mgCountAttrChild</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCountAttrChild</B> - gets the number of attribute children of a node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgCountAttrChild</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCountAttrChild</B> returns the number of attribute children directly 
below the specified node <I>rec</I>.  Descendants of the attribute children are 
not counted in the total.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to count attribute children</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of attribute child nodes immediately below the node.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgCountChild>mgCountChild</A>, <A HREF=#mgCountNestedChild>mgCountNestedChild</A></DD></DL>
<HR>
<LEFT><A NAME=mgCountChild><H1 CLASS="APISYMBOL">mgCountChild</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCountChild</B> - gets the number of immediate children of a node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgCountChild</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCountChild</B> returns the number of children directly below the 
specified node <I>rec</I>.  Descendants of the children are not counted in 
the total.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to count children</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of child nodes immediately below the node.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetChildNth>mgGetChildNth</A>, <A HREF=#mgCountNestedChild>mgCountNestedChild</A>, <A HREF=#mgCountAttrChild>mgCountAttrChild</A></DD></DL>
<HR>
<LEFT><A NAME=mgCountNestedChild><H1 CLASS="APISYMBOL">mgCountNestedChild</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCountNestedChild</B> - gets the number of nested children of a node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgCountNestedChild</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCountNestedChild</B> returns the number of nested children directly 
below the specified node <I>rec</I>.  Descendants of the nested children are 
not counted in the total.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to count nested children</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of nested child nodes immediately below the node.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgCountChild>mgCountChild</A>, <A HREF=#mgCountAttrChild>mgCountAttrChild</A></DD></DL>
<HR>
<LEFT><A NAME=mgCountXform><H1 CLASS="APISYMBOL">mgCountXform</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgCountXform</B> - gets the number of transformations associated to a node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgCountXform</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgCountXform</B> returns the number of transformations directly attached to the 
specified node <I>rec</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to count transformations</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of transformations associated to a node.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetXform>mgGetXform</A>, <A HREF=#mgHasXform>mgHasXform</A>, <A HREF=#mgGetXformType>mgGetXformType</A></DD></DL>
<HR>
<LEFT><A NAME=mgcreatefunc><H1 CLASS="APISYMBOL">mgcreatefunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgcreatefunc</B> - Create function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus (*<B>mgcreatefunc</B>) ( <TD><A HREF=#mgrec>mgrec*</A> <TD><I>db</I>, 
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A> <TD><I>rec</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for create action functions. 
If your data extension declares one or more new node types, you may assign 
a create function for each new node type you have.  If you have assigned 
such a function for a node type, it will be called when a node of that type is 
created by the user either through the Extensions Menu or the Create Tool.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database to which the node belongs</DD><DT><I>rec</I></DT><DD>the node just created</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>The value returned by <B>mgusercreatefunc</B> is currently ignored and 
reserved for future enhancement.  For now, you should always return <A HREF=#MSTAT_OK>MSTAT_OK</A>.
</DD></DL><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterSite>mgRegisterSite</A>, <A HREF=#mgRegisterCreate>mgRegisterCreate</A></DD></DL>
<HR>
<LEFT><A NAME=mgCursorIdsMatch><H1 CLASS="APISYMBOL">mgCursorIdsMatch</H1></A></LEFT>
<DL>
<DT><H3>MACRO NAME</H3></DT>
<DD><B>mgCursorIdsMatch</B> - Checks if two cursor identifiers match.<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgCursorIdsMatch</B> (</TD><TD><A HREF=#></A></TD><TD><I>id1</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>id2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns 1 if identifiers match, 0 otherwise.
</DD></DL><DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>id1</I></DT><DD>A cursor identifier</DD><DT><I>id2</I></DT><DD>Another cursor identifier</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgStringIdsMatch>mgStringIdsMatch</A>, <A HREF=#mgPixmapIdsMatch>mgPixmapIdsMatch</A>, 
<A HREF=#mgControlIdsMatch>mgControlIdsMatch</A></DD></DL>
<HR>
<LEFT><A NAME=mgDeclarePlugin><H1 CLASS="APISYMBOL">mgDeclarePlugin</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDeclarePlugin</B> - Declares a plug-in module.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD> <B>mgDeclarePlugin</B> ( <TD><A HREF=#></A> <TD><I>vendor</I>, 
<TR><TD></TD><TD><A HREF=#></A> <TD><I>name</I>, 
<TR><TD></TD><TD><A HREF=#></A> <TD><I>uuid</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>You must instantiate this macro at the outer most 
scope of your source code so that your plug-in is properly recognized.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>vendor</I></DT><DD>a string representing the name of the vendor of the plug-in</DD><DT><I>name</I></DT><DD>a string representing the name of the plug-in</DD><DT><I>uuid</I></DT><DD>a Universally Unique Identifier to identify the plug-in 
(On Windows, use the <B>uuidgen</B> utility to generate this identifier)</DD></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows how to declare a plug-in module.</DT><DT><PRE CLASS="EXAMPLE">mgDeclarePlugin(
   "My Company",
   "My Plugin",
   "453E73F2-6DD8-4164-A6F3-B59E4C57998A"
);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Instantiated by Plug-in Module</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgpInit>mgpInit</A>, <A HREF=#mgpExit>mgpExit</A></DD></DL>
<HR>
<LEFT><A NAME=mgDelete><H1 CLASS="APISYMBOL">mgDelete</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDelete</B> - deletes a node, transformation, tag-along extension or texture attribute record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgDelete</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a node, transformation, tag-along extension or texture attribute record <I>rec</I>, <B>mgDelete</B> 
deletes it.  If the record is a node in the database and has children, its descendants are 
recursively deleted as well.  This deletion is permanent and there is no "undo".</P></DD><DD><P>When deleting node or transformation records, the corresponding record 
is deleted and removed from the database.  For example if you delete a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltGroup>fltGroup</A>
 
node the group and children are deleted and removed from the database scene graph. 
Similarly if you delete a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXmTranslate>fltXmTranslate</A>
 (or other transformation) record 
attached to a node in the database, the transformation is deleted and removed 
from that node.  This effectively removes the transformation from the node.</P></DD><DD><P>When deleting texture attribute records, however, the corresponding record is 
deallocated only.  The corresponding texture is not removed from any texture 
palette it might be in (use <A HREF=#mgDeleteTexture>mgDeleteTexture</A> to delete a texture from 
its palette).  You should only use <B>mgDelete</B> to delete texture attribute 
records returned by <A HREF=#mgReadImageAttributes>mgReadImageAttributes</A>, not <A HREF=#mgGetTextureAttributes>mgGetTextureAttributes</A>.</P></DD><DD><P>To delete a tag-along extension record, use <A HREF=#mgGetExtRec>mgGetExtRec</A> to get the pointer 
to the tag-along extension record, then pass that pointer to <B>mgDelete</B>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record to delete</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgDetach>mgDetach</A>, <A HREF=#mgRemove>mgRemove</A>, <A HREF=#mgUnRemove>mgUnRemove</A></DD></DL>
<HR>
<LEFT><A NAME=mgDeleteAllConstructs><H1 CLASS="APISYMBOL">mgDeleteAllConstructs</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDeleteAllConstructs</B> - deletes all construction vertices 
and edges for a given editor tool instance.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgDeleteAllConstructs</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDeleteAllConstructs</B> deletes all construction vertices and 
edges associated with the editor tool instance 
identified by editor context, <I>editorContext</I>.</P></DD><DD><P>This function is typically called in the termination function of your 
editor tool.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context for which 
all construction nodes are to be 
deleted</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewConstructVertex>mgNewConstructVertex</A>, <A HREF=#mgNewConstructEdge>mgNewConstructEdge</A>, 
<A HREF=#mgDeleteConstructVertex>mgDeleteConstructVertex</A>, <A HREF=#mgDeleteConstructEdge>mgDeleteConstructEdge</A></DD></DL>
<HR>
<LEFT><A NAME=mgDeleteColorName><H1 CLASS="APISYMBOL">mgDeleteColorName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDeleteColorName</B> - deletes a name from a color 
palette entry&#146s color name list.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgDeleteColorName</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>name</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a database node, <I>db</I>, and an index into the color palette, 
<I>index</I>, <B>mgDeleteColorName</B> deletes the color name <I>name</I> from 
the color name list for <I>index</I>. 
An index of -1 means "search the entire color palette".</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the color palette index, or -1 for the entire palette</DD><DT><I>name</I></DT><DD>the color name to delete from the entry&#146s name list</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewColorName>mgNewColorName</A>, <A HREF=#mgSetCurrentColorName>mgSetCurrentColorName</A>, <A HREF=#mgGetColorIndexByName>mgGetColorIndexByName</A></DD></DL>
<HR>
<LEFT><A NAME=mgDeleteComment><H1 CLASS="APISYMBOL">mgDeleteComment</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDeleteComment</B> - deletes the comment text of a node record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgDeleteComment</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDeleteComment</B> deallocates the memory used (if any) by the comment text of the 
node record <I>rec</I>. Note that vertex node records do not have comment text.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>points to the node record whose comment text is to be deleted</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetComment>mgGetComment</A>, <A HREF=#mgSetComment>mgSetComment</A></DD></DL>
<HR>
<LEFT><A NAME=mgDeleteConstructEdge><H1 CLASS="APISYMBOL">mgDeleteConstructEdge</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDeleteConstructEdge</B> - deletes a construction edge node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgDeleteConstructEdge</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>constructEdge</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDeleteConstructEdge</B> deletes the specified construction edge 
node <I>constructEdge</I>.</P></DD><DD><P>This function is typically called in the termination function of your 
editor tool.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>constructEdge</I></DT><DD>the construction edge to delete</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewConstructEdge>mgNewConstructEdge</A>, <A HREF=#mgDeleteConstructVertex>mgDeleteConstructVertex</A>, <A HREF=#mgDeleteAllConstructs>mgDeleteAllConstructs</A></DD></DL>
<HR>
<LEFT><A NAME=mgDeleteConstructVertex><H1 CLASS="APISYMBOL">mgDeleteConstructVertex</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDeleteConstructVertex</B> - deletes a construction vertex node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgDeleteConstructVertex</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>constructVtx</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDeleteConstructVertex</B> deletes the specified construction vertex 
node <I>constructVtx</I>.</P></DD><DD><P>This function is typically called in the termination function of your 
editor tool.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>constructVtx</I></DT><DD>the construction vertex to delete</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewConstructVertex>mgNewConstructVertex</A>, <A HREF=#mgDeleteConstructEdge>mgDeleteConstructEdge</A>, <A HREF=#mgDeleteAllConstructs>mgDeleteAllConstructs</A></DD></DL>
<HR>
<LEFT><A NAME=mgDeleteLightPointAnimation><H1 CLASS="APISYMBOL">mgDeleteLightPointAnimation</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDeleteLightPointAnimation</B> - deletes an entry in the light 
point animation palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgDeleteLightPointAnimation</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDeleteLightPointAnimation</B> deletes a light point animation 
palette entry for database <I>db</I>.  The entry deleted is specified by <I>index</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the entry to delete</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the entry was deleted successfully, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewLightPointAnimation>mgNewLightPointAnimation</A>, 
<A HREF=#mgGetLightPointAnimation>mgGetLightPointAnimation</A>, 
<A HREF=#mgDeleteLightPointAppearance>mgDeleteLightPointAppearance</A></DD></DL>
<HR>
<LEFT><A NAME=mgDeleteLightPointAppearance><H1 CLASS="APISYMBOL">mgDeleteLightPointAppearance</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDeleteLightPointAppearance</B> - deletes an entry in the light 
point appearance palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgDeleteLightPointAppearance</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDeleteLightPointAppearance</B> deletes a light point appearance 
palette entry for database <I>db</I>.  The entry deleted is specified by <I>index</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the entry to delete</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the entry was deleted successfully, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewLightPointAppearance>mgNewLightPointAppearance</A>, 
<A HREF=#mgGetLightPointAppearance>mgGetLightPointAppearance</A>, 
<A HREF=#mgDeleteLightPointAnimation>mgDeleteLightPointAnimation</A></DD></DL>
<HR>
<LEFT><A NAME=mgDeleteLightSource><H1 CLASS="APISYMBOL">mgDeleteLightSource</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDeleteLightSource</B> - deletes an entry in the light 
source palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgDeleteLightSource</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDeleteLightSource</B> deletes a light source 
palette entry for database <I>db</I>.  The entry deleted is specified by <I>index</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the entry to delete</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the entry was deleted successfully, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewLightSource>mgNewLightSource</A></DD></DL>
<HR>
<LEFT><A NAME=mgDeleteLineStyle><H1 CLASS="APISYMBOL">mgDeleteLineStyle</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDeleteLineStyle</B> - deletes an entry in the light 
source palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgDeleteLineStyle</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDeleteLineStyle</B> deletes a line style 
palette entry for database <I>db</I>.  The entry deleted is specified by <I>index</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the entry to delete</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the entry was deleted successfully, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewLineStyle>mgNewLineStyle</A></DD></DL>
<HR>
<LEFT><A NAME=mgDeleteMaterial><H1 CLASS="APISYMBOL">mgDeleteMaterial</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDeleteMaterial</B> - deletes an entry, defined by the 
material&#146s index, from a database&#146s material palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgDeleteMaterial</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDeleteMaterial</B> deletes the entry defined by the material&#146s 
index, <I>index</I>, from the material palette associated with database 
node <I>db</I>. If no material entry is found matching <I>index</I>, the material 
palette remains unchanged.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of material to delete</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgDeleteMaterialByName>mgDeleteMaterialByName</A>, <A HREF=#mgIndexOfMaterial>mgIndexOfMaterial</A></DD></DL>
<HR>
<LEFT><A NAME=mgDeleteMaterialByName><H1 CLASS="APISYMBOL">mgDeleteMaterialByName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDeleteMaterialByName</B> - deletes a material entry from a 
database&#146s material palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgDeleteMaterialByName</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>name</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDeleteMaterialByName</B> deletes the material entry defined 
by <I>name</I> from the material palette associated with database 
node <I>db</I>. If no material entry is found matching <I>name</I>, the 
material palette remains unchanged.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>name</I></DT><DD>the name of the material to delete</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgDeleteMaterial>mgDeleteMaterial</A>, <A HREF=#mgNameOfMaterial>mgNameOfMaterial</A></DD></DL>
<HR>
<LEFT><A NAME=mgDeleteShader><H1 CLASS="APISYMBOL">mgDeleteShader</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDeleteShader</B> - deletes an entry, defined by the 
shader&#146s index, from a database&#146s shader palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgDeleteShader</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDeleteShader</B> deletes the entry defined by the shader&#146s 
index, <I>index</I>, from the shader palette associated with database 
node <I>db</I>. If no shader entry is found matching <I>index</I>, the shader 
palette remains unchanged.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of shader to delete</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgDeleteShaderByName>mgDeleteShaderByName</A>, <A HREF=#mgIndexOfShader>mgIndexOfShader</A></DD></DL>
<HR>
<LEFT><A NAME=mgDeleteShaderByName><H1 CLASS="APISYMBOL">mgDeleteShaderByName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDeleteShaderByName</B> - deletes a shader entry from a 
database&#146s shader palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgDeleteShaderByName</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>name</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDeleteShaderByName</B> deletes the shader entry defined 
by <I>name</I> from the shader palette associated with database 
node <I>db</I>. If no shader entry is found matching <I>name</I>, the 
shader palette remains unchanged.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>name</I></DT><DD>the name of the shader to delete</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgDeleteShader>mgDeleteShader</A>, <A HREF=#mgNameOfShader>mgNameOfShader</A></DD></DL>
<HR>
<LEFT><A NAME=mgDeleteSound><H1 CLASS="APISYMBOL">mgDeleteSound</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDeleteSound</B> - deletes an entry, defined by the sound&#146s 
index, from a database&#146s sound palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgDeleteSound</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDeleteSound</B> deletes the entry defined by the sound&#146s index 
from the sound palette associated with database node <I>db</I>. If no sound entry 
is found matching index, the sound palette remains unchanged.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the sound record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewSound>mgNewSound</A></DD></DL>
<HR>
<LEFT><A NAME=mgDeleteSwitchMask><H1 CLASS="APISYMBOL">mgDeleteSwitchMask</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDeleteSwitchMask</B> - deletes a mask from a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSwitch>fltSwitch</A>
 node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgDeleteSwitchMask</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maskNo</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDeleteSwitchMask</B> deletes the mask specified by <I>maskNo</I> from 
a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSwitch>fltSwitch</A>
 node.  Upon successful completion, the indices of all 
masks after the one deleted are decremented by one.</P></DD><DD><P>The value of <I>maskNo</I> must be between 0 and the number of masks 
of <I>rec</I> minus 1 (the first mask is <I>maskNo</I> 0).</P></DD><DD><P>Note: Since a switch must have at least one mask, 
<B>mgDeleteSwitchMask</B> will not delete the last mask.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSwitch>fltSwitch</A>
 node</DD><DT><I>maskNo</I></DT><DD>mask index to be deleted, 0 is the first mask</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the new current mask index if successful, -1 otherwise. 
This function will fail if <I>maskNo</I> does not specify a valid mask of <I>rec</I>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetSwitchMaskCount>mgGetSwitchMaskCount</A>, 
<A HREF=#mgGetSwitchMaskNo>mgGetSwitchMaskNo</A>, 
<A HREF=#mgGetSwitchBit>mgGetSwitchBit</A>, 
<A HREF=#mgGetSwitchMaskName>mgGetSwitchMaskName</A>, 
<A HREF=#mgAddSwitchMask>mgAddSwitchMask</A>, 
<A HREF=#mgInitSwitchMask>mgInitSwitchMask</A>, 
<A HREF=#mgSetSwitchBit>mgSetSwitchBit</A>, 
<A HREF=#mgSetSwitchMaskName>mgSetSwitchMaskName</A></DD></DL>
<HR>
<LEFT><A NAME=mgDeleteTexture><H1 CLASS="APISYMBOL">mgDeleteTexture</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDeleteTexture</B> - deletes an entry from a database's texture 
palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgDeleteTexture</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDeleteTexture</B> deletes a texture palette entry specified by its 
<I>index</I>, from the texture palette of the specified database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the texture palette entry</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgInsertTexture>mgInsertTexture</A>, <A HREF=#mgReadTexture>mgReadTexture</A>, <A HREF=#mgReplaceTexture>mgReplaceTexture</A>, 
<A HREF=#mgMoveTexture>mgMoveTexture</A></DD></DL>
<HR>
<LEFT><A NAME=mgDeleteTextureMapping><H1 CLASS="APISYMBOL">mgDeleteTextureMapping</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDeleteTextureMapping</B> - deletes an entry, defined by the 
texture mapping&#146s index, from a database&#146s texture mapping palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgDeleteTextureMapping</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDeleteTextureMapping</B> deletes the entry defined by the texture 
mapping&#146s index, <I>index</I>, from the texture mapping palette associated 
with database node <I>db</I>.  If no texture mapping entry is found matching 
<I>index</I>, the texture mapping palette remains unchanged.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of texture mapping to delete</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgDeleteTextureMappingByName>mgDeleteTextureMappingByName</A>, <A HREF=#mgIndexOfTextureMapping>mgIndexOfTextureMapping</A></DD></DL>
<HR>
<LEFT><A NAME=mgDeleteTextureMappingByName><H1 CLASS="APISYMBOL">mgDeleteTextureMappingByName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDeleteTextureMappingByName</B> - deletes a texture mapping 
entry from a database&#146s texture mapping palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgDeleteTextureMappingByName</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>name</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDeleteTextureMappingByName</B> deletes the texture mapping entry 
defined by <I>name</I> from the texture mapping palette associated with 
database node <I>db</I>. If no texture mapping entry is found matching 
<I>name</I>, the texture mapping palette remains unchanged.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>name</I></DT><DD>the name of the texture mapping to delete</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgDeleteTextureMapping>mgDeleteTextureMapping</A>, <B>mgNameOfTextureMapping</B></DD></DL>
<HR>
<LEFT><A NAME=mgDeReference><H1 CLASS="APISYMBOL">mgDeReference</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDeReference</B> - makes an existing instance node record into a regular node record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgDeReference</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDeReference</B> removes the instance relationship between <I>rec</I> and its reference node.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>an instance node record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReference>mgReference</A></DD></DL>
<HR>
<LEFT><A NAME=mgDeselectAll><H1 CLASS="APISYMBOL">mgDeselectAll</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDeselectAll</B> - deselects all node records.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgDeselectAll</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDeselectAll</B> deselects all node records for the specified 
database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database to de-select all for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSelectOne>mgSelectOne</A>, <A HREF=#mgSelectOneEx>mgSelectOneEx</A>, <A HREF=#mgSelectOneEdge>mgSelectOneEdge</A>, <A HREF=#mgDeselectOne>mgDeselectOne</A>, 
<A HREF=#mgIsSelected>mgIsSelected</A>, <A HREF=#mgIsSelectedEdge>mgIsSelectedEdge</A>, <A HREF=#mgSelectList>mgSelectList</A></DD></DL>
<HR>
<LEFT><A NAME=mgDeselectAllTextures><H1 CLASS="APISYMBOL">mgDeselectAllTextures</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDeselectAllTextures</B> - de-selects all textures in the palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgDeselectAllTextures</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDeselectAllTextures</B> de-selects all the textures in the texture 
palette of the database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSelectTextureIndex>mgSelectTextureIndex</A>, 
<A HREF=#mgDeselectTextureIndex>mgDeselectTextureIndex</A>, 
<A HREF=#mgGetFirstSelectedTexture>mgGetFirstSelectedTexture</A>, 
<A HREF=#mgGetNextSelectedTexture>mgGetNextSelectedTexture</A>, 
<A HREF=#mgGetSelectedTextureCount>mgGetSelectedTextureCount</A>, 
<A HREF=#mgIsTextureIndexSelected>mgIsTextureIndexSelected</A></DD></DL>
<HR>
<LEFT><A NAME=mgDeselectOne><H1 CLASS="APISYMBOL">mgDeselectOne</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDeselectOne</B> - deselect a node record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgDeselectOne</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDeselectOne</B> deselects the specified node record <I>rec</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to de-select</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSelectOne>mgSelectOne</A>, <A HREF=#mgSelectOneEx>mgSelectOneEx</A>, <A HREF=#mgSelectOneEdge>mgSelectOneEdge</A>, <A HREF=#mgIsSelected>mgIsSelected</A>, 
<A HREF=#mgIsSelectedEdge>mgIsSelectedEdge</A>, <A HREF=#mgDeselectAll>mgDeselectAll</A>, <A HREF=#mgSelectList>mgSelectList</A></DD></DL>
<HR>
<LEFT><A NAME=mgDeselectTextureIndex><H1 CLASS="APISYMBOL">mgDeselectTextureIndex</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDeselectTextureIndex</B> - de-selects a texture in the palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgDeselectTextureIndex</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDeselectTextureIndex</B> de-selects the texture with the specified <I>index</I> 
in the texture palette of the database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the texture palette entry 
to de-select</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSelectTextureIndex>mgSelectTextureIndex</A>, 
<A HREF=#mgDeselectAllTextures>mgDeselectAllTextures</A>, 
<A HREF=#mgGetFirstSelectedTexture>mgGetFirstSelectedTexture</A>, 
<A HREF=#mgGetNextSelectedTexture>mgGetNextSelectedTexture</A>, 
<A HREF=#mgGetSelectedTextureCount>mgGetSelectedTextureCount</A>, 
<A HREF=#mgIsTextureIndexSelected>mgIsTextureIndexSelected</A></DD></DL>
<HR>
<LEFT><A NAME=mgDestroyDialog><H1 CLASS="APISYMBOL">mgDestroyDialog</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDestroyDialog</B> - destroys a dialog.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgDestroyDialog</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>dialog</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDestroyDialog</B> destroys a dialog.</P></DD><DD><P>If the dialog is currently displayed, it is first hidden 
and then destroyed.</P></DD><DD><P>If the destroy dialog event has been selected for the dialog function, 
it is sent.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>dialog</I></DT><DD>dialog to destroy</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgDestroyDialogCallback>mgDestroyDialogCallback</A>, <A HREF=#mgShowDialog>mgShowDialog</A>, <A HREF=#mgHideDialog>mgHideDialog</A>, 
<A HREF=#mgRefreshDialog>mgRefreshDialog</A></DD></DL>
<HR>
<LEFT><A NAME=mgDestroyDialogCallback><H1 CLASS="APISYMBOL">mgDestroyDialogCallback</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDestroyDialogCallback</B> - built-in callback function to 
destroy a dialog when a control is activated.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgDestroyDialogCallback</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>gui</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcontrolid>mgcontrolid</A></TD><TD><I>controlId</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgguicallbackreason>mgguicallbackreason</A></TD><TD><I>callbackReason</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>callData</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDestroyDialogCallback</B> can be passed to <A HREF=#mgSetGuiCallback>mgSetGuiCallback</A> 
for a control whose <A HREF=#MGCB_ACTIVATE>MGCB_ACTIVATE</A> event causes the dialog containing 
the control to be destroyed.</P></DD><DD><P>This function is not meant to be called directly, only passed to 
<A HREF=#mgSetGuiCallback>mgSetGuiCallback</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>gui</I></DT><DD>control in the dialog to destroy</DD><DT><I>controlId</I></DT><DD>the identifier of gui</DD><DT><I>callbackReason</I></DT><DD>the control event that 
triggered the callback</DD><DT><I>userData</I></DT><DD>user data passed through</DD><DT><I>callData</I></DT><DD>call data passed through</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>In both of the following examples, a dialog contains a "Close" button 
that when pressed will cause the dialog to be destroyed.  Both examples show 
alternate implementations for setting up this behavior.  Both are functionally 
equivalent.<BR><BR> 
In this first example, the plug-in defines and assigns an explicit control 
callback function to the button control.  This callback function destroys the 
dialog containing the control when the <A HREF=#MGCB_ACTIVATE>MGCB_ACTIVATE</A> event is sent to 
the button control.</DT><DT><PRE CLASS="EXAMPLE">static mgstatus CloseCallback (mggui gui, mgcontrolid controlId,
&#32&#32&#32&#32mgguicallbackreason callbackReason,
&#32&#32&#32&#32void* userData, void* callData)
{
   if (callbackReason == MGCB_ACTIVATE)
      mgDestroyDialog (gui);
   return (MSTAT_OK);
}

static void InitializeControls (mggui dialog)
{
   mggui gui = mgFindGuiById (dialog, IDC_CLOSE);
   mgSetGuiCallback (gui, MGCB_ACTIVATE, CloseCallback, MG_NULL);
}</PRE></DT><DT>In this next example, the plug-in assigns the built-in control callback 
function <B>mgDestroyDialogCallback</B> to the button control.  This built-in callback 
destroys the dialog when the <A HREF=#MGCB_ACTIVATE>MGCB_ACTIVATE</A> event is sent to the button control. 
In this way, defining an explicit callback function is not required.</DT><DT><PRE CLASS="EXAMPLE">static void InitializeControls (mggui dialog)
{
   mggui gui = mgFindGuiById (dialog, IDC_CLOSE);
   // Note: You must select the MGCB_ACTIVATE event.
   //       If you select any other events, they are ignored.
   //       You must pass MG_NULL as the user data.
   mgSetGuiCallback (gui, MGCB_ACTIVATE, mgDestroyDialogCallback, MG_NULL);
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetGuiCallback>mgSetGuiCallback</A>, <A HREF=#mgDestroyDialog>mgDestroyDialog</A>, 
<A HREF=#mgHideDialogCallback>mgHideDialogCallback</A>, <A HREF=#mgRefreshDialogCallback>mgRefreshDialogCallback</A></DD></DL>
<HR>
<LEFT><A NAME=mgDetach><H1 CLASS="APISYMBOL">mgDetach</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDetach</B> - unlinks a node record from the database hierarchy.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgDetach</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDetach</B> unlinks a node record, <I>rec</I>, and its children from the database 
hierarchy. The node is left as an orphan, and is not deleted.</P></DD><DD><P>This function is for node and transformation records only.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record to detach</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function fails if <I>rec</I> is not attached in the hierarchy.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgDelete>mgDelete</A>, <A HREF=#mgRemove>mgRemove</A>, <A HREF=#mgUnRemove>mgUnRemove</A></DD></DL>
<HR>
<LEFT><A NAME=mgdialogfunc><H1 CLASS="APISYMBOL">mgdialogfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgdialogfunc</B> - Dialog function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus (*<B>mgdialogfunc</B>) ( <TD><A HREF=#mggui>mggui</A> <TD><I>dialog</I>, 
<TR><TD></TD><TD><A HREF=#mgdialogid>mgdialogid</A> <TD><I>dialogId</I>, 
<TR><TD></TD><TD><A HREF=#mgguicallbackreason>mgguicallbackreason</A> <TD><I>callbackReason</I>, 
<TR><TD></TD><TD>void* <TD><I>userData</I>, 
<TR><TD></TD><TD>void* <TD><I>callData</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for dialog functions. 
When you create a dialog instance, you will provide a dialog function 
of this form that will be called to notify your plug-in tool of 
significant dialog events.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>dialog</I></DT><DD>the dialog</DD><DT><I>dialogId</I></DT><DD>the identifier of the dialog</DD><DT><I>callbackReason</I></DT><DD>the dialog event that triggered the callback</DD><DT><I>userData</I></DT><DD>user defined data specified when dialog was created</DD><DT><I>callData</I></DT><DD>callback specific data - you can always safely 
cast this pointer to aa pointer to an object of type 
<A HREF=#mgguicallbackrec>mgguicallbackrec</A> to determine the type of call 
data this object really is</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Currently, the value returned by <A HREF=#mgdialogfunc>mgdialogfunc</A> is ignored and 
reserved for future enhancement.  For now always return <A HREF=#MSTAT_OK>MSTAT_OK</A>.
</DD></DL><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetDialog>mgResourceGetDialog</A>, <A HREF=#mgResourceModalDialog>mgResourceModalDialog</A></DD></DL>
<HR>
<LEFT><A NAME=mgDialogSetAttribute><H1 CLASS="APISYMBOL">mgDialogSetAttribute</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDialogSetAttribute</B> - sets the attribute values of a dialog.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgDialogSetAttribute</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>dialog</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgdialogattribute>mgdialogattribute</A></TD><TD><I>dialogAttr</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>attrValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDialogSetAttribute</B> sets the specified dialog attribute <I>dialogAttr</I> 
for the <I>dialog</I> to the specified value <I>attrValue</I>.</P></DD><DD><P>Dialog attributes define how dialogs behave in different situations. 
The dialog attributes and a brief description of each are listed below. 
These are the possible values for  <I>dialogAttr</I>.  For more information 
on the meaning of each attribute, see the description of that particular 
attribute.</P></DD><DD><P><A HREF=#mgdialogattribute>MDA_RESIZEWIDTH</A> - specifies whether or not the 
dialog's width can be resized.</P></DD><DD><P><A HREF=#mgdialogattribute>MDA_RESIZEHEIGHT</A> - specifies whether or not the 
dialog's height can be resized.</P></DD><DD><P><A HREF=#mgdialogattribute>MDA_MINWIDTH</A> - specifies the minimum width 
the dialog can be sized.</P></DD><DD><P><A HREF=#mgdialogattribute>MDA_MAXWIDTH</A> - specifies the maximum width 
the dialog can be sized.</P></DD><DD><P><A HREF=#mgdialogattribute>MDA_MINHEIGHT</A> - specifies the minimum height 
the dialog can be sized.</P></DD><DD><P><A HREF=#mgdialogattribute>MDA_MAXHEIGHT</A> - specifies the maximum height 
the dialog can be sized.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>dialog</I></DT><DD>the dialog whose attribute is to be set</DD><DT><I>dialogAttr</I></DT><DD>the dialog attribute to set</DD><DT><I>attrValue</I></DT><DD>the value to which the attribute is set</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example sets the minimum size the user can resize a 
dialog to be its current dimentions.  This would be done, most likely, 
when the <A HREF=#MGCB_INIT>MGCB_INIT</A> dialog event is handled by the dialog function.</DT><DT><PRE CLASS="EXAMPLE">mggui dialog;
int dlgW, dlgH;

mgGuiGetSize (dialog, &dlgW, &dlgH);
mgDialogSetAttribute (dialog, MDA_MINWIDTH, dlgW);
mgDialogSetAttribute (dialog, MDA_MINHEIGHT, dlgH);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetDialog>mgResourceGetDialog</A>, <A HREF=#mgShowDialog>mgShowDialog</A>, <A HREF=#mgdialogattribute>mgdialogattribute</A>, 
<A HREF=#MGCB_SIZE>MGCB_SIZE</A>, <A HREF=#mgControlSetAttribute>mgControlSetAttribute</A></DD></DL>
<HR>
<LEFT><A NAME=mgDialogSubclass><H1 CLASS="APISYMBOL">mgDialogSubclass</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDialogSubclass</B> - sets the Windows dialog function for a dialog<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgDialogSubclass</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>gui</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgguiwindowfunc>mgguiwindowfunc</A></TD><TD><I>dialogProc</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDialogSubclass</B> allows you to "subclass" the Windows dialog associated 
with a plug-in dialog.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>gui</I></DT><DD>the control whose window procedure is to be set</DD><DT><I>dialogProc</I></DT><DD>the dialog procedure</DD><DT><I>userData</I></DT><DD>user data to be passed to window procedurewhen it is called</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows how you might subclass a plug-in dialog. 
It includes some common Windows messages that might be sent to the Windows 
dialog.</DT><DT><PRE CLASS="EXAMPLE">static int MyDialogFunc (mggui dialog, mgcontrolid controlId,
&#32       mgguihandle hDlg, int msg, int wParam, mgsize_t lParam,
&#32       void* dialogProc, void* userData)
{
   mydata* myData = (mydata*) userData;
   int answer;

   // here are some common messages that are sent to dialogs that you
   // might want to handle - see Windows documentation for complete list

   switch (msg) {
   case WM_LBUTTONDOWN:
      break;
   case WM_LBUTTONUP:
      break;
   case WM_MOUSEMOVE:
      break;
   case WM_COMMAND:
      break;
   case WM_SIZE:
      break;
   case WM_PAINT:
      break;
   case WM_CLOSE:
      // verify user  really wantS to close
      answer = mgMessageDialog (dialog, "Warning",
&#32    "Do you really want to close?",
&#32    MMBX_QUESTION|MMBX_YESNOCANCEL);
      // if user cancels, return 0 so window is not close
      if (answer != 1) return 0;
      break;
   case WM_DESTROY:
      break;
   case WM_NOTIFY:
      break;
   }
   // if our function did not handle the message, call Creator's Dialog function
   return CallWindowProc ((WNDPROC) dialogProc, (HWND)hDlg, (UINT)msg, (WPARAM)wParam, (LPARAM)lParam);
}

static void InitDialog (mggui dialog, mydata* myData)
{
   mgControlSubclass (dialog, MyDialogFunc, myData);
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetGuiHandle>mgGetGuiHandle</A>, <A HREF=#mgControlSubclass>mgControlSubclass</A></DD></DL>
<HR>
<LEFT><A NAME=mgDrawControl><H1 CLASS="APISYMBOL">mgDrawControl</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDrawControl</B> - queues a GL control for drawing.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgDrawControl</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDrawControl</B> queues the specified GL control <B>control</B> for 
drawing.</P></DD><DD><P>If the draw control event has been selected for the control callback 
of the specified GL control, the draw event is sent to the control at the 
time the queue is serviced.  The draw usually occurs immediately after the 
function scope in which <B>mgDrawControl</B> is called exits but this is not 
guaranteed.  If you want the control to draw immediately, use 
<A HREF=#mgDrawControlNow>mgDrawControlNow</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the GL control to draw</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgDrawControlNow>mgDrawControlNow</A>, <A HREF=#mgSetGuiCallback>mgSetGuiCallback</A>, <A HREF=#MGCB_DRAW>MGCB_DRAW</A></DD></DL>
<HR>
<LEFT><A NAME=mgDrawControlNow><H1 CLASS="APISYMBOL">mgDrawControlNow</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDrawControlNow</B> - draws a GL control immediately.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgDrawControlNow</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDrawControlNow</B> draws the specified GL control <B>control</B> 
immediately.</P></DD><DD><P>If the draw control event has been selected for the control callback 
of the specified GL control, the draw event is sent to the control.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the GL control to draw</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgDrawControl>mgDrawControl</A>, <A HREF=#mgSetGuiCallback>mgSetGuiCallback</A>, <A HREF=#MGCB_DRAW>MGCB_DRAW</A></DD></DL>
<HR>
<LEFT><A NAME=mgDuplicate><H1 CLASS="APISYMBOL">mgDuplicate</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDuplicate</B> - duplicates a node or transformation record in the database.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgDuplicate</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a node or transformation record <I>rec</I> in a database, <B>mgDuplicate</B> duplicates 
this record, and in the case of a node record, all of its descendants, returning the new 
(duplicate) record.</P></DD><DD><P>Note: The node or transformation returned can be attached ONLY to another node 
contained in the same database as the original record.  If you want to attach the 
duplicate record to a node contained in another database, use <A HREF=#mgDuplicateToDb>mgDuplicateToDb</A> to 
create the duplicate record.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to duplicate</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the new record if successful, otherwise <A HREF=#MG_NULL>MG_NULL</A>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgDuplicateEx>mgDuplicateEx</A>, <A HREF=#mgDuplicateToDb>mgDuplicateToDb</A>, <A HREF=#mgDuplicateToDbEx>mgDuplicateToDbEx</A></DD></DL>
<HR>
<LEFT><A NAME=mgDuplicateEx><H1 CLASS="APISYMBOL">mgDuplicateEx</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDuplicateEx</B> - duplicates a node or transformation record in the database.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgDuplicateEx</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>flags</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDuplicateEx</B> performs the same function as <A HREF=#mgDuplicate>mgDuplicate</A>, but 
in addition, it allows you to control certain capabilities of the duplication 
using <I>flags</I>.  This parameter is a bitwise combination of the following:</P></DD><DD><P><A HREF=#MDUP_NODEONLY>MDUP_NODEONLY</A> - If you set this mask, only the node record specified 
will be duplicated.  None of its descendants will be duplicated.<BR> 
By default, descendants are duplicated.</P></DD><DD><P><A HREF=#MDUP_DERIVEDNAMES>MDUP_DERIVEDNAMES</A> - If you set this mask, the names (IDs) assigned to 
the duplicate node(s) will be "derived" from the corresponding original node(s). 
The form of a derived name is "name_N" where <B>name</B> is the name of 
the original node and <B>N</B> is an integer such that "name_N" is unique in 
the database.  The alternative to derived names is standard names in which case 
you let the OpenFlight API choose a suitable default name for the duplicate nodes. 
Note that assigning derived names is slower than assigning standard names.<BR> 
By default, standard names are assigned to nodes created.</P></DD><DD><P>For a complete description of <B>mgDuplicateEx</B>, see <A HREF=#mgDuplicate>mgDuplicate</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to duplicate</DD><DT><I>flags</I></DT><DD>duplicate modifiers that allow you to control 
how the duplication is performed - 
this parameter is the bitwise combination of the following masks:<BR> 
<A HREF=#MDUP_NODEONLY>MDUP_NODEONLY</A><BR> <A HREF=#MDUP_DERIVEDNAMES>MDUP_DERIVEDNAMES</A><BR></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the new node if successful, otherwise <A HREF=#MG_NULL>MG_NULL</A>.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following shows different ways to use this function</DT><DT><PRE CLASS="EXAMPLE">// these two calls will do the same thing
mgrec* dup1;
mgrec* dup2;
dup1 = mgDuplicate (rec);
dup2 = mgDuplicateEx (rec, 0);

// duplicate poly, but not vertices or subfaces of poly
mgrec* dup;
dup = mgDuplicateEx (poly, MDUP_NODEONLY);

// duplicate group named "wheel", new node will be named "wheel_1"
mgrec* dup;
dup = mgDuplicateEx (group, MDUP_DERIVEDNAMES);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgDuplicate>mgDuplicate</A>, <A HREF=#mgDuplicateToDb>mgDuplicateToDb</A>, <A HREF=#mgDuplicateToDbEx>mgDuplicateToDbEx</A></DD></DL>
<HR>
<LEFT><A NAME=mgDuplicateToDb><H1 CLASS="APISYMBOL">mgDuplicateToDb</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDuplicateToDb</B> - duplicates a node or transformation record in 
one database for attaching into another database.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgDuplicateToDb</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>toDb</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a node or transformation record <I>rec</I> in one database, 
<B>mgDuplicateToDb</B> duplicates this record, and in the case of a node record, 
all of its descendants, returning the new (duplicate) record that can be attached 
to a node contained in the database <I>toDb</I>.  Unlike <A HREF=#mgDuplicate>mgDuplicate</A>, this 
function allows you to copy nodes from one database to another.</P></DD><DD><P>The record returned can be attached ONLY to a node contained in 
the database <I>toDb</I>.  If you specify <I>toDb</I> as <A HREF=#MG_NULL>MG_NULL</A> or the 
database that contains <I>rec</I>, it is equivalent to calling <A HREF=#mgDuplicate>mgDuplicate</A>.</P></DD><DD><P>Note: This function does not resolve palette indices between the 
source and destination databases.  So if you copy between two databases 
that have "different" palette entries, the duplicate node (and nodes below) 
returned will reference palette entries in the destination database.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to duplicate</DD><DT><I>toDb</I></DT><DD>the database where you are 
going to attach the duplicate</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the new node if successful, otherwise <A HREF=#MG_NULL>MG_NULL</A>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgDuplicateToDbEx>mgDuplicateToDbEx</A>, <A HREF=#mgDuplicate>mgDuplicate</A>, <A HREF=#mgDuplicateEx>mgDuplicateEx</A></DD></DL>
<HR>
<LEFT><A NAME=mgDuplicateToDbEx><H1 CLASS="APISYMBOL">mgDuplicateToDbEx</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgDuplicateToDbEx</B> - duplicates a node or transformation record in 
one database for attaching into another database.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgDuplicateToDbEx</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>toDb</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>flags</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgDuplicateToDbEx</B> performs the same function as <A HREF=#mgDuplicateToDb>mgDuplicateToDb</A>, but 
in addition, it allows you to control certain capabilities of the duplication 
using <I>flags</I>.  This parameter is a bitwise combination of the following:</P></DD><DD><P><A HREF=#MDUP_NODEONLY>MDUP_NODEONLY</A> - If you set this mask, only the node record specified 
will be duplicated.  None of its descendants will be duplicated.<BR> 
By default, descendants are duplicated.</P></DD><DD><P><A HREF=#MDUP_DERIVEDNAMES>MDUP_DERIVEDNAMES</A> - If you set this mask, the names (IDs) assigned to 
the duplicate node(s) will be "derived" from the corresponding original node(s). 
The form of a derived name is "name_N" where <B>name</B> is the name of 
the original node and <B>N</B> is an integer such that "name_N" is unique in 
the database.  The alternative to derived names is standard names in which case 
you let the OpenFlight API choose a suitable default name for the duplicate nodes. 
Note that assigning derived names is slower than assigning standard names.<BR> 
By default, standard names are assigned to nodes created.</P></DD><DD><P>For a complete description of <B>mgDuplicateToDbEx</B>, see <A HREF=#mgDuplicateToDb>mgDuplicateToDb</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to duplicate</DD><DT><I>toDb</I></DT><DD>the database where you are 
going to attach the duplicate</DD><DT><I>flags</I></DT><DD>duplicate modifiers that allow you to control 
how the duplication is performed - 
this parameter is the bitwise combination of the following masks:<BR> 
<A HREF=#MDUP_NODEONLY>MDUP_NODEONLY</A><BR> <A HREF=#MDUP_DERIVEDNAMES>MDUP_DERIVEDNAMES</A><BR></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the new node if successful, otherwise <A HREF=#MG_NULL>MG_NULL</A>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgDuplicateToDb>mgDuplicateToDb</A>, <A HREF=#mgDuplicate>mgDuplicate</A>, <A HREF=#mgDuplicateEx>mgDuplicateEx</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorAddRedo><H1 CLASS="APISYMBOL">mgEditorAddRedo</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorAddRedo</B> - registers a new redo callback action 
for an editor tool instance.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgEditorAddRedo</B> (</TD><TD><A HREF=#mgeditorundofunc>mgeditorundofunc</A></TD><TD><I>redoFunc</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgeditorundocleanupfunc>mgeditorundocleanupfunc</A></TD><TD><I>redoCleanupFunc</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>redoData</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorAddRedo</B> creates a new redo-able action item 
in the redo menu.</P></DD><DD><P>If the action "un-done" by the undo function of an editor tool 
instance is "redo-able", the editor tool registers this redo-able 
action using this function.  Doing so causes a redo entry to be created 
in the Edit->Redo menu with the same label as the corresponding undo.</P></DD><DD><P>When this redo entry is selected by the user, the specified 
redo callback function, <I>redoFunc</I> is called and passed 
the specified redo data <I>redoData</I>.  In this function, the editor 
tool instance is responsible for restoring the database to the state 
it was in prior to the editor tool undo function being called.  This 
is critical for previous undo/redo callback actions to correctly 
perform their processing.</P></DD><DD><P><B>mgEditorAddRedo</B> may only be called by from within an undo 
callback function of the editor tool.  This provides the necessary 
"context" for the redo-able action (editor context, menu label, etc). 
If your undo callback function does not register a redo-able action 
using this function, all the items already in the Edit->Redo menu 
will be cleared.</P></DD><DD><P>Generally, after the redo callback function is called, the redo 
cleanup callback function, <I>redoCleanupFunc</I> is called.  In this 
function, the editor tool instance can deallocate the redo data. 
Alternatively, the redo cleanup callback function may be called 
when the redo entry in the Edit->Redo menu becomes unreachable. 
In this case, the redo callback function will not be called 
before the redo cleanup callback function.</P></DD><DD><P>The redo data <I>redoData</I> specified may be the same data as 
was specified when the undo was registered.  In fact, this is 
very common since the undo and redo data for a specific editor tool 
instance may be very similar in content.  When the <I>redoData</I> specified 
to <B>mgEditorAddRedo</B> is the same address as the undo data, the 
undo and redo cleanup functions are automatically deferred by the 
modeling system until this "shared" data is really not needed anymore. 
When an undo or redo cleanup function is called, it is always safe (and 
required) to free the associated memory.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>redoFunc</I></DT><DD>the redo callback function 
for this redo-able action</DD><DT><I>redoCleanupFunc</I></DT><DD>the redo cleanup callback 
function for this redo-able action</DD><DT><I>redoData</I></DT><DD>user data to be passed to 
callback functions <I>redoFunc</I> 
and <I>redoCleanupFunc</I> when they 
are called</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows how an editor tool 
might register an undo and redo that "share" data.<BR><BR> 
When the editor tool is executed, it registers the undo. An undo 
entry labeled "My Action" is created in the Edit->Undo menu.</DT><DT><PRE CLASS="EXAMPLE">// this object will be shared by the undo and redo
myundodata* myUndoData = BuildUndoData ();

// Register the undo callback action
mgEditorAddUndo (editorContext, "My Action",
&#32&#32  MyUndoFunc, MyUndoCleanupFunc, myUndoData);</PRE></DT><DT>Then when the user invokes Edit->Undo->My Action, <B>MyUndoFunc</B> 
is called and it registers the redo.  A redo entry labeled "My Action" 
is created in the Edit->Redo menu.  This label is inferred by the 
modeling system since it knows which undo callback function it is 
currently in when <B>mgEditorAddRedo</B> is called.</DT><DT><PRE CLASS="EXAMPLE">static void MyUndoFunc (mgrec* db, void* undoData)
{
   myundodata* myUndoData = (myundodata*) undoData;

   // Undo the action
   // ...

   // Then register the redo.  Note that the redo data is the same as
   // the undo data.  This is ok.  This tells the OpenFlight API that the
   // data is purposefully shared.  And as a result, the cleanup
   // function will not be called until the shared data is "really"
   // ready to be freed.  Note also that the same cleanup function
   // is used for undo and redo.  This will most likely be the case
   // when the data is shared between the undo and redo.
   mgEditorAddRedo (MyRedoFunc, MyUndoCleanupFunc, myUndoData);
}</PRE></DT><DT>Then when the user invokes Edit->Redo->My Action, <B>MyRedoFunc</B> 
is called and it registers the undo for the redo.  An undo entry labeled 
"My Action" is created in the Edit->Undo menu.  Like above, this 
label is inferred by the modeling system since it knows which redo 
callback function it is currently in when <A HREF=#mgEditorAddUndoForRedo>mgEditorAddUndoForRedo</A> 
is called.</DT><DT><PRE CLASS="EXAMPLE">static void MyRedoFunc (mgrec* db, void* redoData)
{
   myundodata* myUndoData = (myundodata*) redoData;

   // Redo the action
   // ...

   // Then register the undo for the redo, note that the undo data
   // is the same as the redo data which is the same as the original
   // undo data.  Again, this is ok.  This tells the OpenFlight API that the
   // data is purposefully shared.  And as a result, the cleanup
   // function will be called when the data is "really" ready to
   // be freed.  Note that the undo for redo function is the same
   // as the original undo function.  This is almost always the
   // case when the data is shared since the undo processing
   // required after the tool originally executes is the same
   // processing required after an undo is re-done.
   // Also, note again that the same cleanup function is used
   // for undo, redo and undo for redo.
   mgEditorAddUndoForRedo (myUndoFunc, MyUndoCleanupFunc, myUndoData);
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, 
<A HREF=#mgEditorAddUndo>mgEditorAddUndo</A>, <A HREF=#mgEditorAppendUndo>mgEditorAppendUndo</A>, <A HREF=#mgEditorResetUndo>mgEditorResetUndo</A>, 
<A HREF=#mgEditorAddUndoForRedo>mgEditorAddUndoForRedo</A>, 
<A HREF=#mgEditorAddUndoForCreate>mgEditorAddUndoForCreate</A>, <A HREF=#mgEditorAppendUndoForCreate>mgEditorAppendUndoForCreate</A>, 
<A HREF=#mgEditorAddUndoForDelete>mgEditorAddUndoForDelete</A>, <A HREF=#mgEditorAppendUndoForDelete>mgEditorAppendUndoForDelete</A>, 
<A HREF=#mgEditorAddUndoForMove>mgEditorAddUndoForMove</A>, <A HREF=#mgEditorAppendUndoForMove>mgEditorAppendUndoForMove</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorAddUndo><H1 CLASS="APISYMBOL">mgEditorAddUndo</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorAddUndo</B> - creates a new undo entry and registers 
an undo callback action to it for an editor tool instance.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgEditorAddUndo</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>menuLabel</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgeditorundofunc>mgeditorundofunc</A></TD><TD><I>undoFunc</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgeditorundocleanupfunc>mgeditorundocleanupfunc</A></TD><TD><I>undoCleanupFunc</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>undoData</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorAddUndo</B> creates a new undo-able action item 
in the undo menu for the specified editor context, <I>editorContext</I>. 
This undo-able action results from the user invoking an editor tool 
instance.</P></DD><DD><P>When an editor tool instance performs an undo-able action, it 
registers the action using this function.  Doing so causes 
an undo entry to be created in the Edit->Undo menu with the 
specified label string <I>menuLabel</I>. If <A HREF=#MUML_USETOOLNAME>MUML_USETOOLNAME</A> is 
specified for <I>menuLabel</I>, the name of the editor tool is used 
as the menu label string.</P></DD><DD><P>When this undo entry is selected by the user, the specified 
undo callback function, <I>undoFunc</I> is called and passed 
the specified undo data <I>undoData</I>.  In this function, the editor 
tool instance is responsible for restoring the database to the state 
it was in prior to the editor tool instance being launched.  This 
is critical for previous undo/redo callback actions to correctly 
perform their processing.</P></DD><DD><P>After the undo callback function is called, the undo cleanup 
callback function, <I>undoCleanupFunc</I> is called.  In this 
function, the editor tool instance can deallocate the undo 
data.  Alternatively, the undo cleanup callback function may be 
called when the undo entry in the Edit->Undo menu becomes 
unreachable.  In this case, the undo callback function will not 
be called before the undo cleanup callback function.</P></DD><DD><P>Note that if an editor tool instance performs an action 
but does not register an undo for that action using this function 
or any of the other undo registration functions, it must call 
<A HREF=#mgEditorResetUndo>mgEditorResetUndo</A> so that all the items already in the 
Edit->Undo menu can be properly cleared.  If an editor tool 
instance does not register an undo and does not call 
<A HREF=#mgEditorResetUndo>mgEditorResetUndo</A>, the modeling system may become unstable.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context to 
register undo callback for</DD><DT><I>menuLabel</I></DT><DD>the text of the undo 
menu item to display</DD><DT><I>undoFunc</I></DT><DD>the undo callback function 
for this undo-able action</DD><DT><I>undoCleanupFunc</I></DT><DD>the undo cleanup callback 
function for this undo-able action</DD><DT><I>undoData</I></DT><DD>user data to be passed to 
callback functions <I>undoFunc</I> 
and <I>undoCleanupFunc</I> when they 
are called</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, 
<A HREF=#mgEditorAppendUndo>mgEditorAppendUndo</A>, <A HREF=#mgEditorResetUndo>mgEditorResetUndo</A>, 
<A HREF=#mgEditorAddRedo>mgEditorAddRedo</A>, <A HREF=#mgEditorAddUndoForRedo>mgEditorAddUndoForRedo</A>, 
<A HREF=#mgEditorAddUndoForCreate>mgEditorAddUndoForCreate</A>, <A HREF=#mgEditorAppendUndoForCreate>mgEditorAppendUndoForCreate</A>, 
<A HREF=#mgEditorAddUndoForDelete>mgEditorAddUndoForDelete</A>, <A HREF=#mgEditorAppendUndoForDelete>mgEditorAppendUndoForDelete</A>, 
<A HREF=#mgEditorAddUndoForMove>mgEditorAddUndoForMove</A>, <A HREF=#mgEditorAppendUndoForMove>mgEditorAppendUndoForMove</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorAddUndoForCreate><H1 CLASS="APISYMBOL">mgEditorAddUndoForCreate</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorAddUndoForCreate</B> - registers undo/redo callback 
actions for an editor tool instance that creates new geometry in the scene.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgEditorAddUndoForCreate</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>menuLabel</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>node</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorAddUndoForCreate</B> and <A HREF=#mgEditorAppendUndoForCreate>mgEditorAppendUndoForCreate</A> 
perform all the undo/redo actions automatically for an editor tool instance 
that creates new geometry in the scene.</P></DD><DD><P>When an editor tool instance creates new geometry and attaches 
that new geometry into the scene, it can register this action using 
<B>mgEditorAddUndoForCreate</B> or <A HREF=#mgEditorAppendUndoForCreate>mgEditorAppendUndoForCreate</A>.  Doing 
so causes all the processing required for undo/redo of the node creation 
to be performed by the modeling system automatically.  This can greatly 
reduce the amount of undo/redo support code you must write for your 
editor tool.</P></DD><DD><P>After calling <B>mgEditorAddUndoForCreate</B>, an undo entry is created 
in the Edit->Undo menu with the specified label string <I>menuLabel</I>. 
If <A HREF=#MUML_USETOOLNAME>MUML_USETOOLNAME</A> is specified for <I>menuLabel</I>, the name of the 
editor tool is used as the menu label string.</P></DD><DD><P>When this undo entry is selected by the user, the specified 
<I>node</I> is un-created and removed from the scene and a redo entry is 
created in the Edit->Redo menu with the same label as that used for 
the undo entry.  When this redo entry is selected, <I>node</I> will be 
re-created and attached into the scene, at which point another undo 
entry will be created.  As long as the user selects undo/redo of this 
action, the proper actions will be automatically performed by the 
modeling system with no further action required of the editor tool.</P></DD><DD><P>For <B>mgEditorAddUndoForCreate</B> and <A HREF=#mgEditorAppendUndoForCreate>mgEditorAppendUndoForCreate</A> 
to work correctly, they must be called <B>after</B> the <I>node</I> is 
created and attached into the scene.  This is required so the information 
required by the undo/redo can be captured correctly.  Note that this is 
different from the requirements of <A HREF=#mgEditorAddUndoForDelete>mgEditorAddUndoForDelete</A> and 
<A HREF=#mgEditorAddUndoForMove>mgEditorAddUndoForMove</A> which must be called <B>before</B> the node 
is deleted or moved, respectively.</P></DD><DD><P>Both <B>mgEditorAddUndoForCreate</B> and <A HREF=#mgEditorAppendUndoForCreate>mgEditorAppendUndoForCreate</A> 
can be used in combination with the other automatic and non-automatic 
undo/redo functions.  So, for example, if your editor tool deletes one 
node and creates another, you could call <A HREF=#mgEditorAddUndoForDelete>mgEditorAddUndoForDelete</A> 
to automatically handle the undo/redo for the deleted node, then call 
<A HREF=#mgEditorAppendUndoForCreate>mgEditorAppendUndoForCreate</A> to handle the undo/redo for the node 
you created.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context to 
register automatic undo/redo 
for node creation action</DD><DT><I>menuLabel</I></DT><DD>the text of the undo/redo 
menu items to display</DD><DT><I>node</I></DT><DD>the node created for 
which undo/redo is desired</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows how an editor tool, that creates new 
geometry in the scene, might register undo/redo for the new nodes it 
creates.</DT><DT><PRE CLASS="EXAMPLE">mgrec *newGroup;
mgrec *newObj1, *newObj2;
mgrec *newPoly1, *newPoly2;

// Create hierarchy of new nodes:
//
//    newGroup
//       |
//    newObj1
//       |
//    newPoly1
//
// and attach this hierarchy to an existing group in the scene

newGroup = mgNewRec (fltGroup);
newObj1 = mgNewRec (fltObject);
newPoly1 = mgNewRec (fltPolygon);

mgAttach (newGroup, newObj1);
mgAttach (newObj1, newPoly1);
mgAttach (existingGroup, newGroup);

// Set up undo/redo for node creation.  You only need to register
// the "root" node that you create.  Since newObj1 and newPoly1 are
// children of newGroup, you don't need to register them separately.
// Use mgEditorAddUndoForCreate because this is the first undo-able
// action performed by the editor tool.  Remember to register the
// undo after you attach new nodes into the scene.
mgEditorAddUndoForCreate (editorContext, "New Geometry Example", newGroup);

// Create another hierarchy of new nodes:
//
//    newObj2
//       |
//    newPoly2
//
// and attach this hierarchy to another existing group in the scene

newObj2 = mgNewRec (fltObject);
newPoly2 = mgNewRec (fltPolygon);
mgAttach (newObj2, newPoly2);
mgAttach (anotherGroup, newObj2);

// Set up undo/redo for node creation, only need to register the
// "root" node that you created.  Since newPoly2 is a child of
// newObj2, you don't need to register newPoly2 separately.
// Use mgEditorAppendUndoForCreate to "append" this undo
// callback action to the existing undo menu entry created
// above by mgEditorAddUndoForCreate.  Note that you could
// use mgEditorAddUndoForCreate here if you want another
// undo entry created in the menu.  This would make the
// creation of newGroup and newObj2 undo-able individually.
// Remember again, to register the undo after you attach
// new nodes into the scene.
mgEditorAppendUndoForCreate (editorContext, newObj2);

// The undo entry labeled "New Geometry Example", when selected
// by the user, will un-create both newGroup and newObj2. When
// that happens, a redo entry labeled "New Geometry Example" will
// be automatically created in the Edit-&gtRedo menu.  When that redo
// entry is selected by the user, both newGroup and newObj2 will be
// re-created and attached into the scene and yet another undo entry
// will be automatically created, and so forth.</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, 
<A HREF=#mgEditorAddUndo>mgEditorAddUndo</A>, <A HREF=#mgEditorAppendUndo>mgEditorAppendUndo</A>, <A HREF=#mgEditorResetUndo>mgEditorResetUndo</A>, 
<A HREF=#mgEditorAddRedo>mgEditorAddRedo</A>, <A HREF=#mgEditorAddUndoForRedo>mgEditorAddUndoForRedo</A>, 
<A HREF=#mgEditorAppendUndoForCreate>mgEditorAppendUndoForCreate</A>, 
<A HREF=#mgEditorAddUndoForDelete>mgEditorAddUndoForDelete</A>, <A HREF=#mgEditorAppendUndoForDelete>mgEditorAppendUndoForDelete</A>, 
<A HREF=#mgEditorAddUndoForMove>mgEditorAddUndoForMove</A>, <A HREF=#mgEditorAppendUndoForMove>mgEditorAppendUndoForMove</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorAddUndoForDelete><H1 CLASS="APISYMBOL">mgEditorAddUndoForDelete</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorAddUndoForDelete</B> - registers undo/redo callback 
actions for an editor tool instance that deletes geometry from the scene.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgEditorAddUndoForDelete</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>menuLabel</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>node</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorAddUndoForDelete</B> and <A HREF=#mgEditorAppendUndoForDelete>mgEditorAppendUndoForDelete</A> 
deletes <I>node</I> from the scene and performs all the undo/redo actions 
automatically for an editor tool instance.</P></DD><DD><P>When an editor tool instance wants to delete geometry from the scene, 
it can register this action using <B>mgEditorAddUndoForDelete</B> or 
<A HREF=#mgEditorAppendUndoForDelete>mgEditorAppendUndoForDelete</A>.  Doing so deletes <I>node</I> and causes all 
the processing required for undo/redo of the node deletion to be performed 
by the modeling system automatically.  This can greatly reduce the amount of 
undo/redo support code you must write for your editor tool.</P></DD><DD><P>After calling <B>mgEditorAddUndoForDelete</B>, <I>node</I> is deleted and 
an undo entry is created in the Edit->Undo menu with the specified label 
string <I>menuLabel</I>.  If <A HREF=#MUML_USETOOLNAME>MUML_USETOOLNAME</A> is specified for <I>menuLabel</I>, 
the name of the editor tool is used as the menu label string.</P></DD><DD><P>When this undo entry is selected by the user, the specified 
<I>node</I> is un-deleted and attached back into the scene and a redo entry is 
created in the Edit->Redo menu with the same label as that used for 
the undo entry.  When this redo entry is selected, <I>node</I> will be 
re-deleted and removed from the scene, at which point another undo 
entry will be created.  As long as the user selects undo/redo of this 
action, the proper actions will be automatically performed by the 
modeling system with no further action required of the editor tool.</P></DD><DD><P>For <B>mgEditorAddUndoForDelete</B> and <A HREF=#mgEditorAppendUndoForDelete>mgEditorAppendUndoForDelete</A> 
to work correctly, they must be called <B>instead of</B> deleting the <I>node</I> 
from the scene.  This is required so the information required by 
the undo/redo can be captured correctly before the node is deleted. Note 
that this is different from the requirements of <A HREF=#mgEditorAddUndoForCreate>mgEditorAddUndoForCreate</A> 
which must be called <B>after</B> the node is created and attached.</P></DD><DD><P>Both <B>mgEditorAddUndoForDelete</B> and <A HREF=#mgEditorAppendUndoForDelete>mgEditorAppendUndoForDelete</A> 
can be used in combination with the other automatic and non-automatic 
undo/redo functions.  So, for example, if your editor tool deletes one 
node and creates another, you could call <B>mgEditorAddUndoForDelete</B> 
to automatically handle the undo/redo for the deleted node, then call 
<A HREF=#mgEditorAppendUndoForCreate>mgEditorAppendUndoForCreate</A> to handle the undo/redo for the node 
you created.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context to 
register automatic undo/redo 
for node deletion action</DD><DT><I>menuLabel</I></DT><DD>the text of the undo/redo 
menu items to display</DD><DT><I>node</I></DT><DD>the node to delete and 
perform undo/redo for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>In the following example, an editor tool deletes one node from 
the scene and replaces it with a new node.  The example shows how 
the editor tool might register the undo/redo for these actions.</DT><DT><PRE CLASS="EXAMPLE">mgrec* newGroup;
mgrec* newObj;
mgrec* newPoly;
mgrec* parent;

// Create a new group:
//
//    newGroup
//       |
//    newObj
//       |
//    newPoly
//
// to replace an existing group in the scene

// Build up new group hierarchy
newGroup = mgNewRec (fltGroup);
newObj = mgNewRec (fltObject);
newPoly = mgNewRec (fltPolygon);

mgAttach (newGroup, newObj);
mgAttach (newObj, newPoly);

// We will delete the existing group first, then attach the new
// group to the same parent.  Remember the parent for later.
parent = mgGetParent (existingGroup);

// Set up undo/redo for node deletion.  You only need to register the
// "root" node that you want to delete.  All children are accounted for
// automatically.  Use mgEditorAddUndoForDelete because this is the
// first undo-able action performed by the editor tool. Remember, you
// must register the undo instead of deleting the nodes from the scene.
mgEditorAddUndoForDelete (editorContext, "Replace Geometry", existingGroup);

// DO NOT delete the existing group, mgEditorAddUndoForDelete will do it !!

// Now attach the new group to the old parent
mgAttach (parent, newGroup);

// Set up undo/redo for node creation, only need to register the
// "root" node that you created.  Since newObj and newPoly are
// children of newGroup, you don't need to register them separately.
// Use mgEditorAppendUndoForCreate to "append" this undo callback
// action to the existing undo menu entry created above by
// mgEditorAddUndoForDelete.  Note that you could call
// mgEditorAddUndoForCreate instead if you wanted the deletion
// and creation actions to be undo-able individually. And again,
// remember to register the undo for node creation after you
// attach new nodes into the scene.
mgEditorAppendUndoForCreate (editorContext, newGroup);

// The undo entry labeled "Replace Geometry", when selected by the
// user, will un-delete existingGroup and un-create newGroup. When
// that happens, a redo entry labeled "Replace Geometry" will be
// automatically created in the Edit-&gtRedo menu.  When that redo
// entry is selected by the user, existingGroup will re-deleted and
// newGroup will be re-created and attached into the scene and yet
// another undo entry will be automatically created, and so forth.</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, 
<A HREF=#mgEditorAddUndo>mgEditorAddUndo</A>, <A HREF=#mgEditorAppendUndo>mgEditorAppendUndo</A>, <A HREF=#mgEditorResetUndo>mgEditorResetUndo</A>, 
<A HREF=#mgEditorAddRedo>mgEditorAddRedo</A>, <A HREF=#mgEditorAddUndoForRedo>mgEditorAddUndoForRedo</A>, 
<A HREF=#mgEditorAddUndoForCreate>mgEditorAddUndoForCreate</A>, <A HREF=#mgEditorAppendUndoForCreate>mgEditorAppendUndoForCreate</A>, 
<A HREF=#mgEditorAppendUndoForDelete>mgEditorAppendUndoForDelete</A>, 
<A HREF=#mgEditorAddUndoForMove>mgEditorAddUndoForMove</A>, <A HREF=#mgEditorAppendUndoForMove>mgEditorAppendUndoForMove</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorAddUndoForMove><H1 CLASS="APISYMBOL">mgEditorAddUndoForMove</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorAddUndoForMove</B> - registers undo/redo callback 
actions for an editor tool instance that moves geometry from one attach 
point in the scene to a different attach point in the scene.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgEditorAddUndoForMove</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>menuLabel</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>node</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorAddUndoForMove</B> and <A HREF=#mgEditorAppendUndoForMove>mgEditorAppendUndoForMove</A> 
perform all the undo/redo actions automatically for an editor tool instance 
that moves geometry (hierarchically) from one location in the scene to 
another.  This is typically accomplished by "detaching" a node from its 
current parent and re-attaching it to a different parent or to the same 
parent but in a different sibling order.</P></DD><DD><P>When an editor tool instance moves geometry from one attach point 
to another within the scene, it can register this action using 
<B>mgEditorAddUndoForMove</B> or&#32<A HREF=#mgEditorAppendUndoForMove>mgEditorAppendUndoForMove</A>.  Doing so 
causes all the processing required for undo/redo of the move to be performed 
by the modeling system automatically.  This can greatly reduce the amount of 
undo/redo support code you must write for your editor tool.</P></DD><DD><P>After calling <B>mgEditorAddUndoForMove</B>, an undo entry is created 
in the Edit->Undo menu with the specified label string <I>menuLabel</I>. 
If <A HREF=#MUML_USETOOLNAME>MUML_USETOOLNAME</A> is specified for <I>menuLabel</I>, the name of the 
editor tool is used as the menu label string.</P></DD><DD><P>When this undo entry is selected by the user, the specified 
<I>node</I> is detached from its current location in the scene and re-attached 
back to where it was originally.  In addition, a redo entry is created in 
the Edit->Redo menu with the same label as that used for the undo entry. 
When this redo entry is selected, <I>node</I> will be moved back to its location 
before the undo was selected, at which point another undo entry will be created. 
As long as the user selects undo/redo of this action, the proper actions will 
be automatically performed by the modeling system with no further action 
required of the editor tool.</P></DD><DD><P>For <B>mgEditorAddUndoForMove</B> and <A HREF=#mgEditorAppendUndoForMove>mgEditorAppendUndoForMove</A> 
to work correctly, they must be called <B>before</B> the <I>node</I> is 
moved in the scene.  This is required so the information required by 
the undo/redo can be captured correctly before the node is moved. Note 
that this is different from the requirements of <A HREF=#mgEditorAddUndoForCreate>mgEditorAddUndoForCreate</A> 
which must be called <B>after</B> the node is created and attached.</P></DD><DD><P>Both <B>mgEditorAddUndoForMove</B> and <A HREF=#mgEditorAppendUndoForMove>mgEditorAppendUndoForMove</A> 
can be used in combination with the other automatic and non-automatic 
undo/redo functions.  So, for example, if your editor tool moves one 
node and creates another, you could call <B>mgEditorAddUndoForMove</B> 
to automatically handle the undo/redo for the moved node, then call 
<A HREF=#mgEditorAppendUndoForCreate>mgEditorAppendUndoForCreate</A> to handle the undo/redo for the node 
you created.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context to 
register automatic undo/redo 
for node creation action</DD><DT><I>menuLabel</I></DT><DD>the text of the undo/redo 
menu items to display</DD><DT><I>node</I></DT><DD>the node moved for 
which undo/redo is desired</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>In the following example, an editor tool moves one node to a 
new parent in the scene and creates another node where it used to be. 
The example shows how the editor tool might register the undo/redo 
for these actions.</DT><DT><PRE CLASS="EXAMPLE">mgrec* newGroup;
mgrec* newObj;
mgrec* newPoly;
mgrec* parent;

// Create a new group:
//
//    newGroup
//       |
//    newObj
//       |
//    newPoly
//
// to go where the group we move was before we moved it

// Build up new group hierarchy
newGroup = mgNewRec (fltGroup);
newObj = mgNewRec (fltObject);
newPoly = mgNewRec (fltPolygon);

mgAttach (newGroup, newObj);
mgAttach (newObj, newPoly);

// We will move the existing group first, then attach the new
// group to the same parent.  Remember the parent for later.
parent = mgGetParent (existingGroup);

// Set up undo/redo for node move.  You only need to register
// the "root" node that you move.  All children are accounted for
// automatically.  Use mgEditorAddUndoForMove because this is the
// first undo-able action performed by the editor tool. Remember, you
// must register the undo before you move the nodes in the scene.
mgEditorAddUndoForMove (editorContext, "Move Geometry", existingGroup);

// Move the existing group
mgDetach (existingGroup);
mgAttach (newParent, existingGroup);

// Now attach new group to the parent where existingGroup used to be
mgAttach (parent, newGroup);

// Set up undo/redo for node creation, only need to register the
// "root" node that you created.  Since newObj and newPoly are
// children of newGroup, you don't need to register them separately.
// Use mgEditorAppendUndoForCreate to "append" this undo callback
// action to the existing undo menu entry created above by
// mgEditorAddUndoForMove.  Note that you could call
// mgEditorAddUndoForCreate instead if you wanted the move
// and creation actions to be undo-able individually. And again,
// remember to register the undo for node creation after you
// attach new nodes into the scene.
mgEditorAppendUndoForCreate (editorContext, newGroup);

// The undo entry labeled "Move Geometry", when selected by the
// user, will un-move existingGroup and un-create newGroup. When
// that happens, a redo entry labeled "Move Geometry" will be
// automatically created in the Edit-&gtRedo menu.  When that redo
// entry is selected by the user, existingGroup will be re-moved and
// newGroup will be re-created and attached into the scene and yet
// another undo entry will be automatically created, and so forth.</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, 
<A HREF=#mgEditorAddUndo>mgEditorAddUndo</A>, <A HREF=#mgEditorAppendUndo>mgEditorAppendUndo</A>, <A HREF=#mgEditorResetUndo>mgEditorResetUndo</A>, 
<A HREF=#mgEditorAddRedo>mgEditorAddRedo</A>, <A HREF=#mgEditorAddUndoForRedo>mgEditorAddUndoForRedo</A>, 
<A HREF=#mgEditorAddUndoForCreate>mgEditorAddUndoForCreate</A>, <A HREF=#mgEditorAppendUndoForCreate>mgEditorAppendUndoForCreate</A>, 
<A HREF=#mgEditorAddUndoForDelete>mgEditorAddUndoForDelete</A>, <A HREF=#mgEditorAppendUndoForDelete>mgEditorAppendUndoForDelete</A>, 
<A HREF=#mgEditorAppendUndoForMove>mgEditorAppendUndoForMove</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorAddUndoForRedo><H1 CLASS="APISYMBOL">mgEditorAddUndoForRedo</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorAddUndoForRedo</B> - registers a new undo callback 
action after the redo of an editor tool instance.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgEditorAddUndoForRedo</B> (</TD><TD><A HREF=#mgeditorundofunc>mgeditorundofunc</A></TD><TD><I>undoFunc</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgeditorundocleanupfunc>mgeditorundocleanupfunc</A></TD><TD><I>undoCleanupFunc</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>undoData</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorAddUndoForRedo</B> creates a new undo-able action item 
in the undo menu.  This undo-able action results from the user invoking 
the redo for an editor tool instance.</P></DD><DD><P>If the action "re-done" by the redo function of an editor tool 
instance is "undo-able", the editor tool registers this undo-able 
action using this function.  Doing so causes an undo entry to be created 
in the Edit->Undo menu with the same label as the corresponding redo.</P></DD><DD><P>When this undo entry is selected by the user, the specified 
undo callback function, <I>undoFunc</I> is called and passed the specified 
undo data <I>undoData</I>.  In this function, the editor tool instance is 
responsible for restoring the database to the state it was in prior to 
the editor tool redo function being called.  This is critical for 
previous undo/redo callback actions to correctly perform their processing.</P></DD><DD><P><B>mgEditorAddUndoForRedo</B> may only be called from within a 
redo callback function of the editor tool.  This provides the necessary 
"context" for the undo-able action (editor context, menu label, etc). 
If your redo callback function does not register an undo-able action 
using this function, all the items already in the Edit->Undo menu 
will be cleared.</P></DD><DD><P>Generally, after the undo callback function is called, the undo 
cleanup callback function, <I>undoCleanupFunc</I> is called.  In this 
function, the editor tool instance can deallocate the undo data. 
Alternatively, the undo cleanup callback function may be called 
when the undo entry in the Edit->Undo menu becomes unreachable. 
In this case, the undo callback function will not be called 
before the undo cleanup callback function.</P></DD><DD><P>The undo data <I>undoData</I> specified may be the same data as 
was specified when the redo was registered.  In fact, this is 
very common since the undo and redo data for a specific editor tool 
instance may be very similar in content.  When the <I>undoData</I> specified 
to <B>mgEditorAddUndoForRedo</B> is the same address as the redo data, the 
undo and redo cleanup functions are automatically deferred by the 
modeling system until this "shared" data is really not needed anymore. 
When an undo or redo cleanup function is called, it is always safe (and 
required) to free the associated memory.</P></DD><DD><P>See the example shown for <A HREF=#mgEditorAddRedo>mgEditorAddRedo</A> to see how 
an editor tool instance might use <B>mgEditorAddUndoForRedo</B>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>undoFunc</I></DT><DD>the undo callback function 
for this undo-able action</DD><DT><I>undoCleanupFunc</I></DT><DD>the undo cleanup callback 
function for this undo-able action</DD><DT><I>undoData</I></DT><DD>user data to be passed to 
callback functions <I>undoFunc</I> 
and <I>undoCleanupFunc</I> when they 
are called</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, 
<A HREF=#mgEditorAddUndo>mgEditorAddUndo</A>, <A HREF=#mgEditorAppendUndo>mgEditorAppendUndo</A>, <A HREF=#mgEditorResetUndo>mgEditorResetUndo</A>, 
<A HREF=#mgEditorAddRedo>mgEditorAddRedo</A>, 
<A HREF=#mgEditorAddUndoForCreate>mgEditorAddUndoForCreate</A>, <A HREF=#mgEditorAppendUndoForCreate>mgEditorAppendUndoForCreate</A>, 
<A HREF=#mgEditorAddUndoForDelete>mgEditorAddUndoForDelete</A>, <A HREF=#mgEditorAppendUndoForDelete>mgEditorAppendUndoForDelete</A>, 
<A HREF=#mgEditorAddUndoForMove>mgEditorAddUndoForMove</A>, <A HREF=#mgEditorAppendUndoForMove>mgEditorAppendUndoForMove</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorAppendUndo><H1 CLASS="APISYMBOL">mgEditorAppendUndo</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorAppendUndo</B> - append an undo callback action 
to an existing undo entry for an editor tool instance.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgEditorAppendUndo</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgeditorundofunc>mgeditorundofunc</A></TD><TD><I>undoFunc</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgeditorundocleanupfunc>mgeditorundocleanupfunc</A></TD><TD><I>undoCleanupFunc</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>undoData</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorAppendUndo</B> creates an undo-able action and appends 
it to an existing entry in the undo menu for the specified editor context, 
<I>editorContext</I>.</P></DD><DD><P>Using this function after calling <A HREF=#mgEditorAddUndo>mgEditorAddUndo</A> within the 
same editor tool instance, an editor tool instance can register multiple 
undo callback actions that all are represented by a single undo entry 
in the Edit->Undo menu.</P></DD><DD><P>When the user selects an undo entry from the Edit->Undo menu that 
corresponds to multiple undo callback actions, the undo callback functions 
(including the undo cleanup callback) are called in the reverse order in 
which they were appended.  That is, the last undo callback action to be 
appended is called first and the undo callback action registered by 
<A HREF=#mgEditorAddUndo>mgEditorAddUndo</A> is called last.</P></DD><DD><P>Calling <B>mgEditorAppendUndo</B> without first calling 
<A HREF=#mgEditorAddUndo>mgEditorAddUndo</A> within the editor tool instance is equivalent to 
calling <A HREF=#mgEditorAddUndo>mgEditorAddUndo</A> and specifying <A HREF=#MUML_USETOOLNAME>MUML_USETOOLNAME</A> 
for the menu label.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context in 
which to register undo callback</DD><DT><I>undoFunc</I></DT><DD>the undo callback function 
for this undo-able action to be 
appended</DD><DT><I>undoCleanupFunc</I></DT><DD>the undo cleanup callback 
function for this undo-able action 
to be appended</DD><DT><I>undoData</I></DT><DD>user data to be passed to 
callback functions <I>undoFunc</I> 
and <I>undoCleanupFunc</I> when they 
are called</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows how an editor tool 
might register multiple undo callback actions.<BR><BR> 
When the first undo callback action is registered, an undo entry 
labeled "My Action" is created in the Edit->Undo menu:</DT><DT><PRE CLASS="EXAMPLE">// Register the first undo callback action
mgEditorAddUndo (editorContext, "My Action",
&#32&#32  MyUndoFunc, MyUndoCleanupFunc,
&#32&#32  MyUndoData);</PRE></DT><DT>Then when subsequent undo callback actions are registered (appended) 
within the same editor tool instance, the undo callback functions are 
appended to the "My Action" undo entry added above:</DT><DT><PRE CLASS="EXAMPLE">// Register the "next" undo callback action
mgEditorAppendUndo (editorContext,
&#32&#32     MyUndoFunc, MyUndoCleanupFunc,
&#32&#32     myUndoData);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, 
<A HREF=#mgEditorAddUndo>mgEditorAddUndo</A>, <A HREF=#mgEditorResetUndo>mgEditorResetUndo</A>, 
<A HREF=#mgEditorAddRedo>mgEditorAddRedo</A>, <A HREF=#mgEditorAddUndoForRedo>mgEditorAddUndoForRedo</A>, 
<A HREF=#mgEditorAddUndoForCreate>mgEditorAddUndoForCreate</A>, <A HREF=#mgEditorAppendUndoForCreate>mgEditorAppendUndoForCreate</A>, 
<A HREF=#mgEditorAddUndoForDelete>mgEditorAddUndoForDelete</A>, <A HREF=#mgEditorAppendUndoForDelete>mgEditorAppendUndoForDelete</A>, 
<A HREF=#mgEditorAddUndoForMove>mgEditorAddUndoForMove</A>, <A HREF=#mgEditorAppendUndoForMove>mgEditorAppendUndoForMove</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorAppendUndoForCreate><H1 CLASS="APISYMBOL">mgEditorAppendUndoForCreate</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorAppendUndoForCreate</B> - appends undo/redo callback 
actions for an editor tool instance that creates new geometry in the scene.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgEditorAppendUndoForCreate</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>node</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorAppendUndoForCreate</B> performs the same function as 
<A HREF=#mgEditorAddUndoForCreate>mgEditorAddUndoForCreate</A> but instead of creating a new entry in 
the Edit->Undo menu, <B>mgEditorAppendUndoForCreate</B> appends the 
undo callback actions to an existing undo entry for the editor tool 
instance.</P></DD><DD><P>See <A HREF=#mgEditorAddUndoForCreate>mgEditorAddUndoForCreate</A> for a complete description of 
this function.</P></DD><DD><P>Calling <B>mgEditorAppendUndoForCreate</B> without first calling 
<A HREF=#mgEditorAddUndo>mgEditorAddUndo</A>, <A HREF=#mgEditorAddUndoForCreate>mgEditorAddUndoForCreate</A>, <A HREF=#mgEditorAddUndoForDelete>mgEditorAddUndoForDelete</A>, 
or <A HREF=#mgEditorAddUndoForMove>mgEditorAddUndoForMove</A> within the editor tool instance is equivalent to 
calling <A HREF=#mgEditorAddUndoForCreate>mgEditorAddUndoForCreate</A> and specifying <A HREF=#MUML_USETOOLNAME>MUML_USETOOLNAME</A> 
for the menu label.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context to 
register undo callback for</DD><DT><I>node</I></DT><DD>the node created for 
which undo/redo is desired</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, 
<A HREF=#mgEditorAddUndo>mgEditorAddUndo</A>, <A HREF=#mgEditorAppendUndo>mgEditorAppendUndo</A>, <A HREF=#mgEditorResetUndo>mgEditorResetUndo</A>, 
<A HREF=#mgEditorAddRedo>mgEditorAddRedo</A>, <A HREF=#mgEditorAddUndoForRedo>mgEditorAddUndoForRedo</A>, 
<A HREF=#mgEditorAddUndoForCreate>mgEditorAddUndoForCreate</A>, 
<A HREF=#mgEditorAddUndoForDelete>mgEditorAddUndoForDelete</A>, <A HREF=#mgEditorAppendUndoForDelete>mgEditorAppendUndoForDelete</A>, 
<A HREF=#mgEditorAddUndoForMove>mgEditorAddUndoForMove</A>, <A HREF=#mgEditorAppendUndoForMove>mgEditorAppendUndoForMove</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorAppendUndoForDelete><H1 CLASS="APISYMBOL">mgEditorAppendUndoForDelete</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorAppendUndoForDelete</B> - appends undo/redo callback 
actions for an editor tool instance that deletes geometry from the scene.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgEditorAppendUndoForDelete</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>node</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorAppendUndoForDelete</B> performs the same function as 
<A HREF=#mgEditorAddUndoForDelete>mgEditorAddUndoForDelete</A> but instead of creating a new entry in 
the Edit->Undo menu, <B>mgEditorAppendUndoForDelete</B> appends the 
undo callback actions to an existing undo entry for the editor tool 
instance.</P></DD><DD><P>See <A HREF=#mgEditorAddUndoForDelete>mgEditorAddUndoForDelete</A> for a complete description of 
this function.</P></DD><DD><P>Calling <B>mgEditorAppendUndoForDelete</B> without first calling 
<A HREF=#mgEditorAddUndo>mgEditorAddUndo</A>, <A HREF=#mgEditorAddUndoForCreate>mgEditorAddUndoForCreate</A>, <A HREF=#mgEditorAddUndoForDelete>mgEditorAddUndoForDelete</A>, 
or <A HREF=#mgEditorAddUndoForMove>mgEditorAddUndoForMove</A> within the editor tool instance is equivalent to 
calling <A HREF=#mgEditorAddUndoForDelete>mgEditorAddUndoForDelete</A> and specifying <A HREF=#MUML_USETOOLNAME>MUML_USETOOLNAME</A> 
for the menu label.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context to 
register undo callback for</DD><DT><I>node</I></DT><DD>the node to delete and 
perform undo/redo for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, 
<A HREF=#mgEditorAddUndo>mgEditorAddUndo</A>, <A HREF=#mgEditorAppendUndo>mgEditorAppendUndo</A>, <A HREF=#mgEditorResetUndo>mgEditorResetUndo</A>, 
<A HREF=#mgEditorAddRedo>mgEditorAddRedo</A>, <A HREF=#mgEditorAddUndoForRedo>mgEditorAddUndoForRedo</A>, 
<A HREF=#mgEditorAddUndoForCreate>mgEditorAddUndoForCreate</A>, <A HREF=#mgEditorAppendUndoForCreate>mgEditorAppendUndoForCreate</A>, 
<A HREF=#mgEditorAddUndoForDelete>mgEditorAddUndoForDelete</A>, 
<A HREF=#mgEditorAddUndoForMove>mgEditorAddUndoForMove</A>, <A HREF=#mgEditorAppendUndoForMove>mgEditorAppendUndoForMove</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorAppendUndoForMove><H1 CLASS="APISYMBOL">mgEditorAppendUndoForMove</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorAppendUndoForMove</B> - appends undo/redo callback 
actions for an editor tool instance that moves geometry from one attach 
point in the scene to a different attach point in the scene.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgEditorAppendUndoForMove</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>node</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorAppendUndoForMove</B> performs the same function as 
<A HREF=#mgEditorAddUndoForMove>mgEditorAddUndoForMove</A> but instead of creating a new entry in 
the Edit->Undo menu, <B>mgEditorAppendUndoForMove</B> appends the 
undo callback actions to an existing undo entry for the editor tool 
instance.</P></DD><DD><P>See <A HREF=#mgEditorAddUndoForMove>mgEditorAddUndoForMove</A> for a complete description of 
this function.</P></DD><DD><P>Calling <B>mgEditorAppendUndoForMove</B> without first calling 
<A HREF=#mgEditorAddUndo>mgEditorAddUndo</A>, <A HREF=#mgEditorAddUndoForCreate>mgEditorAddUndoForCreate</A>, <A HREF=#mgEditorAddUndoForDelete>mgEditorAddUndoForDelete</A>, 
or <A HREF=#mgEditorAddUndoForMove>mgEditorAddUndoForMove</A> within the editor tool instance is equivalent to 
calling <A HREF=#mgEditorAddUndoForMove>mgEditorAddUndoForMove</A> and specifying <A HREF=#MUML_USETOOLNAME>MUML_USETOOLNAME</A> 
for the menu label.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context to 
register undo callback for</DD><DT><I>node</I></DT><DD>the node moved for 
which undo/redo is desired</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, 
<A HREF=#mgEditorAddUndo>mgEditorAddUndo</A>, <A HREF=#mgEditorAppendUndo>mgEditorAppendUndo</A>, <A HREF=#mgEditorResetUndo>mgEditorResetUndo</A>, 
<A HREF=#mgEditorAddRedo>mgEditorAddRedo</A>, <A HREF=#mgEditorAddUndoForRedo>mgEditorAddUndoForRedo</A>, 
<A HREF=#mgEditorAddUndoForCreate>mgEditorAddUndoForCreate</A>, <A HREF=#mgEditorAppendUndoForCreate>mgEditorAppendUndoForCreate</A>, 
<A HREF=#mgEditorAddUndoForDelete>mgEditorAddUndoForDelete</A>, <A HREF=#mgEditorAppendUndoForDelete>mgEditorAppendUndoForDelete</A>, 
<A HREF=#mgEditorAddUndoForMove>mgEditorAddUndoForMove</A></DD></DL>
<HR>
<LEFT><A NAME=mgeditorbuttonfunc><H1 CLASS="APISYMBOL">mgeditorbuttonfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgeditorbuttonfunc</B> - Editor dialog button function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void (*<B>mgeditorbuttonfunc</B>) ( <TD><A HREF=#mgeditorcontext>mgeditorcontext</A> <TD><I>editorContext</I>, 
<TR><TD></TD><TD>int <TD><I>whichButton</I>, 
<TR><TD></TD><TD>void* <TD><I>editorToolData</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for editor dialog button functions. 
If your editor tool displays a dialog, you can assign a button 
function to your editor tool of this form.</P></DD><DD><P>Editor dialog button 
functions are called to notify your editor tool when the user 
has pressed one of the pre-defined buttons on your dialog.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context that identifies the 
editor instance receiving the button event</DD><DT><I>whichButton</I></DT><DD>the button that was pressed <BR> 
<A HREF=#MBT_DONE>MBT_DONE</A> - Done button <BR> 
<A HREF=#MBT_CANCEL>MBT_CANCEL</A> - Cancel button <BR> 
<A HREF=#MBT_NEXT>MBT_NEXT</A> - Next button <BR> 
<A HREF=#MBT_UNDO>MBT_UNDO</A> - Undo button <BR> 
<A HREF=#MBT_REDO>MBT_REDO</A> - Redo button <BR> 
<A HREF=#MBT_HELP>MBT_HELP</A> - Help button (reserved for 
future enhancement)</DD><DT><I>editorToolData</I></DT><DD>user defined tool instance data 
set in <I>toolData</I> field of <I>callData</I> 
parameter (<A HREF=#mgeditorcallbackrec>mgeditorcallbackrec</A>) during 
editor tool start function <A HREF=#mgtoolstartfunc>mgtoolstartfunc</A></DD></DL></DD></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSetButtonFunc>mgEditorSetButtonFunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorCancelTool><H1 CLASS="APISYMBOL">mgEditorCancelTool</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorCancelTool</B> - cancels an editor tool instance.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgEditorCancelTool</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorCancelTool</B> terminates the editor tool instance identified 
by editor context, <I>editorContext</I> with the Editor Tool Termination Reason 
<A HREF=#mgtoolterminationreason>MTRM_CANCEL</A>.</P></DD><DD><P>Normally, editor tool instances are terminated when the user presses 
the <I>Done</I> or <I>Cancel</I> buttons in the tool dialog associated with the 
editor instance.  In some cases, however, the editor tool instance may allow 
other actions (user or processing) to cause the cancellation of the 
tool instance.  In these cases, the tool can call <B>mgEditorCancelTool</B> 
to cancel itself.</P></DD><DD><P>When an editor tool is canceled in this way, the termination function 
is called with termination reason <A HREF=#mgtoolterminationreason>MTRM_CANCEL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context that identifies 
the editor instance being canceled</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSetTerminateFunc>mgEditorSetTerminateFunc</A>, <A HREF=#mgEditorTerminateTool>mgEditorTerminateTool</A>, 
<A HREF=#mgeditorterminatefunc>mgeditorterminatefunc</A>, <A HREF=#mgtoolterminationreason>mgtoolterminationreason</A></DD></DL>
<HR>
<LEFT><A NAME=mgeditorclosedialogfunc><H1 CLASS="APISYMBOL">mgeditorclosedialogfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgeditorclosedialogfunc</B> - Editor close dialog function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool (*<B>mgeditorclosedialogfunc</B>) ( <TD><A HREF=#mgeditorcontext>mgeditorcontext</A> <TD><I>editorContext</I>, 
<TR><TD></TD><TD><A HREF=#mgclosedialogcallbackrec>mgclosedialogcallbackrec*</A> <TD><I>callData</I>, 
<TR><TD></TD><TD>void* <TD><I>editorToolData</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for editor close dialog functions. 
If your editor tool displays a dialog, you can assign a close dialog 
function to your editor tool of this form.</P></DD><DD><P>Close dialog functions are called to notify your editor tool 
when the user has pressed the Close Box on your dialog.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context that identifies the 
editor instance being closed</DD><DT><I>callData</I></DT><DD>callback data for close dialog function</DD><DT><I>editorToolData</I></DT><DD>user defined tool instance data 
set in <I>toolData</I> field of <I>callData</I> 
parameter (<A HREF=#mgeditorcallbackrec>mgeditorcallbackrec</A>) during 
editor tool start function <A HREF=#mgtoolstartfunc>mgtoolstartfunc</A></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Return <A HREF=#mgbool>MG_TRUE</A> to close the dialog, <A HREF=#mgbool>MG_FALSE</A> 
to ignore the action from the user.
</DD></DL><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSetCloseDialogFunc>mgEditorSetCloseDialogFunc</A>, <A HREF=#mgclosedialogcallbackrec>mgclosedialogcallbackrec</A></DD></DL>
<HR>
<LEFT><A NAME=mgeditorcreatedialogfunc><H1 CLASS="APISYMBOL">mgeditorcreatedialogfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgeditorcreatedialogfunc</B> - Editor create dialog function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mggui (*<B>mgeditorcreatedialogfunc</B>) ( <TD><A HREF=#mgplugintool>mgplugintool</A> <TD><I>editorPluginTool</I>, 
<TR><TD></TD><TD>void* <TD><I>editorToolData</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for editor create dialog functions. 
If your editor tool displays a dialog, assign a create dialog 
function to your editor tool of this form.</P></DD><DD><P>Create dialog functions are called to create an editor dialog 
instance when your editor tool is launched.  This function must create 
and return a new dialog instance each time it is invoked.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorPluginTool</I></DT><DD>the editor plug-in tool for which 
the dialog is to be created</DD><DT><I>editorToolData</I></DT><DD>user defined tool instance data 
set in <I>toolData</I> field of <I>callData</I> 
parameter (<A HREF=#mgeditorcallbackrec>mgeditorcallbackrec</A>) during 
editor tool start function <A HREF=#mgtoolstartfunc>mgtoolstartfunc</A></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Return the dialog instance created for editor tool instance.
</DD></DL><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgEditorSetPickFunc>mgEditorSetPickFunc</A>, <A HREF=#mgEditorSetCreateDialogFunc>mgEditorSetCreateDialogFunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorDeleteProperty><H1 CLASS="APISYMBOL">mgEditorDeleteProperty</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorDeleteProperty</B> - deletes user defined data 
associated with an editor context.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgEditorDeleteProperty</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgpropertyname>mgpropertyname</A></TD><TD><I>propName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Use <B>mgEditorDeleteProperty</B> to delete the data named 
<I>propName</I> that was associated with the editor context, <I>editorContext</I> 
using <A HREF=#mgEditorPutProperty>mgEditorPutProperty</A>.</P></DD><DD><P>Note that this function does not free or otherwise affect the actual data 
that was associated.  If this data was dynamically allocated, it is the 
callers responsibility to deallocate it.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context</DD><DT><I>propName</I></DT><DD>the name of the property to delete</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgEditorPutProperty>mgEditorPutProperty</A>, <A HREF=#mgEditorGetProperty>mgEditorGetProperty</A></DD></DL>
<HR>
<LEFT><A NAME=mgeditordeviceinputfunc><H1 CLASS="APISYMBOL">mgeditordeviceinputfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgeditordeviceinputfunc</B> - Editor device input function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int (*<B>mgeditordeviceinputfunc</B>) ( <TD><A HREF=#mgeditorcontext>mgeditorcontext</A> <TD><I>editorContext</I>, 
<TR><TD></TD><TD><A HREF=#mgdeviceinputdata>mgdeviceinputdata*</A> <TD><I>deviceInputData</I>, 
<TR><TD></TD><TD>void* <TD><I>editorToolData</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for editor device input functions. 
If your editor tool expects device specific input at 
any time while it is active, you will assign a device 
function to your editor tool of this form.</P></DD><DD><P>device functions are called to notify your editor 
tool when the input device is activated (or gets focus) by the user 
as specified by the input device.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context that identifies the 
editor instance receiving the device specific input</DD><DT><I>deviceInputData</I></DT><DD>address of record describing the device 
specific input</DD><DT><I>editorToolData</I></DT><DD>user defined tool instance data 
set in <I>toolData</I> field of <I>callData</I> 
parameter (<A HREF=#mgeditorcallbackrec>mgeditorcallbackrec</A>) during 
editor tool start function <A HREF=#mgtoolstartfunc>mgtoolstartfunc</A></DD></DL></DD></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgEditorSetDeviceInputFunc>mgEditorSetDeviceInputFunc</A>, <A HREF=#mgEditorSelectMouseInput>mgEditorSelectMouseInput</A></DD></DL>
<HR>
<LEFT><A NAME=mgeditorfocusvertexfunc><H1 CLASS="APISYMBOL">mgeditorfocusvertexfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgeditorfocusvertexfunc</B> - Editor focus vertex function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void (*<B>mgeditorfocusvertexfunc</B>) ( <TD><A HREF=#mgeditorcontext>mgeditorcontext</A> <TD><I>editorContext</I>, 
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A> <TD><I>vertexRec</I>, 
<TR><TD></TD><TD>void* <TD><I>editorToolData</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for editor focus vertex functions. If 
your editor tool uses focus vertices while it is active, you will 
assign a focus vertex function to your editor tool of this form.</P></DD><DD><P>Focus vertex functions are called to notify your editor tool 
when the user has selected or deselected a vertex, vertexRec, from 
your vertex focus list.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context that identifies the 
editor instance receiving the focus vertex 
notification</DD><DT><I>vertexRec</I></DT><DD>the vertex node that was selected by the 
user to become the new focus vertex - <A HREF=#MG_NULL>MG_NULL</A> 
if the user deselected the current focus vertex</DD><DT><I>editorToolData</I></DT><DD>user defined tool instance data 
set in <I>toolData</I> field of <I>callData</I> 
parameter (<A HREF=#mgeditorcallbackrec>mgeditorcallbackrec</A>) during 
editor tool start function <A HREF=#mgtoolstartfunc>mgtoolstartfunc</A></DD></DL></DD></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgEditorSetFocusVertexFunc>mgEditorSetFocusVertexFunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorGetContext><H1 CLASS="APISYMBOL">mgEditorGetContext</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorGetContext</B> - gets the editor context 
associated with an editor tool dialog or control in that dialog.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgeditorcontext <B>mgEditorGetContext</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>gui</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorGetContext</B> returns the editor context that is associated 
with the specified editor tool dialog or control, <I>gui</I>.</P></DD><DD><P>A unique editor context is created for each editor tool instance that 
is launched.  When an editor tool instance creates a dialog, the editor 
context automatically becomes associated with the dialog and therefore may be 
acquired from the dialog or any control contained in the dialog.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>gui</I></DT><DD>the dialog or control to get associated editor 
context for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns editor context if <I>gui</I> is associated with an editor tool dialog, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorGetDialog>mgEditorGetDialog</A>, 
<A HREF=#mgEditorSetCreateDialogFunc>mgEditorSetCreateDialogFunc</A>, <A HREF=#mgeditorcreatedialogfunc>mgeditorcreatedialogfunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorGetDbRec><H1 CLASS="APISYMBOL">mgEditorGetDbRec</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorGetDbRec</B> - gets the database associated with an 
editor context.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgEditorGetDbRec</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorGetDbRec</B> returns the database that is associated 
with the specified editor context, <I>editorContext</I>.</P></DD><DD><P>When an editor tool instance is active, it is explicitly bound 
to the database in which the editor tool was launched. 
This function is used to retrieve the database associated 
with a particular editor tool instance.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context to get 
associated database node for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the database associated with tool instance.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgEditorGetDialog>mgEditorGetDialog</A>, <A HREF=#mgEditorGetContext>mgEditorGetContext</A>, <A HREF=#mgEditorGetToolData>mgEditorGetToolData</A>, 
<A HREF=#mgEditorGetToolActivation>mgEditorGetToolActivation</A>, <A HREF=#mgEditorGetPluginTool>mgEditorGetPluginTool</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorGetDialog><H1 CLASS="APISYMBOL">mgEditorGetDialog</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorGetDialog</B> - gets the dialog associated with an editor 
context.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mggui <B>mgEditorGetDialog</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorGetDialog</B> returns the dialog that is associated with the 
specified editor context, <I>editorContext</I>.</P></DD><DD><P>When an editor tool instance is active, a unique association exists 
between the tool instance and the corresponding editor tool dialog.  This 
function is used to retrieve the dialog associated with a particular editor 
tool instance.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context to get 
associated dialog for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns editor tool dialog if <I>editorContext</I> is associated with one, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorGetContext>mgEditorGetContext</A>, <A HREF=#mgEditorGetToolActivation>mgEditorGetToolActivation</A>, 
<A HREF=#mgEditorSetCreateDialogFunc>mgEditorSetCreateDialogFunc</A>, <A HREF=#mgeditorcreatedialogfunc>mgeditorcreatedialogfunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorGetPluginTool><H1 CLASS="APISYMBOL">mgEditorGetPluginTool</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorGetPluginTool</B> - gets the plug-in tool associated 
with an editor context.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgplugintool <B>mgEditorGetPluginTool</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorGetPluginTool</B> returns the plug-in tool 
that is associated with the specified editor context, <I>editorContext</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context to get 
associated plug-in tool for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the plug-in tool associated with this tool instance 
(if valid), <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgEditorGetDialog>mgEditorGetDialog</A>, <A HREF=#mgEditorGetContext>mgEditorGetContext</A>, <A HREF=#mgEditorGetDbRec>mgEditorGetDbRec</A>, 
<A HREF=#mgEditorGetToolActivation>mgEditorGetToolActivation</A>, <A HREF=#mgEditorGetToolData>mgEditorGetToolData</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorGetProperty><H1 CLASS="APISYMBOL">mgEditorGetProperty</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorGetProperty</B> - retrieves user defined data 
associated with an editor context.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgpropertyvalue <B>mgEditorGetProperty</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgpropertyname>mgpropertyname</A></TD><TD><I>propName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Use <B>mgEditorGetProperty</B> to retrieve the data named <I>propName</I> 
that was associated with the editor context <I>editorContext</I> using 
<A HREF=#mgEditorPutProperty>mgEditorPutProperty</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context</DD><DT><I>propName</I></DT><DD>the name of the property to get</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the user-defined data if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgEditorPutProperty>mgEditorPutProperty</A>, <A HREF=#mgEditorDeleteProperty>mgEditorDeleteProperty</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorGetToolActivation><H1 CLASS="APISYMBOL">mgEditorGetToolActivation</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorGetToolActivation</B> - gets the tool activation object 
associated with an editor context.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgtoolactivation <B>mgEditorGetToolActivation</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorGetToolActivation</B> returns the tool activation object that 
is associated with the specified editor context, <I>editorContext</I>.  You can 
query this tool activation object to obtain useful information about the context 
in which your editor tool is currently running.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context to get 
associated tool activation for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the tool activation object if <I>editorContext</I> is valid, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgtoolactivation>mgtoolactivation</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorGetContext>mgEditorGetContext</A>, <A HREF=#mgEditorGetDialog>mgEditorGetDialog</A>, 
<A HREF=#mgEditorGetDbRec>mgEditorGetDbRec</A>, <A HREF=#mgEditorSetCreateDialogFunc>mgEditorSetCreateDialogFunc</A>, <A HREF=#mgeditorcreatedialogfunc>mgeditorcreatedialogfunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorGetToolData><H1 CLASS="APISYMBOL">mgEditorGetToolData</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorGetToolData</B> - gets the user defined tool instance data 
associated with an editor context.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void* <B>mgEditorGetToolData</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorGetToolData</B> returns the user defined tool instance data 
that is associated with the specified editor context, <I>editorContext</I>.</P></DD><DD><P>When an editor tool instance is active, a unique association exists 
between the tool instance and the corresponding editor tool instance data. 
This function is used to retrieve the tool data associated with a particular 
editor tool instance.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context to get 
associated tool instance data for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns editor tool instance data if defined for this tool instance, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgEditorGetDialog>mgEditorGetDialog</A>, <A HREF=#mgEditorGetContext>mgEditorGetContext</A>, <A HREF=#mgEditorGetDbRec>mgEditorGetDbRec</A>, 
<A HREF=#mgEditorGetToolActivation>mgEditorGetToolActivation</A>, <A HREF=#mgEditorGetPluginTool>mgEditorGetPluginTool</A></DD></DL>
<HR>
<LEFT><A NAME=mgeditorpickfunc><H1 CLASS="APISYMBOL">mgeditorpickfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgeditorpickfunc</B> - Editor pick function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void (*<B>mgeditorpickfunc</B>) ( <TD><A HREF=#mgeditorcontext>mgeditorcontext</A> <TD><I>editorContext</I>, 
<TR><TD></TD><TD><A HREF=#mgpickinputdata>mgpickinputdata*</A> <TD><I>pickInputData</I>, 
<TR><TD></TD><TD>void* <TD><I>editorToolData</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for editor pick functions. 
If your editor tool requires pick input at 
any time while it is active, you will assign a pick 
function to your editor tool of this form.</P></DD><DD><P>Pick functions are called to notify your editor 
tool when geometry has been picked by the user.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context that identifies the 
editor instance receiving the pick input</DD><DT><I>pickInputData</I></DT><DD>address of record describing the 
pick input</DD><DT><I>editorToolData</I></DT><DD>user defined tool instance data 
set in <I>toolData</I> field of <I>callData</I> 
parameter (<A HREF=#mgeditorcallbackrec>mgeditorcallbackrec</A>) during 
editor tool start function <A HREF=#mgtoolstartfunc>mgtoolstartfunc</A></DD></DL></DD></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgEditorSetPickFunc>mgEditorSetPickFunc</A>, <A HREF=#mgEditorSelectMouseInput>mgEditorSelectMouseInput</A></DD></DL>
<HR>
<LEFT><A NAME=mgeditorpointfunc><H1 CLASS="APISYMBOL">mgeditorpointfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgeditorpointfunc</B> - Editor 2D point function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void (*<B>mgeditorpointfunc</B>) ( <TD><A HREF=#mgeditorcontext>mgeditorcontext</A> <TD><I>editorContext</I>, 
<TR><TD></TD><TD><A HREF=#mgpointinputdata>mgpointinputdata*</A> <TD><I>pointInputData</I>, 
<TR><TD></TD><TD>void* <TD><I>editorToolData</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for editor 2D point functions. 
If your editor tool requires 2D point input at 
any time while it is active, you will assign a 2D point 
function to your editor tool of this form.</P></DD><DD><P>2D point functions are called to notify your editor 
tool when a 2D screen coordinate has been entered by the 
user via the mouse.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context that identifies the 
editor instance receiving the 2D point input</DD><DT><I>pointInputData</I></DT><DD>address of record describing the 2D 
point input</DD><DT><I>editorToolData</I></DT><DD>user defined tool instance data 
set in <I>toolData</I> field of <I>callData</I> 
parameter (<A HREF=#mgeditorcallbackrec>mgeditorcallbackrec</A>) during 
editor tool start function <A HREF=#mgtoolstartfunc>mgtoolstartfunc</A></DD></DL></DD></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgEditorSetPointFunc>mgEditorSetPointFunc</A>, <A HREF=#mgEditorSelectMouseInput>mgEditorSelectMouseInput</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorPutProperty><H1 CLASS="APISYMBOL">mgEditorPutProperty</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorPutProperty</B> - associates user defined data an 
editor context.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgEditorPutProperty</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgpropertyname>mgpropertyname</A></TD><TD><I>propName</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgpropertyvalue>mgpropertyvalue</A></TD><TD><I>propValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorPutProperty</B> allows you to associate data of 
any type, <I>propValue</I>, with a plug-in tool instance (editor context). 
The user-defined data is associated with the editor context, <I>editorContext</I>, 
and identified by a property name string, <I>propName</I>, allowing any number of 
data records to be associated with the editor context, as long as all property 
names are unique.</P></DD><DD><P>After using this function to associate user data to an editor context, 
use the function <A HREF=#mgEditorGetProperty>mgEditorGetProperty</A> to retrieve the data.  Then 
when you no longer need the data associated to the editor context, use 
<A HREF=#mgEditorDeleteProperty>mgEditorDeleteProperty</A> to disassociate the data from the editor context. 
Note that <A HREF=#mgEditorDeleteProperty>mgEditorDeleteProperty</A> does not free or otherwise 
affect the actual data that was associated.  If this data was dynamically 
allocated, it is the callers responsibility to deallocate it.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context to which the data 
is to be associated</DD><DT><I>propName</I></DT><DD>the name of the property to assign</DD><DT><I>propValue</I></DT><DD>the value of the property to assign</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example associates a string property to an editor 
context, retrieves the string and prints it out.  Finally, it deletes the 
property from the editor context.</DT><DT><PRE CLASS="EXAMPLE">#define PROPERTY_NAME   "My String Property"
#define USER_STRING     "This String is associated to my editor context"

char* string;

// allocate the string to be associated to the editor context
string = mgMalloc (strlen (USER_STRING) + 1);
strcpy (string, USER_STRING);

// associate the string as a property of the editor context
mgEditorPutProperty (editorContext, PROPERTY_NAME, string);

// Then later, retrieve the string property, print it out

char* string;

// Retrieve the string property from the editor context
string = (char*) mgEditorGetProperty (editorContext, PROPERTY_NAME);
printf ("%s: %s", PROPERTY_NAME, string);

// Output is:
// My String Property: This String is associated to my editor context

// Then finally, when you no longer need the string to be
// associated to the editor context

char* string;

// Retrieve the string property from the editor context (need to free it)
string = (char*) mgEditorGetProperty (editorContext, PROPERTY_NAME);
mgFree (string);
mgEditorDeleteProperty (editorContext, PROPERTY_NAME);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgEditorGetProperty>mgEditorGetProperty</A>, <A HREF=#mgEditorDeleteProperty>mgEditorDeleteProperty</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorResetUndo><H1 CLASS="APISYMBOL">mgEditorResetUndo</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorResetUndo</B> - clear the undo menu.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgEditorResetUndo</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorResetUndo</B> clears the contents of the Edit->Undo menu 
for the database associated with the specified editor context, 
<I>editorContext</I>.</P></DD><DD><P>There are times when an editor tool instance performs actions which 
cannot be "undone".  In other words, the editor tool instance cannot 
guarantee that it can restore the database to the state it was in prior 
to the editor tool instance being launched.  When this is the case, undo 
entries that are currently in the Edit->Undo menu when the editor instance 
is launched must be cleared from the menu as they may not be able to 
correctly perform their processing given that the state of the database 
has been altered.</P></DD><DD><P>If your editor tool performs actions that cannot be undone, you 
should call this function after you perform the drastic action(s), typically 
from your editor termination function.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context used to identify 
the database for which the undo menu 
is to be cleared</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, 
<A HREF=#mgEditorAddUndo>mgEditorAddUndo</A>, <A HREF=#mgEditorAppendUndo>mgEditorAppendUndo</A>, 
<A HREF=#mgEditorAddRedo>mgEditorAddRedo</A>, <A HREF=#mgEditorAddUndoForRedo>mgEditorAddUndoForRedo</A>, 
<A HREF=#mgEditorAddUndoForCreate>mgEditorAddUndoForCreate</A>, <A HREF=#mgEditorAppendUndoForCreate>mgEditorAppendUndoForCreate</A>, 
<A HREF=#mgEditorAddUndoForDelete>mgEditorAddUndoForDelete</A>, <A HREF=#mgEditorAppendUndoForDelete>mgEditorAppendUndoForDelete</A>, 
<A HREF=#mgEditorAddUndoForMove>mgEditorAddUndoForMove</A>, <A HREF=#mgEditorAppendUndoForMove>mgEditorAppendUndoForMove</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorSelectMouseInput><H1 CLASS="APISYMBOL">mgEditorSelectMouseInput</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorSelectMouseInput</B> - selects the active mouse input 
callback function for an editor tool instance.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgEditorSelectMouseInput</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgmouseinputtype>mgmouseinputtype</A></TD><TD><I>inputType</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorSelectMouseInput</B> selects which mouse input callback 
function to make active for the specified editor context, <I>editorContext</I>.</P></DD><DD><P>When an editor tool is registered, a separate mouse input callback 
function may be assigned for each class of mouse input (3D vertex input 
using <A HREF=#mgEditorSetVertexFunc>mgEditorSetVertexFunc</A>, 2D point input 
using <A HREF=#mgEditorSetPointFunc>mgEditorSetPointFunc</A>, geometry pick input using 
<A HREF=#mgEditorSetPickFunc>mgEditorSetPickFunc</A> and device specific input using 
<A HREF=#mgEditorSetDeviceInputFunc>mgEditorSetDeviceInputFunc</A>). When an editor instance is active, 
only one of the mouse input functions registered may be active at a time. 
This is required so Creator 
can interpret the mouse events properly for your tool instance. 
This function is used to select which mouse input callback function is 
currently active for an editor tool instance.</P></DD><DD><P>If your editor tool instance does not handle any mouse input, set 
<I>inputType</I> to <A HREF=#mgmouseinputtype>MMSI_NOINPUT</A> so that none of the 
mouse input callback functions are active.</P></DD><DD><P>You can switch between different mouse input callback functions 
at any time while your editor tool instance is active.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context to select 
active mouse input for</DD><DT><I>inputType</I></DT><DD>the mouse input callback function to select:<BR> 
<A HREF=#mgmouseinputtype>MMSI_VERTEXINPUT</A> - to select 3D vertex input <BR> 
<A HREF=#mgmouseinputtype>MMSI_POINTINPUT</A> - to select 2D point input <BR> 
<A HREF=#mgmouseinputtype>MMSI_PICKINPUT</A> - to select geometry pick input <BR> 
<A HREF=#mgmouseinputtype>MMSI_DEVICEINPUT</A> - to select device specific input <BR> 
<A HREF=#mgmouseinputtype>MMSI_NOINPUT</A> - to select NO mouse input</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows how an editor tool might register 
multiple mouse input functions (a 3D vertex function, a 2D point function 
and a pick function) for an editor tool, <I>editorTool</I> and then select 
one of them to be active when the tool instance is active.<BR><BR> 
When the editor tool is registered:</DT><DT><PRE CLASS="EXAMPLE">// Register the mouse input functions that are used by tool
mgEditorSetVertexFunc (editorTool, MyVertexFunc);
mgEditorSetPointFunc (editorTool, MyPointFunc);
mgEditorSetPickFunc (editorTool, MyPickFunc);
mgEditorSetDeviceInputFunc (editorTool, MyDeviceInputFunc);</PRE></DT><DT>Then when the editor tool instance is active:</DT><DT><PRE CLASS="EXAMPLE">// Activate the 3D vertex function, MyVertexFunc
mgEditorSelectMouseInput (editorContext, MMSI_VERTEXINPUT);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgEditorSetVertexFunc>mgEditorSetVertexFunc</A>, <A HREF=#mgEditorSetPointFunc>mgEditorSetPointFunc</A>, <A HREF=#mgEditorSetPickFunc>mgEditorSetPickFunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorSetButtonFunc><H1 CLASS="APISYMBOL">mgEditorSetButtonFunc</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorSetButtonFunc</B> - sets the dialog button function for an editor tool.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgEditorSetButtonFunc</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>editorPluginTool</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgeditorbuttonfunc>mgeditorbuttonfunc</A></TD><TD><I>buttonFunc</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorSetButtonFunc</B> assigns a dialog button function to the 
specified editor tool <I>editorPluginTool</I>.</P></DD><DD><P>Dialog button functions are called to notify your editor tool when 
the user has pressed one of the pre-defined buttons in the editor 
tool dialog.  These buttons are <A HREF=#MBT_DONE>MBT_DONE</A>, <A HREF=#MBT_CANCEL>MBT_CANCEL</A>, <A HREF=#MBT_NEXT>MBT_NEXT</A>, 
<A HREF=#MBT_UNDO>MBT_UNDO</A>, <A HREF=#MBT_REDO>MBT_REDO</A>, and <A HREF=#MBT_HELP>MBT_HELP</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorPluginTool</I></DT><DD>the editor plug-in tool</DD><DT><I>buttonFunc</I></DT><DD>the editor dialog button function</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following is a typical dialog button function.</DT><DT><PRE CLASS="EXAMPLE">mgEditorSetButtonFunc (pluginTool, ButtonFunc);

static void ButtonFunc (mgeditorcontext editorContext,
&#32 int whichButton,
&#32 void* toolData)
{
   toolrec* toolRec = (toolrec*) toolData;

   switch (whichButton)
   {
   case MBT_DONE:
      break;
   case MBT_CANCEL:
      break;
   case MBT_UNDO:
      break;
   case MBT_REDO:
      break;
   case MBT_NEXT:
      break;
   case MBT_HELP:
      break;
   }
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgeditorbuttonfunc>mgeditorbuttonfunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorSetCloseDialogFunc><H1 CLASS="APISYMBOL">mgEditorSetCloseDialogFunc</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorSetCloseDialogFunc</B> - sets the close dialog function for 
an editor tool.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgEditorSetCloseDialogFunc</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>editorPluginTool</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgeditorclosedialogfunc>mgeditorclosedialogfunc</A></TD><TD><I>closeDialogFunc</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorSetCloseDialogFunc</B> assigns a close dialog function 
to the specified editor tool <I>editorPluginTool</I>.</P></DD><DD><P>Close dialog functions are called to notify your editor tool when the user 
has clicked the Close Box in the title bar of the editor tool dialog. By convention, 
when the user clicks the Close Box of your dialog, this indicates that they want to 
close the dialog and "cancel" any changes they have made. This is equivalent to 
pressing the Cancel button in the tool dialog.</P></DD><DD><P>Normally, when the user clicks the 
Close Box, Creator simply sends the <A HREF=#MBT_CANCEL>MBT_CANCEL</A> event to the button function of 
your editor tool. In this way, however, your tool is unable to distinguish 
between the user pressing the Cancel button and the user clicking the Close Box. 
If you want to change this default behavior or have more control, you can 
assign a close dialog function for your tool. When you do this and the user clicks 
the Close Box, your close dialog function is called before proceeding.</P></DD><DD><P>If your function returns <A HREF=#mgbool>MG_TRUE</A>, Creator proceeds by first sending 
a button event to your button function and then closing the dialog and terminating the 
tool instance. You specify which button event is sent in the <I>buttonEvent</I> field of 
the <A HREF=#mgclosedialogcallbackrec>mgclosedialogcallbackrec</A> record passed to the close dialog function. Supported 
button events include <A HREF=#MBT_CANCEL>MBT_CANCEL</A> and <A HREF=#MBT_DONE>MBT_DONE</A>.</P></DD><DD><P>If your close dialog function returns <A HREF=#mgbool>MG_FALSE</A>, no event is sent 
to your button function, the dialog is not closed and the tool instance is not terminated.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorPluginTool</I></DT><DD>the editor plug-in tool</DD><DT><I>closeDialogFunc</I></DT><DD>the close dialog function</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following is a typical close dialog function.</DT><DT><PRE CLASS="EXAMPLE">mgEditorSetCloseDialogFunc (pluginTool, CloseDialogFunc);

static mgbool CloseDialogFunc (mgplugintool pluginTool,
&#32 mgclosedialogcallbackrec* callData,
&#32 void* toolData)
{
   toolrec* toolRec = (toolrec*) toolData;

   // ask the user if they really want to cancel
   int answer = mgMessageDialog (toolRec-&gtdialog, "Confirm",
&#32       "Are you sure you want to cancel without saving changes?",
&#32       MMBX_YESNOCANCEL);

   if (answer == 1) {
      // user answered Yes, they want to cancel but not save changes
      // tell Creator to send the &ltp Cancel&gt button event
      callData-&gtbuttonEvent = MBT_CANCEL;
   }
   return answer == 1 ? MG_TRUE : MG_FALSE;
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgtoolterminationreason>mgtoolterminationreason</A>, <A HREF=#mgeditorclosedialogfunc>mgeditorclosedialogfunc</A>, 
<A HREF=#mgclosedialogcallbackrec>mgclosedialogcallbackrec</A>, <A HREF=#mgResourceGetDialog>mgResourceGetDialog</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorSetCreateDialogFunc><H1 CLASS="APISYMBOL">mgEditorSetCreateDialogFunc</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorSetCreateDialogFunc</B> - sets the create dialog function for 
an editor tool.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgEditorSetCreateDialogFunc</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>editorPluginTool</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgeditorcreatedialogfunc>mgeditorcreatedialogfunc</A></TD><TD><I>createDialogFunc</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorSetCreateDialogFunc</B> assigns a create dialog function 
to the specified editor tool <I>editorPluginTool</I>.</P></DD><DD><P>Create dialog functions are called to build and return a dialog 
instance for an editor tool instance.  The dialog template is typically 
defined in your plug-in resource.  An instance of the dialog is built using 
<A HREF=#mgResourceGetDialog>mgResourceGetDialog</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorPluginTool</I></DT><DD>the editor plug-in tool</DD><DT><I>createDialogFunc</I></DT><DD>the create dialog function</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following is a typical create dialog function.</DT><DT><PRE CLASS="EXAMPLE">mgEditorSetCreateDialogFunc (pluginTool, CreateDialogFunc);

static mgstatus DialogProc (mggui dialog, mgdialogid dialogId,
&#32 mgguicallbackreason callbackReason,
&#32 void* userData, void* callData)
{
   toolrec* toolRec = (toolrec*) userData;
   mgeditorcontext editorContext = mgEditorGetContext (dialog);

   switch (callbackReason)
   {
   case MGCB_INIT:
      break;
   case MGCB_SIZE:
      break;
   case MGCB_SHOW:
      break;
   case MGCB_HIDE:
      break;
   case MGCB_DESTROY:
      break;
   }
   return (MSTAT_OK);
}

static mggui CreateDialogFunc (mgplugintool pluginTool, void* toolData)
{
   toolrec* toolRec = (toolrec*) toolData;
   mggui dialog;
   dialog = mgResourceGetDialog (MG_NULL, toolRec-&gtresource, MYDIALOG,
&#32&#32&#32&#32  MGCB_INIT|MGCB_SIZE|MGCB_SHOW|MGCB_HIDE|MGCB_DESTROY,
&#32&#32&#32&#32  DialogProc, toolRec);
   return (dialog);
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgtoolterminationreason>mgtoolterminationreason</A>, <A HREF=#mgeditorcreatedialogfunc>mgeditorcreatedialogfunc</A>, 
<A HREF=#mgResourceGetDialog>mgResourceGetDialog</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorSetDeviceInputFunc><H1 CLASS="APISYMBOL">mgEditorSetDeviceInputFunc</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorSetDeviceInputFunc</B> - sets the device input function for an editor tool.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgEditorSetDeviceInputFunc</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>editorPluginTool</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgeditordeviceinputfunc>mgeditordeviceinputfunc</A></TD><TD><I>devInputFunc</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorSetDeviceInputFunc</B> assigns a device input function to the 
specified editor tool <I>editorPluginTool</I>.</P></DD><DD><P>device input functions are called to notify your editor tool when 
an input device is activated by the user</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorPluginTool</I></DT><DD>the editor plug-in tool</DD><DT><I>devInputFunc</I></DT><DD>the device specific input function</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSelectMouseInput>mgEditorSelectMouseInput</A>, <A HREF=#mgeditordeviceinputfunc>mgeditordeviceinputfunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorSetFocusVertexFunc><H1 CLASS="APISYMBOL">mgEditorSetFocusVertexFunc</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorSetFocusVertexFunc</B> - sets the focus vertex function for 
an editor tool.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgEditorSetFocusVertexFunc</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>editorPluginTool</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgeditorfocusvertexfunc>mgeditorfocusvertexfunc</A></TD><TD><I>focusVertexFunc</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorSetFocusVertexFunc</B> assigns a focus vertex function to the 
specified editor tool <I>editorPluginTool</I>.</P></DD><DD><P>Focus vertex functions are called to notify your editor tool 
when the user has selected or deselected a vertex, <I>vertexRec</I>, 
from your vertex focus list.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorPluginTool</I></DT><DD>the editor plug-in tool</DD><DT><I>focusVertexFunc</I></DT><DD>the focus vertex function</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following is a typical focus vertex function.</DT><DT><PRE CLASS="EXAMPLE">mgEditorSetFocusVertexFunc (pluginTool, FocusVertexFunc);

static void FocusVertexFunc (mgeditorcontext editorContext,
&#32 mgrec* vertexRec, void* toolData)
{
   toolrec* toolRec = (toolrec*) toolData;
   if (vertexRec)
      mgSetFocusVertex (editorContext, vertexRec);
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgeditorfocusvertexfunc>mgeditorfocusvertexfunc</A>, 
<A HREF=#mgFocusVertexListAddItem>mgFocusVertexListAddItem</A>, <A HREF=#mgFocusVertexListDeleteItem>mgFocusVertexListDeleteItem</A>, <A HREF=#mgFocusVertexListDeleteAllItems>mgFocusVertexListDeleteAllItems</A>, 
<A HREF=#mgSetFocusVertex>mgSetFocusVertex</A>, <A HREF=#mgClearFocusVertex>mgClearFocusVertex</A>, <B>mgSetAutoFocusVertexEnabled</B></DD></DL>
<HR>
<LEFT><A NAME=mgEditorSetPickFunc><H1 CLASS="APISYMBOL">mgEditorSetPickFunc</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorSetPickFunc</B> - sets the pick function for an editor tool.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgEditorSetPickFunc</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>editorPluginTool</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgeditorpickfunc>mgeditorpickfunc</A></TD><TD><I>pickFunc</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorSetPickFunc</B> assigns a pick function to the specified 
editor tool <I>editorPluginTool</I>.</P></DD><DD><P>Pick functions are called to notify your editor tool when 
geometry has been picked by the user.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorPluginTool</I></DT><DD>the editor plug-in tool</DD><DT><I>pickFunc</I></DT><DD>the pick input function</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following is a typical pick function.</DT><DT><PRE CLASS="EXAMPLE">mgEditorSetPickFunc (pluginTool, PickFunc);

static void PickFunc (mgeditorcontext editorContext,
&#32 mgpickinputdata* pickInputData,
&#32 void* toolData)
{
   toolrec* toolRec = (toolrec*) toolData;

   unsigned keyboardFlags  = pickInputData-&gtkeyboardFlags;
   unsigned buttonFlags    = pickInputData-&gtbuttonFlags;

   int leftMouseDown       = buttonFlags & MMB_LEFTMOUSE;
   int middleMouseDown     = buttonFlags & MMB_MIDDLEMOUSE;
   int rightMouseDown      = buttonFlags & MMB_RIGHTMOUSE;

   int ctrlKeyDown         = keyboardFlags & MKB_CTRLKEY;
   int altKeyDown          = keyboardFlags & MKB_ALTKEY;
   int shiftKeyDown        = keyboardFlags & MKB_SHIFTKEY;
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSelectMouseInput>mgEditorSelectMouseInput</A>, <A HREF=#mgeditorpickfunc>mgeditorpickfunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorSetPointFunc><H1 CLASS="APISYMBOL">mgEditorSetPointFunc</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorSetPointFunc</B> - sets the 2D point function for an editor tool.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgEditorSetPointFunc</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>editorPluginTool</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgeditorpointfunc>mgeditorpointfunc</A></TD><TD><I>pointFunc</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorSetPointFunc</B> assigns a 2D point function to the specified 
editor tool <I>editorPluginTool</I>.</P></DD><DD><P>2D point functions are called to notify your editor tool when 
a 2D screen coordinate has been entered by the user via the mouse.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorPluginTool</I></DT><DD>the editor plug-in tool</DD><DT><I>pointFunc</I></DT><DD>the 2D point input function</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following is a typical 2D point function.</DT><DT><PRE CLASS="EXAMPLE">mgEditorSetPointFunc (pluginTool, PointFunc);

static void PointFunc (mgeditorcontext editorContext,
      mgpointinputdata* pointInputData,
      void* toolData)
{
   toolrec* toolRec = (toolrec*) toolData;
   mgmousestate mouseEvent = pointInputData-&gtmouseEvent;
   unsigned keyboardFlags  = pointInputData-&gtkeyboardFlags;
   unsigned buttonFlags    = pointInputData-&gtbuttonFlags;
   mgcoord2i* thisPoint    = pointInputData-&gtthisPoint;
   mgcoord2i* firstPoint   = pointInputData-&gtfirstPoint;

   int leftMouseDown       = buttonFlags & MMB_LEFTMOUSE;
   int middleMouseDown     = buttonFlags & MMB_MIDDLEMOUSE;
   int rightMouseDown      = buttonFlags & MMB_RIGHTMOUSE;

   int ctrlKeyDown         = keyboardFlags & MKB_CTRLKEY;
   int altKeyDown          = keyboardFlags & MKB_ALTKEY;
   int shiftKeyDown        = keyboardFlags & MKB_SHIFTKEY;

   switch (mouseEvent)
   {
   case MMSS_START:
      break;
   case MMSS_STOP:
      break;
   case MMSS_CONTINUE:
      break;
   }
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSelectMouseInput>mgEditorSelectMouseInput</A>, <A HREF=#mgeditorpointfunc>mgeditorpointfunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorSetPrompt><H1 CLASS="APISYMBOL">mgEditorSetPrompt</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorSetPrompt</B> - sets the prompt string within an 
editor tool dialog.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgEditorSetPrompt</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>promptString</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorSetPrompt</B> copies the prompt string, <I>promptString</I>, 
into the prompt text field of the dialog associated with the specified 
editor context, <I>editorContext</I>.</P></DD><DD><P>If an editor tool instance creates a dialog that contains a text 
control whose identifier is <A HREF=#MGID_PROMPT>MGID_PROMPT</A>, <B>mgEditorSetPrompt</B> can 
be used as a convenience function to load a string into that text control.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context whose 
associated dialog prompt is to be set</DD><DT><I>promptString</I></DT><DD>the prompt string</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgEditorGetDialog>mgEditorGetDialog</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorSetSnapFace><H1 CLASS="APISYMBOL">mgEditorSetSnapFace</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorSetSnapFace</B> - enables or disables "face snapping" 
to control 3D vertex input for an editor tool instance.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgEditorSetSnapFace</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>flag</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorSetSnapFace</B> controls whether 3D vertex input is 
automatically snapped to the face below the mouse for the specified 
editor context, <I>editorContext</I>.</P></DD><DD><P>When a 3D vertex input callback function is active for an editor 
tool instance, you can use this function to specify that all coordinate 
input be "snapped to" (projected onto) the face below (pointed to by) 
the mouse. 
If you set <I>flag</I> to <A HREF=#mgbool>MG_TRUE</A>, face snapping will be enabled. 
If you set <I>flag</I> to <A HREF=#mgbool>MG_FALSE</A>, face snapping will be disabled.</P></DD><DD><P>When face snapping is enabled and the modeler uses the mouse to enter 
a 3D vertex in the graphics view, the 3D vertex coordinate returned will 
be projected onto the plane in which the face below the mouse lies. 
When more than one face is below the mouse, the face selected is that 
which is "topmost" in Z ordering. 
If no faces are below the mouse, the 3D vertex returned will be 
determined by the current trackplane.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context in which 
to enable or disable face snapping</DD><DT><I>flag</I></DT><DD><A HREF=#mgbool>MG_TRUE</A> to enable face 
snapping, <A HREF=#mgbool>MG_FALSE</A> to disable</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgEditorSetVertexFunc>mgEditorSetVertexFunc</A>, <A HREF=#mgEditorSetSnapLine>mgEditorSetSnapLine</A>, <A HREF=#mgEditorSetTrackPlane>mgEditorSetTrackPlane</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorSetSnapLine><H1 CLASS="APISYMBOL">mgEditorSetSnapLine</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorSetSnapLine</B> - selects a snap line to control 3D 
vertex input for an editor tool instance.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgEditorSetSnapLine</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mglined>mglined*</A></TD><TD><I>snapLine</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorSetSnapLine</B> selects a line <I>snapLine</I>, to which all 
3D vertex input is "snapped" for the specified editor context, 
<I>editorContext</I>.</P></DD><DD><P>When a 3D vertex input callback function is active for an editor 
tool instance, you can use this function to specify that all coordinate 
input be "snapped" to the specified line.  In this way, when the user enters 
coordinates (x, y, z), the actual coordinates reported, (x', y', z'), will 
represent the point closest to (x, y, z) on the specified line.</P></DD><DD><P>If <I>snapLine</I> is specified as <A HREF=#MG_NULL>MG_NULL</A>, normal 3D vertex input 
will resume.  That is the current snap line will be ignored.</P></DD><DD><P>Note: The Wall Tool in Creator uses this technique to raise the 
walls of a selected polygon along the normal vector of the polygon.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context to select 
the snap line for</DD><DT><I>snapLine</I></DT><DD>the line to control 3D 
vertex input</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgEditorSetVertexFunc>mgEditorSetVertexFunc</A>, <A HREF=#mgEditorSetTrackPlane>mgEditorSetTrackPlane</A>, 
<A HREF=#mgEditorSetSnapFace>mgEditorSetSnapFace</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorSetTerminateFunc><H1 CLASS="APISYMBOL">mgEditorSetTerminateFunc</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorSetTerminateFunc</B> - sets the termination function for an editor tool.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgEditorSetTerminateFunc</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>editorPluginTool</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgeditorterminatefunc>mgeditorterminatefunc</A></TD><TD><I>terminateFunc</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorSetTerminateFunc</B> assigns a termination function to the 
specified editor tool <I>editorPluginTool</I>.</P></DD><DD><P>Termination functions are called to notify your editor tool when it has 
been terminated.  Refer to <A HREF=#mgtoolterminationreason>mgtoolterminationreason</A> for 
a list of reasons an editor tool can be terminated.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorPluginTool</I></DT><DD>the editor plug-in tool</DD><DT><I>terminateFunc</I></DT><DD>the editor termination function</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following is a typical dialog button function.</DT><DT><PRE CLASS="EXAMPLE">mgEditorSetButtonFunc (pluginTool, ButtonFunc);

static void TerminateFunc (mgeditorcontext editorContext,
&#32 mgtoolterminationreason terminateReason,
&#32 void* toolData)
{
   toolrec* toolRec = (toolrec*) toolData;

   switch (terminateReason)
   {
   case MTRM_DONE:
      break;
   case MTRM_SYSTEM:
      break;
   case MTRM_CANCEL:
      break;
   case MTRM_SELF:
      break;
   }
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgtoolterminationreason>mgtoolterminationreason</A>, <A HREF=#mgeditorterminatefunc>mgeditorterminatefunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorSetTrackPlane><H1 CLASS="APISYMBOL">mgEditorSetTrackPlane</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorSetTrackPlane</B> - selects a tracking plane to control 
3D vertex input for an editor tool instance.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgEditorSetTrackPlane</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgplaned>mgplaned*</A></TD><TD><I>trackPlane</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorSetTrackPlane</B> selects a tracking plane <I>trackPlane</I>, that 
controls 3D vertex input for the specified editor context, 
<I>editorContext</I>.</P></DD><DD><P>When a 3D vertex input callback function is active for an editor 
tool instance, you can use this function to specify that all coordinate 
input be projected onto the specified plane. In this way, you can override 
the tracking plane(s) set up by the modeler in Creator.</P></DD><DD><P>The tracking plane you select does not affect vertex and edge 
references or coordinates input via the Track Coordinate Window. 
Also, Snap To Grid, if set in Creator, is ignored for your selected 
tracking plane.</P></DD><DD><P>If <I>trackPlane</I> is specified as <A HREF=#MG_NULL>MG_NULL</A>, the tracking plane 
set by the modeler in Creator will be used again for 3D vertex input.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context to select 
the tracking plane for</DD><DT><I>trackPlane</I></DT><DD>the tracking plane to control 3D 
vertex input</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgEditorSetVertexFunc>mgEditorSetVertexFunc</A>, <A HREF=#mgEditorSetSnapLine>mgEditorSetSnapLine</A>, <A HREF=#mgEditorSetSnapFace>mgEditorSetSnapFace</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorSetVertexFunc><H1 CLASS="APISYMBOL">mgEditorSetVertexFunc</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorSetVertexFunc</B> - sets the 3D vertex function for an editor tool.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgEditorSetVertexFunc</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>editorPluginTool</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgeditorvertexfunc>mgeditorvertexfunc</A></TD><TD><I>vertexFunc</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEditorSetVertexFunc</B> assigns a 3D vertex function to the 
specified editor tool <I>editorPluginTool</I>.</P></DD><DD><P>3D vertex functions are called to notify your editor tool when 
a 3D coordinate has been entered by the user either via the mouse or 
the Track Coordinate Window.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorPluginTool</I></DT><DD>the editor plug-in tool</DD><DT><I>vertexFunc</I></DT><DD>the 3D vertex input function</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following is a typical 3D vertex function.</DT><DT><PRE CLASS="EXAMPLE">mgEditorSetVertexFunc (pluginTool, VertexFunc);

static int VertexFunc (mgeditorcontext editorContext,
&#32 mgvertexinputdata* vertexInputData,
&#32 void* toolData)
{
   toolrec* toolRec = (toolrec*) toolData;
   int updateRef = 0;

   mgmousestate mouseEvent = vertexInputData-&gtmouseEvent;
   unsigned keyboardFlags  = vertexInputData-&gtkeyboardFlags;
   unsigned buttonFlags    = vertexInputData-&gtbuttonFlags;
   mgcoord3d* thisPoint    = vertexInputData-&gtthisPoint;
   mgcoord3d* firstPoint   = vertexInputData-&gtfirstPoint;

   int leftMouseDown       = buttonFlags & MMB_LEFTMOUSE;
   int middleMouseDown     = buttonFlags & MMB_MIDDLEMOUSE;
   int rightMouseDown      = buttonFlags & MMB_RIGHTMOUSE;

   int ctrlKeyDown         = keyboardFlags & MKB_CTRLKEY;
   int altKeyDown          = keyboardFlags & MKB_ALTKEY;
   int shiftKeyDown        = keyboardFlags & MKB_SHIFTKEY;

   switch (mouseEvent)
   {
   case MMSS_START:
      break;
   case MMSS_STOP:
      break;
   case MMSS_CONTINUE:
      break;
   }
   return (updateRef);
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSelectMouseInput>mgEditorSelectMouseInput</A>, <A HREF=#mgeditorvertexfunc>mgeditorvertexfunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgeditorterminatefunc><H1 CLASS="APISYMBOL">mgeditorterminatefunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgeditorterminatefunc</B> - Editor termination function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void (*<B>mgeditorterminatefunc</B>) ( <TD><A HREF=#mgeditorcontext>mgeditorcontext</A> <TD><I>editorContext</I>, 
<TR><TD></TD><TD><A HREF=#mgtoolterminationreason>mgtoolterminationreason</A> <TD><I>reason</I>, 
<TR><TD></TD><TD>void* <TD><I>editorToolData</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for editor termination callback functions. 
If your editor tool displays a dialog, you can assign a termination 
function to your editor tool of this form.</P></DD><DD><P>Termination 
functions are called to notify your editor tool when it has 
been terminated.  Refer to <A HREF=#mgtoolterminationreason>mgtoolterminationreason</A> for 
a list of reasons an editor tool can be terminated.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context that identifies the 
editor instance being terminated</DD><DT><I>reason</I></DT><DD>the reason editor is being terminated <BR> 
<A HREF=#mgtoolterminationreason>MTRM_DONE</A> <BR> 
<A HREF=#mgtoolterminationreason>MTRM_CANCEL</A> <BR> 
<A HREF=#mgtoolterminationreason>MTRM_SELF</A> <BR> 
<A HREF=#mgtoolterminationreason>MTRM_SYSTEM</A></DD><DT><I>editorToolData</I></DT><DD>user defined tool instance data 
set in <I>toolData</I> field of <I>callData</I> 
parameter (<A HREF=#mgeditorcallbackrec>mgeditorcallbackrec</A>) during 
editor tool start function <A HREF=#mgtoolstartfunc>mgtoolstartfunc</A></DD></DL></DD></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSetTerminateFunc>mgEditorSetTerminateFunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgEditorTerminateTool><H1 CLASS="APISYMBOL">mgEditorTerminateTool</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEditorTerminateTool</B> - terminates an editor tool instance.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgEditorTerminateTool</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><A HREF=#mgEditorCancelTool>mgEditorCancelTool</A> terminates the editor tool instance identified 
by editor context, <I>editorContext</I> with the Editor Tool Termination Reason 
<A HREF=#mgtoolterminationreason>MTRM_SELF</A>.</P></DD><DD><P>Normally, editor tool instances are terminated when the user presses 
the <I>Done</I> or <I>Cancel</I> buttons in the tool dialog associated with the 
editor instance.  In some cases, however, the editor tool instance may allow 
other actions (user or processing) to cause the termination of the 
tool instance.  In these cases, the tool can call <B>mgEditorTerminateTool</B> 
to terminate itself.</P></DD><DD><P>When an editor tool is terminated in this way, the termination function 
is called with termination reason  <A HREF=#mgtoolterminationreason>MTRM_SELF</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context that identifies 
the editor instance being terminated</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSetTerminateFunc>mgEditorSetTerminateFunc</A>, <A HREF=#mgEditorCancelTool>mgEditorCancelTool</A>, 
<A HREF=#mgeditorterminatefunc>mgeditorterminatefunc</A>, <A HREF=#mgtoolterminationreason>mgtoolterminationreason</A></DD></DL>
<HR>
<LEFT><A NAME=mgeditorundocleanupfunc><H1 CLASS="APISYMBOL">mgeditorundocleanupfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgeditorundocleanupfunc</B> - Editor undo cleanup callback function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void (*<B>mgeditorundocleanupfunc</B>) ( <TD><A HREF=#mgrec>mgrec*</A> <TD><I>db</I>, 
<TR><TD></TD><TD><A HREF=#mgundocleanupreason>mgundocleanupreason</A> <TD><I>cleanupReason</I>, 
<TR><TD></TD><TD>void* <TD><I>undoData</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for editor undo cleanup callback functions. 
If your editor tool performs an undo-able action, register 
an undo cleanup callback function for your editor tool instance of this form.</P></DD><DD><P>Editor undo cleanup functions are called to notify your editor tool when 
it is safe to deallocate any undo data you may have allocated for your undo 
callback function.  Undo data may be deallocated either after the 
undo callback function is called or after the corresponding undo entry 
becomes unreachable in the Edit->Undo menu.  Undo entries become unreachable 
when their position in the undo stack becomes deeper than the maximum undo 
stack size set by the user preference.</P></DD><DD><P>This function must deallocate any undo data allocated 
for the corresponding undo callback.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database for which the undo/redo 
cleanup callback is being called</DD><DT><I>cleanupReason</I></DT><DD>the reason why the undo cleanup callback 
is being called - refer to <A HREF=#mgundocleanupreason>mgundocleanupreason</A> 
for a list of reasons an undo cleanup callback 
function can be called</DD><DT><I>undoData</I></DT><DD>user defined undo/redo data specified when 
undo/redo callback was registered via 
<A HREF=#mgEditorAddUndo>mgEditorAddUndo</A>, <A HREF=#mgEditorAppendUndo>mgEditorAppendUndo</A>, 
<A HREF=#mgEditorAddRedo>mgEditorAddRedo</A>, <A HREF=#mgEditorAddUndoForRedo>mgEditorAddUndoForRedo</A>, 
<A HREF=#mgEditorAddUndoForCreate>mgEditorAddUndoForCreate</A>, <A HREF=#mgEditorAppendUndoForCreate>mgEditorAppendUndoForCreate</A>, 
<A HREF=#mgEditorAddUndoForDelete>mgEditorAddUndoForDelete</A>, <A HREF=#mgEditorAppendUndoForDelete>mgEditorAppendUndoForDelete</A>, 
<A HREF=#mgEditorAddUndoForMove>mgEditorAddUndoForMove</A> or <A HREF=#mgEditorAppendUndoForMove>mgEditorAppendUndoForMove</A><BR> 
this is typically the data you will deallocate</DD></DL></DD></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgEditorAddUndo>mgEditorAddUndo</A>, <A HREF=#mgEditorAppendUndo>mgEditorAppendUndo</A>, 
<A HREF=#mgEditorAddRedo>mgEditorAddRedo</A>, <A HREF=#mgEditorAddUndoForRedo>mgEditorAddUndoForRedo</A>, 
<A HREF=#mgEditorAddUndoForCreate>mgEditorAddUndoForCreate</A>, <A HREF=#mgEditorAppendUndoForCreate>mgEditorAppendUndoForCreate</A>, 
<A HREF=#mgEditorAddUndoForDelete>mgEditorAddUndoForDelete</A>, <A HREF=#mgEditorAppendUndoForDelete>mgEditorAppendUndoForDelete</A>, 
<A HREF=#mgEditorAddUndoForMove>mgEditorAddUndoForMove</A>, <A HREF=#mgEditorAppendUndoForMove>mgEditorAppendUndoForMove</A></DD></DL>
<HR>
<LEFT><A NAME=mgeditorundofunc><H1 CLASS="APISYMBOL">mgeditorundofunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgeditorundofunc</B> - Editor undo callback function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void (*<B>mgeditorundofunc</B>) ( <TD><A HREF=#mgrec>mgrec*</A> <TD><I>db</I>, 
<TR><TD></TD><TD>void* <TD><I>undoData</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for editor undo callback functions. 
If your editor tool performs an undo-able action, register 
an undo callback function for your editor tool instance of this form.</P></DD><DD><P>Editor undo functions are called when the user selects the 
corresponding Undo "ToolName" menu item from the Edit->Undo menu. 
This function must "undo" any actions performed by the corresponding 
editor tool instance.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database for which the undo/redo 
callback is being called</DD><DT><I>undoData</I></DT><DD>user defined undo data specified when undo/redo 
callback was registered via 
<A HREF=#mgEditorAddUndo>mgEditorAddUndo</A>, <A HREF=#mgEditorAppendUndo>mgEditorAppendUndo</A>, 
<A HREF=#mgEditorAddRedo>mgEditorAddRedo</A>, <A HREF=#mgEditorAddUndoForRedo>mgEditorAddUndoForRedo</A>, 
<A HREF=#mgEditorAddUndoForCreate>mgEditorAddUndoForCreate</A>, <A HREF=#mgEditorAppendUndoForCreate>mgEditorAppendUndoForCreate</A>, 
<A HREF=#mgEditorAddUndoForDelete>mgEditorAddUndoForDelete</A>, <A HREF=#mgEditorAppendUndoForDelete>mgEditorAppendUndoForDelete</A>, 
<A HREF=#mgEditorAddUndoForMove>mgEditorAddUndoForMove</A> or <A HREF=#mgEditorAppendUndoForMove>mgEditorAppendUndoForMove</A></DD></DL></DD></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgEditorAddUndo>mgEditorAddUndo</A>, <A HREF=#mgEditorAppendUndo>mgEditorAppendUndo</A>, 
<A HREF=#mgEditorAddRedo>mgEditorAddRedo</A>, <A HREF=#mgEditorAddUndoForRedo>mgEditorAddUndoForRedo</A>, 
<A HREF=#mgEditorAddUndoForCreate>mgEditorAddUndoForCreate</A>, <A HREF=#mgEditorAppendUndoForCreate>mgEditorAppendUndoForCreate</A>, 
<A HREF=#mgEditorAddUndoForDelete>mgEditorAddUndoForDelete</A>, <A HREF=#mgEditorAppendUndoForDelete>mgEditorAppendUndoForDelete</A>, 
<A HREF=#mgEditorAddUndoForMove>mgEditorAddUndoForMove</A>, <A HREF=#mgEditorAppendUndoForMove>mgEditorAppendUndoForMove</A></DD></DL>
<HR>
<LEFT><A NAME=mgeditorvertexfunc><H1 CLASS="APISYMBOL">mgeditorvertexfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgeditorvertexfunc</B> - Editor 3D vertex function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int (*<B>mgeditorvertexfunc</B>) ( <TD><A HREF=#mgeditorcontext>mgeditorcontext</A> <TD><I>editorContext</I>, 
<TR><TD></TD><TD><A HREF=#mgvertexinputdata>mgvertexinputdata*</A> <TD><I>vertexInputData</I>, 
<TR><TD></TD><TD>void* <TD><I>editorToolData</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for editor 3D vertex functions. 
If your editor tool requires 3D vertex (coordinate) input at 
any time while it is active, you will assign a 3D vertex 
function to your editor tool of this form.</P></DD><DD><P>3D vertex functions are called to notify your editor 
tool when a 3D coordinate has been entered by the user 
either via the mouse or the Track Coordinate Window.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context that identifies the 
editor instance receiving the 3D vertex input</DD><DT><I>vertexInputData</I></DT><DD>address of record describing the 3D 
vertex input</DD><DT><I>editorToolData</I></DT><DD>user defined tool instance data 
set in <I>toolData</I> field of <I>callData</I> 
parameter (<A HREF=#mgeditorcallbackrec>mgeditorcallbackrec</A>) during 
editor tool start function <A HREF=#mgtoolstartfunc>mgtoolstartfunc</A></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Return 1 if the 3D vertex coordinates passed in should 
be copied to Reference Coordinate in Track Coordinate 
Window, 0 otherwise.
</DD></DL><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgEditorSetVertexFunc>mgEditorSetVertexFunc</A>, <A HREF=#mgEditorSelectMouseInput>mgEditorSelectMouseInput</A></DD></DL>
<HR>
<LEFT><A NAME=mgEvaluateAsBool><H1 CLASS="APISYMBOL">mgEvaluateAsBool</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgEvaluateAsBool</B> - provides a walkfunc that wraps an expression tree.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgEvaluateAsBool</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>parent</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgEvaluateAsBool</B> provides a walkfunc that wraps an expression tree.  This 
walkfunc is to be used in <A HREF=#mgFind>mgFind</A> and <A HREF=#mgFindEx>mgFindEx</A> calls.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database containing the node being visited</DD><DT><I>parent</I></DT><DD>the parent of the node being visited (<A HREF=#MG_NULL>MG_NULL</A> if <I>rec</I> is <I>db</I>)</DD><DT><I>rec</I></DT><DD>the node currently being visited</DD><DT><I>userData</I></DT><DD>user defined data specified in call to <A HREF=#mgFind>mgFind</A>, <A HREF=#mgFindEx>mgFindEx</A></DD></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example collects all polygons of material index 2 in a database.</DT><DT><PRE CLASS="EXAMPLE">mgreclist list;

mgnodeexpression poly = mgNewNodeExpressionOperator(MEOP_EQ);
mgnodeexpression divide = mgNewNodeExpressionOperator(MEOP_DIV);
mgNodeExpressionSetLeft(poly, mgNewNodeExpressionGetAtt(fltPolyMaterial));
mgNodeExpressionSetLeft(divide, mgNewNodeExpressionInteger(4));
mgNodeExpressionSetRight(divide, mgNewNodeExpressionInteger(2));
mgNodeExpressionSetRight(poly, divide);
list = mgFind(toolRec-&gtdb, mgEvaluateAsBool, poly, MWALK_ON);

// do something with list, free it when done

mgFreeRecList (list);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgFindEx>mgFindEx</A>, <A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, <A HREF=#mgWalkGetMatrix>mgWalkGetMatrix</A></DD></DL>
<HR>
<LEFT><A NAME=mgExecute><H1 CLASS="APISYMBOL">mgExecute</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExecute</B> - executes a Creator command.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgExecute</B> (</TD><TD>const char*</TD><TD><I>toolName</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>params</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExecute</B> executes a Creator command.</P></DD><DD><P>This function allows your plug-in tool or OpenFlight Script to 
execute tools in the Creator modeler environment.</P></DD><DD><P>Note: This function is not available in the stand-alone application 
environment.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>toolName</I></DT><DD>the Creator command to execute</DD><DT><I>params</I></DT><DD>the parameters to pass to the command</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show how you might use 
<B>mgExecute</B> to execute the Creator Tool <B>Calculate Shading</B> :</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">// create a parameter block for the Calculate Shading command
// the parameter block is initialized with default values
mgparamblock paramBlock = mgGetParamBlock ("Calculate Shading");

// set the values for each parameter in the block
mgParamSetDouble (paramBlock, "Angular Tolerance", 89.0);
mgParamSetDouble (paramBlock, "Sampling Tolerance", 0.01);
mgParamSetString (paramBlock, "Shading Model", "Lit");
mgParamSetBool (paramBlock, "Triangle Area Weighting", MG_FALSE);
mgParamSetBool (paramBlock, "Update Vertex Colors", MG_TRUE);
mgParamSetBool (paramBlock, "Update Vertex Normals", MG_TRUE);
mgParamSetBool (paramBlock, "Use Face Color Intensities", MG_TRUE);

// execute the Calculate Shading command using the parameters set
mgExecute ("Calculate Shading", paramBlock);</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE"># create a parameter block for the Calculate Shading command
# the parameter block is initialized with default values
paramBlock = mgGetParamBlock ("Calculate Shading")

# set the values for each parameter in the block
mgParamSetDouble (paramBlock, "Angular Tolerance", 89.0)
mgParamSetDouble (paramBlock, "Sampling Tolerance", 0.01)
mgParamSetString (paramBlock, "Shading Model", "Lit")
mgParamSetBool (paramBlock, "Triangle Area Weighting", MG_FALSE)
mgParamSetBool (paramBlock, "Update Vertex Colors", MG_TRUE)
mgParamSetBool (paramBlock, "Update Vertex Normals", MG_TRUE)
mgParamSetBool (paramBlock, "Use Face Color Intensities", MG_TRUE)

# execute the Calculate Shading command using the parameters set
mgExecute ("Calculate Shading", paramBlock)</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetParamBlock>mgGetParamBlock</A>, <A HREF=#mgNewParamBlock>mgNewParamBlock</A>, <A HREF=#mgFreeParamBlock>mgFreeParamBlock</A>, 
<A HREF=#mgParamSetInteger>mgParamSetInteger</A>, <A HREF=#mgParamSetDouble>mgParamSetDouble</A>, <A HREF=#mgParamSetFloat>mgParamSetFloat</A>, 
<A HREF=#mgParamSetBool>mgParamSetBool</A>, <A HREF=#mgParamSetString>mgParamSetString</A></DD></DL>
<HR>
<LEFT><A NAME=mgExit><H1 CLASS="APISYMBOL">mgExit</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExit</B> - exits the OpenFlight API software development 
environment.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgbool <B>mgExit</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExit</B> is the very last function an application should call. 
This function performs the proper exit functions, such as closing all 
database and resource files, housekeeping, and releasing memory. 
It is a mandatory call to exit the entire programming environment. 
<B>mgExit</B> does not write or save any databases.</P></DD><DD><P>Note: This function is for use in stand-alone applications only 
and should not be called from inside a plug-in.  Doing so may yield 
undefined results.</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgCloseDb>mgCloseDb</A>, <A HREF=#mgInit>mgInit</A>, <A HREF=#mgIsInitialized>mgIsInitialized</A></DD></DL>
<HR>
<LEFT><A NAME=mgExportDb><H1 CLASS="APISYMBOL">mgExportDb</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExportDb</B> - exports an OpenFlight database to disk as 
a different file format or version.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgExportDb</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fileName</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>formatName</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>formatVersion</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>...</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExportDb</B> exports the contents of the OpenFlight database 
<I>db</I> to a different file format on disk.  The file format is specified 
by name <I>formatName</I> and version <I>formatVersion</I>.  The name of the 
file created is specified by <I>fileName</I>.  An argument list specifies 
a list of format specific parameters to control the export operation.</P></DD><DD><P>The in-memory representation of <I>db</I> is not affected by this 
function.  In particular, the database <I>db</I> retains its original file 
name so subsequent calls to <A HREF=#mgWriteDb>mgWriteDb</A> will write out the original 
file name, not the name you specified to <B>mgExportDb</B>.  Note that 
this behavior is different from that of <A HREF=#mgSaveAsDb>mgSaveAsDb</A> which changes 
the file name associated with the in-memory representation of <I>db</I>.</P></DD><DD><P>Note: If invoked from within the modeler environment, this function 
will fail if either <I>db</I> or the named file is open in an active window.</P></DD><DD><P>The only valid format name is <A HREF=#MEFN_OPENFLIGHT>MEFN_OPENFLIGHT</A>.</P></DD><DD><P>The valid format versions for format name <A HREF=#MEFN_OPENFLIGHT>MEFN_OPENFLIGHT</A> are:<BR> 
<A HREF=#MEFV_1650>MEFV_1650</A><BR> 
<A HREF=#MEFV_1640>MEFV_1640</A><BR> 
<A HREF=#MEFV_1630>MEFV_1630</A><BR> 
<A HREF=#MEFV_1620>MEFV_1620</A><BR> 
<A HREF=#MEFV_1610>MEFV_1610</A><BR> 
<A HREF=#MEFV_1600>MEFV_1600</A><BR> 
<A HREF=#MEFV_1580>MEFV_1580</A><BR> 
<A HREF=#MEFV_1570>MEFV_1570</A><BR> 
<A HREF=#MEFV_1560>MEFV_1560</A><BR> 
<A HREF=#MEFV_1540>MEFV_1540</A></P></DD><DD><P>The format name <A HREF=#MEFN_OPENFLIGHT>MEFN_OPENFLIGHT</A> does not take any additional 
export parameters so the argument list should be <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database to export</DD><DT><I>fileName</I></DT><DD>the name of the file to create</DD><DT><I>formatName</I></DT><DD>the name of the format to export to</DD><DT><I>formatVersion</I></DT><DD>the version of <I>formatName</I> to export to</DD><DT><I>...</I></DT><DD>the argument list is in pairs of <I>arg</I> and 
<I>value</I> ending with <A HREF=#MG_NULL>MG_NULL</A> terminator</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following opens a file and exports it out to 3 different 
versions of OpenFlight.</DT><DT><PRE CLASS="EXAMPLE">mgrec* db;
db = mgOpenDb ("file.flt");
mgExportDb (db, "file15-4.flt", MEFN_OPENFLIGHT, MEFV_1540, MG_NULL);
mgExportDb (db, "file15-6.flt", MEFN_OPENFLIGHT, MEFV_1560, MG_NULL);
mgExportDb (db, "file15-7.flt", MEFN_OPENFLIGHT, MEFV_1570, MG_NULL);

mgWriteDb (db);&#32&#32// will write out "file.flt"
mgCloseDb (db);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewDb>mgNewDb</A>, <A HREF=#mgOpenDb>mgOpenDb</A>, <A HREF=#mgCloseDb>mgCloseDb</A>, 
<A HREF=#mgWriteDb>mgWriteDb</A>, <A HREF=#mgSaveAsDb>mgSaveAsDb</A>, <A HREF=#mgSetNewOverwriteFlag>mgSetNewOverwriteFlag</A></DD></DL>
<HR>
<LEFT><A NAME=mgExtensionFieldAdd><H1 CLASS="APISYMBOL">mgExtensionFieldAdd</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExtensionFieldAdd</B> - creates a new extension field.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgExtensionFieldAdd</B> (</TD><TD>const char*</TD><TD><I>siteGuid</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fieldGuid</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExtensionFieldAdd</B> creates a new extension field 
identified by <I>fieldGuid</I> and associates the new field to the 
extension site identified by <I>siteGuid</I>.  <I>fieldGuid</I> is a 
GUID (Globally Uniquie IDentifier) and is used to uniquely identify the field.</P></DD><DD><P><I>fieldGuid</I> is expected to be in the form of 
Microsoft's Universally Unique Identifier (UUID) standard. 
In its canonical form, a UUID consists of 32 hexadecimal digits, displayed 
in 5 groups separated by hyphens, in the form 8-4-4-4-12 for a total of 
36 characters (32 digits and 4 '-'). For example: 
<PRE CLASS="EXAMPLE">550e8400-e29b-41d4-a716-446655440000</PRE></P></DD><DD><P>After you create an extension field for a site, use <A HREF=#mgExtensionFieldSetName>mgExtensionFieldSetName</A> 
to set the name of the field, <A HREF=#mgExtensionFieldSetAttach>mgExtensionFieldSetAttach</A> to set its attach type and 
<A HREF=#mgExtensionFieldSetType>mgExtensionFieldSetType</A> to set its data type.</P></DD><DD><P>You can use the function <A HREF=#mgExtensionMakeGUID>mgExtensionMakeGUID</A> to generate a GUID 
for your new extension field, or on Windows you can use the <B>uuidgen</B> utility.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>siteGuid</I></DT><DD>the GUID of the site to add the new field</DD><DT><I>fieldGuid</I></DT><DD>the GUID of the field to create</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>See <A HREF=#mgExtensionSiteAdd>mgExtensionSiteAdd</A> for an example of how you might create an 
extension site and populate it with extension fields.</DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExtensionSiteAdd>mgExtensionSiteAdd</A>, <A HREF=#mgExtensionFieldSetName>mgExtensionFieldSetName</A>, 
<A HREF=#mgExtensionFieldSetAttach>mgExtensionFieldSetAttach</A>, <A HREF=#mgExtensionFieldSetType>mgExtensionFieldSetType</A>, 
<A HREF=#mgExtensionMakeGUID>mgExtensionMakeGUID</A></DD></DL>
<HR>
<LEFT><A NAME=mgExtensionFieldDefined><H1 CLASS="APISYMBOL">mgExtensionFieldDefined</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExtensionFieldDefined</B> - determines whether an extension 
field is attached to a node<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgExtensionFieldDefined</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fieldGuid</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExtensionFieldDefined</B> determines whether the extension field 
identified by <I>fieldGuid</I> is currently attached to node <I>rec</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to check for the extension field</DD><DT><I>fieldGuid</I></DT><DD>the GUID of the extension field</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if extension field is attached, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExtensionFieldAdd>mgExtensionFieldAdd</A>, <A HREF=#mgExtensionSiteAdd>mgExtensionSiteAdd</A>, <A HREF=#mgExtensionFieldDelete>mgExtensionFieldDelete</A></DD></DL>
<HR>
<LEFT><A NAME=mgExtensionFieldDelete><H1 CLASS="APISYMBOL">mgExtensionFieldDelete</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExtensionFieldDelete</B> - deletes an extension field from a node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgExtensionFieldDelete</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fieldGuid</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExtensionFieldDelete</B> deletes the extension field identified by 
<I>fieldGuid</I> from node <I>rec</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to from which to delete the extension field</DD><DT><I>fieldGuid</I></DT><DD>the GUID of the extension field</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExtensionFieldAdd>mgExtensionFieldAdd</A>, <A HREF=#mgExtensionSiteAdd>mgExtensionSiteAdd</A>, <A HREF=#mgExtensionFieldDefined>mgExtensionFieldDefined</A>, <A HREF=#mgExtensionFieldDeleteAll>mgExtensionFieldDeleteAll</A></DD></DL>
<HR>
<LEFT><A NAME=mgExtensionFieldDeleteAll><H1 CLASS="APISYMBOL">mgExtensionFieldDeleteAll</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExtensionFieldDeleteAll</B> - deletes all extension fields from a node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgExtensionFieldDeleteAll</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExtensionFieldDeleteAll</B> deletes all extension fields from node <I>rec</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to from which to delete all extension fields</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> if no extensions were found, if <I>rec</I> is invalid.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExtensionFieldAdd>mgExtensionFieldAdd</A>, <A HREF=#mgExtensionSiteAdd>mgExtensionSiteAdd</A>, <A HREF=#mgExtensionFieldDefined>mgExtensionFieldDefined</A>, <A HREF=#mgExtensionFieldDelete>mgExtensionFieldDelete</A></DD></DL>
<HR>
<LEFT><A NAME=mgExtensionFieldGetAttach><H1 CLASS="APISYMBOL">mgExtensionFieldGetAttach</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExtensionFieldGetAttach</B> - gets the attach type of an extension field.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcode <B>mgExtensionFieldGetAttach</B> (</TD><TD>const char*</TD><TD><I>fieldGuid</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExtensionFieldGetAttach</B> gets the attach type of an extension field 
identified by <I>fieldGuid</I>.  The attach type of an extension field identifies 
the kind of OpenFlight node to which this extension can be associated (or attached). 
An attach type of <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
, for example, indicates that an extension is 
associated (or can be attached) to polygon nodes.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>fieldGuid</I></DT><DD>the GUID of the field</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns field attach type if found, 0 otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows how you might use <B>mgExtensionFieldGetAttach</B> 
to determine what kind of node an extension field is associated with.</DT><DT><PRE CLASS="EXAMPLE">#define MY_FIELD_GUID  "688538E5-E2D1-4098-9AF0-6DE5E386AB97"
mgcode attachTo;

attachTo = mgExtensionFieldGetAttach (MY_FIELD_GUID);
if (attachTo == fltFroup) {
   // extension field is associated to group nodes
}
else if (attachTo == fltObject) {
   // extension field is associated to object nodes
}
else if (attachTo == fltPolyon) {
   // extension field is associated to polygon nodes
}
else if (attachTo == fltVertex) {
   // extension field is associated to vertex nodes
}
else {
   // check other node types here
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExtensionFieldSetAttach>mgExtensionFieldSetAttach</A>, <A HREF=#mgExtensionFieldAdd>mgExtensionFieldAdd</A>, 
<A HREF=#mgExtensionFieldGetName>mgExtensionFieldGetName</A>, <A HREF=#mgExtensionFieldGetType>mgExtensionFieldGetType</A>, 
<A HREF=#mgExtensionSiteAdd>mgExtensionSiteAdd</A></DD></DL>
<HR>
<LEFT><A NAME=mgExtensionFieldGetBool><H1 CLASS="APISYMBOL">mgExtensionFieldGetBool</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExtensionFieldGetBool</B> - gets the boolean value of an 
extension field on a node.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgExtensionFieldGetBool</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fieldGuid</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool*</A></TD><TD><I>fieldValue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, fieldValue <B>mgExtensionFieldGetBool</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fieldGuid</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExtensionFieldGetBool</B> gets the boolean 
value of an extension field identified by <I>fieldGuid</I>, attached to node <I>rec</I>.</P></DD><DD><P>If successful, the value of the extension field is returned in the output 
parameter <I>fieldValue</I>, otherwise it is undefined.</P></DD><DD><P>Note: If the data type of the extension field is not <A HREF=#mgtagtype>MTYPE_FLAG</A>, 
this function will attempt to coerce the extension field value to boolean and return 
the corresponding value in <I>fieldValue</I>.  For example, a field of type 
<A HREF=#mgtagtype>MTYPE_FLAG</A> will set <I>fieldValue</I> to 0.0 or 1.0.  A field of type 
<A HREF=#mgtagtype>MTYPE_INT</A> or <A HREF=#mgtagtype>MTYPE_DOUBLE</A> will simply convert its value 
to float and set <I>fieldValue</I> to the result.  A field of type 
<A HREF=#mgtagtype>MTYPE_TEXT</A> or <A HREF=#mgtagtype>MTYPE_XML</A> will try to "scan" the string for 
a float value and set <I>fieldValue</I> to the result.</P></DD><DD><P>Note: If the data type of the extension field is not <A HREF=#mgtagtype>MTYPE_FLAG</A>, 
this function will attempt to coerce the extension field value to boolean  and return 
the corresponding value in <I>fieldValue</I>. For example, a field of type 
<A HREF=#mgtagtype>MTYPE_INT</A>, <A HREF=#mgtagtype>MTYPE_FLOAT</A> or <A HREF=#mgtagtype>MTYPE_DOUBLE</A> will 
will set <I>fieldValue</I> to <A HREF=#mgbool>MG_FALSE</A> if the numeric value is 0, <A HREF=#mgbool>MG_TRUE</A> 
otherwise. A field of type <A HREF=#mgtagtype>MTYPE_TEXT</A> or <A HREF=#mgtagtype>MTYPE_XML</A> will try to "scan" 
the string for "0" and set <I>fieldValue</I> to <A HREF=#mgbool>MG_FALSE</A> if found, <A HREF=#mgbool>MG_TRUE</A> 
otherwise.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to get extension value from</DD><DT><I>fieldGuid</I></DT><DD>the GUID of the extension field</DD><DT><I>fieldValue</I></DT><DD>the address of value to receive field value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>fieldGuid</I> does not specify a valid extension field 
currently attached to <I>rec</I> or <I>fieldValue</I> is <A HREF=#MG_NULL>MG_NULL</A>.</DD><DT>fieldValue</DT><DD>If function is successful, <I>fieldValue</I> contains the retrieved 
value, otherwise it will not be defined.</DD></DL></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) illustrate the 
use of <B>mgExtensionFieldGetBool</B>.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgbool fieldValue = MG_FALSE;
mgbool status;

status = mgExtensionFieldGetBool (rec, "732202BF-3EFA-4451-B8A6-B817DDB7BBAE", &fieldValue)

if (MSTAT_ISOK (status)) {
   printf ("Field Value: %s", fieldValue==MG_TRUE ? "MG_TRUE":"MG_FALSE");
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">status, fieldValue = mgExtensionFieldGetBool (rec, "732202BF-3EFA-4451-B8A6-B817DDB7BBAE")
if (MSTAT_ISOK (status)):
   print "Field Value:","MG_TRUE" if fieldValue else "MG_FALSE"</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExtensionFieldSetBool>mgExtensionFieldSetBool</A>, 
<A HREF=#mgExtensionFieldGetInteger>mgExtensionFieldGetInteger</A>, <A HREF=#mgExtensionFieldGetDouble>mgExtensionFieldGetDouble</A>, <A HREF=#mgExtensionFieldGetFloat>mgExtensionFieldGetFloat</A>, 
<A HREF=#mgExtensionFieldGetString>mgExtensionFieldGetString</A>, <A HREF=#mgExtensionFieldGetXMLString>mgExtensionFieldGetXMLString</A>, 
<A HREF=#mgExtensionFieldAdd>mgExtensionFieldAdd</A>, <A HREF=#mgExtensionSiteAdd>mgExtensionSiteAdd</A></DD></DL>
<HR>
<LEFT><A NAME=mgExtensionFieldGetDouble><H1 CLASS="APISYMBOL">mgExtensionFieldGetDouble</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExtensionFieldGetDouble</B> - gets the double precision floating 
point value of an extension field on a node.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgExtensionFieldGetDouble</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fieldGuid</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>fieldValue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, fieldValue <B>mgExtensionFieldGetDouble</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fieldGuid</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExtensionFieldGetDouble</B> gets the double precision floating point 
value of an extension field identified by <I>fieldGuid</I>, attached to node <I>rec</I>.</P></DD><DD><P>If successful, the value of the extension field is returned in the output 
parameter <I>fieldValue</I>, otherwise it is undefined.</P></DD><DD><P>Note: If the data type of the extension field is not <A HREF=#mgtagtype>MTYPE_DOUBLE</A>, 
this function will attempt to coerce the extension field value to double and return 
the corresponding value in <I>fieldValue</I>.  For example, a field of type 
<A HREF=#mgtagtype>MTYPE_FLAG</A> will set <I>fieldValue</I> to 0.0 or 1.0.  A field of type 
<A HREF=#mgtagtype>MTYPE_INT</A> or <A HREF=#mgtagtype>MTYPE_FLOAT</A> will simply convert its value 
to double and set <I>fieldValue</I> to the result.  A field of type 
<A HREF=#mgtagtype>MTYPE_TEXT</A> or <A HREF=#mgtagtype>MTYPE_XML</A> will try to "scan" the string for 
a double value and set <I>fieldValue</I> to the result.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to get extension value from</DD><DT><I>fieldGuid</I></DT><DD>the GUID of the extension field</DD><DT><I>fieldValue</I></DT><DD>the address of value to receive field value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>fieldGuid</I> does not specify a valid extension field 
currently attached to <I>rec</I> or <I>fieldValue</I> is <A HREF=#MG_NULL>MG_NULL</A>.</DD><DT>fieldValue</DT><DD>If function is successful, <I>fieldValue</I> contains the retrieved 
value, otherwise it will not be defined.</DD></DL></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) illustrate the 
use of <B>mgExtensionFieldGetDouble</B>.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">double fieldValue = 0.0;
mgbool status;

status = mgExtensionFieldGetDouble (rec, "732202BF-3EFA-4451-B8A6-B817DDB7BBAE", &fieldValue)

if (MSTAT_ISOK (status)) {
   printf ("Field Value: %f", fieldValue);
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">status, fieldValue = mgExtensionFieldGetDouble (rec, "732202BF-3EFA-4451-B8A6-B817DDB7BBAE")
if (MSTAT_ISOK (status)):
   print "Field Value:",fieldValue</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExtensionFieldSetDouble>mgExtensionFieldSetDouble</A>, 
<A HREF=#mgExtensionFieldGetInteger>mgExtensionFieldGetInteger</A>, <A HREF=#mgExtensionFieldGetFloat>mgExtensionFieldGetFloat</A>, <A HREF=#mgExtensionFieldGetBool>mgExtensionFieldGetBool</A>, 
<A HREF=#mgExtensionFieldGetString>mgExtensionFieldGetString</A>, <A HREF=#mgExtensionFieldGetXMLString>mgExtensionFieldGetXMLString</A>, 
<A HREF=#mgExtensionFieldAdd>mgExtensionFieldAdd</A>, <A HREF=#mgExtensionSiteAdd>mgExtensionSiteAdd</A></DD></DL>
<HR>
<LEFT><A NAME=mgExtensionFieldGetFloat><H1 CLASS="APISYMBOL">mgExtensionFieldGetFloat</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExtensionFieldGetFloat</B> - gets the single precision floating 
point value of an extension field on a node.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgExtensionFieldGetFloat</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fieldGuid</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>fieldValue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, fieldValue <B>mgExtensionFieldGetFloat</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fieldGuid</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExtensionFieldGetFloat</B> gets the single precision floating point 
value of an extension field identified by <I>fieldGuid</I>, attached to node <I>rec</I>.</P></DD><DD><P>If successful, the value of the extension field is returned in the output 
parameter <I>fieldValue</I>, otherwise it is undefined.</P></DD><DD><P>Note: If the data type of the extension field is not <A HREF=#mgtagtype>MTYPE_FLOAT</A>, 
this function will attempt to coerce the extension field value to double and return 
the corresponding value in <I>fieldValue</I>.  For example, a field of type 
<A HREF=#mgtagtype>MTYPE_FLAG</A> will set <I>fieldValue</I> to 0.0 or 1.0.  A field of type 
<A HREF=#mgtagtype>MTYPE_INT</A> or <A HREF=#mgtagtype>MTYPE_DOUBLE</A> will simply convert its value 
to float and set <I>fieldValue</I> to the result.  A field of type 
<A HREF=#mgtagtype>MTYPE_TEXT</A> or <A HREF=#mgtagtype>MTYPE_XML</A> will try to "scan" the string for 
a float value and set <I>fieldValue</I> to the result.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to get extension value from</DD><DT><I>fieldGuid</I></DT><DD>the GUID of the extension field</DD><DT><I>fieldValue</I></DT><DD>the address of value to receive field value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>fieldGuid</I> does not specify a valid extension field 
currently attached to <I>rec</I> or <I>fieldValue</I> is <A HREF=#MG_NULL>MG_NULL</A>.</DD><DT>fieldValue</DT><DD>If function is successful, <I>fieldValue</I> contains the retrieved 
value, otherwise it will not be defined.</DD></DL></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) illustrate the 
use of <B>mgExtensionFieldGetFloat</B>.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">float fieldValue = 0.0f;
mgbool status;

status = mgExtensionFieldGetFloat (rec, "732202BF-3EFA-4451-B8A6-B817DDB7BBAE", &fieldValue)

if (MSTAT_ISOK (status)) {
   printf ("Field Value: %f", fieldValue);
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">status, fieldValue = mgExtensionFieldGetFloat (rec, "732202BF-3EFA-4451-B8A6-B817DDB7BBAE")
if (MSTAT_ISOK (status)):
   print "Field Value:",fieldValue</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExtensionFieldSetFloat>mgExtensionFieldSetFloat</A>, 
<A HREF=#mgExtensionFieldGetInteger>mgExtensionFieldGetInteger</A>, <A HREF=#mgExtensionFieldGetDouble>mgExtensionFieldGetDouble</A>, <A HREF=#mgExtensionFieldGetBool>mgExtensionFieldGetBool</A>, 
<A HREF=#mgExtensionFieldGetString>mgExtensionFieldGetString</A>, <A HREF=#mgExtensionFieldGetXMLString>mgExtensionFieldGetXMLString</A>, 
<A HREF=#mgExtensionFieldAdd>mgExtensionFieldAdd</A>, <A HREF=#mgExtensionSiteAdd>mgExtensionSiteAdd</A></DD></DL>
<HR>
<LEFT><A NAME=mgExtensionFieldGetInteger><H1 CLASS="APISYMBOL">mgExtensionFieldGetInteger</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExtensionFieldGetInteger</B> - gets the integer value of an 
extension field on a node.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgExtensionFieldGetInteger</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fieldGuid</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>fieldValue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, fieldValue <B>mgExtensionFieldGetInteger</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fieldGuid</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExtensionFieldGetInteger</B> gets the integer value of an extension field 
identified by <I>fieldGuid</I>, attached to node <I>rec</I>.</P></DD><DD><P>If successful, the value of the extension field is returned in the output 
parameter <I>fieldValue</I>, otherwise it is undefined.</P></DD><DD><P>Note: If the data type of the extension field is not <A HREF=#mgtagtype>MTYPE_INT</A>, 
this function will attempt to coerce the extension field value to integer and return 
the corresponding value in <I>fieldValue</I>.  For example, a field of type 
<A HREF=#mgtagtype>MTYPE_FLAG</A> will set <I>fieldValue</I> to 0 or 1.  A field of type 
<A HREF=#mgtagtype>MTYPE_DOUBLE</A> or <A HREF=#mgtagtype>MTYPE_FLOAT</A> 
will truncate any fractional component and set <I>fieldValue</I> to the integer result. 
A field of type <A HREF=#mgtagtype>MTYPE_TEXT</A> or <A HREF=#mgtagtype>MTYPE_XML</A> will try to 
"scan" the string for an integer value and set <I>fieldValue</I> to the result.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to get extension value from</DD><DT><I>fieldGuid</I></DT><DD>the GUID of the extension field</DD><DT><I>fieldValue</I></DT><DD>the address of value to receive field value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>fieldGuid</I> does not specify a valid extension field 
currently attached to <I>rec</I> or <I>fieldValue</I> is <A HREF=#MG_NULL>MG_NULL</A>.</DD><DT>fieldValue</DT><DD>If function is successful, <I>fieldValue</I> contains the retrieved 
value, otherwise it will not be defined.</DD></DL></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) illustrate the 
use of <B>mgExtensionFieldGetInteger</B>.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">int fieldValue = 0;
mgbool status;

status = mgExtensionFieldGetInteger (rec, "732202BF-3EFA-4451-B8A6-B817DDB7BBAE", &fieldValue)

if (MSTAT_ISOK (status)) {
   printf ("Field Value: %d", fieldValue);
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">status, fieldValue = mgExtensionFieldGetInteger (rec, "732202BF-3EFA-4451-B8A6-B817DDB7BBAE")
if (MSTAT_ISOK (status)):
   print "Field Value:",fieldValue</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExtensionFieldSetInteger>mgExtensionFieldSetInteger</A>, 
<A HREF=#mgExtensionFieldGetDouble>mgExtensionFieldGetDouble</A>, <A HREF=#mgExtensionFieldGetFloat>mgExtensionFieldGetFloat</A>, <A HREF=#mgExtensionFieldGetBool>mgExtensionFieldGetBool</A>, 
<A HREF=#mgExtensionFieldGetString>mgExtensionFieldGetString</A>, <A HREF=#mgExtensionFieldGetXMLString>mgExtensionFieldGetXMLString</A>, 
<A HREF=#mgExtensionFieldAdd>mgExtensionFieldAdd</A>, <A HREF=#mgExtensionSiteAdd>mgExtensionSiteAdd</A></DD></DL>
<HR>
<LEFT><A NAME=mgExtensionFieldGetName><H1 CLASS="APISYMBOL">mgExtensionFieldGetName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExtensionFieldGetName</B> - gets the name of an extension field.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char* <B>mgExtensionFieldGetName</B> (</TD><TD>const char*</TD><TD><I>fieldGuid</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExtensionFieldGetName</B> gets the name of an extension field 
identified by <I>fieldGuid</I>.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned string in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>fieldGuid</I></DT><DD>the GUID of the field</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns field name if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExtensionFieldSetName>mgExtensionFieldSetName</A>, <A HREF=#mgExtensionFieldAdd>mgExtensionFieldAdd</A>, 
<A HREF=#mgExtensionFieldGetAttach>mgExtensionFieldGetAttach</A>, <A HREF=#mgExtensionFieldGetType>mgExtensionFieldGetType</A>, 
<A HREF=#mgExtensionSiteAdd>mgExtensionSiteAdd</A>, <A HREF=#mgExtensionSiteGetName>mgExtensionSiteGetName</A></DD></DL>
<HR>
<LEFT><A NAME=mgExtensionFieldGetString><H1 CLASS="APISYMBOL">mgExtensionFieldGetString</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExtensionFieldGetString</B> - gets the ASCII string of an 
extension field on a node.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgExtensionFieldGetString</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fieldGuid</I>,</TD></TR>
<TR><TD></TD><TD>char**</TD><TD><I>fieldValue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, fieldValue <B>mgExtensionFieldGetString</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fieldGuid</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExtensionFieldGetString</B> gets the ASCII string 
value of an extension field identified by <I>fieldGuid</I>, attached to node <I>rec</I>.</P></DD><DD><P>If successful, the value of the extension field is returned in the output 
parameter <I>fieldValue</I>, otherwise it is undefined.</P></DD><DD><P>Note: If the data type of the extension field is not <A HREF=#mgtagtype>MTYPE_TEXT</A>, 
this function will attempt to coerce the extension field value to string and return 
the corresponding value in <I>fieldValue</I>.  For example, a field of type 
<A HREF=#mgtagtype>MTYPE_FLAG</A> will set <I>fieldValue</I> to "0" or "1".  A field of type 
<A HREF=#mgtagtype>MTYPE_INT</A>, <A HREF=#mgtagtype>MTYPE_FLOAT</A> or <A HREF=#mgtagtype>MTYPE_DOUBLE</A> 
will simply convert the numeric value to string set <I>fieldValue</I> to the result.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string returned in <I>fieldValue</I> is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned string in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to get extension value from</DD><DT><I>fieldGuid</I></DT><DD>the GUID of the extension field</DD><DT><I>fieldValue</I></DT><DD>the address of value to receive field value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>fieldGuid</I> does not specify a valid extension field 
currently attached to <I>rec</I> or <I>fieldValue</I> is <A HREF=#MG_NULL>MG_NULL</A>.</DD><DT>fieldValue</DT><DD>If function is successful, <I>fieldValue</I> contains the retrieved 
value, otherwise it will not be defined.</DD></DL></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) illustrate the 
use of <B>mgExtensionFieldGetString</B>.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">char* fieldValue = NULL;
mgbool status;

status = mgExtensionFieldGetString (rec, "732202BF-3EFA-4451-B8A6-B817DDB7BBAE", &fieldValue)

if (MSTAT_ISOK (status)) {
   printf ("Field Value: %s", fieldValue);
   // free allocated memory when done with value
   mgFree (fieldValue);
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">status, fieldValue = mgExtensionFieldGetString (rec, "732202BF-3EFA-4451-B8A6-B817DDB7BBAE")
if (MSTAT_ISOK (status)):
   print "Field Value:",fieldValue</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExtensionFieldSetString>mgExtensionFieldSetString</A>, 
<A HREF=#mgExtensionFieldGetInteger>mgExtensionFieldGetInteger</A>, <A HREF=#mgExtensionFieldGetDouble>mgExtensionFieldGetDouble</A>, <A HREF=#mgExtensionFieldGetBool>mgExtensionFieldGetBool</A>, 
<A HREF=#mgExtensionFieldGetFloat>mgExtensionFieldGetFloat</A>, <A HREF=#mgExtensionFieldGetXMLString>mgExtensionFieldGetXMLString</A>, 
<A HREF=#mgExtensionFieldAdd>mgExtensionFieldAdd</A>, <A HREF=#mgExtensionSiteAdd>mgExtensionSiteAdd</A></DD></DL>
<HR>
<LEFT><A NAME=mgExtensionFieldGetType><H1 CLASS="APISYMBOL">mgExtensionFieldGetType</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExtensionFieldGetType</B> - gets the data type of an extension field.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgtagtype <B>mgExtensionFieldGetType</B> (</TD><TD>const char*</TD><TD><I>fieldGuid</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExtensionFieldGetType</B> gets the data type of an extension field 
identified by <I>fieldGuid</I>.  The data type of an extension field identifies 
the kind of data this extension stores.  A data type of <A HREF=#mgtagtype>MTYPE_INT</A>, 
for example, indicates that an extension stores an integer value.</P></DD><DD><P>Note that although the enumeration type <A HREF=#mgtagtype>mgtagtype</A> contains many more 
enumerants, extension fields can be only the following types:<BR> 
<A HREF=#mgtagtype>MTYPE_INT</A><BR> 
<A HREF=#mgtagtype>MTYPE_FLOAT</A><BR> 
<A HREF=#mgtagtype>MTYPE_DOUBLE</A><BR> 
<A HREF=#mgtagtype>MTYPE_TEXT</A><BR> 
<A HREF=#mgtagtype>MTYPE_XML</A><BR> 
<A HREF=#mgtagtype>MTYPE_FLAG</A></P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>fieldGuid</I></DT><DD>the GUID of the field</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns field data type if found, <A HREF=#mgtagtype>MTYPE_NULL</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows the valid return values for <B>mgExtensionFieldGetType</B>.</DT><DT><PRE CLASS="EXAMPLE">#define MY_FIELD_GUID  "688538E5-E2D1-4098-9AF0-6DE5E386AB97"
mgtagtype tag;

tag = mgExtensionFieldGetType (MY_FIELD_GUID);
switch (tag)
{
case MTYPE_INT:
   // extension field is an integer value
   break;

case MTYPE_FLOAT:
   // extension field is a single precision floating point value
   break;

case MTYPE_DOUBLE:
   // extension field is a double precision floating point value
   break;

case MTYPE_TEXT:
   // extension field is a character string (unformatted)
   break;

case MTYPE_XML:
   // extension field is a character string (formatted as XML)
   break;

case MTYPE_FLAG:
   // extension field is a boolean value (&lte mgbool.MG_TRUE&gt or &lte mgbool.MG_FALSE&gt )
   break;

case MTYPE_NULL:
   // extension field identified by myFieldGuid is unknown
   break;
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExtensionFieldSetType>mgExtensionFieldSetType</A>, <A HREF=#mgExtensionFieldAdd>mgExtensionFieldAdd</A>, 
<A HREF=#mgExtensionFieldGetName>mgExtensionFieldGetName</A>, <A HREF=#mgExtensionFieldGetAttach>mgExtensionFieldGetAttach</A>, 
<A HREF=#mgExtensionSiteAdd>mgExtensionSiteAdd</A></DD></DL>
<HR>
<LEFT><A NAME=mgExtensionFieldGetXMLString><H1 CLASS="APISYMBOL">mgExtensionFieldGetXMLString</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExtensionFieldGetXMLString</B> - gets the XML string of an 
extension field on a node.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgExtensionFieldGetXMLString</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fieldGuid</I>,</TD></TR>
<TR><TD></TD><TD>char**</TD><TD><I>fieldValue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, fieldValue <B>mgExtensionFieldGetXMLString</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fieldGuid</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExtensionFieldGetXMLString</B> gets the XML string 
value of an extension field identified by <I>fieldGuid</I>, attached to node <I>rec</I>.</P></DD><DD><P>If successful, the value of the extension field is returned in the output 
parameter <I>fieldValue</I>, otherwise it is undefined.</P></DD><DD><P>Note: If the data type of the extension field is not <A HREF=#mgtagtype>MTYPE_XML</A>, 
this function will attempt to coerce the extension field value to string and return 
the corresponding value in <I>fieldValue</I>.  For example, a field of type 
<A HREF=#mgtagtype>MTYPE_FLAG</A> will set <I>fieldValue</I> to "0" or "1".  A field of type 
<A HREF=#mgtagtype>MTYPE_INT</A>, <A HREF=#mgtagtype>MTYPE_FLOAT</A> or <A HREF=#mgtagtype>MTYPE_DOUBLE</A> 
will simply convert the numeric value to string set <I>fieldValue</I> to the result.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string returned in <I>fieldValue</I> is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned string in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to get extension value from</DD><DT><I>fieldGuid</I></DT><DD>the GUID of the extension field</DD><DT><I>fieldValue</I></DT><DD>the address of value to receive field value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>fieldGuid</I> does not specify a valid extension field 
currently attached to <I>rec</I> or <I>fieldValue</I> is <A HREF=#MG_NULL>MG_NULL</A>.</DD><DT>fieldValue</DT><DD>If function is successful, <I>fieldValue</I> contains the retrieved 
value, otherwise it will not be defined.</DD></DL></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) illustrate the 
use of <B>mgExtensionFieldGetXMLString</B>.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">char* fieldValue = NULL;
mgbool status;

status = mgExtensionFieldGetXMLString (rec, "732202BF-3EFA-4451-B8A6-B817DDB7BBAE", &fieldValue)

if (MSTAT_ISOK (status)) {
   printf ("Field Value: %s", fieldValue);
   // free allocated memory when done with value
   mgFree (fieldValue);
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">status, fieldValue = mgExtensionFieldGetXMLString (rec, "732202BF-3EFA-4451-B8A6-B817DDB7BBAE")
if (MSTAT_ISOK (status)):
   print "Field Value:",fieldValue</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExtensionFieldSetXMLString>mgExtensionFieldSetXMLString</A>, 
<A HREF=#mgExtensionFieldGetInteger>mgExtensionFieldGetInteger</A>, <A HREF=#mgExtensionFieldGetDouble>mgExtensionFieldGetDouble</A>, <A HREF=#mgExtensionFieldGetBool>mgExtensionFieldGetBool</A>, 
<A HREF=#mgExtensionFieldGetFloat>mgExtensionFieldGetFloat</A>, <A HREF=#mgExtensionFieldGetString>mgExtensionFieldGetString</A>, 
<A HREF=#mgExtensionFieldAdd>mgExtensionFieldAdd</A>, <A HREF=#mgExtensionSiteAdd>mgExtensionSiteAdd</A></DD></DL>
<HR>
<LEFT><A NAME=mgExtensionFieldSetAttach><H1 CLASS="APISYMBOL">mgExtensionFieldSetAttach</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExtensionFieldSetAttach</B> - sets the attach type of an extension field.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgExtensionFieldSetAttach</B> (</TD><TD>const char*</TD><TD><I>fieldGuid</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>attach</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExtensionFieldSetAttach</B> sets the attach type of an extension field 
identified by <I>fieldGuid</I>.  The attach type of an extension field identifies 
the kind of OpenFlight node to which this extension can be associated (or attached). 
An attach type of <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
, for example, indicates that an extension is 
associated (or can be attached) to polygon nodes.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>fieldGuid</I></DT><DD>the GUID of the site</DD><DT><I>attach</I></DT><DD>the attach type to assign</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExtensionFieldGetAttach>mgExtensionFieldGetAttach</A>, <A HREF=#mgExtensionFieldAdd>mgExtensionFieldAdd</A>, 
<A HREF=#mgExtensionFieldSetName>mgExtensionFieldSetName</A>, <A HREF=#mgExtensionFieldSetType>mgExtensionFieldSetType</A>, 
<A HREF=#mgExtensionSiteAdd>mgExtensionSiteAdd</A></DD></DL>
<HR>
<LEFT><A NAME=mgExtensionFieldSetBool><H1 CLASS="APISYMBOL">mgExtensionFieldSetBool</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExtensionFieldSetBool</B> - sets the boolean value of an 
extension field on a node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgExtensionFieldSetBool</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fieldGuid</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>fieldValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExtensionFieldSetBool</B> sets the value of an extension field 
identified by <I>fieldGuid</I>, attached to node <I>rec</I> to <I>fieldValue</I>.</P></DD><DD><P>Note: If the extension field is already attached to <I>rec</I> and is not of 
type <A HREF=#mgtagtype>MTYPE_FLAG</A>, <I>fieldValue</I> is coerced to the type of the existing 
extension field.  For example, if the current extension field is of type <A HREF=#mgtagtype>MTYPE_INT</A>, 
<A HREF=#mgtagtype>MTYPE_FLOAT</A> or <A HREF=#mgtagtype>MTYPE_DOUBLE</A>, <I>fieldValue</I> will simply be converted 
to the corresponding numeric type (0 for <A HREF=#mgbool>MG_FALSE</A> or 1 for <A HREF=#mgbool>MG_TRUE</A>). 
If the current extension field is of type <A HREF=#mgtagtype>MTYPE_TEXT</A> or <A HREF=#mgtagtype>MTYPE_XML</A> 
<I>fieldValue</I> will converted to the corresponding ASCII text ("0" for <A HREF=#mgbool>MG_FALSE</A> 
or "1" for <A HREF=#mgbool>MG_TRUE</A>).</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to set extension value on</DD><DT><I>fieldGuid</I></DT><DD>the GUID of the extension field</DD><DT><I>fieldValue</I></DT><DD>the value to set</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExtensionFieldGetBool>mgExtensionFieldGetBool</A>, 
<A HREF=#mgExtensionFieldSetDouble>mgExtensionFieldSetDouble</A>, <A HREF=#mgExtensionFieldSetInteger>mgExtensionFieldSetInteger</A>, <A HREF=#mgExtensionFieldSetFloat>mgExtensionFieldSetFloat</A>, 
<A HREF=#mgExtensionFieldSetString>mgExtensionFieldSetString</A>, <A HREF=#mgExtensionFieldSetXMLString>mgExtensionFieldSetXMLString</A>, 
<A HREF=#mgExtensionFieldAdd>mgExtensionFieldAdd</A>, <A HREF=#mgExtensionSiteAdd>mgExtensionSiteAdd</A></DD></DL>
<HR>
<LEFT><A NAME=mgExtensionFieldSetDouble><H1 CLASS="APISYMBOL">mgExtensionFieldSetDouble</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExtensionFieldSetDouble</B> - sets the double precision 
floating point value of an extension field on a node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgExtensionFieldSetDouble</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fieldGuid</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>fieldValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExtensionFieldSetDouble</B> sets the value of an extension field 
identified by <I>fieldGuid</I>, attached to node <I>rec</I> to <I>fieldValue</I>.</P></DD><DD><P>Note: If the extension field is already attached to <I>rec</I> and is not of 
type <A HREF=#mgtagtype>MTYPE_DOUBLE</A>, <I>fieldValue</I> is coerced to the type of the existing 
extension field.  For example, if the current extension field is of type 
<A HREF=#mgtagtype>MTYPE_FLAG</A>, a value of 0 will be set on <I>rec</I> if <I>fieldValue</I> 
is 0.0, a value of 1 will be set otherwise. 
If the current extension field is of type <A HREF=#mgtagtype>MTYPE_INT</A> or <A HREF=#mgtagtype>MTYPE_FLOAT</A>, 
<I>fieldValue</I> will simply be converted to the corresponding numeric type. Note that if 
the type is <A HREF=#mgtagtype>MTYPE_INT</A>, <I>fieldValue</I> will be truncated. 
If the current extension field is of type <A HREF=#mgtagtype>MTYPE_TEXT</A> or <A HREF=#mgtagtype>MTYPE_XML</A> 
<I>fieldValue</I> will converted to the corresponding ASCII text.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to set extension value on</DD><DT><I>fieldGuid</I></DT><DD>the GUID of the extension field</DD><DT><I>fieldValue</I></DT><DD>the value to set</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExtensionFieldGetInteger>mgExtensionFieldGetInteger</A>, 
<B>mgExtensionFieldSetDouble</B>, <A HREF=#mgExtensionFieldSetFloat>mgExtensionFieldSetFloat</A>, <A HREF=#mgExtensionFieldSetBool>mgExtensionFieldSetBool</A>, 
<A HREF=#mgExtensionFieldSetString>mgExtensionFieldSetString</A>, <A HREF=#mgExtensionFieldSetXMLString>mgExtensionFieldSetXMLString</A>, 
<A HREF=#mgExtensionFieldAdd>mgExtensionFieldAdd</A>, <A HREF=#mgExtensionSiteAdd>mgExtensionSiteAdd</A></DD></DL>
<HR>
<LEFT><A NAME=mgExtensionFieldSetFloat><H1 CLASS="APISYMBOL">mgExtensionFieldSetFloat</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExtensionFieldSetFloat</B> - sets the single precision 
floating point value of an extension field on a node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgExtensionFieldSetFloat</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fieldGuid</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>fieldValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExtensionFieldSetFloat</B> sets the value of an extension field 
identified by <I>fieldGuid</I>, attached to node <I>rec</I> to <I>fieldValue</I>.</P></DD><DD><P>Note: If the extension field is already attached to <I>rec</I> and is not of 
type <A HREF=#mgtagtype>MTYPE_FLOAT</A>, <I>fieldValue</I> is coerced to the type of the existing 
extension field.  For example, if the current extension field is of type 
<A HREF=#mgtagtype>MTYPE_FLAG</A>, a value of 0 will be set on <I>rec</I> if <I>fieldValue</I> 
is 0.0, a value of 1 will be set otherwise. 
If the current extension field is of type <A HREF=#mgtagtype>MTYPE_INT</A> or <A HREF=#mgtagtype>MTYPE_DOUBLE</A>, 
<I>fieldValue</I> will simply be converted to the corresponding numeric type. Note that if 
the type is <A HREF=#mgtagtype>MTYPE_INT</A>, <I>fieldValue</I> will be truncated. 
If the current extension field is of type <A HREF=#mgtagtype>MTYPE_TEXT</A> or <A HREF=#mgtagtype>MTYPE_XML</A> 
<I>fieldValue</I> will converted to the corresponding ASCII text.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to set extension value on</DD><DT><I>fieldGuid</I></DT><DD>the GUID of the extension field</DD><DT><I>fieldValue</I></DT><DD>the value to set</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExtensionFieldGetFloat>mgExtensionFieldGetFloat</A>, 
<A HREF=#mgExtensionFieldSetDouble>mgExtensionFieldSetDouble</A>, <A HREF=#mgExtensionFieldSetInteger>mgExtensionFieldSetInteger</A>, <A HREF=#mgExtensionFieldSetBool>mgExtensionFieldSetBool</A>, 
<A HREF=#mgExtensionFieldSetString>mgExtensionFieldSetString</A>, <A HREF=#mgExtensionFieldSetXMLString>mgExtensionFieldSetXMLString</A>, 
<A HREF=#mgExtensionFieldAdd>mgExtensionFieldAdd</A>, <A HREF=#mgExtensionSiteAdd>mgExtensionSiteAdd</A></DD></DL>
<HR>
<LEFT><A NAME=mgExtensionFieldSetInteger><H1 CLASS="APISYMBOL">mgExtensionFieldSetInteger</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExtensionFieldSetInteger</B> - sets the integer value of an 
extension field on a node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgExtensionFieldSetInteger</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fieldGuid</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>fieldValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExtensionFieldSetInteger</B> sets the value of an extension field 
identified by <I>fieldGuid</I>, attached to node <I>rec</I> to <I>fieldValue</I>.</P></DD><DD><P>Note: If the extension field is already attached to <I>rec</I> and is not of 
type <A HREF=#mgtagtype>MTYPE_INT</A>, <I>fieldValue</I> is coerced to the type of the existing 
extension field.  For example, if the current extension field is of type 
<A HREF=#mgtagtype>MTYPE_FLAG</A>, a value of 0 will be set on <I>rec</I> if <I>fieldValue</I> 
is 0, a value of 1 will be set otherwise. 
If the current extension field is of type <A HREF=#mgtagtype>MTYPE_DOUBLE</A> or <A HREF=#mgtagtype>MTYPE_FLOAT</A>, 
<I>fieldValue</I> will simply be converted to the corresponding numeric type. 
If the current extension field is of type <A HREF=#mgtagtype>MTYPE_TEXT</A> or <A HREF=#mgtagtype>MTYPE_XML</A> 
<I>fieldValue</I> will converted to the corresponding ASCII text.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to set extension value on</DD><DT><I>fieldGuid</I></DT><DD>the GUID of the extension field</DD><DT><I>fieldValue</I></DT><DD>the value to set</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExtensionFieldGetInteger>mgExtensionFieldGetInteger</A>, 
<A HREF=#mgExtensionFieldSetDouble>mgExtensionFieldSetDouble</A>, <A HREF=#mgExtensionFieldSetFloat>mgExtensionFieldSetFloat</A>, <A HREF=#mgExtensionFieldSetBool>mgExtensionFieldSetBool</A>, 
<A HREF=#mgExtensionFieldSetString>mgExtensionFieldSetString</A>, <A HREF=#mgExtensionFieldSetXMLString>mgExtensionFieldSetXMLString</A>, 
<A HREF=#mgExtensionFieldAdd>mgExtensionFieldAdd</A>, <A HREF=#mgExtensionSiteAdd>mgExtensionSiteAdd</A></DD></DL>
<HR>
<LEFT><A NAME=mgExtensionFieldSetName><H1 CLASS="APISYMBOL">mgExtensionFieldSetName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExtensionFieldSetName</B> - sets the name of an extension field.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgExtensionFieldSetName</B> (</TD><TD>const char*</TD><TD><I>fieldGuid</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>name</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExtensionFieldSetName</B> sets the name of an extension field 
identified by <I>fieldGuid</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>fieldGuid</I></DT><DD>the GUID of the site</DD><DT><I>name</I></DT><DD>the name to assign</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExtensionFieldGetName>mgExtensionFieldGetName</A>, <A HREF=#mgExtensionFieldAdd>mgExtensionFieldAdd</A>, 
<A HREF=#mgExtensionFieldSetAttach>mgExtensionFieldSetAttach</A>, <A HREF=#mgExtensionFieldSetType>mgExtensionFieldSetType</A>, 
<A HREF=#mgExtensionSiteGetName>mgExtensionSiteGetName</A>, <A HREF=#mgExtensionSiteAdd>mgExtensionSiteAdd</A></DD></DL>
<HR>
<LEFT><A NAME=mgExtensionFieldSetString><H1 CLASS="APISYMBOL">mgExtensionFieldSetString</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExtensionFieldSetString</B> - sets the ASCII string value of an 
extension field on a node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgExtensionFieldSetString</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fieldGuid</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fieldValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExtensionFieldSetString</B> sets the value of an extension field 
identified by <I>fieldGuid</I>, attached to node <I>rec</I> to <I>fieldValue</I>.</P></DD><DD><P>Note: If the extension field is already attached to <I>rec</I> and is not of 
type <A HREF=#mgtagtype>MTYPE_TEXT</A>, <I>fieldValue</I> is coerced to the type of the existing 
extension field.  For example, if the current extension field is of type <A HREF=#mgtagtype>MTYPE_INT</A>, 
<A HREF=#mgtagtype>MTYPE_FLOAT</A> or <A HREF=#mgtagtype>MTYPE_DOUBLE</A>, <I>fieldValue</I> will be "scanned" for 
a value of the corresponding numeric type and the extension field will be set to the result. 
If the current extension field is of type <A HREF=#mgtagtype>MTYPE_FLAG</A>, a value of 
<A HREF=#mgbool>MG_FALSE</A> will be set on <I>rec</I> if <I>fieldValue</I> contains "0", <A HREF=#mgbool>MG_TRUE</A> 
otherwise.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to set extension value on</DD><DT><I>fieldGuid</I></DT><DD>the GUID of the extension field</DD><DT><I>fieldValue</I></DT><DD>the value to set</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExtensionFieldGetString>mgExtensionFieldGetString</A>, 
<A HREF=#mgExtensionFieldSetDouble>mgExtensionFieldSetDouble</A>, <A HREF=#mgExtensionFieldSetInteger>mgExtensionFieldSetInteger</A>, <A HREF=#mgExtensionFieldSetFloat>mgExtensionFieldSetFloat</A>, 
<A HREF=#mgExtensionFieldSetBool>mgExtensionFieldSetBool</A>, <A HREF=#mgExtensionFieldSetXMLString>mgExtensionFieldSetXMLString</A>, 
<A HREF=#mgExtensionFieldAdd>mgExtensionFieldAdd</A>, <A HREF=#mgExtensionSiteAdd>mgExtensionSiteAdd</A></DD></DL>
<HR>
<LEFT><A NAME=mgExtensionFieldSetType><H1 CLASS="APISYMBOL">mgExtensionFieldSetType</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExtensionFieldSetType</B> - sets the data type of an extension field.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgExtensionFieldSetType</B> (</TD><TD>const char*</TD><TD><I>fieldGuid</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgtagtype>mgtagtype</A></TD><TD><I>type</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExtensionFieldSetType</B> sets the data type of an extension field 
identified by <I>fieldGuid</I>.  The data type of an extension field identifies 
the kind of data this extension stores.  A data type of <A HREF=#mgtagtype>MTYPE_INT</A>, 
for example, indicates that an extension stores an integer value.</P></DD><DD><P>Note that although the enumeration type <A HREF=#mgtagtype>mgtagtype</A> contains many more 
enumerants, extension fields can be only the following types:<BR> 
<A HREF=#mgtagtype>MTYPE_INT</A><BR> 
<A HREF=#mgtagtype>MTYPE_FLOAT</A><BR> 
<A HREF=#mgtagtype>MTYPE_DOUBLE</A><BR> 
<A HREF=#mgtagtype>MTYPE_TEXT</A><BR> 
<A HREF=#mgtagtype>MTYPE_XML</A><BR> 
<A HREF=#mgtagtype>MTYPE_FLAG</A></P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>fieldGuid</I></DT><DD>the GUID of the site</DD><DT><I>type</I></DT><DD>the data type to assign</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExtensionFieldGetType>mgExtensionFieldGetType</A>, <A HREF=#mgExtensionFieldAdd>mgExtensionFieldAdd</A>, 
<A HREF=#mgExtensionFieldSetName>mgExtensionFieldSetName</A>, <A HREF=#mgExtensionFieldSetAttach>mgExtensionFieldSetAttach</A>, 
<A HREF=#mgExtensionSiteAdd>mgExtensionSiteAdd</A></DD></DL>
<HR>
<LEFT><A NAME=mgExtensionFieldSetXMLString><H1 CLASS="APISYMBOL">mgExtensionFieldSetXMLString</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExtensionFieldSetXMLString</B> - sets the XML string value of an 
extension field on a node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgExtensionFieldSetXMLString</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fieldGuid</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fieldValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExtensionFieldSetXMLString</B> sets the value of an extension field 
identified by <I>fieldGuid</I>, attached to node <I>rec</I> to <I>fieldValue</I>.</P></DD><DD><P>Note: If the extension field is already attached to <I>rec</I> and is not of 
type <A HREF=#mgtagtype>MTYPE_XML</A>, <I>fieldValue</I> is coerced to the type of the existing 
extension field.  For example, if the current extension field is of type <A HREF=#mgtagtype>MTYPE_INT</A>, 
<A HREF=#mgtagtype>MTYPE_FLOAT</A> or <A HREF=#mgtagtype>MTYPE_DOUBLE</A>, <I>fieldValue</I> will be "scanned" for 
a value of the corresponding numeric type and the extension field will be set to the result. 
If the current extension field is of type <A HREF=#mgtagtype>MTYPE_FLAG</A>, a value of 
<A HREF=#mgbool>MG_FALSE</A> will be set on <I>rec</I> if <I>fieldValue</I> contains "0", <A HREF=#mgbool>MG_TRUE</A> 
otherwise.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to set extension value on</DD><DT><I>fieldGuid</I></DT><DD>the GUID of the extension field</DD><DT><I>fieldValue</I></DT><DD>the value to set</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExtensionFieldGetXMLString>mgExtensionFieldGetXMLString</A>, 
<A HREF=#mgExtensionFieldSetDouble>mgExtensionFieldSetDouble</A>, <A HREF=#mgExtensionFieldSetInteger>mgExtensionFieldSetInteger</A>, <A HREF=#mgExtensionFieldSetFloat>mgExtensionFieldSetFloat</A>, 
<A HREF=#mgExtensionFieldSetBool>mgExtensionFieldSetBool</A>, <A HREF=#mgExtensionFieldSetString>mgExtensionFieldSetString</A>, 
<A HREF=#mgExtensionFieldAdd>mgExtensionFieldAdd</A>, <A HREF=#mgExtensionSiteAdd>mgExtensionSiteAdd</A></DD></DL>
<HR>
<LEFT><A NAME=mgExtensionMakeGUID><H1 CLASS="APISYMBOL">mgExtensionMakeGUID</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExtensionMakeGUID</B> - creates a GUID that can be used 
to create OpenFlight extension sites and fields.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> char* <B>mgExtensionMakeGUID</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExtensionMakeGUID</B> creates and returns a GUID string that, 
in turn, can be used to create and identify extension sites and fields.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned string in Python.</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns GUID string if successful, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows how you could use this function to 
help create a simple extension site and populate it with some 
extension fields.</DT><DT><PRE CLASS="EXAMPLE">// make the GUIDs for one site and two fields
char* siteGUID = mgExtensionMakeGUID ();
char* field1GUID = mgExtensionMakeGUID ();
char* field2GUID = mgExtensionMakeGUID ();

// create the new extension site and give it a name
mgExtensionSiteAdd (siteGUID);
mgExtensionSiteSetName (siteGUID, "My Extension Site");

// create the first new extension field and describe it
mgExtensionFieldAdd (siteGUID, field1GUID);
mgExtensionFieldSetName (field1GUID, "My Extension Field 1");

// this field will "extend" fltPolygon (polygon) nodes
mgExtensionFieldSetAttach (field1GUID, fltPolgyon);

// it will be an integer value
mgExtensionFieldSetType (field1GUID, MTYPE_INT);

// create the second new extension field and describe it
mgExtensionFieldAdd (siteGUID, field2GUID);
mgExtensionFieldSetName (field2GUID, "My Extension Field 2");

// free the allocated GUID strings when done
mgFree (siteGUID);
mgFree (field1GUID);
mgFree (field2GUID);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExtensionSiteAdd>mgExtensionSiteAdd</A>, <A HREF=#mgExtensionFieldAdd>mgExtensionFieldAdd</A></DD></DL>
<HR>
<LEFT><A NAME=mgExtensionSiteAdd><H1 CLASS="APISYMBOL">mgExtensionSiteAdd</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExtensionSiteAdd</B> - creates a new extension site.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgExtensionSiteAdd</B> (</TD><TD>const char*</TD><TD><I>siteGuid</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExtensionSiteAdd</B> creates a new extension site 
identified by <I>siteGuid</I>.  This GUID (Globally Uniquie IDentifier) 
is used to uniquely identify the site.</P></DD><DD><P><I>siteGuid</I> is expected to be in the form of 
Microsoft's Universally Unique Identifier (UUID) standard. 
In its canonical form, a UUID consists of 32 hexadecimal digits, displayed 
in 5 groups separated by hyphens, in the form 8-4-4-4-12 for a total of 
36 characters (32 digits and 4 '-'). For example: 
<PRE CLASS="EXAMPLE">550e8400-e29b-41d4-a716-446655440000</PRE></P></DD><DD><P>You can use the function <A HREF=#mgExtensionMakeGUID>mgExtensionMakeGUID</A> to generate a GUID 
for your new extension site, or on Windows you can use the <B>uuidgen</B> utility.</P></DD><DD><P>After you create an extension site, use <A HREF=#mgExtensionFieldSetName>mgExtensionFieldSetName</A> 
to set the name of the site.  Then use <A HREF=#mgExtensionFieldAdd>mgExtensionFieldAdd</A> to add extension 
fields to your site.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>siteGuid</I></DT><DD>the GUID of the site to create</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows how you might create an extension site 
and populate it with extension fields.</DT><DT><PRE CLASS="EXAMPLE">#define MY_SITE_GUID    "550e8400-e29b-41d4-a716-446655440000"
#define MY_FIELD1_GUID  "688538E5-E2D1-4098-9AF0-6DE5E386AB97"
#define MY_FIELD2_GUID  "735A87F0-F8F8-4926-860A-1EBA5D2EAB74"

// create the new extension site and give it a name
mgExtensionSiteAdd (MY_SITE_GUID);
mgExtensionSiteSetName (MY_SITE_GUID, "My Extension Site");

// create the first new extension field and describe it
mgExtensionFieldAdd (MY_SITE_GUID, MY_FIELD1_GUID);
mgExtensionFieldSetName (MY_FIELD1_GUID, "My Extension Field 1");

// this field will "extend" fltPolygon (polygon) nodes
mgExtensionFieldSetAttach (MY_FIELD1_GUID, fltPolgyon);

// it will be an integer value
mgExtensionFieldSetType (MY_FIELD1_GUID, MTYPE_INT);

// create the second new extension field and describe it
mgExtensionFieldAdd (MY_SITE_GUID, MY_FIELD2_GUID);
mgExtensionFieldSetName (MY_FIELD2_GUID, "My Extension Field 2");

// this field will "extend" fltGroup (group) nodes
mgExtensionFieldSetAttach (MY_FIELD2_GUID, fltGroup);

// it will be an XML formatted string
mgExtensionFieldSetType (MY_FIELD2_GUID, MTYPE_XML);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExtensionSiteSetName>mgExtensionSiteSetName</A>, <A HREF=#mgExtensionFieldAdd>mgExtensionFieldAdd</A>, <A HREF=#mgExtensionMakeGUID>mgExtensionMakeGUID</A></DD></DL>
<HR>
<LEFT><A NAME=mgExtensionSiteGetName><H1 CLASS="APISYMBOL">mgExtensionSiteGetName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExtensionSiteGetName</B> - gets the name of an extension site.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char* <B>mgExtensionSiteGetName</B> (</TD><TD>const char*</TD><TD><I>siteGuid</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExtensionSiteGetName</B> gets the name of an extension site 
identified by <I>siteGuid</I>.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned string in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>siteGuid</I></DT><DD>the GUID of the site</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns site name if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExtensionSiteSetName>mgExtensionSiteSetName</A>, <A HREF=#mgExtensionSiteAdd>mgExtensionSiteAdd</A>, <A HREF=#mgExtensionFieldGetName>mgExtensionFieldGetName</A></DD></DL>
<HR>
<LEFT><A NAME=mgExtensionSiteSetName><H1 CLASS="APISYMBOL">mgExtensionSiteSetName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExtensionSiteSetName</B> - sets the name of an extension site.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgExtensionSiteSetName</B> (</TD><TD>const char*</TD><TD><I>siteGuid</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>name</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExtensionSiteSetName</B> sets the name of an extension site 
identified by <I>siteGuid</I>.  This name can be any character string of any 
length.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>siteGuid</I></DT><DD>the GUID of the site</DD><DT><I>name</I></DT><DD>the name to assign</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExtensionSiteGetName>mgExtensionSiteGetName</A>, <A HREF=#mgExtensionSiteAdd>mgExtensionSiteAdd</A>, <A HREF=#mgExtensionFieldSetName>mgExtensionFieldSetName</A></DD></DL>
<HR>
<LEFT><A NAME=mgExtRefGetLocatorFunc><H1 CLASS="APISYMBOL">mgExtRefGetLocatorFunc</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExtRefGetLocatorFunc</B> - gets the current 
external reference file locator function.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD> mgfilelocatorfunc <B>mgExtRefGetLocatorFunc</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExtRefGetLocatorFunc</B> returns the current external reference 
file locator function.  In this way, you can query the current locator 
function and then call it as part of the locator function you set 
up or call it directly for other file location processing your 
application or plug-in requires.</P></DD><DD><P>Note: Although only stand-alone applications can override the 
external reference file locator, stand-alone applications as well as 
plug-ins can obtain it.  This allows both stand-alone applications 
and plug-ins to "mimic" the behavior of the default file locator 
when locating files as part of their processing.</P></DD></DT></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExtRefSetLocatorFunc>mgExtRefSetLocatorFunc</A>, <A HREF=#mgTextureGetLocatorFunc>mgTextureGetLocatorFunc</A>, 
<A HREF=#mgShaderGetLocatorFunc>mgShaderGetLocatorFunc</A>, <A HREF=#mgfilelocatorfunc>mgfilelocatorfunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgExtRefSetLocatorFunc><H1 CLASS="APISYMBOL">mgExtRefSetLocatorFunc</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgExtRefSetLocatorFunc</B> - sets the external reference 
file locator function.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgExtRefSetLocatorFunc</B> (</TD><TD><A HREF=#mgfilelocatorfunc>mgfilelocatorfunc</A></TD><TD><I>locatorFunc</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgExtRefSetLocatorFunc</B> allows you to setup an external refernce 
file locator function used by the OpenFlight API to "locate" external 
reference files referenced within OpenFlight databases.  When a database 
file is opened using the OpenFlight API, the current external reference 
file locator function set will be called to locate the external 
reference file.  In this way, your application can override 
the way the API locates external reference files.</P></DD><DD><P>Note: This function is for use in stand-alone applications only, 
and should not be called from inside a plug-in.  Doing so may yield 
undefined results.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>locatorFunc</I></DT><DD>the external reference file 
locator function</DD><DT><I>userData</I></DT><DD>user defined data that will be 
passed to <I>locatorFunc</I> when it is 
called</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExtRefGetLocatorFunc>mgExtRefGetLocatorFunc</A>, <A HREF=#mgTextureSetLocatorFunc>mgTextureSetLocatorFunc</A>, 
<A HREF=#mgShaderSetLocatorFunc>mgShaderSetLocatorFunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgfilelocatorfunc><H1 CLASS="APISYMBOL">mgfilelocatorfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgfilelocatorfunc</B> - File locator function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool (*<B>mgfilelocatorfunc</B>) ( <TD><A HREF=#mgrec>mgrec*</A> <TD><I>db</I>, 
<TR><TD></TD><TD>const char* <TD><I>inputFileName</I>, 
<TR><TD></TD><TD>char** <TD><I>outputFileName</I>, 
<TR><TD></TD><TD>void* <TD><I>userData</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for the file locator function.  You can 
register file locator functions for texture files and external reference 
files.  When you do this, the OpenFlight API will use the functions 
you register to "locate" files referenced by databases being read. 
This allows you to override the file location strategy normally 
used by the OpenFlight API.</P></DD><DD><P>When the OpenFlight API calls your file locator function, your 
function will search for the file using a strategy that is appropriate 
for your application.  If your function can locate the file, it will 
return to the OpenFlight API, the full path to where it was found.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database being opened</DD><DT><I>inputFileName</I></DT><DD>the original name of the file 
being located (texture or external 
reference) including the full path 
and name</DD><DT><I>outputFileName</I></DT><DD>the full path and name of the 
file where it was located.  Your file 
locator functions must use <A HREF=#mgMalloc>mgMalloc</A> 
to allocate this memory.  Upon return 
of your file locator function, the OpenFlight 
API will call <A HREF=#mgFree>mgFree</A> to deallocate the 
memory</DD><DT><I>userData</I></DT><DD>user defined data specified 
when file locator function was set 
by <A HREF=#mgTextureSetLocatorFunc>mgTextureSetLocatorFunc</A>, 
<A HREF=#mgExtRefSetLocatorFunc>mgExtRefSetLocatorFunc</A> or 
<A HREF=#mgShaderSetLocatorFunc>mgShaderSetLocatorFunc</A></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Return <A HREF=#mgbool>MG_TRUE</A> if the file was located, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows a typical file locator function.</DT><DT><PRE CLASS="EXAMPLE">static mgbool MyLocator (mgrec* db, char* inFile,
&#32&#32&#32  char** outFile, void* userData)
{
   // userData was setup as the default texture locator
   mgfilelocatorfunc defLocator = (mgfilelocatorfunc) userData;
   mgbool found;
   char path [1024];

   // Call my function that searches for the file and
   // loads up path with the full path of where the
   // file was located.
   found = LocateFile (inFile, path, 1024);
   if (found) {
      // Allocate the output file buffer. OpenFlight API
      // will call mgFree to deallocate *outFile.
      *outFile = mgMalloc (strlen(path) + 1);
      strcpy (*outFile, path);
   }
   else {
      // My function could not find it, let the default
      // locator function try.
      found = (*defLocator) (db, inFile, outFile, MG_NULL);
   }
   // Tell the OpenFlight API whether or not the file was found
   return (found);
}

static void SetupLocator (void)
{
   mgfilelocatorfunc locator;
   mgbool status;

   // Setup my texture locator.  Have the default texture
   // locator passed to my function so it can be used by
   // my function if my function cannot locate the file.
   locator = mgTextureGetLocatorFunc ();
   status = mgTextureSetLocatorFunc (MyLocator, locator);
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgTextureSetLocatorFunc>mgTextureSetLocatorFunc</A>, <A HREF=#mgTextureGetLocatorFunc>mgTextureGetLocatorFunc</A>, 
<A HREF=#mgExtRefSetLocatorFunc>mgExtRefSetLocatorFunc</A>, <A HREF=#mgExtRefGetLocatorFunc>mgExtRefGetLocatorFunc</A>, 
<A HREF=#mgShaderSetLocatorFunc>mgShaderSetLocatorFunc</A>, <A HREF=#mgShaderGetLocatorFunc>mgShaderGetLocatorFunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgFind><H1 CLASS="APISYMBOL">mgFind</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFind</B> - walks a node hierarchy and collects a list of nodes that 
match a user specified criteria.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgreclist <B>mgFind</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>node</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgwalkfunc>mgwalkfunc</A></TD><TD><I>matchFunc</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>flags</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFind</B> walks a <I>node</I> hierarchy and calls the <I>matchFunc</I> function 
for each node visited.  If the <I>matchFunc</I> function returns <A HREF=#mgbool>MG_TRUE</A> 
for a node, the node is added to the record list that is returned from <B>mgFind</B>. 
If <B>matchFunc</B> returns <A HREF=#mgbool>MG_FALSE</A>, the node is not added to the record list.</P></DD><DD><P><B>mgFind</B> traverses a <I>node</I> hierarchy in the same way as <A HREF=#mgWalk>mgWalk</A>. You 
control this traversal using <I>flags</I>.  See <A HREF=#mgWalk>mgWalk</A> for more information on this 
traversal mechanism.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>When you are done accessing the record list returned by this 
function, you should dispose of it using <A HREF=#mgFreeRecList>mgFreeRecList</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to dispose of the record list returned in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>node</I></DT><DD>the starting node of the traversal</DD><DT><I>matchFunc</I></DT><DD>the match function invoked for each node visited</DD><DT><I>userData</I></DT><DD>pointer to user defined data that will be passed 
to the <I>matchFunc</I> callback function</DD><DT><I>flags</I></DT><DD>traversal modifiers that allow you to select 
certain types of nodes for visiting. 
This parameter is the bitwise combination of the following masks:<BR> 
<A HREF=#MWALK_NEXT>MWALK_NEXT</A><BR> <A HREF=#MWALK_VERTEX>MWALK_VERTEX</A><BR> <A HREF=#MWALK_MASTER>MWALK_MASTER</A><BR> 
<A HREF=#MWALK_MASTERALL>MWALK_MASTERALL</A><BR> <A HREF=#MWALK_ON>MWALK_ON</A><BR> <A HREF=#MWALK_NOREADONLY>MWALK_NOREADONLY</A><BR> 
<A HREF=#MWALK_NONESTED>MWALK_NONESTED</A><BR> <A HREF=#MWALK_MATRIXSTACK>MWALK_MATRIXSTACK</A></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a record list containing all the nodes visited for which the 
<I>matchFunc</I> function returned <A HREF=#mgbool>MG_TRUE</A>.
</DD></DL><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) collect all visible 
polygons in a database.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">static mgbool MatchPolygon (mgrec* db, mgrec* parent, mgrec* rec, void* userData)
{
   if (mgGetCode (rec) == fltPolygon)
      return MG_TRUE;
   else
      return MG_FALSE;
}

mgreclist polygonList = mgFind (db, MatchPolygon, MG_NULL, MWALK_ON);

// do something with polygonList, free it when done
mgFreeRecList (polygonList);</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">def MatchPolygon (db, parent, rec, userData):
   if (mgGetCode (rec) == fltPolygon):
      return MG_TRUE
   else:
      return MG_FALSE

polygonList = mgFind (db, MatchPolygon, None, MWALK_ON)

# do something with polygonList, don't have to free in Python</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgFindEx>mgFindEx</A>, <A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, <A HREF=#mgWalkRecList>mgWalkRecList</A>, <A HREF=#mgWalkGetMatrix>mgWalkGetMatrix</A>, 
<A HREF=#mgIterateRecList>mgIterateRecList</A></DD></DL>
<HR>
<LEFT><A NAME=mgFindEx><H1 CLASS="APISYMBOL">mgFindEx</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFindEx</B> - walks a node hierarchy and collects a list of nodes that 
match a user specified criteria.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgreclist <B>mgFindEx</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>node</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>startMatrix</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgwalkfunc>mgwalkfunc</A></TD><TD><I>matchFunc</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>flags</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFindEx</B> performs the same function as <A HREF=#mgFind>mgFind</A>, but in addition also collects 
a matrix for each node in the record list returned.  This matrix represents the cumulative 
transformations between the root <I>node</I> and the node in the record list.  When using <B>mgFindEx</B> 
in this way, you specify a starting matrix, <I>startMatrix</I>, to use when accumulating a matrix 
stack during the traversal.</P></DD><DD><P>Note: If <I>flags</I> does not specify <A HREF=#MWALK_MATRIXSTACK>MWALK_MATRIXSTACK</A>, <I>startMatrix</I> is ignored 
and no matrices are collected for the nodes in the record list.</P></DD><DD><P>For more information and example code, see <A HREF=#mgFind>mgFind</A>.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>When you are done accessing the record list returned by this 
function, you should dispose of it using <A HREF=#mgFreeRecList>mgFreeRecList</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to dispose of the record list returned in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>node</I></DT><DD>the starting node of the traversal</DD><DT><I>startMatrix</I></DT><DD>the starting matrix to use when accumulating a matrix 
stack during the traversal - ignored if <A HREF=#MWALK_MATRIXSTACK>MWALK_MATRIXSTACK</A> 
is not specified in <I>flags</I></DD><DT><I>matchFunc</I></DT><DD>the match function invoked for each node visited</DD><DT><I>userData</I></DT><DD>pointer to user defined data that will be passed 
to the <I>matchFunc</I> callback function</DD><DT><I>flags</I></DT><DD>traversal modifiers that allow you to select 
certain types of nodes for visiting. 
This parameter is the bitwise combination of the following masks:<BR> 
<A HREF=#MWALK_NEXT>MWALK_NEXT</A><BR> <A HREF=#MWALK_VERTEX>MWALK_VERTEX</A><BR> <A HREF=#MWALK_MASTER>MWALK_MASTER</A><BR> 
<A HREF=#MWALK_MASTERALL>MWALK_MASTERALL</A><BR> <A HREF=#MWALK_ON>MWALK_ON</A><BR> <A HREF=#MWALK_NOREADONLY>MWALK_NOREADONLY</A><BR> 
<A HREF=#MWALK_NONESTED>MWALK_NONESTED</A><BR> <A HREF=#MWALK_MATRIXSTACK>MWALK_MATRIXSTACK</A></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a record list containing all the nodes visited for which the 
<I>matchFunc</I> function returned <A HREF=#mgbool>MG_TRUE</A>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, <A HREF=#mgWalkRecList>mgWalkRecList</A>, <A HREF=#mgWalkGetMatrix>mgWalkGetMatrix</A>, <A HREF=#mgFind>mgFind</A>, 
<A HREF=#mgIterateRecList>mgIterateRecList</A></DD></DL>
<HR>
<LEFT><A NAME=mgFindGuiById><H1 CLASS="APISYMBOL">mgFindGuiById</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFindGuiById</B> - retrieves handle to a control in a dialog.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mggui <B>mgFindGuiById</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>gui</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcontrolid>mgcontrolid</A></TD><TD><I>controlId</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFindGuiById</B> returns the abstract handle to a control identified 
by <I>controlId</I> contained in the dialog specified by <I>gui</I>.<P>
Note that <I>gui</I> can be either a control or a dialog.  If <I>gui</I> is a control, 
it is assumed to be contained in the dialog to be searched.  If <I>gui</I> is a dialog, 
it is the dialog to be searched.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>gui</I></DT><DD>the dialog that contains the control 
to find or a control in the dialog</DD><DT><I>controlId</I></DT><DD>the identifier of the control to find</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the control handle if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<HR>
<LEFT><A NAME=mgFirstConstructEdge><H1 CLASS="APISYMBOL">mgFirstConstructEdge</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFirstConstructEdge</B> - gets the first construction edge 
node associated with an active editor tool instance.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgFirstConstructEdge</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFirstConstructEdge</B> gets the first construction edge node 
associated with the editor tool instance identified by 
editor context, <I>editorContext</I>.</P></DD><DD><P>While an editor tool instance is active, all construction edges 
created via calls to <A HREF=#mgNewConstructEdge>mgNewConstructEdge</A> are maintained internally 
within the editor context record.  In this way, you can use 
<B>mgFirstConstructEdge</B> and <A HREF=#mgNextConstructEdge>mgNextConstructEdge</A> to traverse 
all construction edges associated with the current editor tool 
instance.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context from which to 
get the first construction edge node</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the first construction edge node if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewConstructEdge>mgNewConstructEdge</A>, <A HREF=#mgNextConstructEdge>mgNextConstructEdge</A></DD></DL>
<HR>
<LEFT><A NAME=mgFirstConstructVertex><H1 CLASS="APISYMBOL">mgFirstConstructVertex</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFirstConstructVertex</B> - gets the first construction vertex 
node associated with an active editor tool instance.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgFirstConstructVertex</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFirstConstructVertex</B> gets the first construction vertex node 
associated with the editor tool instance identified by editor 
context, <I>editorContext</I>.</P></DD><DD><P>While an editor tool instance is active, all construction vertices 
created via calls to <A HREF=#mgNewConstructVertex>mgNewConstructVertex</A> are maintained internally 
within the editor context record.  In this way, you can use 
<B>mgFirstConstructVertex</B> and <A HREF=#mgNextConstructVertex>mgNextConstructVertex</A> to traverse 
all construction vertices associated with the current editor tool 
instance.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context from which to 
get the first construction vertex node</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the first construction vertex node if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewConstructVertex>mgNewConstructVertex</A>, <A HREF=#mgNextConstructVertex>mgNextConstructVertex</A></DD></DL>
<HR>
<LEFT><A NAME=mgFitOnGrid><H1 CLASS="APISYMBOL">mgFitOnGrid</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFitOnGrid</B> - fits the current view on the grid.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgFitOnGrid</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFitOnGrid</B> fits the current view on the current grid in <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the graphics view was set 
in Creator, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgFitOnNode>mgFitOnNode</A>, 
<A HREF=#mgFitOnRecList>mgFitOnRecList</A>, 
<A HREF=#mgFitOnSelect>mgFitOnSelect</A>, 
<A HREF=#mgResetView>mgResetView</A></DD></DL>
<HR>
<LEFT><A NAME=mgFitOnNode><H1 CLASS="APISYMBOL">mgFitOnNode</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFitOnNode</B> - fits the current view on the given node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgFitOnNode</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>node</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFitOnNode</B> fits the current view in <I>db</I> on the given node 
<I>node</I>. If <I>node</I> is invalid the view remains unchanged.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>node</I></DT><DD>the node to fit on</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the graphics view was set 
in Creator, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgFitOnGrid>mgFitOnGrid</A>, 
<A HREF=#mgFitOnRecList>mgFitOnRecList</A>, 
<A HREF=#mgFitOnSelect>mgFitOnSelect</A>, 
<A HREF=#mgResetView>mgResetView</A></DD></DL>
<HR>
<LEFT><A NAME=mgFitOnRecList><H1 CLASS="APISYMBOL">mgFitOnRecList</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFitOnRecList</B> - fits the current view on a record list.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgFitOnRecList</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgreclist>mgreclist</A></TD><TD><I>recList</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFitOnRecList</B> fits the current view in <I>db</I> on the given record 
list <I>recList</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>recList</I></DT><DD>the list of records to fit to</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the graphics view was set 
in Creator, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgFitOnNode>mgFitOnNode</A>, 
<A HREF=#mgFitOnGrid>mgFitOnGrid</A>, 
<A HREF=#mgFitOnSelect>mgFitOnSelect</A>, 
<A HREF=#mgResetView>mgResetView</A></DD></DL>
<HR>
<LEFT><A NAME=mgFitOnSelect><H1 CLASS="APISYMBOL">mgFitOnSelect</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFitOnSelect</B> - fits the view on the selection.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgFitOnSelect</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFitOnSelect</B> fits the current view on the current selection in 
<I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the graphics view was set 
in Creator, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgFitOnNode>mgFitOnNode</A>, 
<A HREF=#mgFitOnGrid>mgFitOnGrid</A>, 
<A HREF=#mgFitOnRecList>mgFitOnRecList</A>, 
<A HREF=#mgResetView>mgResetView</A></DD></DL>
<HR>
<LEFT><A NAME=mgFlipImage><H1 CLASS="APISYMBOL">mgFlipImage</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFlipImage</B> - flips an image about its u-axis.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgFlipImage</B> (</TD><TD>unsigned char*</TD><TD><I>pixels</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>width</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>height</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>type</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFlipImage</B> flips an image about its u-axis.  This is useful 
for converting an image with an origin in the upper-left corner to one 
with an origin in the lower-left corner (the orientation used by MultiGen, 
IRIS GL and OpenGL). <B>mgFlipImage</B> can also be used to perform the 
opposite conversion.</P></DD><DD><P>See <A HREF=#mgReadImage>mgReadImage</A> for a description of the expected memory layout 
for <I>pixels</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pixels</I></DT><DD>a pointer to the image pixels</DD><DT><I>width</I></DT><DD>the width of the image</DD><DT><I>height</I></DT><DD>the height of the image</DD><DT><I>type</I></DT><DD>the image type specifying how the <I>pixels</I> 
are packed - possible values are <A HREF=#MIMG_INT>MIMG_INT</A>, 
<A HREF=#MIMG_INTA>MIMG_INTA</A>, <A HREF=#MIMG_RGB>MIMG_RGB</A> and <A HREF=#MIMG_RGBA>MIMG_RGBA</A></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#MIMG_NO_ERROR>MIMG_NO_ERROR</A> if successful, otherwise applicable 
texture error code.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadImage>mgReadImage</A>, <A HREF=#mgWriteImage>mgWriteImage</A></DD></DL>
<HR>
<LEFT><A NAME=mgFocusVertexListAddItem><H1 CLASS="APISYMBOL">mgFocusVertexListAddItem</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFocusVertexListAddItem</B> - add a node as a potential 
focus vertex.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgFocusVertexListAddItem</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFocusVertexListAddItem</B> adds a node to the focus vertex list 
for the specified editor context, <I>editorContext</I>.  All vertices below 
the specified node <I>rec</I> will become candidates for focus vertex selection.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context used to identify 
the focus vertex list to which the specified 
node is to be added</DD><DT><I>rec</I></DT><DD>the node containing vertices to be 
added</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgEditorSetFocusVertexFunc>mgEditorSetFocusVertexFunc</A>, <A HREF=#mgFocusVertexListDeleteItem>mgFocusVertexListDeleteItem</A></DD></DL>
<HR>
<LEFT><A NAME=mgFocusVertexListDeleteAllItems><H1 CLASS="APISYMBOL">mgFocusVertexListDeleteAllItems</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFocusVertexListDeleteAllItems</B> - clear focus vertex list.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgFocusVertexListDeleteAllItems</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFocusVertexListDeleteAllItems</B> clears all nodes from the focus 
vertex list for the specified editor context, editorContext.</P></DD><DD><P>After calling this function, no vertices will be candidates for 
focus vertex selection.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context used to identify 
the focus vertex list to be cleared</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgEditorSetFocusVertexFunc>mgEditorSetFocusVertexFunc</A>, <A HREF=#mgFocusVertexListAddItem>mgFocusVertexListAddItem</A>, 
<A HREF=#mgFocusVertexListDeleteItem>mgFocusVertexListDeleteItem</A></DD></DL>
<HR>
<LEFT><A NAME=mgFocusVertexListDeleteItem><H1 CLASS="APISYMBOL">mgFocusVertexListDeleteItem</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFocusVertexListDeleteItem</B> - remove a node from the 
focus vertex list.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgFocusVertexListDeleteItem</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFocusVertexListDeleteItem</B> removes a node from the focus 
vertex list for the specified editor context, <I>editorContext</I>.  All vertices 
below the specified node <I>rec</I> will no longer be candidates for focus vertex 
selection.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context used to identify 
the focus vertex list from which the specified 
node is to be removed</DD><DT><I>rec</I></DT><DD>the node containing vertices to be 
removed</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgEditorSetFocusVertexFunc>mgEditorSetFocusVertexFunc</A>, <A HREF=#mgFocusVertexListAddItem>mgFocusVertexListAddItem</A></DD></DL>
<HR>
<LEFT><A NAME=mgFree><H1 CLASS="APISYMBOL">mgFree</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFree</B> - deallocates a dynamic memory buffer.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgFree</B> (</TD><TD>void*</TD><TD><I>ptr</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a pointer to a dynamic memory buffer, <I>ptr</I>, <B>mgFree</B> 
deallocates it. Use <A HREF=#mgMalloc>mgMalloc</A> to allocate dynamic memory buffers. 
It is a serious error to attempt to free a memory block that is already 
deallocated. In this case, <B>mgFree</B> displays the message 
"attempt to free a free block @< address >".</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>ptr</I></DT><DD>the pointer to the dynamic memory buffer</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMalloc>mgMalloc</A></DD></DL>
<HR>
<LEFT><A NAME=mgFreeConvexHull><H1 CLASS="APISYMBOL">mgFreeConvexHull</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFreeConvexHull</B> - frees a convex hull object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgFreeConvexHull</B> (</TD><TD><A HREF=#mgconvexhull>mgconvexhull</A></TD><TD><I>hull</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFreeConvexHull</B> frees the dynamic memory associated with the 
convex hull object <I>hull</I>.</P></DD><DD><P>The convex hull is assumed to have been created using either of the 
functions <A HREF=#mgGetConvexHull>mgGetConvexHull</A> or <A HREF=#mgConvexHullBuilderClose>mgConvexHullBuilderClose</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>hull</I></DT><DD>the convex hull to free</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetConvexHull>mgGetConvexHull</A>, <A HREF=#mgConvexHullBuilderClose>mgConvexHullBuilderClose</A></DD></DL>
<HR>
<LEFT><A NAME=mgFreeConvexHullBuilder><H1 CLASS="APISYMBOL">mgFreeConvexHullBuilder</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFreeConvexHullBuilder</B> - frees a convex hull builder object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgFreeConvexHullBuilder</B> (</TD><TD><A HREF=#mgconvexhullbuilder>mgconvexhullbuilder</A></TD><TD><I>hullBuilder</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFreeConvexHullBuilder</B> frees the dynamic memory associated with the 
convex hull builder object <I>hullBuilder</I>.</P></DD><DD><P>The convex hull builder is assumed to have been created using the 
function <A HREF=#mgNewConvexHullBuilder>mgNewConvexHullBuilder</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>hullBuilder</I></DT><DD>the convex hull builder to free</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewConvexHullBuilder>mgNewConvexHullBuilder</A>, <A HREF=#mgConvexHullBuilderClose>mgConvexHullBuilderClose</A></DD></DL>
<HR>
<LEFT><A NAME=mgFreeImageGeoInfo><H1 CLASS="APISYMBOL">mgFreeImageGeoInfo</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFreeImageGeoInfo</B> - frees a georeference info object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgFreeImageGeoInfo</B> (</TD><TD><A HREF=#mgimagegeoinfo>mgimagegeoinfo</A></TD><TD><I>geoInfo</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFreeImageGeoInfo</B> frees a georeference info object that was 
allocated and returned by the function <A HREF=#mgReadImageGeoInfo>mgReadImageGeoInfo</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>geoInfo</I></DT><DD>the georeference info object to free</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadImageGeoInfo>mgReadImageGeoInfo</A></DD></DL>
<HR>
<LEFT><A NAME=mgFreeImageInfo><H1 CLASS="APISYMBOL">mgFreeImageInfo</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFreeImageInfo</B> - frees an image info object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgFreeImageInfo</B> (</TD><TD><A HREF=#mgimageinfo>mgimageinfo</A></TD><TD><I>textureInfo</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFreeImageInfo</B> frees an image info object that was 
allocated and returned by the function <A HREF=#mgReadImageInfo>mgReadImageInfo</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>textureInfo</I></DT><DD>the image info object to free</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadImageInfo>mgReadImageInfo</A></DD></DL>
<HR>
<LEFT><A NAME=mgFreeLicense><H1 CLASS="APISYMBOL">mgFreeLicense</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFreeLicense</B> - deallocates a license.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgFreeLicense</B> (</TD><TD><A HREF=#mglicense>mglicense</A></TD><TD><I>license</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFreeLicense</B> deallocates a license created by <A HREF=#mgNewLicense>mgNewLicense</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>license</I></DT><DD>the license to deallocate</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewLicense>mgNewLicense</A>, <A HREF=#mgCheckoutLicense>mgCheckoutLicense</A>, <A HREF=#mgCheckinLicense>mgCheckinLicense</A></DD></DL>
<HR>
<LEFT><A NAME=mgFreeMatrix><H1 CLASS="APISYMBOL">mgFreeMatrix</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFreeMatrix</B> - deallocates a matrix created by <A HREF=#mgNewMatrix>mgNewMatrix</A>.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgFreeMatrix</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFreeMatrix</B> deallocates a matrix that was created previously by 
a call <A HREF=#mgNewMatrix>mgNewMatrix</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to deallocate</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewMatrix>mgNewMatrix</A>, <A HREF=#mgMatrixIdentity>mgMatrixIdentity</A>, <A HREF=#mgMatrixIsIdentity>mgMatrixIsIdentity</A>, 
<A HREF=#mgMatrixInvert>mgMatrixInvert</A>, <A HREF=#mgMatrixMultiply>mgMatrixMultiply</A>, <A HREF=#mgMatrixCopy>mgMatrixCopy</A></DD></DL>
<HR>
<LEFT><A NAME=mgFreeMatrixStack><H1 CLASS="APISYMBOL">mgFreeMatrixStack</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFreeMatrixStack</B> - deallocates a matrix stack object 
created by <A HREF=#mgNewMatrixStack>mgNewMatrixStack</A>.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgFreeMatrixStack</B> (</TD><TD><A HREF=#mgmatrixstack>mgmatrixstack</A></TD><TD><I>matrixStack</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFreeMatrixStack</B> deallocates a matrix stack object that was 
created previously by a call <A HREF=#mgNewMatrixStack>mgNewMatrixStack</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrixStack</I></DT><DD>matrix stack to free</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, <A HREF=#mgNewMatrixStack>mgNewMatrixStack</A>, 
<A HREF=#mgMatrixStackPush>mgMatrixStackPush</A>, <A HREF=#mgMatrixStackPop>mgMatrixStackPop</A>, 
<A HREF=#mgMatrixStackLoadIdentity>mgMatrixStackLoadIdentity</A>, <A HREF=#mgMatrixStackIsIdentity>mgMatrixStackIsIdentity</A>, 
<A HREF=#mgMatrixStackLoadMatrix>mgMatrixStackLoadMatrix</A>, <A HREF=#mgMatrixStackGetMatrix>mgMatrixStackGetMatrix</A>, 
<A HREF=#mgMatrixStackMultiply>mgMatrixStackMultiply</A>, <A HREF=#mgMatrixStackTranslate>mgMatrixStackTranslate</A>, <A HREF=#mgMatrixStackScale>mgMatrixStackScale</A>, 
<A HREF=#mgMatrixStackRotate>mgMatrixStackRotate</A>, <A HREF=#mgMatrixStackRotateX>mgMatrixStackRotateX</A>, 
<A HREF=#mgMatrixStackRotateY>mgMatrixStackRotateY</A>, <A HREF=#mgMatrixStackRotateZ>mgMatrixStackRotateZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgFreeNewEyePoint><H1 CLASS="APISYMBOL">mgFreeNewEyePoint</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFreeNewEyePoint</B> - frees an eyepoint record.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgFreeNewEyePoint</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>eyeRec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFreeEyePoint</B> frees the memory associated with an eyepoint record 
previously obtained by <A HREF=#mgGetNewEyePoint>mgGetNewEyePoint</A>.</P></DD><DD><P>Do not use <B>mgFreeNewEyePoint</B> on an eyepoint record obtained from 
<A HREF=#mgGetEyePoint>mgGetEyePoint</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>eyeRec</I></DT><DD>the eyepoint record to be freed</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetNewEyePoint>mgGetNewEyePoint</A></DD></DL>
<HR>
<LEFT><A NAME=mgFreeNodeExpression><H1 CLASS="APISYMBOL">mgFreeNodeExpression</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFreeNodeExpression</B> - frees the mgnodeexpression passed in.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD> void <B>mgFreeNodeExpression</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFreeNodeExpression</B> frees the mgnodeexpression passed in.</P></DD></DT></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewNodeExpressionOperator>mgNewNodeExpressionOperator</A>, <A HREF=#mgNewNodeExpressionCallback>mgNewNodeExpressionCallback</A></DD></DL>
<HR>
<LEFT><A NAME=mgFreePaneLayout><H1 CLASS="APISYMBOL">mgFreePaneLayout</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFreePaneLayout</B> - frees a previously allocated <I>layout</I>.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgFreePaneLayout</B> (</TD><TD><A HREF=#mgpanelayout>mgpanelayout</A></TD><TD><I>layout</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFreePaneLayout</B> frees a previously allocated <I>layout</I>. Each 
call to <A HREF=#mgNewPaneLayout>mgNewPaneLayout</A> should be matched with a call to <B>mgFreePaneLayout</B> 
in order to prevent memory leaks.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>layout</I></DT><DD>the address of the struct to 
be freed</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewPaneLayout>mgNewPaneLayout</A>, <A HREF=#mgGetPaneLayout>mgGetPaneLayout</A>, <A HREF=#mgSetPaneLayout>mgSetPaneLayout</A></DD></DL>
<HR>
<LEFT><A NAME=mgFreeParamBlock><H1 CLASS="APISYMBOL">mgFreeParamBlock</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFreeParamBlock</B> - deallocates a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgFreeParamBlock</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFreeParamBlock</B> deallocates a parameter block 
created by <A HREF=#mgNewParamBlock>mgNewParamBlock</A> or <A HREF=#mgGetParamBlock>mgGetParamBlock</A>.</P></DD><DD><P>Note: If you passed the parameter block to <A HREF=#mgPluginToolSetDefaultParamBlock>mgPluginToolSetDefaultParamBlock</A>, 
you transfer ownership of the parameter block to the OpenFlight API and you should 
NOT deallocate the block with this function.  The OpenFlight API will automatically 
dispose of the memory when it is appropriate to do so.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block to deallocate</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgparamblock>mgparamblock</A>, <A HREF=#mgNewParamBlock>mgNewParamBlock</A>, <A HREF=#mgGetParamBlock>mgGetParamBlock</A>, 
<A HREF=#mgPluginToolSetDefaultParamBlock>mgPluginToolSetDefaultParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgFreeProjection><H1 CLASS="APISYMBOL">mgFreeProjection</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFreeProjection</B> - frees a projection object.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgFreeProjection</B> (</TD><TD><A HREF=#mgprojection>mgprojection</A></TD><TD><I>projection</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFreeProjection</B> disposes of the dynamic memory allocated for 
the projection object created by <A HREF=#mgNewProjection>mgNewProjection</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>projection</I></DT><DD>the projection object to free</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgprojcoord>mgprojcoord</A>, <A HREF=#mgcoord3d>mgcoord3d</A>, 
<A HREF=#mgNewProjection>mgNewProjection</A>, <A HREF=#mgProjectionConvertLLEtoXYZ>mgProjectionConvertLLEtoXYZ</A>, 
<A HREF=#mgProjectionConvertXYZtoLLE>mgProjectionConvertXYZtoLLE</A>, <A HREF=#mgProject>mgProject</A>, <A HREF=#mgUnproject>mgUnproject</A></DD></DL>
<HR>
<LEFT><A NAME=mgFreePtrArray><H1 CLASS="APISYMBOL">mgFreePtrArray</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFreePtrArray</B> - frees a pointer array.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgFreePtrArray</B> (</TD><TD><A HREF=#mgptrarray>mgptrarray</A></TD><TD><I>ptrArray</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFreePtrArray</B> frees the dynamic memory associated with the 
pointer array <I>ptrArray</I>.</P></DD><DD><P>Note that this function does not free or otherwise affect 
the actual items that may be in the array when called.  If the array contains 
any items that were dynamically allocated, it is the callers responsibility to 
deallocate them.</P></DD><DD><P>The pointer array is assumed to have been created using the function 
<A HREF=#mgNewPtrArray>mgNewPtrArray</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>ptrArray</I></DT><DD>the pointer array</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewPtrArray>mgNewPtrArray</A>, <A HREF=#mgPtrArrayAppend>mgPtrArrayAppend</A>, <A HREF=#mgPtrArrayInsert>mgPtrArrayInsert</A>, 
<A HREF=#mgPtrArrayReplace>mgPtrArrayReplace</A>, <A HREF=#mgPtrArrayGet>mgPtrArrayGet</A>, <A HREF=#mgPtrArrayRemove>mgPtrArrayRemove</A>, 
<A HREF=#mgPtrArrayClear>mgPtrArrayClear</A>, <A HREF=#mgPtrArrayLength>mgPtrArrayLength</A>, <A HREF=#mgPtrArraySort>mgPtrArraySort</A>, 
<A HREF=#mgPtrArraySearch>mgPtrArraySearch</A>, <A HREF=#mgPtrArrayBSearch>mgPtrArrayBSearch</A></DD></DL>
<HR>
<LEFT><A NAME=mgFreePtrStack><H1 CLASS="APISYMBOL">mgFreePtrStack</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFreePtrStack</B> - frees a pointer stack.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgFreePtrStack</B> (</TD><TD><A HREF=#mgptrstack>mgptrstack</A></TD><TD><I>ptrStack</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFreePtrStack</B> frees the dynamic memory associated with the 
pointer stack <I>ptrStack</I>.</P></DD><DD><P>Note that this function does not free or otherwise affect 
the actual items that may be in the stack when called.  If the stack contains 
any items that were dynamically allocated, it is the callers responsibility to 
deallocate them.</P></DD><DD><P>The pointer stack is assumed to have been created using the function 
<A HREF=#mgNewPtrStack>mgNewPtrStack</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>ptrStack</I></DT><DD>the pointer stack</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewPtrStack>mgNewPtrStack</A>, 
<A HREF=#mgPtrStackPush>mgPtrStackPush</A>, <A HREF=#mgPtrStackPop>mgPtrStackPop</A>, <A HREF=#mgPtrStackClear>mgPtrStackClear</A>, 
<A HREF=#mgPtrStackTop>mgPtrStackTop</A>, <A HREF=#mgPtrStackLength>mgPtrStackLength</A></DD></DL>
<HR>
<LEFT><A NAME=mgFreeRecList><H1 CLASS="APISYMBOL">mgFreeRecList</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFreeRecList</B> - frees a record list.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgFreeRecList</B> (</TD><TD><A HREF=#mgreclist>mgreclist</A></TD><TD><I>recList</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFreeRecList</B> frees the contents of a record list 
allocated by a call to <A HREF=#mgGetSelectList>mgGetSelectList</A>, <A HREF=#mgGetConstructList>mgGetConstructList</A>, 
of <A HREF=#mgGetTriangleList>mgGetTriangleList</A>. 
When you are done accessing a record list, dispose of it using 
this function.</P></DD><DD><P>Only the internal contents of the record list is disposed.  This 
function does not affect the actual nodes that were contained in the list.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to dispose of record lists in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>recList</I></DT><DD>the record list to free</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetSelectList>mgGetSelectList</A>, <A HREF=#mgResetRecList>mgResetRecList</A>, <A HREF=#mgGetNextRecInList>mgGetNextRecInList</A>, 
<A HREF=#mgGetNthRecInList>mgGetNthRecInList</A>, <A HREF=#mgGetRecListCount>mgGetRecListCount</A>, 
<A HREF=#mgGetConstructList>mgGetConstructList</A>, <A HREF=#mgGetTriangleList>mgGetTriangleList</A>, <A HREF=#mgIsRecInList>mgIsRecInList</A></DD></DL>
<HR>
<LEFT><A NAME=mgFreeStringList><H1 CLASS="APISYMBOL">mgFreeStringList</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFreeStringList</B> - frees the string list returned by 
<A HREF=#mgListGetStrings>mgListGetStrings</A>, <A HREF=#mgListGetSelectedStrings>mgListGetSelectedStrings</A>, <A HREF=#mgPromptDialogFile>mgPromptDialogFile</A>, 
<A HREF=#mgPromptDialogTexture>mgPromptDialogTexture</A> or <A HREF=#mgGetColorNameList>mgGetColorNameList</A><P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgFreeStringList</B> (</TD><TD><A HREF=#mgstringlist>mgstringlist</A></TD><TD><I>strings</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFreeStringList</B> disposes of the dynamic memory allocated for 
the string lists returned by the functions listed.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>strings</I></DT><DD>the string list to free</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListGetStrings>mgListGetStrings</A>, <A HREF=#mgStringListCount>mgStringListCount</A>, 
<A HREF=#mgListGetSelectedStrings>mgListGetSelectedStrings</A>, <A HREF=#mgPromptDialogFile>mgPromptDialogFile</A>, 
<A HREF=#mgPromptDialogTexture>mgPromptDialogTexture</A></DD></DL>
<HR>
<LEFT><A NAME=mgFreeTabRuler><H1 CLASS="APISYMBOL">mgFreeTabRuler</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgFreeTabRuler</B> - frees a tab ruler control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgFreeTabRuler</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgFreeTabRuler</B> deallocates an initialized tab ruler control that is associated with a control. 
<I>control</I> is the GL control that is associated with the tab ruler control.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>tab ruler control</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewTabRuler>mgNewTabRuler</A>, <A HREF=#mgTabRulerSetOptions>mgTabRulerSetOptions</A>, <A HREF=#mgTabRulerGetTabCount>mgTabRulerGetTabCount</A>, <A HREF=#mgTabRulerGetTabPosition>mgTabRulerGetTabPosition</A>, 
<A HREF=#mgTabRulerSetTabPosition>mgTabRulerSetTabPosition</A>, <A HREF=#mgTabRulerSetTabFrozen>mgTabRulerSetTabFrozen</A>, 
<A HREF=#mgTabRulerNewTab>mgTabRulerNewTab</A>, <A HREF=#mgTabRulerDeleteTab>mgTabRulerDeleteTab</A>, 
<A HREF=#mgTabRulerGetSelectedTab>mgTabRulerGetSelectedTab</A>, <A HREF=#mgTabRulerSelectTab>mgTabRulerSelectTab</A></DD></DL>
<HR>
<LEFT><A NAME=mgGeoCoordAdd><H1 CLASS="APISYMBOL">mgGeoCoordAdd</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGeoCoordAdd</B> - adds geospecific coordinates to a texture 
attribute record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgGeoCoordAdd</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>imgRec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mggeocoorddata>mggeocoorddata</A></TD><TD><I>geoCoordData[]</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>n</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGeoCoordAdd</B> adds <I>n</I> geospecific coordinates to the specified 
texture attribute record <I>imgRec</I> (of type <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltImage>fltImage</A>
).  The coordinates 
are passed via the array <I>geoCoordData</I>. The number of coordinates actually 
added is returned.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>imgRec</I></DT><DD>the texture attribute record</DD><DT><I>geoCoordData[]</I></DT><DD>the array of geospecific coordinates to be added</DD><DT><I>n</I></DT><DD>the number of coordinates in the 
the array <I>geoCoordData</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of coordinates added.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* imgRec = mgGetTextureAttributes (db, textureIndex);
mggeocoorddata geoCoords[3];

// set the data for each element of the sequence
geoCoords[0].u = 0.0;
geoCoords[0].v = 0.0;
geoCoords[0].lat = 37.0;
geoCoords[0].lon = 122.0;

geoCoords[1].u = 1024.0;
geoCoords[1].v = 0.0;
geoCoords[1].lat = 38.0;
geoCoords[1].lon = 122.0;

geoCoords[2].u = 1024.0;
geoCoords[2].v = 1024.0;
geoCoords[2].lat = 38.0;
geoCoords[2].lon = 123.0;

// add these geoCoords to the existing coordinates
mgGeoCoordAdd (imgRec, geoCoords, 3);</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">imgRec = mgGetTextureAttributes (db, textureIndex)
# allocate 3 elements for the subtexture data
geoCoords = mggeocoorddata(3)

# set the data for each geoCoord
geoCoords[0].u = 0.0
geoCoords[0].v = 0.0
geoCoords[0].lat = 37.0
geoCoords[0].lon = 122.0

geoCoords[1].u = 1024.0
geoCoords[1].v = 0.0
geoCoords[1].lat = 38.0
geoCoords[1].lon = 122.0

geoCoords[2].u = 1024.0
geoCoords[2].v = 1024.0
geoCoords[2].lat = 38.0
geoCoords[2].lon = 123.0

# add these geoCoords to the existing coordinates
mgGeoCoordAdd (imgRec, geoCoords, 3)</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGeoCoordDelete>mgGeoCoordDelete</A>, <A HREF=#mgGeoCoordGet>mgGeoCoordGet</A>, <A HREF=#mgGeoCoordCount>mgGeoCoordCount</A>, 
<A HREF=#mggeocoorddata>mggeocoorddata</A></DD></DL>
<HR>
<LEFT><A NAME=mgGeoCoordCount><H1 CLASS="APISYMBOL">mgGeoCoordCount</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGeoCoordCount</B> - gets the number of geospecific coordinates 
in a texture attribute record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgGeoCoordCount</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>imgRec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><A HREF=#mgGeoCoordGet>mgGeoCoordGet</A> returns the number of geospecific coordinates 
in the specified texture attribute record <I>imgRec</I> (of type <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltImage>fltImage</A>
).</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>imgRec</I></DT><DD>the texture attribute record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of coordinates contained in the texture attribute 
record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGeoCoordAdd>mgGeoCoordAdd</A>, <A HREF=#mgGeoCoordDelete>mgGeoCoordDelete</A>, <A HREF=#mgGeoCoordGet>mgGeoCoordGet</A></DD></DL>
<HR>
<LEFT><A NAME=mgGeoCoordDelete><H1 CLASS="APISYMBOL">mgGeoCoordDelete</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGeoCoordDelete</B> - Deletes a geospecific coordinate with the 
given index.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGeoCoordDelete</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>imgRec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGeoCoordDelete</B> deletes a geospecific coordinate at index <I>index</I> 
from the specified texture attribute record <I>imgRec</I> (of type <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltImage>fltImage</A>
).</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>imgRec</I></DT><DD>the texture attribute record</DD><DT><I>index</I></DT><DD>the index to be deleted</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGeoCoordAdd>mgGeoCoordAdd</A>, <A HREF=#mgGeoCoordGet>mgGeoCoordGet</A>, <A HREF=#mgGeoCoordCount>mgGeoCoordCount</A></DD></DL>
<HR>
<LEFT><A NAME=mgGeoCoordGet><H1 CLASS="APISYMBOL">mgGeoCoordGet</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGeoCoordGet</B> - gets the geospecific coordinates from a 
texture attribute record.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgGeoCoordGet</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>imgRec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mggeocoorddata>mggeocoorddata</A></TD><TD><I>geoCoordData[]</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>arrayLen</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>numGeoCoords, geoCoordData <B>mgGeoCoordGet</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>imgRec</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGeoCoordGet</B> gets the geospecific coordinates of the specified 
texture attribute record <I>imgRec</I> (of type <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltImage>fltImage</A>
).</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P><B>mgGeoCoordGet</B> writes the data into the output parameter <I>subTextureData</I>. 
The size of the array is specified by <I>arrayLen</I>.  The number of geospecific coordinates 
actually written into the array is returned.  You can determine the actual number of 
geospecific coordinates contained in a texture attribute record by querying the 
attribute <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltTxtGeoCoordLst>fltTGNumCoords</A>
.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P><B>mgGeoCoordGet</B> returns the geospecific coordinate data. The number 
of geospecific coordinates included is also returned.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>imgRec</I></DT><DD>the texture attribute record</DD><DT><I>geoCoordData[]</I></DT><DD>the array of geospecific coordinates to be filled in</DD><DT><I>arrayLen</I></DT><DD>the size of the array <I>geoCoordData</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>numGeoCoords</DT><DD>The number of geospecific coordinate records being returned.</DD><DT>geoCoordData</DT><DD>The records returned.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* imgRec = mgGetTextureAttributes (db, textureIndex);
int numCoords = mgGeoCoordCount (imgRec);
if (numCoords &gt 0) {
   int num;
   mggeocoorddata gcData[10];
   num = mgGeoCoordGet (imgRec, gcData, 10);
   // num will be minimum of 10 and numCoords
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">imgRec = mgGetTextureAttributes (db, textureIndex)
num,geoCoords = mgGeoCoordGet (imgRec)
print "Number of Geo Coords:",num
for i in range (0, num):
   print "GeoCoord",i+1,":"
   geoCoord = geoCoords[i]
   print "   u,v,lat,lon:",geoCoord.u,geoCoord.v,geoCoord.lat,geoCoord.lon</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGeoCoordAdd>mgGeoCoordAdd</A>, <A HREF=#mgGeoCoordDelete>mgGeoCoordDelete</A>, <A HREF=#mgGeoCoordCount>mgGeoCoordCount</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetAbsoluteFilename><H1 CLASS="APISYMBOL">mgGetAbsoluteFilename</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetAbsoluteFilename</B> - gets the absolute path of a file 
relative to a database.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetAbsoluteFilename</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>relFilename</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>absFilename</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maxLen</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, absFilename <B>mgGetAbsoluteFilename</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>relFilename</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a database <I>db</I>, and a relative filename <I>relFilename</I>, 
<B>mgGetAbsoluteFilename</B> forms and returns the absolute filename for the file. 
The file does not have to exist.</P></DD><DD><P>The following table shows the forms the relative filename <I>relFilename</I> can take 
and the absolute path results for <I>db</I> located in <SPAN CLASS="MONOSPACE">C:/folder1/folder2/db.flt</SPAN>:<BR> 
<TABLE CLASS="SIMPLE">
 
<TR CLASS="HEADER">
 
<TD CLASS="BORDER">
 Relative Filename </TD>
 
<TD CLASS="BORDER">
 Absolute Path Returned </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">../path1/file.ext</SPAN> </TD>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">C:/folder1/path1/file.ext</SPAN> </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">./file.ext</SPAN> </TD>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">C:/folder1/folder2/file.ext</SPAN> </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">./path1/file.ext</SPAN> </TD>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">C:/folder1/folder2/path1/file.ext</SPAN> </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">../../path1/path2/file.ext</SPAN> </TD>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">C:/path1/path2/file.ext</SPAN> </TD>
 
</TR>
<P>
</TABLE>
</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database to which <I>relFilename</I> is relative</DD><DT><I>relFilename</I></DT><DD>the relative file name</DD><DT><I>absFilename</I></DT><DD>the address of string to receive absolute filename</DD><DT><I>maxLen</I></DT><DD>maximum number of characters to store in 
<I>absFilename</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the absolute filename can be formed, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>absFilename</DT><DD>If function is successful,this contains the absolute 
filename, otherwise it is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExtRefSetLocatorFunc>mgExtRefSetLocatorFunc</A>, <A HREF=#mgTextureGetLocatorFunc>mgTextureGetLocatorFunc</A>, <A HREF=#mgIsDbUntitled>mgIsDbUntitled</A>, 
<A HREF=#mgShaderGetLocatorFunc>mgShaderGetLocatorFunc</A>, <A HREF=#mgfilelocatorfunc>mgfilelocatorfunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetActivationDb><H1 CLASS="APISYMBOL">mgGetActivationDb</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetActivationDb</B> - retrieves the database from a tool 
activation object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetActivationDb</B> (</TD><TD><A HREF=#mgtoolactivation>mgtoolactivation</A></TD><TD><I>toolActivation</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetActivationDb</B> retrieves the database associated to 
the specific tool activation object <I>toolActivation</I>.</P></DD><DD><P>When a plug-in tool is launched, the corresponding start function 
is called.  The start function is passed a tool specific callback 
record that contains a tool activation object.  Among other things, 
this tool activation object contains the top database or focus database 
for which the tool was launched.</P></DD><DD><P>Use this function to extract the focus database from a tool 
activation object.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>toolActivation</I></DT><DD>the tool activation 
to get database node for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the database referenced in the specified tool 
activation object if the 
tool activation is valid, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgimportercallbackrec>mgimportercallbackrec</A>, <A HREF=#mgexportercallbackrec>mgexportercallbackrec</A>, 
<A HREF=#mgviewercallbackrec>mgviewercallbackrec</A>, <A HREF=#mgeditorcallbackrec>mgeditorcallbackrec</A>, 
<A HREF=#mgGetModelingMode>mgGetModelingMode</A>, <A HREF=#mgSetModelingMode>mgSetModelingMode</A>, <A HREF=#mgIsModelingModeEdge>mgIsModelingModeEdge</A>, <A HREF=#mgSetModelingModeEdge>mgSetModelingModeEdge</A>, 
<A HREF=#mgGetModelingParent>mgGetModelingParent</A>, <A HREF=#mgGetModelingParentMatrix>mgGetModelingParentMatrix</A>, <A HREF=#mgGetDefaultModelingParent>mgGetDefaultModelingParent</A>, <A HREF=#mgSetModelingParent>mgSetModelingParent</A>, 
<A HREF=#mgGetActivationType>mgGetActivationType</A>, <A HREF=#mgGetActivationParamBlock>mgGetActivationParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetActivationKeyboardFlags><H1 CLASS="APISYMBOL">mgGetActivationKeyboardFlags</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetActivationKeyboardFlags</B> - retrieves the state of 
the <I>Alt</I>, <I>Ctrl</I>, and <I>Shift</I> keys from a tool activation object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>unsigned int <B>mgGetActivationKeyboardFlags</B> (</TD><TD><A HREF=#mgtoolactivation>mgtoolactivation</A></TD><TD><I>toolActivation</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetActivationKeyboardFlags</B> retrieves the state of the <I>Alt</I>, 
<I>Ctrl</I>, and <I>Shift</I> modifier keys when a plug-in tool was activated.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>toolActivation</I></DT><DD>the tool activation to get 
modifier key state for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the state of the <I>Alt</I>, <I>Ctrl</I>, and <I>Shift</I> keys. This value is a 
bitwise combination of <A HREF=#MKB_ALTKEY>MKB_ALTKEY</A>, <A HREF=#MKB_CTRLKEY>MKB_CTRLKEY</A> and <A HREF=#MKB_SHIFTKEY>MKB_SHIFTKEY</A>
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows how an editor plug-in tool checks the state of 
each modifier key. It is similar for other plug-in tool types.</DT><DT><PRE CLASS="EXAMPLE">// editor tool start function
static mgstatus StartTool (mgplugintool pluginTool, void* userData, void* callData)
{
   mgeditorcallbackrec* cbData = (mgeditorcallbackrec*) callData;
   mgrec* db = mgGetActivationDb (cbData-&gttoolActivation);
   unsigned int keyboardFlags = mgGetActivationKeyboardFlags(cbData-&gttoolActivation);

   int ctrlKeyDown  = keyboardFlags & MKB_CTRLKEY;
   int altKeyDown   = keyboardFlags & MKB_ALTKEY;
   int shiftKeyDown = keyboardFlags & MKB_SHIFTKEY;

   // your tool may behave slightly differently based on which modifier keys
   // were pressed when the user activated the tool

   return (MSTAT_OK);
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgtoolactivation>mgtoolactivation</A>, 
<A HREF=#mgimportercallbackrec>mgimportercallbackrec</A>, <A HREF=#mgexportercallbackrec>mgexportercallbackrec</A>, 
<A HREF=#mgviewercallbackrec>mgviewercallbackrec</A>, <A HREF=#mgeditorcallbackrec>mgeditorcallbackrec</A>, <A HREF=#mgGetActivationDb>mgGetActivationDb</A>, <A HREF=#mgGetActivationType>mgGetActivationType</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetActivationParamBlock><H1 CLASS="APISYMBOL">mgGetActivationParamBlock</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetActivationParamBlock</B> - retrieves the activation 
parameter block from a tool activation object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgparamblock <B>mgGetActivationParamBlock</B> (</TD><TD><A HREF=#mgtoolactivation>mgtoolactivation</A></TD><TD><I>toolActivation</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetActivationParamBlock</B> retrieves the activation type for the 
specific tool activation object <I>toolActivation</I>.</P></DD><DD><P>When a scriptable editor tool is invoked in Creator Script, Creator 
gathers user-specified tool parameters from the script and packages them 
into an activation parameter block.  It provides this parameter block to 
the editor tool in the <A HREF=#mgtoolactivation>mgtoolactivation</A> object of the tool specific 
callback record passed to the start function.  For editor tools, this 
callback record is an object of type <A HREF=#mgeditorcallbackrec>mgeditorcallbackrec</A>.</P></DD><DD><P>Use functions <A HREF=#mgParamGetInteger>mgParamGetInteger</A>, <A HREF=#mgParamGetDouble>mgParamGetDouble</A>, <A HREF=#mgParamGetFloat>mgParamGetFloat</A>, 
<A HREF=#mgParamGetBool>mgParamGetBool</A>, <A HREF=#mgParamGetString>mgParamGetString</A>, <A HREF=#mgParamGetDouble2>mgParamGetDouble2</A> and <A HREF=#mgParamGetDouble3>mgParamGetDouble3</A> 
to get pararamter values from the activation parameter block.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>toolActivation</I></DT><DD>the tool activation to get 
activation parameter block for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the activation parameter block for the specific tool activation object 
<I>toolActivation</I> if the tool activation is valid, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows how a scriptable editor tool uses this 
function to obtain the parameter block when invoked in Creator Script. 
It also shows how to get values of individual parameters in the parameter block.</DT><DT><PRE CLASS="EXAMPLE">// editor tool start function
static mgstatus StartTool (mgplugintool pluginTool, void* userData, void* callData)
{
   mgeditorcallbackrec* cbData = (mgeditorcallbackrec*) callData;
   mgrec* db = mgGetActivationDb (cbData-&gttoolActivation);
   mgtoolactivationtype activationType = mgGetActivationType (cbData-&gttoolActivation);

   if (activationType == MTAT_NORMAL) {
      // tool is being run in Creator interactively
      // get user parameters from dialog
   }
   else if (activationType == MTAT_SCRIPT) {
      // tool is being run in Creator Script
      // get user parameters from the activation parameter block
      mgparamblock paramBlock = mgGetActivationParamBlock (cbData-&gttoolActivation);
      mgparam param;
      int typeValue;

      // in this example, the parameter block is expected to contain
      // an integer parameter (named "Type")

      // get the "Type" parameter value
      mgParamGetInteger (paramBlock, "Type", &typeValue, 1);
   }
   return (MSTAT_OK);
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgtoolactivationtype>mgtoolactivationtype</A>, <A HREF=#mgtoolactivation>mgtoolactivation</A>, 
<A HREF=#mgimportercallbackrec>mgimportercallbackrec</A>, <A HREF=#mgexportercallbackrec>mgexportercallbackrec</A>, 
<A HREF=#mgviewercallbackrec>mgviewercallbackrec</A>, <A HREF=#mgeditorcallbackrec>mgeditorcallbackrec</A>, <A HREF=#mgGetActivationDb>mgGetActivationDb</A>, <A HREF=#mgGetActivationType>mgGetActivationType</A>, 
<A HREF=#mgParamGetInteger>mgParamGetInteger</A>, <A HREF=#mgParamGetDouble>mgParamGetDouble</A>, <A HREF=#mgParamGetFloat>mgParamGetFloat</A>, 
<A HREF=#mgParamGetBool>mgParamGetBool</A>, <A HREF=#mgParamGetString>mgParamGetString</A>, <A HREF=#mgParamGetDouble2>mgParamGetDouble2</A>, <A HREF=#mgParamGetDouble3>mgParamGetDouble3</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetActivationType><H1 CLASS="APISYMBOL">mgGetActivationType</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetActivationType</B> - retrieves the activation 
type from a tool activation object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgtoolactivationtype <B>mgGetActivationType</B> (</TD><TD><A HREF=#mgtoolactivation>mgtoolactivation</A></TD><TD><I>toolActivation</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetActivationType</B> retrieves the activation type for the 
specific tool activation object <I>toolActivation</I>.</P></DD><DD><P>When a plug-in tool is invoked in Creator, its start function is 
invoked and a <A HREF=#mgtoolactivation>mgtoolactivation</A> object is provided in the corresponding 
tool specific callback record. The tool activation object contains information 
about the context in which the tool is being invoked.  The activation type 
of the tool activation object specifies is the tool is being activated 
interactively or in Creator Script.  The start function of a scriptable 
editor tool will use this information to determine how to proceed.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>toolActivation</I></DT><DD>the tool activation 
to get activation type for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the activation type for the specific tool activation object 
<I>toolActivation</I> if the tool activation is valid, <B>MTAT_UNKNOWN</B> otherwise. 
See <A HREF=#mgtoolactivationtype>mgtoolactivationtype</A> for a description of the possible activation 
types returned.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows how a scriptable editor tool uses this 
function to detect if it is being run interactively or in Creator Script. 
Note that only scriptable editor tools can be invoked in Creator Script.</DT><DT><PRE CLASS="EXAMPLE">// editor tool start function
static mgstatus StartTool (mgplugintool pluginTool, void* userData, void* callData)
{
   mgeditorcallbackrec* cbData = (mgeditorcallbackrec*) callData;
   mgrec* db = mgGetActivationDb (cbData-&gttoolActivation);
   mgtoolactivationtype activationType = mgGetActivationType (cbData-&gttoolActivation);

   if (activationType == MTAT_NORMAL) {
      // tool is being run in Creator interactively
      // finish start function accordingly
   }
   else if (activationType == MTAT_SCRIPT) {
      // tool is being run in Creator Script
      // finish start function accordingly
   }
   return (MSTAT_OK);
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgtoolactivationtype>mgtoolactivationtype</A>, <A HREF=#mgtoolactivation>mgtoolactivation</A>, <A HREF=#mgGetActivationParamBlock>mgGetActivationParamBlock</A>, 
<A HREF=#mgimportercallbackrec>mgimportercallbackrec</A>, <A HREF=#mgexportercallbackrec>mgexportercallbackrec</A>, 
<A HREF=#mgviewercallbackrec>mgviewercallbackrec</A>, <A HREF=#mgeditorcallbackrec>mgeditorcallbackrec</A>, <A HREF=#mgGetActivationDb>mgGetActivationDb</A>, <A HREF=#mgGetActivationParamBlock>mgGetActivationParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetAttBuf><H1 CLASS="APISYMBOL">mgGetAttBuf</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetAttBuf</B> - gets consecutive values from an attribute 
record and stores them in a data buffer.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetAttBuf</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>fcode</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>buf</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a record, rec, <B>mgGetAttBuf</B> gets the values of the attribute 
<I>fcode</I> from <I>rec</I> and stores those values in the data buffer <I>buf</I>. 
It is the caller's responsibility to ensure that sufficient storage is 
allocated.</P></DD><DD><P>This routine is used for getting all attribute values of a record, 
with the condition that the attributes are consecutive as defined by the 
data dictionary. Note: Simple records such as <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3d</A>
 and 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMatrix>fltMatrix</A>
 are guaranteed to be stored consecutively; more complex 
records are not. Exercise caution when using this routine.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>points to the record from which to get values</DD><DT><I>fcode</I></DT><DD>the attribute code</DD><DT><I>buf</I></DT><DD>points to the storage area for the attribute values</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if data is stored in the buffer, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example gets the attribute values of <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMatrix>fltMatrix</A>
 
in <I>polyRec</I>.</DT><DT><PRE CLASS="EXAMPLE">mgmatrix matrix;

mgGetAttBuf (polyRec, fltMatrix, matrix);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetAttBuf>mgSetAttBuf</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetAttList><H1 CLASS="APISYMBOL">mgGetAttList</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetAttList</B> - gets the values of record attributes using the 
<B>varargs</B> argument style.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgGetAttList</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>< attrCode ></I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>< attrValAddr ></I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>...</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>numAttr, < attrCode >, < attrVal >, ... <B>mgGetAttList</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>< attrCode ></I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>< attrCode ></I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>...</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetAttList</B> gets one or more values of <I>rec</I>'s attributes named by the 
attribute codes <I>attrCode</I>.  Note that <I>rec</I> must be a proper record and cannot 
be a value record.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P><B>mgGetAttList</B> writes the attribute values into the corresponding output 
variables <I>attrValAddr</I>.</P></DD><DD><P>For numeric attribute types (char, short, int, float, double, etc), pass 
the address of the corresponding variable type (char, short, int, float, double, etc). 
For character string attributes (char*), pass the address of a char* variable 
(initialized to NULL).  In this case <B>mgGetAttList</B> will allocate a dynamic 
memory buffer of type char*, fill this buffer with the character string value 
and return this buffer (now pointed to by your char* variable).  Since this 
string is dynamically allocated, the caller must deallocate it when it 
is no longer needed using <A HREF=#mgFree>mgFree</A>.  The example below shows this in more detail.</P></DD><DD><P>Since variable-length argument lists cannot be type-checked by the compiler, 
<B>varargs</B> functions can be a source of bugs.  Be sure to terminate your argument 
list with <A HREF=#MG_NULL>MG_NULL</A> and be sure that the type of each argument is as expected. 
Also, when passing the address of variables here, be sure to use variables of the 
exact size expected by the specified attribute codes.  For example, when an attribute 
is of type "short", be sure to pass the address of a "short" variable.  Passing the 
address of an "int" in this case would yield incorrect results.</P></DD><DD><P>The expected sizes for all OpenFlight attribute values are shown in the 
OpenFlight Data Dictionary.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P><B>mgGetAttList</B> returns the attribute values as a tuple as shown in the example 
below. The number of items returned in the tuple varies with the number of attributes 
requested. The first item in the tuple indicates how many attribute code and value pairs 
follow in the tuple returned.</P></DD><DD><P>It is not necessary to terminate the argument list with <A HREF=#MG_NULL>MG_NULL</A> in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record from which to get values</DD><DT><I>< attrCode ></I></DT><DD>the attribute record code</DD><DT><I>< attrValAddr ></I></DT><DD>the pointer to the returned attribute value</DD><DT><I>...</I></DT><DD>the argument list is <BR><B>C</B> - in pairs of <I>attrCode</I> and <I>attrValAddr</I> 
ending with <A HREF=#MG_NULL>MG_NULL</A> terminator <BR><B>Python</B> - items of <I>attrCode</I> with no terminator</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>numAttr</DT><DD>The number of attribute values successfully retrieved.</DD><DT>< attrCode ></DT><DD>The first code.</DD><DT>< attrVal ></DT><DD>The value retrieved for the first code, 
<B>None</B> if not retrieved successfully.</DD><DT>...</DT><DD>etc.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">// get the material and texture indices from a polygon node
// both are of type short

mgrec* poly;
short texture;
short material;
int numAttr;

numAttr = mgGetAttList (poly,
&#32       fltPolyMaterial, &material,
&#32       fltPolyTexture, &texture,
&#32       MG_NULL);
if (numAttr == 2)
   printf ("success");
else
   printf ("fail");

// get the revision number and the date of last revision from a
// header node - revision number is int and date is character
// string - note special handling of character strings

mgrec* header;
int formatRev;
char* date = MG_NULL;
int numAttr;

numAttr = mgGetAttList (header,
&#32       fltHdrFormatRev, &formatRev,
&#32       fltHdrLastDate, &date,
&#32       MG_NULL);
if (date) {
   // date now points to a character string filled with
   // the fltHdrLastDate attribute value - you need to
   // free the memory when you are done with it !
   mgFree (date);
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE"># get the material and texture indices from a polygon node

outs = mgGetAttList (poly, fltPolyMaterial, fltPolyTexture)
# outs is a tuple with 5 elements as follows:
# outs[0] = number of attributes returned, 2 if successful
# outs[1] = fltPolyMaterial
# outs[2] = value of fltPolyMaterial
# outs[3] = fltPolyTexture
# outs[4] = value of fltPolyTexture
numAttr = outs[0]
if (numAttr == 2):
   material = outs[2]
   texture = outs[4]
   print "success"
else:
   print "fail"

# get the revision number and the date of last revision from a
# header node

outs = mgGetAttList (header, fltHdrFormatRev, fltHdrLastDate)
# outs is a tuple with 5 elements as follows:
# outs[0] = number of attributes returned, 2 if successful
# outs[1] = fltHdrFormatRev
# outs[2] = value of fltHdrFormatRev
# outs[3] = fltHdrLastDate
# outs[4] = value of fltHdrLastDate
numAttr = outs[0]
if (numAttr == 2):
   formatRev = outs[2]
   date = outs[4]
   print "success"
else:
   print "fail"

# here is an alternate PYTHON syntax not using tuples:
numAttr,matCode,material,txtCode,texture = mgGetAttList (poly, fltPolyMaterial, fltPolyTexture)
# numAttr = number of attributes returned, 2 if successful
# matCode = fltPolyMaterial
# material = value of fltPolyMaterial
# txtCode = fltPolyTexture
# texture = value of fltPolyTexture</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetAttList>mgSetAttList</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetAttrChild><H1 CLASS="APISYMBOL">mgGetAttrChild</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetAttrChild</B> - gets the attribute child of a node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetAttrChild</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetAttrChild</B> returns the attribute child of the specified 
node <I>rec</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to get attribute child for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the node if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, <A HREF=#mgGetChild>mgGetChild</A>, <A HREF=#mgGetChildNth>mgGetChildNth</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetAttRec><H1 CLASS="APISYMBOL">mgGetAttRec</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetAttRec</B> - gets pointer to one of a record's attribute records.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetAttRec</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>rcode</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>recOut</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetAttRec</B> returns a pointer to the attribute record identified by 
<I>rcode</I> from <I>rec</I>.  Use this function to retrieve an attribute record 
as opposed to an attribute value.  Use <A HREF=#mgGetAttList>mgGetAttList</A> to retrieve an 
attribute value.</P></DD><DD><P>If you specify <A HREF=#MG_NULL>MG_NULL</A> for <I>recOut</I>, a new record will be 
allocated and returned.  If you specify a valid <B>mgrec*</B> for <I>recOut</I>, 
the record retrieved will be copied into <I>recOut</I>.  In this way, you 
can reuse records.</P></DD><DD><P>Note: Any <I>recOut</I> that you pass in must have been returned 
from a previous call to <B>mgGetAttRec</B> or must be <A HREF=#MG_NULL>MG_NULL</A>. 
This ensures that the contents of other records do not 
inadvertently get overwritten.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>points to the record from which to get 
the attribute record</DD><DT><I>rcode</I></DT><DD>the attribute record code</DD><DT><I>recOut</I></DT><DD>points to the attribute record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the attribute record pointer if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example gets the attribute record pointer of 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltBoundingBox>fltBoundingBox</A>
 in <I>groupRec</I> through <I>attRec</I>.</DT><DT><PRE CLASS="EXAMPLE">mgrec* groupRec;
mgrec* attRec;
int boundType;

attRec = mgGetAttRec (groupRec, fltBoundingBox, MG_NULL);
mgGetAttList (attRec, fltBoundingType, &boundType, MG_NULL);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetAttList>mgGetAttList</A>, <A HREF=#mgGetAttBuf>mgGetAttBuf</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetBounds><H1 CLASS="APISYMBOL">mgGetBounds</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetBounds</B> - retrieves the bounding box for a node.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetBounds</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgboxd>mgboxd*</A></TD><TD><I>box</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, box <B>mgGetBounds</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetBounds</B> retrieves the axis aligned bounding box for a node 
record <I>rec</I>. The bounding box is in local coordinates.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>a node record</DD><DT><I>box</I></DT><DD>address of box to receive bounds</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the box was retrieved successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>box</DT><DD>If function is successful, box contains the retrieved coordinates, otherwise 
box is undefined.</DD></DL></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show you might use <B>mgGetBounds</B>:</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgbool ok;
mgboxd bounds;

ok = mgGetBounds (rec, &bounds);
if (ok == MG_TRUE) {
   printf ("Min: ( %f, %f, %f ), Max: ( %f, %f, %f )",
&#32    bounds.min.x, bounds.min.y, bounds.min.z,
&#32    bounds.max.x, bounds.max.y, bounds.max.z);
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">ok, bounds = mgGetBounds (rec)
if (ok == MG_TRUE):
   print "Min: (", bounds.min.x, bounds.min.y, bounds.min.z, "), " \\
&#32 "Max: (", bounds.max.x, bounds.max.y, bounds.max.z, ")"</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMakeBox>mgMakeBox</A>, 
<A HREF=#mgGetBoundsForRecList>mgGetBoundsForRecList</A>, 
<A HREF=#mgGetBoundsForSelect>mgGetBoundsForSelect</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetBoundsForRecList><H1 CLASS="APISYMBOL">mgGetBoundsForRecList</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetBoundsForRecList</B> - retrieves the bounding box for a list of nodes.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetBoundsForRecList</B> (</TD><TD><A HREF=#mgreclist>mgreclist</A></TD><TD><I>list</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgboxd>mgboxd*</A></TD><TD><I>box</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, box <B>mgGetBoundsForRecList</B> (</TD><TD><A HREF=#mgreclist>mgreclist</A></TD><TD><I>list</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetBoundsForRecList</B> retrieves the axis aligned bounding box for the nodes 
in the record list <I>list</I>. The bounding box is in world coordinates.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>list</I></DT><DD>a record list</DD><DT><I>box</I></DT><DD>address of box to receive bounds</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the box was retrieved successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>box</DT><DD>If function is successful, box contains the retrieved coordinates, otherwise 
box is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMakeBox>mgMakeBox</A>, 
<A HREF=#mgGetBounds>mgGetBounds</A>, 
<A HREF=#mgGetBoundsForSelect>mgGetBoundsForSelect</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetBoundsForSelect><H1 CLASS="APISYMBOL">mgGetBoundsForSelect</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetBoundsForSelect</B> - retrieves the bounding box for the selection.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetBoundsForSelect</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgboxd>mgboxd*</A></TD><TD><I>box</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, box <B>mgGetBoundsForSelect</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetBoundsForSelect</B> retrieves the axis aligned bounding box for the selected node 
records in database <I>db</I>. The bounding box is in world coordinates.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>box</I></DT><DD>address of box to receive bounds</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the box was retrieved successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>box</DT><DD>If function is successful, box contains the retrieved coordinates, otherwise 
box is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMakeBox>mgMakeBox</A>, 
<A HREF=#mgGetBounds>mgGetBounds</A>, 
<A HREF=#mgGetBoundsForRecList>mgGetBoundsForRecList</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetCaption><H1 CLASS="APISYMBOL">mgGetCaption</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetCaption</B> - retrieves caption string for a control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgGetCaption</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>string</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maxLen</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetCaption</B> retrieves the caption string of the specified 
<I>control</I>.</P></DD><DD><P>The caption is truncated and null terminated if it is longer than <I>maxLen</I> characters.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the control to get caption string for</DD><DT><I>string</I></DT><DD>character buffer to hold caption retrieved</DD><DT><I>maxLen</I></DT><DD>the maximum number of characters to store in <I>string</I></DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCaption>mgSetCaption</A>, <A HREF=#mgSetTitle>mgSetTitle</A>, <A HREF=#mgGetTitle>mgGetTitle</A></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgstatus</DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.</DD><DT>string</DT><DD>If function is successful, string contains the retrieved caption, otherwise 
string is undefined.</DD></DL></DL>
<HR>
<LEFT><A NAME=mgGetChild><H1 CLASS="APISYMBOL">mgGetChild</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetChild</B> - gets the first child of a node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetChild</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetChild</B> returns the first child of the specified 
node <I>rec</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to get first child for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the node if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, <A HREF=#mgGetChildNth>mgGetChildNth</A>, <A HREF=#mgGetParent>mgGetParent</A>, <A HREF=#mgGetAttrChild>mgGetAttrChild</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetChildNth><H1 CLASS="APISYMBOL">mgGetChildNth</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetChildNth</B> - gets the nth child of a node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetChildNth</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>parent</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>nth</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetChildNth</B> returns the nth child node of the 
specified node <B>parent</B>.  The first child is specified by <I>nth</I> equal to 1.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>parent</I></DT><DD>the parent node</DD><DT><I>nth</I></DT><DD>which child to return from the list of children</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the <I>nth</I> child node if it exists, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec *db, *node, *parent, *child;
int i;
db = mgOpenDb ("file1.flt");
node = UserGetNodeRecFunc (db);
parent = mgGetParent (node);
for (i = 1 ; child = mgGetChildNth (parent, i); i++) {
   if (child == node) {
      printf ("node is child number %d of parent", i);
      return;
   }
}
printf ("node is not a child of parent");</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgCountChild>mgCountChild</A>, <A HREF=#mgGetChild>mgGetChild</A>, <A HREF=#mgGetNext>mgGetNext</A>, <A HREF=#mgGetParent>mgGetParent</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetCode><H1 CLASS="APISYMBOL">mgGetCode</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetCode</B> - gets the code of a record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcode <B>mgGetCode</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetCode</B> returns the code associated to the specified record <I>rec</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the code of the record <I>rec</I> if valid, 0 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=mgGetColorIndexByName><H1 CLASS="APISYMBOL">mgGetColorIndexByName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetColorIndexByName</B> - finds the index of a color 
palette entry from its name.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetColorIndexByName</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>name</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, index <B>mgGetColorIndexByName</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#string>string</A></TD><TD><I>name</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a database node, <I>db</I>, and a color name <I>name</I>, 
<B>mgGetColorIndexByName</B> sets <I>index</I> to the index of the color 
palette entry that has <I>name</I> in its name list.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>name</I></DT><DD>the color name</DD><DT><I>index</I></DT><DD>address of value to receive index</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the named color was found, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved color index, otherwise 
index is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCurrentColorName>mgGetCurrentColorName</A>, <A HREF=#mgGetNextColorName>mgGetNextColorName</A>, <A HREF=#mgDeleteColorName>mgDeleteColorName</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetColorNameList><H1 CLASS="APISYMBOL">mgGetColorNameList</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetColorNameList</B> - gets the list of names for 
a particular color index.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstringlist <B>mgGetColorNameList</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Each color palette entry can have a list of names associated with it. 
Given a database node, <I>db</I> 
and an index into the color palette, <I>index</I>, <B>mgGetColorNameList</B> returns 
<I>index</I>&#146s color name list.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string list returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFreeStringList>mgFreeStringList</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned string list in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the color palette index</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the color name list for the given index 
if successful, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples print all the names associated with color 
index 4 in a database.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgstringlist nameList;

// get the list of color names
nameList = mgGetColorNameList (db, 4);
if (nameList)
{
   mgstringlist cursor = nameList;
   int n = 1;
   while (*cursor != MG_NULL)
   {
      // at this point name holds the nth name associated with color index 4
      printf ("Name %d: %s&#92;n", n, *cursor);

      // and go get the next one
      n++;
      cursor++;
   }
   // remember to free the list when you're done with it
   mgFreeStringList (nameList);
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE"># get the list of color names
nameList = mgGetColorNameList (db, 4)

n = 1
for colorName in nameList:
   print "Name",n,":",colorName
   n = n + 1

# in Python, you don't have to free the list</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCurrentColorName>mgGetCurrentColorName</A>, <A HREF=#mgGetColorIndexByName>mgGetColorIndexByName</A>, 
<A HREF=#mgGetPolyColorName>mgGetPolyColorName</A>, <A HREF=#mgGetPolyAltColorName>mgGetPolyAltColorName</A>, 
<A HREF=#mgSetPolyColorName>mgSetPolyColorName</A>, <A HREF=#mgSetPolyAltColorName>mgSetPolyAltColorName</A>, 
<A HREF=#mgGetNextColorName>mgGetNextColorName</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetColorRGBA><H1 CLASS="APISYMBOL">mgGetColorRGBA</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetColorRGBA</B> - gets values out of a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltColorRGBA>fltColorRGBA</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetColorRGBA</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>colorRGBACode</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>red</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>green</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>blue</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>alpha</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, red, green, blue, alpha <B>mgGetColorRGBA</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>colorRGBACode</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a record, <I>rec</I>, <B>mgGetColorRGBA</B> gets the values of <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltColorRGBA>fltColorRGBA</A>
 attribute 
record <I>colorRGBACode</I> from <I>rec</I> and stores them in <I>red</I>, <I>green</I>, <I>blue</I> and <I>alpha</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record from which to get the 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltColorRGBA>fltColorRGBA</A>
 attribute code</DD><DT><I>colorRGBACode</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltColorRGBA>fltColorRGBA</A>
 attribute code</DD><DT><I>red</I></DT><DD>address of value to receive red component</DD><DT><I>green</I></DT><DD>address of value to receive green component</DD><DT><I>blue</I></DT><DD>address of value to receive blue component</DD><DT><I>alpha</I></DT><DD>address of value to receive alpha component</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>red</DT><DD>If function is successful, red contains the corresponding numeric value, otherwise 
red is undefined.</DD><DT>green</DT><DD>If function is successful, green contains the corresponding numeric value, otherwise 
green is undefined.</DD><DT>blue</DT><DD>If function is successful, blue contains the corresponding numeric value, otherwise 
blue is undefined.</DD><DT>alpha</DT><DD>If function is successful, alpha contains the corresponding numeric value, otherwise 
alpha is undefined.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* db;
mgrec* ltsRec;
float r, g, b, a;
int index;

db = mgOpenDb ("file.flt");
ltsRec = mgGetFirstLightSource (db, &index);
mgGetColorRGBA (ltsRec, fltLtspAmbient, &r, &g, &b, &a);</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetAttList>mgGetAttList</A>, <A HREF=#mgGetAttBuf>mgGetAttBuf</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetComment><H1 CLASS="APISYMBOL">mgGetComment</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetComment</B> - gets the comment text of a node record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char* <B>mgGetComment</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetComment</B> returns the comment text of a node record, <I>rec</I>.</P></DD><DD><P>Use <A HREF=#mgSetComment>mgSetComment</A> or <A HREF=#mgDeleteComment>mgDeleteComment</A> to change or delete 
the comment text of a node record.  Vertex node records do not have comment text.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned string in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>points to the node record whose comment text is desired</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the comment text of the node if successful, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetComment>mgSetComment</A>, <A HREF=#mgDeleteComment>mgDeleteComment</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetConstructEdgeCoords><H1 CLASS="APISYMBOL">mgGetConstructEdgeCoords</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetConstructEdgeCoords</B> - gets the endpoint coordinates 
of a construction edge node.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgGetConstructEdgeCoords</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>constructEdge</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord1</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord2</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus, coord1, coord2 <B>mgGetConstructEdgeCoords</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>constructEdge</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetConstructEdgeCoords</B> gets the coordinates of the endpoints 
of a construction edge node <I>constructEdge</I>.</P></DD><DD><P>If either of the coordinate parameters (<I>coord1</I> or <I>coord2</I>) are 
MG_NULL, that particular coordinate will not be returned.  In this way you can 
query one endpoint of the construction edge without the other.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>constructEdge</I></DT><DD>the construction edge to 
get coordinates for</DD><DT><I>coord1</I></DT><DD>address of record to receive 
coordinates of first vertex of 
construction edge</DD><DT><I>coord2</I></DT><DD>address of record to receive 
coordinates of second vertex of 
construction edge</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgstatus</DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.</DD><DT>coord1</DT><DD>If function is successful, <I>coord1</I> contains coordinates of first vertex 
of construction edge, otherwise <I>coord1</I> is undefined.</DD><DT>coord2</DT><DD>If function is successful, <I>coord2</I> contains coordinates of second vertex 
of construction edge, otherwise <I>coord2</I> is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewConstructEdge>mgNewConstructEdge</A>, <A HREF=#mgSetConstructEdgeColor>mgSetConstructEdgeColor</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetConstructList><H1 CLASS="APISYMBOL">mgGetConstructList</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetConstructList</B> - gets the construction 
vertices and edges in a database.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgselectlist <B>mgGetConstructList</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetConstructList</B> creates a new node list containing all 
the construction vertex and edge nodes in the specified database <I>db</I>. 
The traversal pointer of the list returned is set to the first 
item in the list.</P></DD><DD><P>This function returns a list object that reflects the state 
of the database constructions when it was called.  Typically call 
this function, examine the contents of the list returned and then 
dispose of the list when you are done.  If you retain the list, its 
contents are not guaranteed to be valid if the modeler subsequently 
adds or deletes a construction vertex or edge.</P></DD><DD><P>When you are done accessing the list returned by this 
function, you should dispose of it using <A HREF=#mgFreeRecList>mgFreeRecList</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to dispose of the record list 
returned in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database to get the construction list for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a record list object containing all the construction nodes 
in database, <A HREF=#MG_NULL>MG_NULL</A> if no construction nodes found.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example gets the construction list for a 
database <I>db</I> and traverses each node it contains.</DT><DT><PRE CLASS="EXAMPLE">mgrec* rec;
mgmatrix constructMatrix;
mgreclist constructList = mgGetConstructList (db);

rec = mgGetNextRecInList (constructList, &constructMatrix);
while (rec)
{
   // do something with rec
   if (mgGetNext (rec)) {
      // rec is an "edge"
   }
   else {
      // rec is a "vertex"
   }
   // get next construct rec in list
   rec = mgGetNextRecInList (constructList, &constructMatrix);
}
mgFreeRecList (constructList);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgreclist>mgreclist</A>, <A HREF=#mgFreeRecList>mgFreeRecList</A>, <A HREF=#mgResetRecList>mgResetRecList</A>, 
<A HREF=#mgGetNextRecInList>mgGetNextRecInList</A>, <A HREF=#mgGetNthRecInList>mgGetNthRecInList</A>, <A HREF=#mgGetRecListCount>mgGetRecListCount</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetConstructVertexCoords><H1 CLASS="APISYMBOL">mgGetConstructVertexCoords</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetConstructVertexCoords</B> - gets the coordinates of a 
construction vertex node.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgGetConstructVertexCoords</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>constructVtx</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus, coord <B>mgGetConstructVertexCoords</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>constructVtx</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetConstructVertexCoords</B> gets the coordinates of a construction 
vertex node <I>constructVtx</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>constructVtx</I></DT><DD>the construction vertex to 
get coordinates for</DD><DT><I>coord</I></DT><DD>address of record to receive 
coordinates of construction vertex</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgstatus</DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.</DD><DT>coord</DT><DD>If function is successful, <I>coord</I> contains the corresponding coordinate values, 
otherwise <I>coord</I> is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewConstructVertex>mgNewConstructVertex</A>, <A HREF=#mgSetConstructVertexColor>mgSetConstructVertexColor</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetConvexHull><H1 CLASS="APISYMBOL">mgGetConvexHull</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetConvexHull</B> - builds and returns a convex hull 
object around a node record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgconvexhull <B>mgGetConvexHull</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>node</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetConvexHull</B> builds a convex hull object surrounding <I>node</I>. 
The convex hull is composed of a set of triangles that form an object that 
completely "envelops" the geometry of the <I>node</I>.</P></DD><DD><P>Use the function <A HREF=#mgConvexHullGetTriangleCount>mgConvexHullGetTriangleCount</A> to query the convex 
hull for the number of triangles it contains.  Use <A HREF=#mgConvexHullGetTriangleNth>mgConvexHullGetTriangleNth</A> 
to get each of these triangles.</P></DD><DD><P>Use the function <A HREF=#mgFreeConvexHull>mgFreeConvexHull</A> to dispose of the convex hull 
object when you are through using it.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>node</I></DT><DD>the node to build convex hull for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the convex hull object if successful, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows how to build and examine a convex hull 
for the a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltGroup>fltGroup</A>
 node <I>groupRec</I>.</DT><DT><PRE CLASS="EXAMPLE">// calculate the hull around the group node
int numTriangles, i;
mgconvexhull hull = mgGetConvexHull (groupRec);
if (hull)
{
   // get the number of triangles in the convex hull
   int numTriangles = mgConvexHullGetTriangleCount (hull);

   if (numTriangles &gt 0)
   {

      // loop over each triangle in the convex hull
      // remember, first triangle is index 1
      for (i = 1; i &lt= numTriangles; ++i)
      {
&#32 mgconvexhulltriangle triangle;
&#32 if (mgConvexHullGetTriangleNth (hull, i, &triangle) == MG_TRUE)
&#32 {
&#32    // triangle contains the ith triangle of the hull
&#32 }
      }
   }
   mgFreeConvexHull (hull);      // must free it to avoid a memory leak
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgConvexHullGetTriangleCount>mgConvexHullGetTriangleCount</A>, <A HREF=#mgConvexHullGetTriangleNth>mgConvexHullGetTriangleNth</A>, 
<A HREF=#mgFreeConvexHull>mgFreeConvexHull</A>, <A HREF=#mgNewConvexHullBuilder>mgNewConvexHullBuilder</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetCoord2i><H1 CLASS="APISYMBOL">mgGetCoord2i</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetCoord2i</B> - gets values out of a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord2i>fltCoord2i</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetCoord2i</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>y</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, x, y <B>mgGetCoord2i</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a record, <I>rec</I>, <B>mgGetCoord2i</B> gets the values of <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord2i>fltCoord2i</A>
 
attribute record <I>code</I> from <I>rec</I> and stores them in <I>x</I> and <I>y</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>points to the record from which to get values</DD><DT><I>code</I></DT><DD>the code of the point record to get</DD><DT><I>x</I></DT><DD>address of value to receive x coordinate</DD><DT><I>y</I></DT><DD>address of value to receive y coordinate</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the coord was retrieved successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>x</DT><DD>If function is successful, x contains the retrieved x component, otherwise 
x is undefined.</DD><DT>y</DT><DD>If function is successful, y contains the retrieved y component, otherwise 
y is undefined.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* db;
mgrec* imgRec;
int x, y;

db = mgOpenDb ("file.flt");

// Get image rec

mgGetCoord2i (imgRec, fltImgUp, &x, &y);</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetAttList>mgGetAttList</A>, <A HREF=#mgGetAttBuf>mgGetAttBuf</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetCoord3d><H1 CLASS="APISYMBOL">mgGetCoord3d</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetCoord3d</B> - gets values out of a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3d</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetCoord3d</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>y</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>z</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, x, y, z <B>mgGetCoord3d</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a record <I>rec</I>, <B>mgGetCoord3d</B> gets the values of <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3d</A>
 
attribute record <I>code</I> from <I>rec</I> and stores them in <I>x</I>, <I>y</I>, 
and <I>z</I>.</P></DD><DD><P>For retrieving vertex coordinates, it is much more efficient to call the 
convenience function <A HREF=#mgGetVtxCoord>mgGetVtxCoord</A>.</P></DD><DD><P>You do not have to provide addresses for all <I>x</I>, <I>y</I>, and <I>z</I> values.  For 
example, if you only want to receive the x and y components (but not z), specify valid 
addresses for <I>x</I> and <I>y</I> and leave <I>z</I> NULL.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record from which to get the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3d</A>
 
attribute record</DD><DT><I>code</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3d</A>
 attribute record code</DD><DT><I>x</I></DT><DD>address of value to receive x component</DD><DT><I>y</I></DT><DD>address of value to receive y component</DD><DT><I>z</I></DT><DD>address of value to receive z component</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the coord was retrieved successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>x</DT><DD>If function is successful, x contains the retrieved x component, otherwise 
x is undefined.</DD><DT>y</DT><DD>If function is successful, y contains the retrieved y component, otherwise 
y is undefined.</DD><DT>z</DT><DD>If function is successful, z contains the retrieved z component, otherwise 
z is undefined.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* db;
mgrec* lodRec;
double x, y, z;

db = mgOpenDb ("file.flt");

// create lod rec
lodRec = UserMakeLODRec (db);

mgGetCoord3d (lodRec, fltLodCenterPoint, &x, &y, &z);</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetAttList>mgGetAttList</A>, <A HREF=#mgGetAttBuf>mgGetAttBuf</A>, <A HREF=#mgGetVtxCoord>mgGetVtxCoord</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetCoord3f><H1 CLASS="APISYMBOL">mgGetCoord3f</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetCoord3f</B> - gets values out of a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3f>fltCoord3f</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetCoord3f</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>y</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>z</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, x, y, z <B>mgGetCoord3f</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a record <I>rec</I>, <B>mgGetCoord3f</B> gets the values of <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3f>fltCoord3f</A>
 
attribute record <I>code</I> from <I>rec</I> and stores them in <I>x</I>, <I>y</I>, 
and <I>z</I>.</P></DD><DD><P>You do not have to provide addresses for all <I>x</I>, <I>y</I>, and <I>z</I> values.  For 
example, if you only want to receive the x and y components (but not z), specify valid 
addresses for <I>x</I> and <I>y</I> and leave <I>z</I> NULL.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record from which to get the 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3f>fltCoord3f</A>
 attribute record</DD><DT><I>code</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3f>fltCoord3f</A>
 attribute record code</DD><DT><I>x</I></DT><DD>address of value to receive x component</DD><DT><I>y</I></DT><DD>address of value to receive y component</DD><DT><I>z</I></DT><DD>address of value to receive z component</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the coord was retrieved successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>x</DT><DD>If function is successful, x contains the retrieved x component, otherwise 
x is undefined.</DD><DT>y</DT><DD>If function is successful, y contains the retrieved y component, otherwise 
y is undefined.</DD><DT>z</DT><DD>If function is successful, z contains the retrieved z component, otherwise 
z is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCoord3d>mgSetCoord3d</A>, <A HREF=#mgSetCoord3f>mgSetCoord3f</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetCurrentAltColor><H1 CLASS="APISYMBOL">mgGetCurrentAltColor</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetCurrentAltColor</B> - returns color index and intensity for 
the current alternate modeling color.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetCurrentAltColor</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int*</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>intensity</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, index, intensity <B>mgGetCurrentAltColor</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetCurrentAltColor</B> returns the color 
palette <I>index</I> and <I>intensity</I> corresponding to 
the current alternate modeling color selected for database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>address of value to receive index of current 
alternate modeling color</DD><DT><I>intensity</I></DT><DD>address of value to receive intensity of current 
alternate modeling color</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if current alternate modeling color for <I>db</I> 
could be determined, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved color index, otherwise 
index is undefined.</DD><DT>intensity</DT><DD>If function is successful, intensity contains the retrieved color intensity, otherwise 
intensity is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCurrentAltColor>mgSetCurrentAltColor</A>, <A HREF=#mgGetCurrentAltColorRGB>mgGetCurrentAltColorRGB</A>, <A HREF=#mgGetCurrentColor>mgGetCurrentColor</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetCurrentAltColorRGB><H1 CLASS="APISYMBOL">mgGetCurrentAltColorRGB</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetCurrentAltColorRGB</B> - returns the RGB 
components of the current alternate modeling color.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetCurrentAltColorRGB</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>red</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>green</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>blue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, red, green, blue <B>mgGetCurrentAltColorRGB</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetCurrentAltColorRGB</B> returns the <I>red</I>, <I>green</I>, 
and <I>blue</I> components of the current alternate modeling color 
selected for database <I>db</I>.  The values 
returned are in the range 0..255.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>red</I></DT><DD>address of value to receive red component 
of current alternate modeling color</DD><DT><I>green</I></DT><DD>address of value to receive green component 
of current alternate modeling color</DD><DT><I>blue</I></DT><DD>address of value to receive blue component 
of current alternate modeling color</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if RGB components of current alternate modeling 
color for <I>db</I> could be determined, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>red</DT><DD>If function is successful, red contains the retrieved red component, otherwise 
red is undefined.</DD><DT>green</DT><DD>If function is successful, green contains the retrieved green component, otherwise 
green is undefined.</DD><DT>blue</DT><DD>If function is successful, blue contains the retrieved blue component, otherwise 
blue is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCurrentAltColorRGB>mgSetCurrentAltColorRGB</A>, <A HREF=#mgSetCurrentAltColor>mgSetCurrentAltColor</A>, <A HREF=#mgGetCurrentColorRGB>mgGetCurrentColorRGB</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetCurrentColor><H1 CLASS="APISYMBOL">mgGetCurrentColor</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetCurrentColor</B> - returns color index and intensity for 
the current primary modeling color.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetCurrentColor</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int*</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>intensity</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, index, intensity <B>mgGetCurrentColor</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetCurrentColor</B> returns the color 
palette <I>index</I> and <I>intensity</I> corresponding to 
the current primary modeling color selected for database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>address of value to receive index of current 
primary modeling color</DD><DT><I>intensity</I></DT><DD>address of value to receive intensity of current 
primary modeling color</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if current primary modeling color for <I>db</I> 
could be determined, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved color index, otherwise 
index is undefined.</DD><DT>intensity</DT><DD>If function is successful, intensity contains the retrieved color intensity, otherwise 
intensity is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCurrentColor>mgSetCurrentColor</A>, <A HREF=#mgGetCurrentColorRGB>mgGetCurrentColorRGB</A>, <A HREF=#mgGetCurrentAltColor>mgGetCurrentAltColor</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetCurrentColorName><H1 CLASS="APISYMBOL">mgGetCurrentColorName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetCurrentColorName</B> - gets the current name of a color 
palette entry.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char* <B>mgGetCurrentColorName</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Each color palette entry can have a list of names associated with it. 
One of these names is always the current name for that entry. 
Given a database node, <I>db</I>, and an index into the color palette, 
<I>index</I>, <B>mgGetCurrentColorName</B> <I>returns</I> the current name of the 
given color palette entry.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned string in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the color palette index</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the current name for the color palette entry if successful, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCurrentColorName>mgSetCurrentColorName</A>, <A HREF=#mgGetNextColorName>mgGetNextColorName</A>, <A HREF=#mgGetColorIndexByName>mgGetColorIndexByName</A>, 
<A HREF=#mgGetPolyColorName>mgGetPolyColorName</A>, <A HREF=#mgGetPolyAltColorName>mgGetPolyAltColorName</A>, 
<A HREF=#mgSetPolyColorName>mgSetPolyColorName</A>, <A HREF=#mgSetPolyAltColorName>mgSetPolyAltColorName</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetCurrentColorRGB><H1 CLASS="APISYMBOL">mgGetCurrentColorRGB</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetCurrentColorRGB</B> - returns the RGB 
components of the current primary modeling color.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetCurrentColorRGB</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>red</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>green</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>blue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, red, green, blue <B>mgGetCurrentColorRGB</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetCurrentColorRGB</B> returns the <I>red</I>, <I>green</I>, 
and <I>blue</I> components of the current primary modeling color 
selected for database <I>db</I>.  The color values 
returned are in the range 0..255.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>red</I></DT><DD>address of value to receive red component 
of current primary modeling color</DD><DT><I>green</I></DT><DD>address of value to receive green component 
of current primary modeling color</DD><DT><I>blue</I></DT><DD>address of value to receive blue component 
of current primary modeling color</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if RGB components of current primary modeling 
color for <I>db</I> could be determined, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>red</DT><DD>If function is successful, red contains the retrieved red component, otherwise 
red is undefined.</DD><DT>green</DT><DD>If function is successful, green contains the retrieved green component, otherwise 
green is undefined.</DD><DT>blue</DT><DD>If function is successful, blue contains the retrieved blue component, otherwise 
blue is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCurrentColorRGB>mgSetCurrentColorRGB</A>, <A HREF=#mgSetCurrentColor>mgSetCurrentColor</A>, <A HREF=#mgGetCurrentAltColorRGB>mgGetCurrentAltColorRGB</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetCurrentDb><H1 CLASS="APISYMBOL">mgGetCurrentDb</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetCurrentDb</B> - gets the current database.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgrec* <B>mgGetCurrentDb</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>returns the top node of the current database.</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the top node of the current database, <A HREF=#MG_NULL>MG_NULL</A> if there is 
no current database.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCurrentDb>mgSetCurrentDb</A>, <A HREF=#mgRec2Db>mgRec2Db</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetCurrentEyePoint><H1 CLASS="APISYMBOL">mgGetCurrentEyePoint</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetCurrentEyePoint</B> - returns the attributes of the current 
eyepoint.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetCurrentEyePoint</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>eyeRec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetCurrentEyePoint</B> copies the current eyepoint into the eyepoint 
record <I>eyeRec</I>.  <I>eyeRec</I> must have previously been obtained by a call 
to <A HREF=#mgGetNewEyePoint>mgGetNewEyePoint</A></P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>eyeRec</I></DT><DD>the address of the record to 
receive the eyepoint record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
If successful, the attributes of the current eyepoint are copied to the 
output parameter <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltEyePoint>fltEyePoint</A>
 record <I>eyeRec</I>, otherwise 
no attributes are copied.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCurrentEyePoint>mgSetCurrentEyePoint</A>, <A HREF=#mgGetNewEyePoint>mgGetNewEyePoint</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetCurrentGridMatrix><H1 CLASS="APISYMBOL">mgGetCurrentGridMatrix</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetCurrentGridMatrix</B> - gets the current modeling grid 
matrix.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetCurrentGridMatrix</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetCurrentGridMatrix</B> returns a matrix that can be used to 
normalize the position of the grid in the current Creator graphics view. 
This matrix, returned in the output parameter, <I>matrix</I> describes the 
transformation that transforms a coordinate in world space onto the grid 
in its current position and orientation.</P></DD><DD><P>The function <A HREF=#mgMatrixInvert>mgMatrixInvert</A> can be used to obtain the inverse 
of this grid matrix.  This inverse matrix describes the transformation 
that moves the grid from its current position and orientation to the 
database origin aligned with the X and Y axes.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>matrix</I></DT><DD>address of matrix to receive grid matrix</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
If successful, the matrix will be returned in the output parameter <I>matrix</I>, 
otherwise it will be undefined.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCurrentGridPoints>mgGetCurrentGridPoints</A>, <A HREF=#mgSetCurrentGridPoints>mgSetCurrentGridPoints</A>, <A HREF=#mgGetCurrentTrackPlane>mgGetCurrentTrackPlane</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetCurrentGridPoints><H1 CLASS="APISYMBOL">mgGetCurrentGridPoints</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetCurrentGridPoints</B> - gets the current modeling grid 
points.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetCurrentGridPoints</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>origin</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>xAxis</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>third</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, origin, xAxis, third <B>mgGetCurrentGridPoints</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetCurrentGridPoints</B> returns the three points that define the 
location and orientation of the grid in the current Creator graphics view. 
These points are returned in the output parameter, <I>origin</I>, <I>xAxis</I>, and 
<I>third</I> where <I>origin</I> is the origin of the grid, <I>xAxis</I> is a point 
on the x axis of the grid and <I>third</I> is a point that along with <I>origin</I> 
and <I>xAxis</I> define the plane in which the grid is located.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>origin</I></DT><DD>address of 3D coordinate to receive grid origin</DD><DT><I>xAxis</I></DT><DD>address of 3D coordinate to receive x axis point</DD><DT><I>third</I></DT><DD>address of 3D coordinate to receive third point 
on the grid plane</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if RGB components of current primary modeling 
color for <I>db</I> could be determined, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>origin</DT><DD>If function is successful, origin contains the retrieved origin coordinate, otherwise 
origin is undefined.</DD><DT>xAxis</DT><DD>If function is successful, xAxis contains the retrieved xAxis coordinate, otherwise 
xAxis is undefined.</DD><DT>third</DT><DD>If function is successful, third contains the retrieved third coordinate, otherwise 
third is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCurrentGridPoints>mgSetCurrentGridPoints</A>, <A HREF=#mgGetCurrentGridMatrix>mgGetCurrentGridMatrix</A>, <A HREF=#mgGetCurrentTrackPlane>mgGetCurrentTrackPlane</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetCurrentLightPointAnimation><H1 CLASS="APISYMBOL">mgGetCurrentLightPointAnimation</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetCurrentLightPointAnimation</B> - returns index of current 
modeling light point animation.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetCurrentLightPointAnimation</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, index <B>mgGetCurrentLightPointAnimation</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetCurrentLightPointAnimation</B> returns the <I>index</I> of the 
current modeling light point animation selected for database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>address of value to receive index of current 
modeling light point animation.</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if current modeling light point animation for <I>db</I> 
could be determined, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCurrentLightPointAnimation>mgSetCurrentLightPointAnimation</A>, 
<A HREF=#mgGetCurrentLightPointAppearance>mgGetCurrentLightPointAppearance</A>, 
<A HREF=#mgSetCurrentLightPointAppearance>mgSetCurrentLightPointAppearance</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetCurrentLightPointAppearance><H1 CLASS="APISYMBOL">mgGetCurrentLightPointAppearance</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetCurrentLightPointAppearance</B> - returns index of current 
modeling light point appearance.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetCurrentLightPointAppearance</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, index <B>mgGetCurrentLightPointAppearance</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetCurrentLightPointAppearance</B> returns the <I>index</I> of the 
current modeling light point appearance selected for database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>address of value to receive index of current 
modeling light point appearance</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if current modeling light point appearance for <I>db</I> 
could be determined, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCurrentLightPointAppearance>mgSetCurrentLightPointAppearance</A>, 
<A HREF=#mgGetCurrentLightPointAnimation>mgGetCurrentLightPointAnimation</A>, 
<A HREF=#mgSetCurrentLightPointAnimation>mgSetCurrentLightPointAnimation</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetCurrentLightSource><H1 CLASS="APISYMBOL">mgGetCurrentLightSource</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetCurrentLightSource</B> - returns index of current modeling 
light source.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetCurrentLightSource</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, index <B>mgGetCurrentLightSource</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetCurrentLightSource</B> returns the <I>index</I> of the current 
modeling light source selected for database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>address of value to receive index of current 
modeling light source.</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if current modeling light source selected for <I>db</I> 
could be determined, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCurrentLightSource>mgSetCurrentLightSource</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetCurrentLineStyle><H1 CLASS="APISYMBOL">mgGetCurrentLineStyle</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetCurrentLineStyle</B> - returns index of current modeling 
line style.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetCurrentLineStyle</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, index <B>mgGetCurrentLineStyle</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetCurrentLineStyle</B> returns the <I>index</I> of the current 
modeling line style selected for database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>address of value to receive index of current 
modeling line style.</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if current modeling line style selected for <I>db</I> 
could be determined, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCurrentLineStyle>mgSetCurrentLineStyle</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetCurrentLookAt><H1 CLASS="APISYMBOL">mgGetCurrentLookAt</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetCurrentLookAt</B> - returns the current eyepoint in 
"look at" form.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetCurrentLookAt</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>eyex</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>eyey</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>eyez</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>centerx</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>centery</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>centerz</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>upx</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>upy</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>upz</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, eyex, eyey, eyez, centerx, centery, centerz, upx, upy, upz <B>mgGetCurrentLookAt</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetCurrentLookAt</B> returns the current eyepoint using "look at" 
style parameters.  The "look at" parameters include 3 sets of values. 
The first set, <I>eyex</I>, <I>eyey</I>, and <I>eyez</I> is the position of 
the eye point (the "look from"). 
The second set, <I>centerx</I>, <I>centery</I>, <I>centerz</I> is the position 
of the reference point (the "look at"). 
The third set, <I>upx</I>, <I>upy</I>, and <I>upz</I> is the direction of the up vector.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>eyex</I></DT><DD>address of value to receive x component of the eyepoint position</DD><DT><I>eyey</I></DT><DD>address of value to receive y component of the eyepoint position</DD><DT><I>eyez</I></DT><DD>address of value to receive z component of the eyepoint position</DD><DT><I>centerx</I></DT><DD>address of value to receive x component of the reference point</DD><DT><I>centery</I></DT><DD>address of value to receive y component of the reference point</DD><DT><I>centerz</I></DT><DD>address of value to receive z component of the reference point</DD><DT><I>upx</I></DT><DD>address of value to receive i component of the up vector</DD><DT><I>upy</I></DT><DD>address of value to receive j component of the up vector</DD><DT><I>upz</I></DT><DD>address of value to receive k component of the up vector</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if current "look at" selected for <I>db</I> 
could be determined, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>eyex</DT><DD>If function is successful, eyex contains the retrieved eyepoint x, otherwise 
eyex is undefined.</DD><DT>eyey</DT><DD>If function is successful, eyey contains the retrieved eyepoint y, otherwise 
eyey is undefined.</DD><DT>eyez</DT><DD>If function is successful, eyez contains the retrieved eyepoint z, otherwise 
eyez is undefined.</DD><DT>centerx</DT><DD>If function is successful, centerx contains the retrieved reference x, otherwise 
centerx is undefined.</DD><DT>centery</DT><DD>If function is successful, centery contains the retrieved reference y, otherwise 
centery is undefined.</DD><DT>centerz</DT><DD>If function is successful, centerz contains the retrieved reference z, otherwise 
centerz is undefined.</DD><DT>upx</DT><DD>If function is successful, upx contains the retrieved up vector x, otherwise 
upx is undefined.</DD><DT>upy</DT><DD>If function is successful, upy contains the retrieved up vector y, otherwise 
upy is undefined.</DD><DT>upz</DT><DD>If function is successful, upz contains the retrieved up vector z, otherwise 
upz is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCurrentLookAt>mgSetCurrentLookAt</A>, <A HREF=#mgGetEyePointLookAt>mgGetEyePointLookAt</A>, <A HREF=#mgGetGraphicViewLookAt>mgGetGraphicViewLookAt</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetCurrentMaterial><H1 CLASS="APISYMBOL">mgGetCurrentMaterial</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetCurrentMaterial</B> - returns index of current modeling 
material.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetCurrentMaterial</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, index <B>mgGetCurrentMaterial</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetCurrentMaterial</B> returns the <I>index</I> of the current 
modeling material selected for database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>address of value to receive index of current 
modeling material.</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if current modeling material for <I>db</I> 
could be determined, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCurrentMaterial>mgSetCurrentMaterial</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetCurrentShader><H1 CLASS="APISYMBOL">mgGetCurrentShader</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetCurrentShader</B> - returns index of current modeling 
shader.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetCurrentShader</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, index <B>mgGetCurrentShader</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetCurrentShader</B> returns the <I>index</I> of the current 
modeling shader selected for database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>address of value to receive index of current 
modeling shader.</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if current modeling shader for <I>db</I> 
could be determined, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCurrentShader>mgSetCurrentShader</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetCurrentSound><H1 CLASS="APISYMBOL">mgGetCurrentSound</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetCurrentSound</B> - returns index of current modeling 
sound.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetCurrentSound</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetCurrentSound</B> returns the <I>index</I> of the current 
modeling sound selected for database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>address of value to receive index of current 
modeling sound</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if current modeling sound for <I>db</I> 
could be determined, <A HREF=#mgbool>MG_FALSE</A> otherwise.  If successful, the 
corresponding index is returned in the output parameter <I>index</I>, 
otherwise it is undefined.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCurrentSound>mgSetCurrentSound</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetCurrentSubTexture><H1 CLASS="APISYMBOL">mgGetCurrentSubTexture</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetCurrentSubTexture</B> - returns index of current modeling 
subtexture.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetCurrentSubTexture</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, index <B>mgGetCurrentSubTexture</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetCurrentSubTexture</B> returns the <I>index</I> of the current 
modeling subtexture selected for database <I>db</I>.  Subtexture indices are contiguous 
and range from 0..N-1 where N is the value returned by <A HREF=#mgSubTextureCount>mgSubTextureCount</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>address of value to receive index of current 
modeling subtexture.</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if current modeling subtexture for <I>db</I> 
could be determined, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCurrentSubTexture>mgSetCurrentSubTexture</A>, <A HREF=#mgGetCurrentTexture>mgGetCurrentTexture</A>, <A HREF=#mgSetCurrentTexture>mgSetCurrentTexture</A>, 
<A HREF=#mgGetCurrentTextureLayer>mgGetCurrentTextureLayer</A>, <A HREF=#mgSetCurrentTextureLayer>mgSetCurrentTextureLayer</A>, 
<A HREF=#mgGetCurrentTextureMapping>mgGetCurrentTextureMapping</A>, <A HREF=#mgSetCurrentTextureMapping>mgSetCurrentTextureMapping</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetCurrentTexture><H1 CLASS="APISYMBOL">mgGetCurrentTexture</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetCurrentTexture</B> - returns index of current modeling 
texture.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetCurrentTexture</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, index <B>mgGetCurrentTexture</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetCurrentTexture</B> returns the <I>index</I> of the current 
modeling texture selected for database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>address of value to receive index of current 
modeling texture.</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if current modeling texture for <I>db</I> 
could be determined, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCurrentTexture>mgSetCurrentTexture</A>, <A HREF=#mgGetCurrentSubTexture>mgGetCurrentSubTexture</A>, <A HREF=#mgSetCurrentSubTexture>mgSetCurrentSubTexture</A>, 
<A HREF=#mgGetCurrentTextureLayer>mgGetCurrentTextureLayer</A>, <A HREF=#mgSetCurrentTextureLayer>mgSetCurrentTextureLayer</A>, 
<A HREF=#mgGetCurrentTextureMapping>mgGetCurrentTextureMapping</A>, <A HREF=#mgSetCurrentTextureMapping>mgSetCurrentTextureMapping</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetCurrentTextureLayer><H1 CLASS="APISYMBOL">mgGetCurrentTextureLayer</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetCurrentTextureLayer</B> - returns the current 
modeling texture layer.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetCurrentTextureLayer</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>layer</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, index <B>mgGetCurrentTextureLayer</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetCurrentTextureLayer</B> returns the modeling texture layer 
selected by the user for the current graphics view of database <I>db</I>. 
If a specific layer is selected, then this layer number, 0-7 (0 is 
the base texture layer) is&#32returned.  If "Blend" is selected, a value 
of -1 is returned.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>layer</I></DT><DD>address of value to receive layer number</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if current modeling texture layer (0-7 or -1 for "Blend") for <I>db</I> 
could be determined, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCurrentTextureLayer>mgSetCurrentTextureLayer</A>, <A HREF=#mgGetCurrentTexture>mgGetCurrentTexture</A>, <A HREF=#mgSetCurrentTexture>mgSetCurrentTexture</A>, 
<A HREF=#mgGetCurrentSubTexture>mgGetCurrentSubTexture</A>, <A HREF=#mgSetCurrentSubTexture>mgSetCurrentSubTexture</A>, 
<A HREF=#mgGetCurrentTextureMapping>mgGetCurrentTextureMapping</A>, <A HREF=#mgSetCurrentTextureMapping>mgSetCurrentTextureMapping</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetCurrentTextureMapping><H1 CLASS="APISYMBOL">mgGetCurrentTextureMapping</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetCurrentTextureMapping</B> - returns index of current modeling 
texture mapping.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetCurrentTextureMapping</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, index <B>mgGetCurrentTextureMapping</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetCurrentTextureMapping</B> returns the <I>index</I> of the current 
modeling texture mapping selected for database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>address of value to receive index of current 
modeling texture mapping</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if current modeling texture mapping for <I>db</I> 
could be determined, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCurrentTextureMapping>mgSetCurrentTextureMapping</A>, <A HREF=#mgGetCurrentTexture>mgGetCurrentTexture</A>, <A HREF=#mgSetCurrentTexture>mgSetCurrentTexture</A>, 
<A HREF=#mgGetCurrentSubTexture>mgGetCurrentSubTexture</A>, <A HREF=#mgSetCurrentSubTexture>mgSetCurrentSubTexture</A> 
<A HREF=#mgGetCurrentTextureLayer>mgGetCurrentTextureLayer</A>, <A HREF=#mgSetCurrentTextureLayer>mgSetCurrentTextureLayer</A>,</DD></DL>
<HR>
<LEFT><A NAME=mgGetCurrentTrackPlane><H1 CLASS="APISYMBOL">mgGetCurrentTrackPlane</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetCurrentTrackPlane</B> - gets the current modeling trackplane.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetCurrentTrackPlane</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgplaned>mgplaned*</A></TD><TD><I>trackplane</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, trackplane <B>mgGetCurrentTrackPlane</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetCurrentTrackPlane</B> returns the equation of the current modeling 
trackplane in a <A HREF=#mgplaned>mgplaned</A> structure.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>trackplane</I></DT><DD>the current track plane equation</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if current modeling trackplane for <I>db</I> 
could be determined, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>trackplane</DT><DD>If function is successful, trackplane contains the retrieved track plane equation, otherwise 
trackplane is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCurrentGridMatrix>mgGetCurrentGridMatrix</A>, <A HREF=#mgGetCurrentGridPoints>mgGetCurrentGridPoints</A>, <A HREF=#mgSetCurrentGridPoints>mgSetCurrentGridPoints</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetCursorHandle><H1 CLASS="APISYMBOL">mgGetCursorHandle</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetCursorHandle</B> - returns a native cursor handle.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcursorhandle <B>mgGetCursorHandle</B> (</TD><TD><A HREF=#mgcursor>mgcursor</A></TD><TD><I>cursor</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given an abstract <I>cursor</I>, this function returns 
a platform specific handle to the cursor in its native format.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>cursor</I></DT><DD>abstract cursor to extract native form</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>On Windows, this function returns an object of type HCURSOR.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgLoadResource>mgLoadResource</A>, <A HREF=#mgResourceGetCursor>mgResourceGetCursor</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetDbOnDesktop><H1 CLASS="APISYMBOL">mgGetDbOnDesktop</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetDbOnDesktop</B> - gets the database associated with 
an OpenFlight file open on the Creator desktop.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetDbOnDesktop</B> (</TD><TD>const char*</TD><TD><I>fileName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetDbOnDesktop</B> gets the database record associated with the 
OpenFlight file <I>fileName</I> if that file is open on the Creator desktop.</P></DD><DD><P>Note: This function is only applicable in the Creator modeler environment 
and will always return <A HREF=#mgbool>MG_NULL</A> when called by a stand-alone application.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>fileName</I></DT><DD>the name of the file to check</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns database open on desktop if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgIsDbOnDesktop>mgIsDbOnDesktop</A>, <A HREF=#mgIsFileOnDesktop>mgIsFileOnDesktop</A>, <A HREF=#mgIsDbUntitled>mgIsDbUntitled</A>, <A HREF=#mgIsDbModified>mgIsDbModified</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetDbVersion><H1 CLASS="APISYMBOL">mgGetDbVersion</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetDbVersion</B> - gets the OpenFlight version number of a file.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgGetDbVersion</B> (</TD><TD>const char*</TD><TD><I>fileName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a file name, <B>mgGetDbVersion</B> returns the OpenFlight version 
number if the specified file has a valid format, 0 otherwise.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>fileName</I></DT><DD>the name of the file to be queried</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the OpenFlight version number if the specified file 
has a valid format, 0 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgOpenDb>mgOpenDb</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetDefaultModelingParent><H1 CLASS="APISYMBOL">mgGetDefaultModelingParent</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetDefaultModelingParent</B> - returns default modeling parent.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetDefaultModelingParent</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetDefaultModelingParent</B> returns the default modeling parent node 
for the specified database <I>db</I>.</P></DD><DD><P>In Creator, the user specifies whether or not the default parent 
is allowed for modeling (this is set on the Preferences Window in Creator). 
If it is allowed, the default parent is always a node of type <B>fltGroup</B>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database to get modeling parent for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the default modeling parent node for database <I>db</I> if this is 
allowed by the user,&#32<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetActivationDb>mgGetActivationDb</A>, 
<A HREF=#mgGetModelingMode>mgGetModelingMode</A>, <A HREF=#mgSetModelingMode>mgSetModelingMode</A>, <A HREF=#mgIsModelingModeEdge>mgIsModelingModeEdge</A>, <A HREF=#mgSetModelingModeEdge>mgSetModelingModeEdge</A>, 
<A HREF=#mgGetModelingParent>mgGetModelingParent</A>, <A HREF=#mgGetModelingParentMatrix>mgGetModelingParentMatrix</A>, <A HREF=#mgSetModelingParent>mgSetModelingParent</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetExtRec><H1 CLASS="APISYMBOL">mgGetExtRec</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetExtRec</B> - gets pointer to one of a record's tag-along 
extension records.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetExtRec</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>rcode</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetExtRec</B> returns the tag-along extension record 
identified by <I>rcode</I> attached to <I>rec</I>.  Use this function to 
retrieve a tag-along extension record that may or may not be attached 
to <I>rec</I>. Use <A HREF=#mgGetAttRec>mgGetAttRec</A> to retrieve a nested attribute record.</P></DD><DD><P>This function is useful to resolve field name ambiguity caused 
by multiple tag-along extension records containing common field names. 
For example, consider an OpenFlight data extension that defines two 
tag-along extension records for <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltGroup>fltGroup</A>
, <B>myExt1</B> and <B>myExt2</B>. 
In turn, each of these tag-along extension records contains a field 
named <B>myIntField</B>.  Given any <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltGroup>fltGroup</A>
 node, referencing field 
<B>myIntField</B> using <A HREF=#mgGetAttList>mgGetAttList</A> or <A HREF=#mgSetAttList>mgSetAttList</A> is ambiguous 
since both <B>myExt1</B> and <B>myExt2</B> contain fields by that name.  The 
example below shows how to resolve this ambiguity when accessing 
these nested values.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>points to the record that may or 
may not have a tag-along extension record 
attached</DD><DT><I>rcode</I></DT><DD>the tag-along extension record code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the tag-along extension record pointer if found, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows two techniques for getting the value 
of the field <B>myIntField</B> from a tag-along extension record 
attached to <B>groupRec</B>.  The first technique leads to undefined 
results because it is not clear which tag-along extension record 
containing <B>myIntField</B> to use.  The second technique uses 
<B>mgGetExtRec</B> to resolve the ambiguity.</DT><DT><PRE CLASS="EXAMPLE">mgrec* groupRec;
mgrec* extRec;
int fieldVal;

// this call to mgGetAttList is ambiguous
mgGetAttList (groupRec, myIntField, &fieldVal, MG_NULL);

// this call to mgGetAttList is not ambiguous
extRec = mgGetExtRec (groupRec, myExt1);
if (extRec)
   mgGetAttList (extRec, myIntField, &fieldVal, MG_NULL);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetAttList>mgGetAttList</A>, <A HREF=#mgGetAttRec>mgGetAttRec</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetEyePoint><H1 CLASS="APISYMBOL">mgGetEyePoint</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetEyePoint</B> - gets an eyepoint record from the database<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetEyePoint</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetEyePoint</B> gets the eyepoint record defined by <I>index</I> 
from the database <I>db</I>, <I>index</I> must be between 1 and 9. 
Eyepoint 0 is reserved for use by MultiGen.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the eyepoint to get</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the eyepoint record if successful, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetEyePoint>mgSetEyePoint</A>, <A HREF=#mgSetAttList>mgSetAttList</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetEyePointLookAt><H1 CLASS="APISYMBOL">mgGetEyePointLookAt</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetEyePointLookAt</B> - converts an eyepoint to 
"look at" form.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetEyePointLookAt</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>eyeRec</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>eyex</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>eyey</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>eyez</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>centerx</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>centery</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>centerz</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>upx</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>upy</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>upz</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, eyex, eyey, eyez, centerx, centery, centerz, upx, upy, upz <B>mgGetEyePointLookAt</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>eyeRec</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetEyePointLookAt</B> converts the specified eyepoint <I>eyeRec</I> 
to "look at" style parameters.  The "look at" parameters include 
3 sets of values.  The first set, <I>eyex</I>, <I>eyey</I>, and <I>eyez</I> 
is the position of the eye point (the "look from"). 
The second set, <I>centerx</I>, <I>centery</I>, <I>centerz</I> is the position 
of the reference point (the "look at"). 
The third set, <I>upx</I>, <I>upy</I>, and <I>upz</I> is the direction of the 
up vector.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>eyeRec</I></DT><DD>the eyepoint</DD><DT><I>eyex</I></DT><DD>address of value to receive x component of the eyepoint position</DD><DT><I>eyey</I></DT><DD>address of value to receive y component of the eyepoint position</DD><DT><I>eyez</I></DT><DD>address of value to receive z component of the eyepoint position</DD><DT><I>centerx</I></DT><DD>address of value to receive x component of the reference point</DD><DT><I>centery</I></DT><DD>address of value to receive y component of the reference point</DD><DT><I>centerz</I></DT><DD>address of value to receive z component of the reference point</DD><DT><I>upx</I></DT><DD>address of value to receive i component of the up vector</DD><DT><I>upy</I></DT><DD>address of value to receive j component of the up vector</DD><DT><I>upz</I></DT><DD>address of value to receive k component of the up vector</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>eyex</DT><DD>If function is successful, eyex contains the retrieved eyepoint x, otherwise 
eyex is undefined.</DD><DT>eyey</DT><DD>If function is successful, eyey contains the retrieved eyepoint y, otherwise 
eyey is undefined.</DD><DT>eyez</DT><DD>If function is successful, eyez contains the retrieved eyepoint z, otherwise 
eyez is undefined.</DD><DT>centerx</DT><DD>If function is successful, centerx contains the retrieved reference x, otherwise 
centerx is undefined.</DD><DT>centery</DT><DD>If function is successful, centery contains the retrieved reference y, otherwise 
centery is undefined.</DD><DT>centerz</DT><DD>If function is successful, centerz contains the retrieved reference z, otherwise 
centerz is undefined.</DD><DT>upx</DT><DD>If function is successful, upx contains the retrieved up vector x, otherwise 
upx is undefined.</DD><DT>upy</DT><DD>If function is successful, upy contains the retrieved up vector y, otherwise 
upy is undefined.</DD><DT>upz</DT><DD>If function is successful, upz contains the retrieved up vector z, otherwise 
upz is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCurrentLookAt>mgGetCurrentLookAt</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetFirstInstance><H1 CLASS="APISYMBOL">mgGetFirstInstance</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetFirstInstance</B> - gets the first instance node of a reference node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetFirstInstance</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>ref</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Instancing is a technique in which one node is a child of several parent nodes. 
The child is said to be a <B>reference</B> node and each parent node is an <B>instance</B> node 
of the child. A parent node can have either a regular child or a reference child, but 
not both.</P></DD><DD><P><B>mgGetFirstInstance</B> returns the first instance node of the specified 
reference node <I>ref</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>ref</I></DT><DD>the reference node to get first instance for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the first instance node of the reference node, if found.  If <I>ref</I> is not 
a reference node, <A HREF=#MG_NULL>MG_NULL</A> is returned.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* ref;
mgrec* inst;
inst = mgGetFirstInstance (ref);
while (inst) {
   // Do something with inst
   inst = mgGetNextInstance (inst);
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgIsFirstInstance>mgIsFirstInstance</A>, <A HREF=#mgGetNextInstance>mgGetNextInstance</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetFirstLightPointAnimation><H1 CLASS="APISYMBOL">mgGetFirstLightPointAnimation</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetFirstLightPointAnimation</B> - gets the first entry in 
a light point animation palette.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetFirstLightPointAnimation</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec, index <B>mgGetFirstLightPointAnimation</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetFirstLightPointAnimation</B> gets the first entry contained 
in the light point animation palette for database <I>db</I>.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLpAnimationPalette>fltLpAnimationPalette</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>address of value to receive index of entry 
returned</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgrec</DT><DD>The first light point animation entry record, or <A HREF=#MG_NULL>MG_NULL</A> 
if no light point animations in palette.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example gets the first and next light point animation palette entries 
for database <I>db</I>.</DT><DT><PRE CLASS="EXAMPLE">mgrec* thisEntry;
mgrec* nextEntry;
int index;
thisEntry = mgGetFirstLightPointAnimation (db, &index);
nextEntry = mgGetNextLightPointAnimation (thisEntry, &index);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetLightPointAppearance>mgGetLightPointAppearance</A>, 
<A HREF=#mgGetLightPointAppearanceCount>mgGetLightPointAppearanceCount</A>, 
<A HREF=#mgIndexOfLightPointAppearance>mgIndexOfLightPointAppearance</A>, 
<A HREF=#mgNameOfLightPointAppearance>mgNameOfLightPointAppearance</A>, 
<A HREF=#mgGetNextLightPointAppearance>mgGetNextLightPointAppearance</A>, 
<A HREF=#mgGetLightPointAnimation>mgGetLightPointAnimation</A>, 
<A HREF=#mgGetLightPointAnimationCount>mgGetLightPointAnimationCount</A>, 
<A HREF=#mgIndexOfLightPointAnimation>mgIndexOfLightPointAnimation</A>, 
<A HREF=#mgNameOfLightPointAnimation>mgNameOfLightPointAnimation</A>, 
<A HREF=#mgGetNextLightPointAnimation>mgGetNextLightPointAnimation</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetFirstLightPointAppearance><H1 CLASS="APISYMBOL">mgGetFirstLightPointAppearance</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetFirstLightPointAppearance</B> - gets the first entry in 
a light point appearance palette.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetFirstLightPointAppearance</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec, index <B>mgGetFirstLightPointAppearance</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetFirstLightPointAppearance</B> gets the first entry contained 
in the light point appearance palette for database <I>db</I>.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLpAppearancePalette>fltLpAppearancePalette</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>address of value to receive index of entry 
returned</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgrec</DT><DD>The first light point appearance entry record, or <A HREF=#MG_NULL>MG_NULL</A> 
if no light point appearances in palette.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example gets the first and next light point appearance palette entries 
for database <I>db</I>.</DT><DT><PRE CLASS="EXAMPLE">mgrec* thisEntry;
mgrec* nextEntry;
int index;
thisEntry = mgGetFirstLightPointAppearance (db, &index);
nextEntry = mgGetNextLightPointAppearance (thisEntry, &index);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetLightPointAppearance>mgGetLightPointAppearance</A>, 
<A HREF=#mgGetLightPointAppearanceCount>mgGetLightPointAppearanceCount</A>, 
<A HREF=#mgIndexOfLightPointAppearance>mgIndexOfLightPointAppearance</A>, 
<A HREF=#mgNameOfLightPointAppearance>mgNameOfLightPointAppearance</A>, 
<A HREF=#mgGetNextLightPointAppearance>mgGetNextLightPointAppearance</A>, 
<A HREF=#mgGetLightPointAnimation>mgGetLightPointAnimation</A>, 
<A HREF=#mgGetLightPointAnimationCount>mgGetLightPointAnimationCount</A>, 
<A HREF=#mgIndexOfLightPointAnimation>mgIndexOfLightPointAnimation</A>, 
<A HREF=#mgNameOfLightPointAnimation>mgNameOfLightPointAnimation</A>, 
<A HREF=#mgGetFirstLightPointAnimation>mgGetFirstLightPointAnimation</A>, 
<A HREF=#mgGetNextLightPointAnimation>mgGetNextLightPointAnimation</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetFirstLightSource><H1 CLASS="APISYMBOL">mgGetFirstLightSource</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetFirstLightSource</B> - gets the first entry record 
from a database&#146s light source palette.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetFirstLightSource</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec, index <B>mgGetFirstLightSource</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a database node <I>db</I>, <B>mgGetFirstLightSource</B> gets the 
database&#146s first light source entry record. If successful, the record is 
returned.  If unsuccessful, <A HREF=#MG_NULL>MG_NULL</A> is returned. The index of the light 
source in the palette is returned in index.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLightSourcePalette>fltLightSourcePalette</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>address of value to receive index of entry 
returned</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgrec</DT><DD>The first light source entry record, or <A HREF=#MG_NULL>MG_NULL</A> 
if no light sources in palette.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* lightSource;
mgrec* db;
int index;
db = mgOpenDb ("anyfile.flt");
lightSource = mgGetFirstLightSource (db, &index);
while (lightSource != MG_NULL) {
   // do something with lightSource
   lightSource = mgGetNextLightSource (lightSource, &index);
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetLightSource>mgGetLightSource</A>, <A HREF=#mgGetNextLightSource>mgGetNextLightSource</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetFirstLineStyle><H1 CLASS="APISYMBOL">mgGetFirstLineStyle</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetFirstLineStyle</B> - gets the first entry record 
from a database&#146s line style palette.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetFirstLineStyle</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec, index <B>mgGetFirstLineStyle</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a database node <I>db</I>, <B>mgGetFirstLineStyle</B> gets the 
database&#146s first line style entry record. If successful, the record is 
returned.  If unsuccessful, <A HREF=#MG_NULL>MG_NULL</A> is returned. The index of the light 
source in the palette is returned in index.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLineStylePalette>fltLineStylePalette</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>address of value to receive index of entry 
returned</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgrec</DT><DD>The first line style entry record, or <A HREF=#MG_NULL>MG_NULL</A> 
if no line styles in palette.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* lineStyle;
mgrec* db;
int index;
db = mgOpenDb ("anyfile.flt");
lineStyle = mgGetFirstLineStyle (db, &index);
while (lineStyle != MG_NULL) {
   // do something with lineStyle
   lineStyle = mgGetNextLineStyle (lineStyle, &index);
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetLineStyle>mgGetLineStyle</A>, <A HREF=#mgGetNextLineStyle>mgGetNextLineStyle</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetFirstMaterial><H1 CLASS="APISYMBOL">mgGetFirstMaterial</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetFirstMaterial</B> - gets the first entry from a 
database&#146s material palette.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetFirstMaterial</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec, index <B>mgGetFirstMaterial</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a database node <I>db</I>, <B>mgGetFirstMaterial</B> gets the 
first entry record from the database&#146s material palette. 
The index of the material record is returned in  <I>index</I>.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltFMaterial>fltFMaterial</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the returned index of the material 
palette entry record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgrec</DT><DD>The first material palette entry in the database&#146s 
material palette, <A HREF=#MG_NULL>MG_NULL</A> if no material in palette.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetNextMaterial>mgGetNextMaterial</A>, <A HREF=#mgGetMaterialCount>mgGetMaterialCount</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetFirstSelectedTexture><H1 CLASS="APISYMBOL">mgGetFirstSelectedTexture</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetFirstSelectedTexture</B> - gets the first selected entry 
in a texture palette.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetFirstSelectedTexture</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>textureName</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, index, name <B>mgGetFirstSelectedTexture</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetFirstSelectedTexture</B> get the index and name of the first 
selected texture contained in the texture palette of database <I>db</I>.</P></DD><DD><P>If you pass <A HREF=#MG_NULL>MG_NULL</A> for <I>textureName</I>, the name of the texture is 
not returned.  If you do pass a character string for <I>textureName</I>, the buffer 
should be at least 1024 characters.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>address of value to receive index</DD><DT><I>textureName</I></DT><DD>address of string to receive texture name</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the texture palette entry is found, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD><DT>name</DT><DD>If function is successful, name contains the retrieved name, otherwise 
name is undefined.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example traverses all the selected texture palette entries 
for database <I>db</I>.</DT><DT><PRE CLASS="EXAMPLE">mgbool gotOne;
int index;
char name[1024];

gotOne = mgGetFirstSelectedTexture (db, &index, name);
while (gotOne == MG_TRUE)
{
   // do something with texture palette entry
   gotOne = mgGetNextSelectedTexture (db, &index, name);
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT>The following example traverses all the selected texture palette entries 
for database <I>db</I>.</DT><DT><PRE CLASS="EXAMPLE">gotOne,index,name = mgGetFirstSelectedTexture (db)
while (gotOne == MG_TRUE):
   # do something with texture palette entry
   gotOne,index,name = mgGetNextSelectedTexture (db)</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSelectTextureIndex>mgSelectTextureIndex</A>, 
<A HREF=#mgDeselectTextureIndex>mgDeselectTextureIndex</A>, 
<A HREF=#mgDeselectAllTextures>mgDeselectAllTextures</A>, 
<A HREF=#mgGetNextSelectedTexture>mgGetNextSelectedTexture</A>, 
<A HREF=#mgGetSelectedTextureCount>mgGetSelectedTextureCount</A>, 
<A HREF=#mgIsTextureIndexSelected>mgIsTextureIndexSelected</A>, 
<A HREF=#mgGetFirstTexture>mgGetFirstTexture</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetFirstShader><H1 CLASS="APISYMBOL">mgGetFirstShader</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetFirstShader</B> - gets the first entry from a 
database&#146s shader palette.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetFirstShader</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec, index <B>mgGetFirstShader</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a database node <I>db</I>, <B>mgGetFirstShader</B> gets the 
first entry record from the database&#146s shader palette. 
The index of the shader record is returned in  <I>index</I>. 
If the first shader entry record is found, it is returned. 
If it is not found, <A HREF=#MG_NULL>MG_NULL</A> is returned.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltShaderPalette>fltShaderPalette</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>address of value to receive palette index of entry returned, -1 if none</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgrec</DT><DD>The first shader palette entry in the database&#146s 
material palette, <A HREF=#MG_NULL>MG_NULL</A> if no shaders in palette.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetShaderCount>mgGetShaderCount</A>, <A HREF=#mgGetNextShader>mgGetNextShader</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetFirstSound><H1 CLASS="APISYMBOL">mgGetFirstSound</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetFirstSound</B> - gets the first sound entry 
from a database&#146s sound palette.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetFirstSound</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec, index <B>mgGetFirstSound</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a database node <I>db</I>, <B>mgGetFirstSound</B> gets the 
database&#146s first sound entry record.  The index of the sound record 
in the palette is returned in <I>index</I>, if there is one.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSoundPalette>fltSoundPalette</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>address of value to receive palette index of entry returned, -1 if none</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgrec</DT><DD>The first sound palette entry in the database&#146s 
sound palette, <A HREF=#MG_NULL>MG_NULL</A> if no sounds in palette.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* sound;
mgrec* next;
mgrec* db;
int index;
db = mgNewDb ("newfile.flt");
sound = mgGetFirstSound (db, index);
next = mgGetNextSound (sound, index);</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetSound>mgGetSound</A>, <A HREF=#mgGetNextSound>mgGetNextSound</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetFirstTexture><H1 CLASS="APISYMBOL">mgGetFirstTexture</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetFirstTexture</B> - gets the first entry in a texture palette.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetFirstTexture</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>textureName</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, index, name <B>mgGetFirstTexture</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetFirstTexture</B> gets the index and name of the first texture 
contained in the texture palette of database <I>db</I>.</P></DD><DD><P>If the texture was located when it was loaded, the <I>textureName</I> 
includes the full path specification of the file where it was found 
on disk.  If the texture was not located at load time, the <I>textureName</I> 
returned by this function will be the same name returned by 
<A HREF=#mgGetTextureSaveName>mgGetTextureSaveName</A>.</P></DD><DD><P>If you pass <A HREF=#MG_NULL>MG_NULL</A> for <I>index</I>, the index of the texture is not returned.</P></DD><DD><P>If you pass <A HREF=#MG_NULL>MG_NULL</A> for <I>textureName</I>, the name of the texture is 
not returned.  If you do pass a character string for <I>textureName</I>, the buffer 
should be at least 1024 characters.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>address of value to receive index</DD><DT><I>textureName</I></DT><DD>address of string to receive texture name</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the first texture palette entry is found, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD><DT>name</DT><DD>If function is successful, name contains the retrieved name, otherwise 
name is undefined.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example traverses all the texture palette entries for 
database <I>db</I>.</DT><DT><PRE CLASS="EXAMPLE">mgbool gotOne;
int index;
char name[1024];

gotOne = mgGetFirstTexture (db, &index, name);
while (gotOne == MG_TRUE)
{
   // do something with texture palette entry
   gotOne = mgGetNextTexture (db, &index, name);
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT>The following example traverses all the texture palette entries for 
database <I>db</I>.</DT><DT><PRE CLASS="EXAMPLE">gotOne,index,name = mgGetFirstTexture (db)
while (gotOne == MG_TRUE):
   # do something with texture palette entry
   gotOne,index,name = mgGetNextTexture (db)</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetNextTexture>mgGetNextTexture</A>, <A HREF=#mgGetTextureCount>mgGetTextureCount</A>, 
<A HREF=#mgGetSelectedTextureCount>mgGetSelectedTextureCount</A>, <A HREF=#mgGetFirstSelectedTexture>mgGetFirstSelectedTexture</A>, 
<A HREF=#mgGetNextSelectedTexture>mgGetNextSelectedTexture</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetFirstTextureMapping><H1 CLASS="APISYMBOL">mgGetFirstTextureMapping</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetFirstTextureMapping</B> - gets the first texture 
mapping in a database&#146s palette.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetFirstTextureMapping</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>textureMappingName</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, index, name <B>mgGetFirstTextureMapping</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetFirstTextureMapping</B> gets the index and name of the first 
texture mapping in a database&#146s palette.</P></DD><DD><P>If you pass <A HREF=#MG_NULL>MG_NULL</A> for <I>index</I>, the index of the texture mapping 
palette entry is not returned.</P></DD><DD><P>If you pass <A HREF=#MG_NULL>MG_NULL</A> for <I>textureMappingName</I>, the name of the texture 
mapping palette entry is not returned.  If you do pass a character string for 
<I>textureMappingName</I>, the buffer&#32should be at least 20 characters.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>address of value to receive palette index of entry returned, -1 if none</DD><DT><I>textureMappingName</I></DT><DD>address of string to receive texture mapping name</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the first texture mapping palette entry is found, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD><DT>name</DT><DD>If function is successful, name contains the retrieved name, otherwise 
name is undefined.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>This example traverses all the texture mapping entries for database <I>db</I>.</DT><DT><PRE CLASS="EXAMPLE">mgbool gotOne;
int index;
char name [200];

gotOne = mgGetFirstTextureMapping (db, &index, name);
while (gotOne == MG_TRUE) {
   // Do something with the texture mapping
   gotOne = mgGetNextTextureMapping (db, &index, name);
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT>This example traverses all the texture mapping entries for database <I>db</I>.</DT><DT><PRE CLASS="EXAMPLE">gotOne,index,name = mgGetFirstTextureMapping (db)
while (gotOne == MG_TRUE):
   // Do something with the texture mapping
   gotOne,index,name = mgGetNextTextureMapping (db)</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetNextTextureMapping>mgGetNextTextureMapping</A>, <A HREF=#mgGetTextureMappingCount>mgGetTextureMappingCount</A>, <A HREF=#mgGetTextureMappingName>mgGetTextureMappingName</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetFocusVertex><H1 CLASS="APISYMBOL">mgGetFocusVertex</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetFocusVertex</B> - get the current focus vertex.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetFocusVertex</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetFocusVertex</B> gets the current focus vertex associated 
to the specified editor context, <I>editorContext</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context used to identify 
the database for which the focus vertex 
is to be returned</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns current focus vertex node if set, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgEditorSetFocusVertexFunc>mgEditorSetFocusVertexFunc</A>, <A HREF=#mgFocusVertexListAddItem>mgFocusVertexListAddItem</A>, 
<A HREF=#mgSetFocusVertex>mgSetFocusVertex</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetGraphicViewLookAt><H1 CLASS="APISYMBOL">mgGetGraphicViewLookAt</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetGraphicViewLookAt</B> - returns the eyepoint of a graphic 
view in "look at" form.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetGraphicViewLookAt</B> (</TD><TD><A HREF=#mggraphicview>mggraphicview</A></TD><TD><I>graphicView</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>eyex</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>eyey</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>eyez</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>centerx</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>centery</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>centerz</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>upx</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>upy</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>upz</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetGraphicViewLookAt</B> returns the eyepoint of the graphic view 
<I>graphicView</I> using "look at" style parameters.  The "look at" parameters 
include 3 sets of values. 
The first set, <I>eyex</I>, <I>eyey</I>, and <I>eyez</I> is the position of 
the eye point (the "look from"). 
The second set, <I>centerx</I>, <I>centery</I>, <I>centerz</I> is the position 
of the reference point (the "look at"). 
The third set, <I>upx</I>, <I>upy</I>, and <I>upz</I> is the direction of the up vector.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>graphicView</I></DT><DD>the graphic view</DD><DT><I>eyex</I></DT><DD>the x component of the eyepoint position</DD><DT><I>eyey</I></DT><DD>the y component of the eyepoint position</DD><DT><I>eyez</I></DT><DD>the z component of the eyepoint position</DD><DT><I>centerx</I></DT><DD>the x component of the reference point</DD><DT><I>centery</I></DT><DD>the y component of the reference point</DD><DT><I>centerz</I></DT><DD>the z component of the reference point</DD><DT><I>upx</I></DT><DD>the i component of the up vector</DD><DT><I>upy</I></DT><DD>the j component of the up vector</DD><DT><I>upz</I></DT><DD>the k component of the up vector</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCurrentLookAt>mgGetCurrentLookAt</A>, <A HREF=#mgSetCurrentLookAt>mgSetCurrentLookAt</A>, <A HREF=#mgGetEyePointLookAt>mgGetEyePointLookAt</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetGuiHandle><H1 CLASS="APISYMBOL">mgGetGuiHandle</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetGuiHandle</B> - return a native GUI handle.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgguihandle <B>mgGetGuiHandle</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>gui</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetGuiHandle</B> returns a platform specific handle to the specified 
dialog or control <I>gui</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>gui</I></DT><DD>abstract dialog or control to get native handle for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>On Windows, this function returns an object of type HWND.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgFindGuiById>mgFindGuiById</A>, <A HREF=#mgResourceGetDialog>mgResourceGetDialog</A></DD></DL>
<HR>
<LEFT><A NAME=mggetheadercodefunc><H1 CLASS="APISYMBOL">mggetheadercodefunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mggetheadercodefunc</B> - Get Header Code function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool (*<B>mggetheadercodefunc</B>) ( <TD><A HREF=#mgrec>mgrec*</A> <TD><I>db</I>, 
<TR><TD></TD><TD><A HREF=#mgcode>mgcode*</A> <TD><I>code</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for get header code (extension node helper) 
functions. 
If your data extension declares one or more new node types, assign 
a get header code function to your data extension of this form.</P></DD><DD><P>Get header code functions are called when nodes of your new type 
are created and are responsible for returning the record code corresponding 
to your header extension record.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database into which the new node was created</DD><DT><I>code</I></DT><DD>address of value to receive record code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Return <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
If successful, the function returns the record code in the output 
parameter, <I>code</I>.
</DD></DL><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterSite>mgRegisterSite</A>, <A HREF=#mggetmaxidfunc>mggetmaxidfunc</A>, <A HREF=#mggetheadercodefunc>mggetheadercodefunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetImageRowWidth><H1 CLASS="APISYMBOL">mgGetImageRowWidth</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetImageRowWidth</B> - gets the padded width of an image row.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgGetImageRowWidth</B> (</TD><TD>int</TD><TD><I>width</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>sampleSize</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>type</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>pad</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>paddedWidth, padSize <B>mgGetImageRowWidth</B> (</TD><TD>int</TD><TD><I>width</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>sampleSize</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>type</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><A HREF=#mgGetTextureSize>mgGetTextureSize</A> is a convenience function which computes the padded 
width of an image row.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>width</I></DT><DD>the unpadded width of the image</DD><DT><I>sampleSize</I></DT><DD>the number of bits per texel per channel</DD><DT><I>type</I></DT><DD>the image type</DD><DT><I>pad</I></DT><DD>address of value to receive pad value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>paddedWidth</DT><DD>The padded width (in bytes).</DD><DT>padSize</DT><DD>The pad size (in bytes).</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadImageInfo>mgReadImageInfo</A>, <A HREF=#mgGetTextureWidth>mgGetTextureWidth</A>, 
<A HREF=#mgGetTextureType>mgGetTextureType</A>, <A HREF=#mgGetTextureSampleSize>mgGetTextureSampleSize</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetLastError><H1 CLASS="APISYMBOL">mgGetLastError</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetLastError</B> - retrieves the text of the last reported 
message.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetLastError</B> (</TD><TD>char*</TD><TD><I>message</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maxLen</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, string <B>mgGetLastError</B> (  )
</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>The text of every message generated by a call to <A HREF=#mgSendMessage>mgSendMessage</A>, 
<A HREF=#mgSendStatus>mgSendStatus</A>, <A HREF=#mgSendWarning>mgSendWarning</A>, and <A HREF=#mgSendError>mgSendError</A> 
is saved until the next call, and can be retrieved by <B>mgGetLastError</B>.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>A copy of the message is stored in <I>message</I>, up to the length 
defined by <I>maxLen</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>message</I></DT><DD>character buffer to hold the message retrieved</DD><DT><I>maxLen</I></DT><DD>maximum number of characters to store in <I>message</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if last error message retrieved successfully, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>string</DT><DD>If function is successful, string contains the message, otherwise undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSendMessage>mgSendMessage</A>, <A HREF=#mgSendStatus>mgSendStatus</A>, <A HREF=#mgSendWarning>mgSendWarning</A>, <A HREF=#mgSendError>mgSendError</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetLicenseCustomerID><H1 CLASS="APISYMBOL">mgGetLicenseCustomerID</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetLicenseCustomerID</B> - gets the customer id associated 
with a license.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char* <B>mgGetLicenseCustomerID</B> (</TD><TD><A HREF=#mglicense>mglicense</A></TD><TD><I>license</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetLicenseCustomerID</B> gets the customer id associated with 
a license that has been previously checked out using <A HREF=#mgCheckoutLicense>mgCheckoutLicense</A>.</P></DD><DD><P>The character string returned is a dynamically allocated copy of 
the customer id.  It is the responsibility of the caller to deallocate 
this string when it is no longer needed using the function <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>license</I></DT><DD>the license to get the customer id for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the customer id if the license is valid and is currently 
checked out, otherwise <A HREF=#MG_NULL>MG_NULL</A>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewLicense>mgNewLicense</A>, <A HREF=#mgCheckoutLicense>mgCheckoutLicense</A>, <A HREF=#mgCheckinLicense>mgCheckinLicense</A>, 
<A HREF=#mgGetLicenseVendorString>mgGetLicenseVendorString</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetLicenseVendorString><H1 CLASS="APISYMBOL">mgGetLicenseVendorString</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetLicenseVendorString</B> - gets the vendor string associated 
with a license.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char* <B>mgGetLicenseVendorString</B> (</TD><TD><A HREF=#mglicense>mglicense</A></TD><TD><I>license</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetLicenseVendorString</B> gets the vendor string associated with 
a license that has been previously checked out using <A HREF=#mgCheckoutLicense>mgCheckoutLicense</A>.</P></DD><DD><P>The character string returned is a dynamically allocated copy of 
the vendor string.  It is the responsibility of the caller to deallocate 
this string when it is no longer needed using the function <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>license</I></DT><DD>the license to get the vendor string for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the vendor string if the license is valid and is currently 
checked out, otherwise <A HREF=#MG_NULL>MG_NULL</A>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewLicense>mgNewLicense</A>, <A HREF=#mgCheckoutLicense>mgCheckoutLicense</A>, <A HREF=#mgCheckinLicense>mgCheckinLicense</A>, 
<A HREF=#mgGetLicenseCustomerID>mgGetLicenseCustomerID</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetLightPointAnimation><H1 CLASS="APISYMBOL">mgGetLightPointAnimation</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetLightPointAnimation</B> - gets an entry from the 
light point animation palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetLightPointAnimation</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetLightPointAnimation</B> gets a light point animation 
palette entry for database <I>db</I>.  The entry retrieved is specified 
by <I>index</I>.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLpAnimationPalette>fltLpAnimationPalette</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the entry to get</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the palette entry record if found, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetLightPointAppearanceCount>mgGetLightPointAppearanceCount</A>, 
<A HREF=#mgIndexOfLightPointAppearance>mgIndexOfLightPointAppearance</A>, 
<A HREF=#mgNameOfLightPointAppearance>mgNameOfLightPointAppearance</A>, 
<A HREF=#mgGetFirstLightPointAppearance>mgGetFirstLightPointAppearance</A>, 
<A HREF=#mgGetNextLightPointAppearance>mgGetNextLightPointAppearance</A>, 
<A HREF=#mgGetLightPointAnimationCount>mgGetLightPointAnimationCount</A>, 
<A HREF=#mgIndexOfLightPointAnimation>mgIndexOfLightPointAnimation</A>, 
<A HREF=#mgNameOfLightPointAnimation>mgNameOfLightPointAnimation</A>, 
<A HREF=#mgGetFirstLightPointAnimation>mgGetFirstLightPointAnimation</A>, 
<A HREF=#mgGetNextLightPointAnimation>mgGetNextLightPointAnimation</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetLightPointAnimationCount><H1 CLASS="APISYMBOL">mgGetLightPointAnimationCount</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetLightPointAnimationCount</B> - gets the number of entries 
in the light point appearance palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgGetLightPointAnimationCount</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetLightPointAnimationCount</B> gets the number of entries 
contained in the light point appearance palette for database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of palette entries.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetLightPointAppearance>mgGetLightPointAppearance</A>, 
<A HREF=#mgIndexOfLightPointAppearance>mgIndexOfLightPointAppearance</A>, 
<A HREF=#mgNameOfLightPointAppearance>mgNameOfLightPointAppearance</A>, 
<A HREF=#mgGetFirstLightPointAppearance>mgGetFirstLightPointAppearance</A>, 
<A HREF=#mgGetNextLightPointAppearance>mgGetNextLightPointAppearance</A>, 
<A HREF=#mgGetLightPointAnimation>mgGetLightPointAnimation</A>, 
<A HREF=#mgIndexOfLightPointAnimation>mgIndexOfLightPointAnimation</A>, 
<A HREF=#mgNameOfLightPointAnimation>mgNameOfLightPointAnimation</A>, 
<A HREF=#mgGetFirstLightPointAnimation>mgGetFirstLightPointAnimation</A>, 
<A HREF=#mgGetNextLightPointAnimation>mgGetNextLightPointAnimation</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetLightPointAppearance><H1 CLASS="APISYMBOL">mgGetLightPointAppearance</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetLightPointAppearance</B> - gets an entry from the 
light point appearance palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetLightPointAppearance</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetLightPointAppearance</B> gets a light point appearance 
palette entry for database <I>db</I>.  The entry retrieved is specified 
by <I>index</I>.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLpAppearancePalette>fltLpAppearancePalette</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the entry to get</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the light point appearance entry record if found, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetLightPointAppearanceCount>mgGetLightPointAppearanceCount</A>, 
<A HREF=#mgIndexOfLightPointAppearance>mgIndexOfLightPointAppearance</A>, 
<A HREF=#mgNameOfLightPointAppearance>mgNameOfLightPointAppearance</A>, 
<A HREF=#mgGetFirstLightPointAppearance>mgGetFirstLightPointAppearance</A>, 
<A HREF=#mgGetNextLightPointAppearance>mgGetNextLightPointAppearance</A>, 
<A HREF=#mgGetLightPointAnimation>mgGetLightPointAnimation</A>, 
<A HREF=#mgGetLightPointAnimationCount>mgGetLightPointAnimationCount</A>, 
<A HREF=#mgIndexOfLightPointAnimation>mgIndexOfLightPointAnimation</A>, 
<A HREF=#mgNameOfLightPointAnimation>mgNameOfLightPointAnimation</A>, 
<A HREF=#mgGetFirstLightPointAnimation>mgGetFirstLightPointAnimation</A>, 
<A HREF=#mgGetNextLightPointAnimation>mgGetNextLightPointAnimation</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetLightPointAppearanceCount><H1 CLASS="APISYMBOL">mgGetLightPointAppearanceCount</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetLightPointAppearanceCount</B> - gets the number of entries 
in the light point appearance palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgGetLightPointAppearanceCount</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetLightPointAppearanceCount</B> gets the number of entries 
contained in the light point appearance palette for database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of palette entries.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetLightPointAppearance>mgGetLightPointAppearance</A>, 
<A HREF=#mgIndexOfLightPointAppearance>mgIndexOfLightPointAppearance</A>, 
<A HREF=#mgNameOfLightPointAppearance>mgNameOfLightPointAppearance</A>, 
<A HREF=#mgGetFirstLightPointAppearance>mgGetFirstLightPointAppearance</A>, 
<A HREF=#mgGetNextLightPointAppearance>mgGetNextLightPointAppearance</A>, 
<A HREF=#mgGetLightPointAnimation>mgGetLightPointAnimation</A>, 
<A HREF=#mgGetLightPointAnimationCount>mgGetLightPointAnimationCount</A>, 
<A HREF=#mgIndexOfLightPointAnimation>mgIndexOfLightPointAnimation</A>, 
<A HREF=#mgNameOfLightPointAnimation>mgNameOfLightPointAnimation</A>, 
<A HREF=#mgGetFirstLightPointAnimation>mgGetFirstLightPointAnimation</A>, 
<A HREF=#mgGetNextLightPointAnimation>mgGetNextLightPointAnimation</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetLightSource><H1 CLASS="APISYMBOL">mgGetLightSource</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetLightSource</B> - gets an entry record from a 
database&#146s light source palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetLightSource</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetLightSource</B> gets light source entry record defined 
by <I>index</I> from the light source palette of <I>db</I>. The record is 
returned.  If the requested light source does not exist, 
<A HREF=#MG_NULL>MG_NULL</A> is returned.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLightSourcePalette>fltLightSourcePalette</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the palette index of the requested 
light source palette entry</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the light source entry record if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example gets the type of the light source 
palette element at index 5 in the light source palette.</DT><DT><PRE CLASS="EXAMPLE">int lighttype;
     mgrec* db;
mgrec* lightSource;
db = mgOpenDb ("anyfile.flt");
if (lightSource = mgGetLightSource (db, 5)) {
   mgGetAttList (lightSource, fltLtspType, &lighttype, MG_NULL);
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetLightSourceCount>mgGetLightSourceCount</A>, <A HREF=#mgGetFirstLightSource>mgGetFirstLightSource</A>, 
<A HREF=#mgGetNextLightSource>mgGetNextLightSource</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetLightSourceCount><H1 CLASS="APISYMBOL">mgGetLightSourceCount</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetLightSourceCount</B> - gets the number of entries in a 
database&#146s light source palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgGetLightSourceCount</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetLightSourceCount</B> gets the number of light source entries 
for a given database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of light source entries.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetLightSource>mgGetLightSource</A>, <A HREF=#mgGetFirstLightSource>mgGetFirstLightSource</A>, 
<A HREF=#mgGetNextLightSource>mgGetNextLightSource</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetLineStyle><H1 CLASS="APISYMBOL">mgGetLineStyle</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetLineStyle</B> - gets an entry record from a 
database&#146s line style palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetLineStyle</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetLineStyle</B> gets line style entry record defined 
by <I>index</I> from the line style palette of <I>db</I>. The record is 
returned.  If the requested line style does not exist, 
<A HREF=#MG_NULL>MG_NULL</A> is returned.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLineStylePalette>fltLineStylePalette</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the palette index of the requested 
line style palette entry</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the line style entry record if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetLineStyleCount>mgGetLineStyleCount</A>, <A HREF=#mgGetFirstLineStyle>mgGetFirstLineStyle</A>, 
<A HREF=#mgGetNextLineStyle>mgGetNextLineStyle</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetLineStyleCount><H1 CLASS="APISYMBOL">mgGetLineStyleCount</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetLineStyleCount</B> - gets the number of entries in a 
database&#146s line style palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgGetLineStyleCount</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetLineStyleCount</B> gets the number of line style entries 
for a given database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of line style entries.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetLineStyle>mgGetLineStyle</A>, <A HREF=#mgGetFirstLineStyle>mgGetFirstLineStyle</A>, 
<A HREF=#mgGetNextLineStyle>mgGetNextLineStyle</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetMaterial><H1 CLASS="APISYMBOL">mgGetMaterial</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetMaterial</B> - gets an entry record from a 
database&#146s material palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetMaterial</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetMaterial</B> gets the material entry record defined by 
<I>index</I> from the material palette of database node <I>db</I>.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltFMaterial>fltFMaterial</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the material palette index</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the material entry record if found, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgIndexOfMaterial>mgIndexOfMaterial</A>, <A HREF=#mgNewMaterial>mgNewMaterial</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetMaterialCount><H1 CLASS="APISYMBOL">mgGetMaterialCount</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetMaterialCount</B> - gets the number of entries in a 
database&#146s material palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgGetMaterialCount</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a database node, <I>db</I>, <B>mgGetMaterialCount</B> gets the number 
of entries in the database&#146s material palette.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of entries in the database&#146s material palette.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetFirstMaterial>mgGetFirstMaterial</A>, <A HREF=#mgGetNextMaterial>mgGetNextMaterial</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetMaterialElem><H1 CLASS="APISYMBOL">mgGetMaterialElem</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetMaterialElem</B> - gets the material components of a record.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetMaterialElem</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>ambientR</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>ambientG</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>ambientB</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>diffuseR</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>diffuseG</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>diffuseB</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>specularR</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>specularG</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>specularB</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>emissiveR</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>emissiveG</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>emissiveB</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>shininess</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>alpha</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, ambientR, ambientG, ambientB, diffuseR, diffuseG, diffuseB, specularR, specularG, specularB, emissiveR, emissiveG, emissiveB, shininess, alpha <B>mgGetMaterialElem</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltIMaterial>fltIMaterial</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 record, this function 
extracts the individual material components of that record.  If <I>rec</I> 
is a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltIMaterial>fltIMaterial</A>
 record, this function extracts the components 
directly from <I>rec</I>.  If <I>rec</I> is a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 record, this 
function extracts the components from the material assigned to the polygon.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the material record pointer</DD><DT><I>ambientR</I></DT><DD>the pointer for the ambient red value</DD><DT><I>ambientG</I></DT><DD>the pointer for the ambient green value</DD><DT><I>ambientB</I></DT><DD>the pointer for the ambient blue value</DD><DT><I>diffuseR</I></DT><DD>the pointer for the diffuse red value</DD><DT><I>diffuseG</I></DT><DD>the pointer for the diffuse green value</DD><DT><I>diffuseB</I></DT><DD>the pointer for the diffuse blue value</DD><DT><I>specularR</I></DT><DD>the pointer for the specular red value</DD><DT><I>specularG</I></DT><DD>the pointer for the specular green value</DD><DT><I>specularB</I></DT><DD>the pointer for the specular blue value</DD><DT><I>emissiveR</I></DT><DD>the pointer for the emissive red value</DD><DT><I>emissiveG</I></DT><DD>the pointer for the emissive green value</DD><DT><I>emissiveB</I></DT><DD>the pointer for the emissive blue value</DD><DT><I>shininess</I></DT><DD>the pointer for the shininess value</DD><DT><I>alpha</I></DT><DD>the pointer for the alpha (transparency) value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the material components are found. 
<A HREF=#mgbool>MG_FALSE</A> if the record doesn&#146t have material properties.</DD><DT>ambientR</DT><DD>If function is successful, ambientR contains the ambient red value, otherwise 
ambientR is undefined.</DD><DT>ambientG</DT><DD>If function is successful, ambientG contains the ambient green value, otherwise 
ambientG is undefined.</DD><DT>ambientB</DT><DD>If function is successful, ambientB contains the ambient blue value, otherwise 
ambientB is undefined.</DD><DT>diffuseR</DT><DD>If function is successful, diffuseR contains the diffuse red value, otherwise 
diffuseR is undefined.</DD><DT>diffuseG</DT><DD>If function is successful, diffuseG contains the diffuse green value, otherwise 
diffuseG is undefined.</DD><DT>diffuseB</DT><DD>If function is successful, diffuseB contains the diffuse blue value, otherwise 
diffuseB is undefined.</DD><DT>specularR</DT><DD>If function is successful, specularR contains the specular red value, otherwise 
specularR is undefined.</DD><DT>specularG</DT><DD>If function is successful, specularG contains the specular green value, otherwise 
specularG is undefined.</DD><DT>specularB</DT><DD>If function is successful, specularB contains the specular blue value, otherwise 
specularB is undefined.</DD><DT>emissiveR</DT><DD>If function is successful, emissiveR contains the emissive red value, otherwise 
emissiveR is undefined.</DD><DT>emissiveG</DT><DD>If function is successful, emissiveG contains the emissive green value, otherwise 
emissiveG is undefined.</DD><DT>emissiveB</DT><DD>If function is successful, emissiveB contains the emissive blue value, otherwise 
emissiveB is undefined.</DD><DT>shininess</DT><DD>If function is successful, shininess contains the shininess value, otherwise 
shininess is undefined.</DD><DT>alpha</DT><DD>If function is successful, alpha contains the alpha value, otherwise 
alpha is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetFirstMaterial>mgGetFirstMaterial</A>, <A HREF=#mgGetNextMaterial>mgGetNextMaterial</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetMatrix><H1 CLASS="APISYMBOL">mgGetMatrix</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetMatrix</B> - gets values out of a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMatrix>fltMatrix</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetMatrix</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>matrixCode</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, mgmatrix <B>mgGetMatrix</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>matrixCode</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a record <I>rec</I> which contains a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMatrix>fltMatrix</A>
 record identified 
by the record code <I>matrixCode</I>, <B>mgGetMatrix</B> copies the corresponding 
matrix of <I>rec</I> into <I>matrix</I>.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>Note: Memory is not allocated for <I>matrix</I> by this function.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>a node or record containing a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMatrix>fltMatrix</A>
 record</DD><DT><I>matrixCode</I></DT><DD>the record code of the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMatrix>fltMatrix</A>
 to retrieve</DD><DT><I>matrix</I></DT><DD>the address of the matrix to receive values</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> if 
<I>rec</I> has no such matrix or if otherwise unsuccessful.</DD><DT>mgmatrix</DT><DD>the corresponding matrix of <I>rec</I>.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetMatrix>mgSetMatrix</A>, <A HREF=#mgHasXform>mgHasXform</A>, <A HREF=#mgGetXform>mgGetXform</A>, <A HREF=#mgGetXformType>mgGetXformType</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetMatTextureLayer><H1 CLASS="APISYMBOL">mgGetMatTextureLayer</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetMatTextureLayer</B> - gets values out of a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMatTextureLayer>fltMatTextureLayer</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetMatTextureLayer</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>matTextureCode</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>textureIndex</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>textureLayer</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, textureIndex, textureLayer <B>mgGetMatTextureLayer</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>matTextureCode</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a record, <I>rec</I>, <B>mgGetMatTextureLayer</B> gets the values of <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMatTextureLayer>fltMatTextureLayer</A>
 
attribute record <I>matTextureCode</I> from <I>rec</I> and stores them in <I>textureIndex</I> and <I>textureLayer</I>.</P></DD><DD><P>You do not have to provide addresses for both <I>textureIndex</I> and <I>textureLayer</I> values.  For 
example, if you only want to receive the index value (but not layer), specify a valid 
address for <I>textureIndex</I> and leave <I>textureLayer</I> NULL.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record from which to get the 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMatTextureLayer>fltMatTextureLayer</A>
 attribute code</DD><DT><I>matTextureCode</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMatTextureLayer>fltMatTextureLayer</A>
 attribute code</DD><DT><I>textureIndex</I></DT><DD>address of value to receive texture index</DD><DT><I>textureLayer</I></DT><DD>address of value to receive texture layer</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the layer was retrieved successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>textureIndex</DT><DD>If function is successful, textureIndex contains the retrieved index, otherwise 
textureIndex is undefined.</DD><DT>textureLayer</DT><DD>If function is successful, textureLayer contains the retrieved layer, otherwise 
textureLayer is undefined.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* db;
mgrec* matRec;
int materialIndex;
int textureIndex, textureLayer;
mgbool status;

db = mgOpenDb ("file.flt");
matRec = mgGetFirstMaterial (db, &materialIndex);
status = mgGetMatTextureLayer (matRec, fltAmbientExLayer1, &textureIndex, &textureLayer);</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetMatTextureLayer>mgSetMatTextureLayer</A>, <A HREF=#mgGetNormColor>mgGetNormColor</A>, <A HREF=#mgGetAttList>mgGetAttList</A>, <A HREF=#mgGetAttBuf>mgGetAttBuf</A></DD></DL>
<HR>
<LEFT><A NAME=mggetmaxidfunc><H1 CLASS="APISYMBOL">mggetmaxidfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mggetmaxidfunc</B> - Get Max Id function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool (*<B>mggetmaxidfunc</B>) ( <TD><A HREF=#mgrec>mgrec*</A> <TD><I>db</I>, 
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A> <TD><I>code</I>, 
<TR><TD></TD><TD>int* <TD><I>no</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for get max id (extension node helper) functions. 
If your data extension declares one or more new node types, assign 
a get max id function to your data extension of this form.</P></DD><DD><P>Get max id functions are called before nodes of your new type 
are created and are responsible for returning the next index to assign 
to the new node.  This index is used to form the name of the new node 
so that the name can be unique within the database.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database into which the new node is being created</DD><DT><I>code</I></DT><DD>the record code of the new node being created</DD><DT><I>no</I></DT><DD>address of value to receive "next" index for 
new node name</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
If successful, the function returns the index in the output 
parameter, <I>no</I>.
</DD></DL><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterSite>mgRegisterSite</A>, <A HREF=#mgsetmaxidfunc>mgsetmaxidfunc</A>, <A HREF=#mggetheadercodefunc>mggetheadercodefunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetMessagesEnabled><H1 CLASS="APISYMBOL">mgGetMessagesEnabled</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetMessagesEnabled</B> - determines if messages are enabled or 
disabled.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetMessagesEnabled</B> (</TD><TD><A HREF=#mgmessageseverityenum>mgmessageseverityenum</A></TD><TD><I>severity</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetMessagesEnabled</B> determines if messages of level 
<I>severity</I> have been enabled or disabled via <A HREF=#mgSetMessagesEnabled>mgSetMessagesEnabled</A>.</P></DD><DD><P>Note: Within the modeler environment, messages are always enabled 
and cannot be disabled. For this reason, this function always returns 
<A HREF=#mgbool>MG_TRUE</A> when invoked from within the modeler environment.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>severity</I></DT><DD>severity level of the messages 
to check whether enabled or disabled</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if messages of level <I>severity</I> are enabled, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetMessagesEnabled>mgSetMessagesEnabled</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetModelingMode><H1 CLASS="APISYMBOL">mgGetModelingMode</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetModelingMode</B> - returns current modeling mode.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcode <B>mgGetModelingMode</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetModelingMode</B> returns the current modeling mode 
for the specified database <I>db</I>.</P></DD><DD><P>Note that the edge modeling mode is a special case of vertex mode. 
Since there is no "edge" type in OpenFlight, you must interpret the return 
value of this function carefully to differentiate between vertex and edge 
mode. In both vertex and edge modes, this function will return <B>fltVertex</B>. 
To know if the modeling mode is really edge mode, call <A HREF=#mgIsModelingModeEdge>mgIsModelingModeEdge</A>. 
It will return <A HREF=#mgbool>MG_TRUE</A> if the modeling mode is really edge, 
<A HREF=#mgbool>MG_FALSE</A> if the modeling mode is truly vertex.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database to get modeling mode for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns current modeling mode for database if valid, 0 (zero) otherwise.
</DD></DL><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show how to use this 
function for different modeling modes:</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgcode mode;

mode = mgGetModelingMode (db);
if (mode == fltGroup) {
   printf ("modeling mode is group&#92;n");
}
else if (mode == fltVertex) {
   // modeling mode is vertex OR edge
   mgbool isEdge = mgIsModelingModeEdge (db);
   if (isEdge == MG_TRUE) {
      printf ("modeling mode is edge&#92;n")
   }
   else {
      printf ("modeling mode is really vertex&#92;n")
   }
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mode = mgGetModelingMode (db)
if (mode == fltGroup):
   print "modeling mode is group"
elif (mode == fltVertex:
   # modeling mode is vertex OR edge
   isEdge = mgIsModelingModeEdge (db)
   if (isEdge == MG_TRUE):
      print "modeling mode is edge"
   else:
      print "modeling mode is really vertex"</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetActivationDb>mgGetActivationDb</A>, 
<A HREF=#mgSetModelingMode>mgSetModelingMode</A>, <A HREF=#mgIsModelingModeEdge>mgIsModelingModeEdge</A>, <A HREF=#mgSetModelingModeEdge>mgSetModelingModeEdge</A>, 
<A HREF=#mgGetModelingParent>mgGetModelingParent</A>, <A HREF=#mgGetModelingParentMatrix>mgGetModelingParentMatrix</A>, <A HREF=#mgGetDefaultModelingParent>mgGetDefaultModelingParent</A>, 
<A HREF=#mgSetModelingParent>mgSetModelingParent</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetModelingParent><H1 CLASS="APISYMBOL">mgGetModelingParent</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetModelingParent</B> - returns current modeling parent.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetModelingParent</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetModelingParent</B> returns the current modeling parent node 
for the specified database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database to get modeling parent for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the current modeling parent node for database if one is set, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetActivationDb>mgGetActivationDb</A>, 
<A HREF=#mgGetModelingMode>mgGetModelingMode</A>, <A HREF=#mgSetModelingMode>mgSetModelingMode</A>, <A HREF=#mgIsModelingModeEdge>mgIsModelingModeEdge</A>, <A HREF=#mgSetModelingModeEdge>mgSetModelingModeEdge</A>, 
<A HREF=#mgGetModelingParentMatrix>mgGetModelingParentMatrix</A>, <A HREF=#mgGetDefaultModelingParent>mgGetDefaultModelingParent</A>, <A HREF=#mgSetModelingParent>mgSetModelingParent</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetModelingParentMatrix><H1 CLASS="APISYMBOL">mgGetModelingParentMatrix</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetModelingParentMatrix</B> - returns current modeling parent 
and a matrix representing the cumulative transformation matrix applied 
to this parent node.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetModelingParentMatrix</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec, mgmatrix <B>mgGetModelingParentMatrix</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Similar to <A HREF=#mgGetModelingParent>mgGetModelingParent</A>, <B>mgGetModelingParentMatrix</B> returns 
the current modeling parent node for the specified database <I>db</I>.  Additionally, 
<B>mgGetModelingParentMatrix</B> returns a <I>matrix</I> that represents the cumulative 
transformation matrix applied to the parent node returned.</P></DD><DD><P>The function <A HREF=#mgMatrixInvert>mgMatrixInvert</A> can be used to obtain the inverse 
of this modeling parent matrix.  This inverse matrix describes the 
transformation that transforms a coordinate in world space back to local 
space under the current modeling parent.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database to get parent matrix for</DD><DT><I>matrix</I></DT><DD>address of matrix to receive parent matrix</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgrec</DT><DD>The current modeling parent node for database if one is set, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.</DD><DT>mgmatrix</DT><DD>If a parent node is returned, the composite matrix 
representing the cumulative transformations applied to this parent node 
is returned in the output parameter <I>matrix</I>.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetActivationDb>mgGetActivationDb</A>, 
<A HREF=#mgGetModelingMode>mgGetModelingMode</A>, <A HREF=#mgSetModelingMode>mgSetModelingMode</A>, <A HREF=#mgIsModelingModeEdge>mgIsModelingModeEdge</A>, <A HREF=#mgSetModelingModeEdge>mgSetModelingModeEdge</A>, 
<A HREF=#mgGetModelingParent>mgGetModelingParent</A>, <A HREF=#mgGetDefaultModelingParent>mgGetDefaultModelingParent</A>, <A HREF=#mgSetModelingParent>mgSetModelingParent</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetModuleFilename><H1 CLASS="APISYMBOL">mgGetModuleFilename</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetModuleFilename</B> - returns the path and file name 
associated with a plug-in.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char* <B>mgGetModuleFilename</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetModuleFilename</B> returns the full path and file name 
specification for the plug-in module <I>plugin</I>.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned string in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in module being queried</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the path and file name if successful, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgLoadResource>mgLoadResource</A>, <A HREF=#mgGetModuleHandle>mgGetModuleHandle</A>, <A HREF=#mgGetModulePath>mgGetModulePath</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetModuleHandle><H1 CLASS="APISYMBOL">mgGetModuleHandle</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetModuleHandle</B> - returns a native plug-in module handle.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgmodulehandle <B>mgGetModuleHandle</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetModuleHandle</B> returns a platform specific handle to the specified 
plug-in module <I>plugin</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in module being queried</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>On Windows, this function returns an object of type HINSTANCE.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgLoadResource>mgLoadResource</A>, <A HREF=#mgGetModuleFilename>mgGetModuleFilename</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetModulePath><H1 CLASS="APISYMBOL">mgGetModulePath</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetModulePath</B> - returns the path associated with a plug-in.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char* <B>mgGetModulePath</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetModulePath</B> returns the path specification of the folder 
that contains the plug-in module <I>plugin</I>.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned string in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in module being queried</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the path and file name if successful, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgLoadResource>mgLoadResource</A>, <A HREF=#mgGetModuleHandle>mgGetModuleHandle</A>, <A HREF=#mgGetModuleFilename>mgGetModuleFilename</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetMorphVertex><H1 CLASS="APISYMBOL">mgGetMorphVertex</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetMorphVertex</B> - gets the morph vertex for a given vertex.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetMorphVertex</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetMorphVertex</B> returns the morph vertex node corresponding to 
the specified vertex node <I>rec</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the vertex node</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the morph vertex of <I>rec</I> if it has one, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, <A HREF=#mgAttach>mgAttach</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetMyCode><H1 CLASS="APISYMBOL">mgGetMyCode</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetMyCode</B> - gets the enum code of a record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcode <B>mgGetMyCode</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetMyCode</B> returns the original enum code (with the offset 
removed) of the record <I>rec</I>.  These enum values are not unique across 
extension sites.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the enum code of the record <I>rec</I>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgIsCode>mgIsCode</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetName><H1 CLASS="APISYMBOL">mgGetName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetName</B> - gets the name (ID) of a node record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char* <B>mgGetName</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetName</B> returns the name (ID) of a node record, <I>rec</I>.</P></DD><DD><P>Use <A HREF=#mgSetName>mgSetName</A> to change the name of a record.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned string in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the name of the node if successful, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetRecByName>mgGetRecByName</A>, <A HREF=#mgSetName>mgSetName</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetNestedChild><H1 CLASS="APISYMBOL">mgGetNestedChild</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetNestedChild</B> - gets the nested child of a polygon node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetNestedChild</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetNestedChild</B> returns the nested child of the specified 
polygon node <I>rec</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to get nested child for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the node if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, <A HREF=#mgGetNestedParent>mgGetNestedParent</A>, <A HREF=#mgGetChild>mgGetChild</A>, <A HREF=#mgGetChildNth>mgGetChildNth</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetNestedParent><H1 CLASS="APISYMBOL">mgGetNestedParent</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetNestedParent</B> - gets the nested parent of a polygon node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetNestedParent</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetNestedParent</B> returns the nested parent of the specified 
polygon node <I>rec</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to get nested parent for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the node if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, <A HREF=#mgGetNestedChild>mgGetNestedChild</A>, <A HREF=#mgGetParent>mgGetParent</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetNewEyePoint><H1 CLASS="APISYMBOL">mgGetNewEyePoint</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetNewEyePoint</B> - returns a new eyepoint record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetNewEyePoint</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetNewEyePoint</B> returns a new eyepoint record that must solely be 
used as a parameter to <A HREF=#mgGetCurrentEyePoint>mgGetCurrentEyePoint</A>, <A HREF=#mgSetCurrentEyePoint>mgSetCurrentEyePoint</A> 
and <A HREF=#mgSetEyePoint>mgSetEyePoint</A>.</P></DD><DD><P>Use <A HREF=#mgFreeNewEyePoint>mgFreeNewEyePoint</A> when you are done with the record.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgCopyEyePoint>mgCopyEyePoint</A>, <A HREF=#mgFreeNewEyePoint>mgFreeNewEyePoint</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetNext><H1 CLASS="APISYMBOL">mgGetNext</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetNext</B> - gets the next immediate sibling of a node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetNext</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetNext</B> returns the next immediate sibling of the 
specified node <I>rec</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to get next sibling</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the node if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, <A HREF=#mgGetPrevious>mgGetPrevious</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetNextColorName><H1 CLASS="APISYMBOL">mgGetNextColorName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetNextColorName</B> - gets the name of the next color for 
a particular color index.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char* <B>mgGetNextColorName</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>void**</TD><TD><I>ptr</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Each color palette entry can have a list of names associated with it. 
Given a database node, <I>db</I>, an index into the color palette, <I>index</I>, 
and the name list, <I>ptr</I>, <B>mgGetNextColorName</B> returns the next name in 
<I>index</I>&#146s color name list.  If <I>ptr</I> points to MG_NULL, then it will be 
set to hold an opaque pointer to the name list, and the first name in the 
list will be returned. Subsequent calls to <B>mgGetNextColorName</B> for the 
same index can then be made using <I>ptr</I>.</P></DD><DD><P>The string returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the color palette index</DD><DT><I>ptr</I></DT><DD>an opaque pointer holding the name 
list (can point to <A HREF=#MG_NULL>MG_NULL</A>).  If points 
to <A HREF=#MG_NULL>MG_NULL</A>, returns an opaque 
pointer to the name list</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the next name in the color name list for the given index 
if successful, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example iterates all the names associated with color 
index 4 in a database.</DT><DT><PRE CLASS="EXAMPLE">void* nameList = MG_NULL;
int colorIndex = 4;
int n = 1;
char* name;

// get first color name - make sure nameList is MG_NULL
name = mgGetNextColorName (db, colorIndex, &nameList);
while (name != MG_NULL)
{
   // at this point name holds the nth name associated with color index 4
   printf ("Name %d: %s&#92;n", n, name);

   // remember to free the name when you're done with it
   mgFree (name);

   // and go get the next one
   name = mgGetNextColorName (db, colorIndex, &nameList);
   n++;
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCurrentColorName>mgGetCurrentColorName</A>, <A HREF=#mgGetColorIndexByName>mgGetColorIndexByName</A>, 
<A HREF=#mgGetPolyColorName>mgGetPolyColorName</A>, <A HREF=#mgGetPolyAltColorName>mgGetPolyAltColorName</A>, 
<A HREF=#mgSetPolyColorName>mgSetPolyColorName</A>, <A HREF=#mgSetPolyAltColorName>mgSetPolyAltColorName</A>, 
<A HREF=#mgGetColorNameList>mgGetColorNameList</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetNextInstance><H1 CLASS="APISYMBOL">mgGetNextInstance</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetNextInstance</B> - gets successive instance nodes of a reference node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetNextInstance</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>inst</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetNextInstance</B> returns the instance that follows the specified 
instance node <I>inst</I>.  If node <I>inst</I> is an instance of a reference node, this 
function will return the next instance of that reference node.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>inst</I></DT><DD>the instance node to get next instance for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the instance node if found.  If <I>inst</I> is not 
an instance node, <A HREF=#MG_NULL>MG_NULL</A> is returned.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgIsFirstInstance>mgIsFirstInstance</A>, <A HREF=#mgGetFirstInstance>mgGetFirstInstance</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetNextLightPointAnimation><H1 CLASS="APISYMBOL">mgGetNextLightPointAnimation</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetNextLightPointAnimation</B> - gets the next entry in 
a light point animation palette.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetNextLightPointAnimation</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>lightPointAnimation</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec, index <B>mgGetNextLightPointAnimation</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>lightPointAnimation</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetNextLightPointAnimation</B> gets the entry that follows 
<I>lightPointAnimation</I> in the light point appearance palette for 
database <I>db</I>.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLpAnimationPalette>fltLpAnimationPalette</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>lightPointAnimation</I></DT><DD>the palette entry to get next for</DD><DT><I>index</I></DT><DD>address of value to receive 
index of entry returned</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgrec</DT><DD>The next light point animation entry record, or <A HREF=#MG_NULL>MG_NULL</A> 
if no next light point animation in palette.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD></DL></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>See <A HREF=#mgGetFirstLightPointAnimation>mgGetFirstLightPointAnimation</A> for an example of how to use this function.</DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetLightPointAppearance>mgGetLightPointAppearance</A>, 
<A HREF=#mgGetLightPointAppearanceCount>mgGetLightPointAppearanceCount</A>, 
<A HREF=#mgIndexOfLightPointAppearance>mgIndexOfLightPointAppearance</A>, 
<A HREF=#mgNameOfLightPointAppearance>mgNameOfLightPointAppearance</A>, 
<A HREF=#mgGetFirstLightPointAppearance>mgGetFirstLightPointAppearance</A>, 
<A HREF=#mgGetLightPointAnimation>mgGetLightPointAnimation</A>, 
<A HREF=#mgGetLightPointAnimationCount>mgGetLightPointAnimationCount</A>, 
<A HREF=#mgIndexOfLightPointAnimation>mgIndexOfLightPointAnimation</A>, 
<A HREF=#mgNameOfLightPointAnimation>mgNameOfLightPointAnimation</A>, 
<A HREF=#mgGetFirstLightPointAnimation>mgGetFirstLightPointAnimation</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetNextLightPointAppearance><H1 CLASS="APISYMBOL">mgGetNextLightPointAppearance</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetNextLightPointAppearance</B> - gets the next entry in 
a light point appearance palette.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetNextLightPointAppearance</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>lightPointAppearance</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec, index <B>mgGetNextLightPointAppearance</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>lightPointAppearance</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetNextLightPointAppearance</B> gets the entry that follows 
<I>lightPointAppearance</I> in the light point appearance palette for 
database <I>db</I>.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLpAppearancePalette>fltLpAppearancePalette</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>lightPointAppearance</I></DT><DD>the palette entry to get next for</DD><DT><I>index</I></DT><DD>address of value to receive 
index of entry returned</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgrec</DT><DD>The next light point appearance entry record, or <A HREF=#MG_NULL>MG_NULL</A> 
if no next light point appearance in palette.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD></DL></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>See <A HREF=#mgGetFirstLightPointAppearance>mgGetFirstLightPointAppearance</A> for an example of how to use this function.</DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetLightPointAppearance>mgGetLightPointAppearance</A>, 
<A HREF=#mgGetLightPointAppearanceCount>mgGetLightPointAppearanceCount</A>, 
<A HREF=#mgIndexOfLightPointAppearance>mgIndexOfLightPointAppearance</A>, 
<A HREF=#mgNameOfLightPointAppearance>mgNameOfLightPointAppearance</A>, 
<A HREF=#mgGetFirstLightPointAppearance>mgGetFirstLightPointAppearance</A>, 
<A HREF=#mgGetLightPointAnimation>mgGetLightPointAnimation</A>, 
<A HREF=#mgGetLightPointAnimationCount>mgGetLightPointAnimationCount</A>, 
<A HREF=#mgIndexOfLightPointAnimation>mgIndexOfLightPointAnimation</A>, 
<A HREF=#mgNameOfLightPointAnimation>mgNameOfLightPointAnimation</A>, 
<A HREF=#mgGetFirstLightPointAnimation>mgGetFirstLightPointAnimation</A>, 
<A HREF=#mgGetNextLightPointAnimation>mgGetNextLightPointAnimation</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetNextLightSource><H1 CLASS="APISYMBOL">mgGetNextLightSource</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetNextLightSource</B> - gets the next entry record 
from a database&#146s light source palette.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetNextLightSource</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>lightSource</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec, index <B>mgGetNextLightSource</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>lightSource</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a light source entry record, <I>lightSource</I>, <B>mgGetNextLightSource</B> 
returns the light source entry record following <I>lightSource</I> in the light 
source palette. The index of the next light source in the palette is 
returned in <I>index</I>, if there is one. If there is no next light source 
entry record, <A HREF=#MG_NULL>MG_NULL</A> is returned.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLightSourcePalette>fltLightSourcePalette</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>lightSource</I></DT><DD>the previous light source palette entry record</DD><DT><I>index</I></DT><DD>address of value to receive index of entry 
returned</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgrec</DT><DD>The next light source entry record, or <A HREF=#MG_NULL>MG_NULL</A> 
if unsuccessful.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* lightSource;
mgrec* db;
int index;
db = mgOpenDb ("anyfile.flt");
lightSource = mgGetFirstLightSource (db, &index);
while (lightSource != MG_NULL) {
   // do something with lightSource
   lightSource = mgGetNextLightSource (lightSource, &index);
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetLightSource>mgGetLightSource</A>, <A HREF=#mgGetFirstLightSource>mgGetFirstLightSource</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetNextLineStyle><H1 CLASS="APISYMBOL">mgGetNextLineStyle</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetNextLineStyle</B> - gets the next entry record 
from a database&#146s line style palette.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetNextLineStyle</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>lightSource</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec, index <B>mgGetNextLineStyle</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>lineStyle</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a line style entry record, <I>lineStyle</I>, <B>mgGetNextLineStyle</B> 
returns the line style entry record following <I>lineStyle</I> in the light 
source palette. The index of the next line style in the palette is 
returned in <I>index</I>, if there is one. If there is no next line style 
entry record, <A HREF=#MG_NULL>MG_NULL</A> is returned.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLineStylePalette>fltLineStylePalette</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>lightSource</I></DT><DD>the previous line style palette entry record</DD><DT><I>index</I></DT><DD>address of value to receive index of entry 
returned</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgrec</DT><DD>The next line style entry record, or <A HREF=#MG_NULL>MG_NULL</A> 
if unsuccessful.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* lineStyle;
mgrec* db;
int index;
db = mgOpenDb ("anyfile.flt");
lineStyle = mgGetFirstLineStyle (db, &index);
while (lineStyle != MG_NULL) {
   // do something with lineStyle
   lineStyle = mgGetNextLineStyle (lineStyle, &index);
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetLineStyle>mgGetLineStyle</A>, <A HREF=#mgGetFirstLineStyle>mgGetFirstLineStyle</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetNextMaterial><H1 CLASS="APISYMBOL">mgGetNextMaterial</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetNextMaterial</B> - gets the next material palette 
entry record from the material palette.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetNextMaterial</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>matrec</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec, index <B>mgGetNextMaterial</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>matrec</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a material record pointer <I>matrec</I>, <B>mgGetNextMaterial</B> 
gets the next material entry record from the material palette. 
The index of the next material record is returned in <I>index</I>.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltFMaterial>fltFMaterial</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrec</I></DT><DD>the previous material palette entry record</DD><DT><I>index</I></DT><DD>address of value to receive palette index of entry returned, -1 if none</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgrec</DT><DD>The next material palette entry record, or <A HREF=#MG_NULL>MG_NULL</A> 
if unsuccessful.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetFirstMaterial>mgGetFirstMaterial</A>, <A HREF=#mgGetMaterialCount>mgGetMaterialCount</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetNextRecInList><H1 CLASS="APISYMBOL">mgGetNextRecInList</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetNextRecInList</B> - returns the next item in the record list.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetNextRecInList</B> (</TD><TD><A HREF=#mgreclist>mgreclist</A></TD><TD><I>recList</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec, mgmatrix <B>mgGetNextRecInList</B> (</TD><TD><A HREF=#mgreclist>mgreclist</A></TD><TD><I>recList</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetNextRecInList</B> returns the item in the specified record 
list <I>recList</I> that corresponds to the current position of 
the traversal pointer.</P></DD><DD><P>Before this function returns, it advances the position of the 
traversal pointer of the record list so that the next call 
to <B>mgGetNextRecInList</B> returns the proper list node.</P></DD><DD><P>If this function is successful and the output parameter <I>matrix</I> 
is not <A HREF=#MG_NULL>MG_NULL</A>, it is loaded with the composite matrix representing 
the cumulative transformations applied to this item.  If you do not need 
this matrix, you may specify <I>matrix</I> as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>recList</I></DT><DD>the record list to traverse</DD><DT><I>matrix</I></DT><DD>address of a matrix to receive 
the composite of all transformations above 
the returned record list item</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgrec</DT><DD>The next item in the record list, <A HREF=#MG_NULL>MG_NULL</A> if 
no more items are in the list.</DD><DT>mgmatrix</DT><DD>If an item is returned, the output parameter 
<I>matrix</I> (if specified) is loaded with the composite matrix representing 
the cumulative transformations applied to this item.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResetRecList>mgResetRecList</A>, <A HREF=#mgGetNthRecInList>mgGetNthRecInList</A>, <A HREF=#mgIsRecInList>mgIsRecInList</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetNextSelectedTexture><H1 CLASS="APISYMBOL">mgGetNextSelectedTexture</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetNextSelectedTexture</B> - gets successive selected entries 
in a texture palette.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetNextSelectedTexture</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>textureName</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, index, name <B>mgGetNextSelectedTexture</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetNextSelectedTexture</B> gets the index and name of the next 
selected texture contained in the texture palette of database <I>db</I>.</P></DD><DD><P>After calling <A HREF=#mgGetFirstSelectedTexture>mgGetFirstSelectedTexture</A>, successive calls to 
<B>mgGetNextSelectedTexture</B> returns successive texture palette entries.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>If you pass <A HREF=#MG_NULL>MG_NULL</A> for <I>textureName</I>, the name of the texture is 
not returned.  If you do pass a character string for <I>textureName</I>, the buffer 
should be at least 1024 characters.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>address of value to receive index</DD><DT><I>textureName</I></DT><DD>address of string to receive texture name</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the texture palette entry is found, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD><DT>name</DT><DD>If function is successful, name contains the retrieved name, otherwise 
name is undefined.</DD></DL></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>See <A HREF=#mgGetFirstSelectedTexture>mgGetFirstSelectedTexture</A> for an example of how to use this function.</DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSelectTextureIndex>mgSelectTextureIndex</A>, 
<A HREF=#mgDeselectTextureIndex>mgDeselectTextureIndex</A>, 
<A HREF=#mgDeselectAllTextures>mgDeselectAllTextures</A>, 
<A HREF=#mgGetFirstSelectedTexture>mgGetFirstSelectedTexture</A>, 
<A HREF=#mgGetSelectedTextureCount>mgGetSelectedTextureCount</A>, 
<A HREF=#mgIsTextureIndexSelected>mgIsTextureIndexSelected</A>, 
<A HREF=#mgGetNextTexture>mgGetNextTexture</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetNextShader><H1 CLASS="APISYMBOL">mgGetNextShader</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetNextShader</B> - gets the next shader palette 
entry record from the shader palette.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetNextShader</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>shader</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec, index <B>mgGetNextShader</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>shader</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a shader record pointer <I>shader</I>, <B>mgGetNextShader</B> 
gets the next shader entry record from the shader palette. 
The index of the next shader record is returned in <I>index</I>.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltShaderPalette>fltShaderPalette</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>shader</I></DT><DD>the previous shader palette entry record</DD><DT><I>index</I></DT><DD>the index of the returned shader palette</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgrec</DT><DD>The next shader entry record, or <A HREF=#MG_NULL>MG_NULL</A> 
if unsuccessful.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetShaderCount>mgGetShaderCount</A>, <A HREF=#mgGetFirstShader>mgGetFirstShader</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetNextSound><H1 CLASS="APISYMBOL">mgGetNextSound</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetNextSound</B> - gets the next entry record 
from a database&#146s sound palette.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetNextSound</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>sound</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec, index <B>mgGetNextSound</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>sound</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a sound entry record, <I>sound</I>, <B>mgGetNextSound</B> 
returns the sound entry record following <I>sound</I> in the sound 
palette. The index of the next sound in the palette is 
returned in <I>index</I>, if there is one.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSoundPalette>fltSoundPalette</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>sound</I></DT><DD>the sound record</DD><DT><I>index</I></DT><DD>the index of the next sound record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgrec</DT><DD>The next sound palette entry record, or <A HREF=#MG_NULL>MG_NULL</A> 
if unsuccessful.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* sound;
mgrec* next;
mgrec* db;
int index;
db = mgNewDb ("newfile.flt");
sound = mgGetFirstSound (db, index);
next = mgGetNextSound (sound, index);</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetSound>mgGetSound</A>, <A HREF=#mgGetFirstSound>mgGetFirstSound</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetNextTexture><H1 CLASS="APISYMBOL">mgGetNextTexture</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetNextTexture</B> - gets successive entries in a texture palette.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetNextTexture</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>textureName</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, index, textureName <B>mgGetNextTexture</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetNextTexture</B> gets the index and name of the next texture 
contained in the texture palette of database <I>db</I>.</P></DD><DD><P>After calling <A HREF=#mgGetFirstTexture>mgGetFirstTexture</A>, successive calls to <B>mgGetNextTexture</B> 
return successive texture palette entries.</P></DD><DD><P>If the texture was located when it was loaded, the <I>textureName</I> 
includes the full path specification of the file where it was found 
on disk.  If the texture was not located at load time, the <I>textureName</I> 
returned by this function will be the same name returned by 
<A HREF=#mgGetTextureSaveName>mgGetTextureSaveName</A>.</P></DD><DD><P>If you pass <A HREF=#MG_NULL>MG_NULL</A> for <I>index</I>, the index of the texture is not returned.</P></DD><DD><P>If you pass <A HREF=#MG_NULL>MG_NULL</A> for <I>textureName</I>, the name of the texture is 
not returned.  If you do pass a character string for <I>textureName</I>, the buffer 
should be at least 1024 characters.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>address of value to receive index</DD><DT><I>textureName</I></DT><DD>address of string to receive texture name</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the next texture palette entry is found, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD><DT>textureName</DT><DD>If function is successful, textureName contains the retrieved name, 
otherwise textureName is undefined.</DD></DL></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>See <A HREF=#mgGetFirstTexture>mgGetFirstTexture</A> for an example of how to use this function.</DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetFirstTexture>mgGetFirstTexture</A>, <A HREF=#mgGetTextureCount>mgGetTextureCount</A>, 
<A HREF=#mgGetSelectedTextureCount>mgGetSelectedTextureCount</A>, <A HREF=#mgGetFirstSelectedTexture>mgGetFirstSelectedTexture</A>, 
<A HREF=#mgGetNextSelectedTexture>mgGetNextSelectedTexture</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetNextTextureMapping><H1 CLASS="APISYMBOL">mgGetNextTextureMapping</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetNextTextureMapping</B> - gets the next texture 
mapping in a database&#146s palette.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetNextTextureMapping</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>textureMappingName</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, index, name <B>mgGetNextTextureMapping</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetNextTextureMapping</B> gets the index and name of the next texture 
mapping contained in the texture mapping palette of database <I>db</I>.</P></DD><DD><P>If you pass <A HREF=#MG_NULL>MG_NULL</A> for <I>index</I>, the index of the texture mapping 
palette entry is not returned.</P></DD><DD><P>If you pass <A HREF=#MG_NULL>MG_NULL</A> for <I>textureMappingName</I>, the name of the texture 
mapping palette entry is not returned.  If you do pass a character string for 
<I>textureMappingName</I>, the buffer&#32should be at least 20 characters.</P></DD><DD><P>After calling <A HREF=#mgGetFirstTextureMapping>mgGetFirstTextureMapping</A>, successive calls to 
<B>mgGetNextTextureMapping</B> return successive texture mapping palette entries.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>pointer to the index of the next texture mapping</DD><DT><I>textureMappingName</I></DT><DD>the name of the next texture mapping</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the next texture mapping palette entry is found, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD><DT>name</DT><DD>If function is successful, name contains the retrieved name, otherwise 
name is undefined.</DD></DL></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>See <A HREF=#mgGetFirstTextureMapping>mgGetFirstTextureMapping</A> for an example of how to use this function.</DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetFirstTextureMapping>mgGetFirstTextureMapping</A>, <A HREF=#mgGetTextureMappingCount>mgGetTextureMappingCount</A>, <A HREF=#mgGetTextureMappingName>mgGetTextureMappingName</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetNormColor><H1 CLASS="APISYMBOL">mgGetNormColor</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetNormColor</B> - gets values out of a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltNormColor>fltNormColor</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetNormColor</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>normColorCode</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>red</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>green</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>blue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, red, green, blue <B>mgGetNormColor</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>normColorCode</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a record, <I>rec</I>, <B>mgGetNormColor</B> gets the values of <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltNormColor>fltNormColor</A>
 attribute 
record <I>normColorCode</I> from <I>rec</I> and stores them in <I>red</I>, <I>green</I>, and <I>blue</I>.</P></DD><DD><P>You do not have to provide addresses for all <I>red</I>, <I>green</I>, and <I>blue</I> values.  For 
example, if you only want to receive the red and blue components (but not green), specify valid 
addresses for <I>red</I> and <I>blue</I> and leave <I>green</I> NULL.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record from which to get the 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltNormColor>fltNormColor</A>
 attribute code</DD><DT><I>normColorCode</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltNormColor>fltNormColor</A>
 attribute code</DD><DT><I>red</I></DT><DD>address of value to receive red component value</DD><DT><I>green</I></DT><DD>address of value to receive green component value</DD><DT><I>blue</I></DT><DD>address of value to receive blue component value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>red</DT><DD>If function is successful, red contains the retrieved value, otherwise 
red is undefined.</DD><DT>green</DT><DD>If function is successful, green contains the retrieved value, otherwise 
green is undefined.</DD><DT>blue</DT><DD>If function is successful, blue contains the retrieved value, otherwise 
blue is undefined.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* db;
mgrec* matRec;
float r, g, b;
int index;
mgbool status;

db = mgOpenDb ("file.flt");
matRec = mgGetFirstMaterial (db, &index);
status = mgGetNormColor (matRec, fltAmbient, &r, &g, &b);</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetNormColor>mgSetNormColor</A>, <A HREF=#mgGetMatTextureLayer>mgGetMatTextureLayer</A>, <A HREF=#mgGetAttList>mgGetAttList</A>, <A HREF=#mgGetAttBuf>mgGetAttBuf</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetNthRecInList><H1 CLASS="APISYMBOL">mgGetNthRecInList</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetNthRecInList</B> - returns the nth item in the record list.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetNthRecInList</B> (</TD><TD><A HREF=#mgreclist>mgreclist</A></TD><TD><I>recList</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>nth</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec, mgmatrix <B>mgGetNthRecInList</B> (</TD><TD><A HREF=#mgreclist>mgreclist</A></TD><TD><I>recList</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>nth</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetNthRecInList</B> returns the item in the specified record list 
<I>recList</I> that is at position <I>nth</I>.  The first item is at position 1.</P></DD><DD><P>This function does not affect the traversal pointer of the record list.</P></DD><DD><P>If this function is successful and the output parameter <I>matrix</I> 
is not <A HREF=#MG_NULL>MG_NULL</A>, it is loaded with the composite matrix representing 
the cumulative transformations applied to this item.  If you do not need 
this matrix, you may specify <I>matrix</I> as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>recList</I></DT><DD>the record list to traverse</DD><DT><I>matrix</I></DT><DD>the address of a matrix to receive 
the composite of all transformations above 
the returned record list item</DD><DT><I>nth</I></DT><DD>the position in the list of the 
item to get, 1 (one) is the first item</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgrec</DT><DD>The nth item in the record list, <A HREF=#MG_NULL>MG_NULL</A> if 
nth item is not in the list.</DD><DT>mgmatrix</DT><DD>If an item is returned, the output parameter 
<I>matrix</I> (if specified) is loaded with the composite matrix representing 
the cumulative transformations applied to this item.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResetRecList>mgResetRecList</A>, <A HREF=#mgGetNextRecInList>mgGetNextRecInList</A>, <A HREF=#mgIsRecInList>mgIsRecInList</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetOpenFlightVersion><H1 CLASS="APISYMBOL">mgGetOpenFlightVersion</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetOpenFlightVersion</B> - returns the OpenFlight file format 
version corresponding to the current OpenFlight API version running.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetOpenFlightVersion</B> (</TD><TD>char*</TD><TD><I>version</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maxLen</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, string <B>mgGetOpenFlightVersion</B> (  )
</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetOpenFlightVersion</B> returns the version of the OpenFlight file 
format that will be written out by the current OpenFlight API version loaded in the 
program runtime environment.  The version is returned in <I>version</I> 
as a character string of the form "MMmm" where:</P></DD><DD><P><B>MM</B> is the major revision number, e.g. 15<BR> 
<B>mm</B> is the minor revision number, e.g. 80<BR></P></DD><DD><P>Use this function to determine, at runtime, which version of the 
OpenFlight file format would be written out by the API. Use the macro 
<A HREF=#MVERSION_OPENFLIGHT>MVERSION_OPENFLIGHT</A> to determine which version 
of the OpenFlight Format your code is compiled and linked against.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>version</I></DT><DD>address of string to receive OpenFlight version string</DD><DT><I>maxLen</I></DT><DD>maximum number of characters to store in 
<I>version</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if version retrieved successfully, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>string</DT><DD>If function is successful, string contains the version, otherwise undefined.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>In this example, the code was compiled against version 1560 of 
the OpenFlight Format and is running with version 1580.</DT><DT><PRE CLASS="EXAMPLE">char runTimeVersion [20];
char linkTimeVersion [20];

// runTimeVersion will contain "1580"
mgGetOpenFlightVersion (runTimeVersion, 20);

// linkTimeVersion will contain "1560"
strncpy (linkTimeVersion, MVERSION_OPENFLIGHT, 20);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#MVERSION_API>MVERSION_API</A>, <A HREF=#mgGetVersion>mgGetVersion</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetPaneLayout><H1 CLASS="APISYMBOL">mgGetPaneLayout</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetPaneLayout</B> - gets the current pane layout.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetPaneLayout</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgpanelayout>mgpanelayout</A></TD><TD><I>layout</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetPaneLayout</B> copies the current pane layout settings in <I>db</I> 
into the given&#32<I>layout</I>. Pane settings constitute location of splitters 
and the pane type (graphics view, structure view, etc). The <I>layout</I> must 
be allocated with a call to <A HREF=#mgNewPaneLayout>mgNewPaneLayout</A>&#32prior to use.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>layout</I></DT><DD>the address of the struct to 
receive the layout record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
On success current pane layout is copied into <I>layout</I>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewPaneLayout>mgNewPaneLayout</A>, <A HREF=#mgFreePaneLayout>mgFreePaneLayout</A>, <A HREF=#mgSetPaneLayout>mgSetPaneLayout</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetParamBlock><H1 CLASS="APISYMBOL">mgGetParamBlock</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetParamBlock</B> - gets a parameter block for a tool.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgparamblock <B>mgGetParamBlock</B> (</TD><TD>const char*</TD><TD><I>commandName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetParamBlock</B> creates a new parameter block initialized with 
the values for the Creator command identified by <I>commandName</I>. The 
parameter block returned is typically used to pass to <A HREF=#mgExecute>mgExecute</A> to 
execute a Creator command.</P></DD><DD><P>See the example code in <A HREF=#mgExecute>mgExecute</A>.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The parameter block is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using 
<A HREF=#mgFreeParamBlock>mgFreeParamBlock</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned parameter block in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>commandName</I></DT><DD>the Creator command for the 
parameter block returned</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Pointer to parameter block if created successfully, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgparamblock>mgparamblock</A>, <A HREF=#mgFreeParamBlock>mgFreeParamBlock</A>, <A HREF=#mgNewParamBlock>mgNewParamBlock</A>, 
<A HREF=#mgExecute>mgExecute</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetParent><H1 CLASS="APISYMBOL">mgGetParent</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetParent</B> - gets the parent of a node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetParent</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetParent</B> returns the parent of the specified node <I>rec</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to get parent for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the node if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, <A HREF=#mgGetChild>mgGetChild</A>, <A HREF=#mgGetChildNth>mgGetChildNth</A>, <A HREF=#mgGetAttrChild>mgGetAttrChild</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetPixmapHandle><H1 CLASS="APISYMBOL">mgGetPixmapHandle</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetPixmapHandle</B> - returns a native pixmap handle.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgpixmaphandle <B>mgGetPixmapHandle</B> (</TD><TD><A HREF=#mgpixmap>mgpixmap</A></TD><TD><I>pixmap</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given an abstract <I>pixmap</I>, this function returns 
a platform specific handle to the pixmap in its native format.</P></DD><DD><P>On Windows, both bitmaps and icons can be represented as pixmaps.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pixmap</I></DT><DD>abstract pixmap to extract native bitmap</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>On Windows, this function returns an object of type HBITMAP or 
HICON depending on the underlying format of the image in the resource file 
when it was extracted into the abstract <I>pixmap</I>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgLoadResource>mgLoadResource</A>, <A HREF=#mgResourceGetPixmap>mgResourceGetPixmap</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetPlane><H1 CLASS="APISYMBOL">mgGetPlane</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetPlane</B> - gets values out of a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDPlane>fltDPlane</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetPlane</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>planeCode</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>a</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>b</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>c</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>d</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, a, b, c, d <B>mgGetPlane</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>planeCode</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a record <I>rec</I>, <B>mgGetPlane</B> gets the values of <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDPlane>fltDPlane</A>
 
attribute record <I>planeCode</I> from <I>rec</I> and stores them in <I>a</I>, <I>b</I>, 
<I>c</I> and <I>d</I>.</P></DD><DD><P>You do not have to provide addresses for all <I>a</I>, <I>b</I>, <I>c</I>, and <I>d</I> values. 
For example, if you only want to receive the a, b and c coefficients (but not d), specify 
valid addresses for <I>a</I>, <I>b</I>, and <I>c</I> and leave <I>d</I> NULL.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record from which to get the 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDPlane>fltDPlane</A>
 attribute record</DD><DT><I>planeCode</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDPlane>fltDPlane</A>
 attribute record code</DD><DT><I>a</I></DT><DD>address of value to receive a coefficient</DD><DT><I>b</I></DT><DD>address of value to receive b coefficient</DD><DT><I>c</I></DT><DD>address of value to receive c coefficient</DD><DT><I>d</I></DT><DD>address of value to receive d coefficient</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the plane was retrieved successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>a</DT><DD>If function is successful, a contains the retrieved a coefficient, otherwise 
a is undefined.</DD><DT>b</DT><DD>If function is successful, b contains the retrieved b coefficient, otherwise 
b is undefined.</DD><DT>c</DT><DD>If function is successful, c contains the retrieved c coefficient, otherwise 
c is undefined.</DD><DT>d</DT><DD>If function is successful, d contains the retrieved d coefficient, otherwise 
d is undefined.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* db;
mgrec* clipRec;
mgplaned plane;

db = mgOpenDb ("file.flt");

// create clip rec
clipRec = UserMakeClipRec (db);

mgGetPlane (clipRec, fltClipPlane0, &plane.a, &plane.b,
&#32&#32&#32&#32&#32&plane.c, &plane.d);</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetPlane>mgSetPlane</A>, <A HREF=#mgGetAttList>mgGetAttList</A>, <A HREF=#mgGetAttBuf>mgGetAttBuf</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetPolyAltColorName><H1 CLASS="APISYMBOL">mgGetPolyAltColorName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetPolyAltColorName</B> - gets the alternate color name of 
a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char* <B>mgGetPolyAltColorName</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>poly</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 record, <I>poly</I>, <B>mgGetPolyAltColorName</B> 
returns the alternate color name for the polygon.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned string in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>poly</I></DT><DD>a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the alternate color name for the polygon if successful, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetPolyAltColorName>mgSetPolyAltColorName</A>, 
<A HREF=#mgGetPolyColorName>mgGetPolyColorName</A>, <A HREF=#mgSetPolyColorName>mgSetPolyColorName</A>, 
<A HREF=#mgNewColorName>mgNewColorName</A>, <A HREF=#mgGetNextColorName>mgGetNextColorName</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetPolyAltColorRGB><H1 CLASS="APISYMBOL">mgGetPolyAltColorRGB</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetPolyAltColorRGB</B> - gets the alternate RGB color 
values out of a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetPolyAltColorRGB</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>red</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>green</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>blue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, red, green, blue <B>mgGetPolyAltColorRGB</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record, <I>rec</I>, this 
function gets the red, green, and blue values of its 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyAltColor</A>
 attribute.</P></DD><DD><P>Colors set in index mode are automatically converted to RGB values.  The color values 
returned are in the range 0..255.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 
record from which to get the color values</DD><DT><I>red</I></DT><DD>the red component</DD><DT><I>green</I></DT><DD>the green component</DD><DT><I>blue</I></DT><DD>the blue component</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>red</DT><DD>If function is successful, red contains the retrieved value, otherwise 
red is undefined.</DD><DT>green</DT><DD>If function is successful, green contains the retrieved value, otherwise 
green is undefined.</DD><DT>blue</DT><DD>If function is successful, blue contains the retrieved value, otherwise 
blue is undefined.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* db;
mgrec* rec;
short r, g, b;
mgbool status;

db = mgOpenDb ("file.flt");

// create polygon or Mesh rec
rec = UserMakePolyOrMeshRec (db);

status = mgGetPolyAltColorRGB (rec, &r, &g, &b);
if (status == MG_TRUE) {
   // r, g and b contain the color components
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetPolyAltColorRGB>mgSetPolyAltColorRGB</A>, <A HREF=#mgGetPolyColorRGB>mgGetPolyColorRGB</A>, <A HREF=#mgSetPolyColorRGB>mgSetPolyColorRGB</A>, 
<A HREF=#mgGetVtxColorRGB>mgGetVtxColorRGB</A>, <A HREF=#mgSetVtxColorRGB>mgSetVtxColorRGB</A>, 
<A HREF=#mgGetVtxColorRGBA>mgGetVtxColorRGBA</A>, <A HREF=#mgSetVtxColorRGBA>mgSetVtxColorRGBA</A>, 
<A HREF=#mgGetVtxBackColorRGB>mgGetVtxBackColorRGB</A>, 
<A HREF=#mgGetAttList>mgGetAttList</A>, <A HREF=#mgGetAttBuf>mgGetAttBuf</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetPolyColorName><H1 CLASS="APISYMBOL">mgGetPolyColorName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetPolyColorName</B> - gets the primary color name of 
a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char* <B>mgGetPolyColorName</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>poly</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 record, <I>poly</I>, <B>mgGetPolyColorName</B> returns the 
color name for the polygon.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned string in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>poly</I></DT><DD>a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the primary color name for the polygon if successful, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetPolyColorName>mgSetPolyColorName</A>, 
<A HREF=#mgGetPolyAltColorName>mgGetPolyAltColorName</A>, <A HREF=#mgSetPolyAltColorName>mgSetPolyAltColorName</A>, 
<A HREF=#mgNewColorName>mgNewColorName</A>, <A HREF=#mgGetNextColorName>mgGetNextColorName</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetPolyColorRGB><H1 CLASS="APISYMBOL">mgGetPolyColorRGB</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetPolyColorRGB</B> - gets the primary RGB color values out of a 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetPolyColorRGB</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>red</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>green</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>blue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, red, green, blue <B>mgGetPolyColorRGB</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record, <I>rec</I>, this function 
gets the red, green, and blue values of its <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyPrimeColor</A>
 attribute.</P></DD><DD><P>Colors set in index mode are automatically converted to RGB values.  The color values 
returned are in the range 0..255.</P></DD><DD><P>You do not have to provide addresses for all <I>red</I>, <I>green</I>, and <I>blue</I> values.  For 
example, if you only want to receive the red and blue components (but not green), specify valid 
addresses for <I>red</I> and <I>blue</I> and leave <I>green</I> NULL.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record from 
which to get the color values</DD><DT><I>red</I></DT><DD>the red component</DD><DT><I>green</I></DT><DD>the green component</DD><DT><I>blue</I></DT><DD>the blue component</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>red</DT><DD>If function is successful, red contains the retrieved value, otherwise 
red is undefined.</DD><DT>green</DT><DD>If function is successful, green contains the retrieved value, otherwise 
green is undefined.</DD><DT>blue</DT><DD>If function is successful, blue contains the retrieved value, otherwise 
blue is undefined.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* rec;
short r, g, b;
mgbool status;

db = mgOpenDb ("file.flt");

// create polygon or mesh record
rec = UserMakePolyOrMeshRec (db);

status = mgGetPolyColorRGB (rec, &r, &g, &b);
if (status == MG_TRUE) {
   // r, g and b contain the color components
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetPolyColorRGB>mgSetPolyColorRGB</A>, <A HREF=#mgGetPolyAltColorRGB>mgGetPolyAltColorRGB</A>, <A HREF=#mgSetPolyAltColorRGB>mgSetPolyAltColorRGB</A>, 
<A HREF=#mgGetVtxColorRGB>mgGetVtxColorRGB</A>, <A HREF=#mgSetVtxColorRGB>mgSetVtxColorRGB</A>, 
<A HREF=#mgGetVtxColorRGBA>mgGetVtxColorRGBA</A>, <A HREF=#mgSetVtxColorRGBA>mgSetVtxColorRGBA</A>, 
<A HREF=#mgGetVtxBackColorRGB>mgGetVtxBackColorRGB</A>, 
<A HREF=#mgGetAttList>mgGetAttList</A>, <A HREF=#mgGetAttBuf>mgGetAttBuf</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetPolyNormal><H1 CLASS="APISYMBOL">mgGetPolyNormal</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetPolyNormal</B> - retrieves the normal vector from a 
polygon record.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetPolyNormal</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>i</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>j</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>k</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, i, j, k <B>mgGetPolyNormal</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetPolyNormal</B> retrieves the <I>i</I>, <I>j</I>, and <I>k</I> values of the 
polygon normal vector from a polygon record <I>rec</I>.</P></DD><DD><P>You do not have to provide addresses for all <I>i</I>, <I>j</I>, and <I>k</I> values.  For 
example, if you only want to receive the i and j components (but not k), specify valid 
addresses for <I>i</I> and <I>j</I> and leave <I>k</I> NULL.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>a polygon record</DD><DT><I>i</I></DT><DD>address of value to receive i component of normal vector</DD><DT><I>j</I></DT><DD>address of value to receive j component of normal vector</DD><DT><I>k</I></DT><DD>address of value to receive k component of normal vector</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the polygon has a normal vector, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>i</DT><DD>If function is successful, i contains the retrieved value, otherwise 
i is undefined.</DD><DT>j</DT><DD>If function is successful, j contains the retrieved value, otherwise 
j is undefined.</DD><DT>k</DT><DD>If function is successful, k contains the retrieved value, otherwise 
k is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetVtxNormal>mgGetVtxNormal</A>, <A HREF=#mgSetVtxNormal>mgSetVtxNormal</A>, <A HREF=#mgRemoveVtxNormal>mgRemoveVtxNormal</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetPrevious><H1 CLASS="APISYMBOL">mgGetPrevious</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetPrevious</B> - gets the previous immediate sibling of a node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetPrevious</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetPrevious</B> returns the previous immediate sibling of the 
specified node <I>rec</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to get previous sibling</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the node if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, <A HREF=#mgGetNext>mgGetNext</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetRecByName><H1 CLASS="APISYMBOL">mgGetRecByName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetRecByName</B> - finds a node by identifier.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetRecByName</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>name</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetRecByName</B> searches the specified database <I>db</I>, and locates 
the node in the database that has identifier <I>name</I>. Each node has a unique 
case-sensitive identifier hence there is a one-to-one correspondence between 
the identifier <I>name</I> and the node returned.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>name</I></DT><DD>the identifier of the node to find</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the node if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetName>mgGetName</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetRecListCount><H1 CLASS="APISYMBOL">mgGetRecListCount</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetRecListCount</B> - counts the number of items in a record list.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgGetRecListCount</B> (</TD><TD><A HREF=#mgreclist>mgreclist</A></TD><TD><I>recList</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetRecListCount</B> returns the number of items contained in the 
specified record list <I>recList</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>recList</I></DT><DD>the record list to count items for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of items in the record list, 
and returns 0 if list is empty.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetSelectList>mgGetSelectList</A>, <A HREF=#mgGetConstructList>mgGetConstructList</A>, <A HREF=#mgGetTriangleList>mgGetTriangleList</A>, 
<A HREF=#mgSelectOne>mgSelectOne</A>, <A HREF=#mgDeselectOne>mgDeselectOne</A>, <A HREF=#mgIsSelected>mgIsSelected</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetRecListLevel><H1 CLASS="APISYMBOL">mgGetRecListLevel</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetRecListLevel</B> - returns the level of the record list.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcode <B>mgGetRecListLevel</B> (</TD><TD><A HREF=#mgreclist>mgreclist</A></TD><TD><I>recList</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetRecListLevel</B> returns the node level of the first item 
in the specified record list <I>recList</I>.</P></DD><DD><P>Nodes contained in a record list are not guaranteed to 
all be of the same level.  This level returned by this function may 
not be indicative of all nodes contained in the record list.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>recList</I></DT><DD>the record list to get level</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the node level of the first item in the list, and returns 
0 if list is empty.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetRecListCount>mgGetRecListCount</A>, <A HREF=#mgIsRecInList>mgIsRecInList</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetReference><H1 CLASS="APISYMBOL">mgGetReference</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetReference</B> - finds the reference node for an instance node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetReference</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetReference</B> returns the reference node for the specified instance 
node <I>rec</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to get reference for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the node if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, <A HREF=#mgIsInstance>mgIsInstance</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetRegistryRoot><H1 CLASS="APISYMBOL">mgGetRegistryRoot</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetRegistryRoot</B> - returns the root name of the Creator registry.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetRegistryRoot</B> (</TD><TD>char*</TD><TD><I>rootString</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maxLen</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, string <B>mgGetRegistryRoot</B> (  )
</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetRegistryRoot</B> returns the root path of the registry currently in 
use by Creator.  The output string is truncated and null terminated if it is 
longer than <I>maxLen</I> characters.</P></DD><DD><P>This function is only applicable on the Windows operation system platform 
in the Creator modeler environment.  This function will always return <A HREF=#mgbool>MG_FALSE</A> 
when called by a stand-alone application or from any code running on IRIX.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rootString</I></DT><DD>character buffer to hold the root path</DD><DT><I>maxLen</I></DT><DD>maximum number of characters to store in <I>rootString</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if registry root retrieved successfully, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>string</DT><DD>If function is successful, string contains the root path, otherwise undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetRegistryString>mgGetRegistryString</A>, <A HREF=#mgSetRegistryString>mgSetRegistryString</A>, 
<A HREF=#mgLoadResource>mgLoadResource</A>, <A HREF=#mgGetModuleHandle>mgGetModuleHandle</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetRegistryString><H1 CLASS="APISYMBOL">mgGetRegistryString</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetRegistryString</B> - returns the value of a Creator registry key.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetRegistryString</B> (</TD><TD>const char*</TD><TD><I>keyName</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>keyString</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maxLen</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, string <B>mgGetRegistryString</B> (  )
</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetRegistryString</B> returns the value of the specified Creator registry 
key <I>keyName</I> in the output string <I>keyString</I>.  The output string is truncated 
and null terminated if it is longer than <I>maxLen</I> characters.</P></DD><DD><P>This function is only applicable on the Windows operation system platform 
in the Creator modeler environment.  This function will always return <A HREF=#mgbool>MG_FALSE</A> 
when called by a stand-alone application or from any code running on IRIX.</P></DD><DD><P>The key is looked up in the Windows system registry corresponding to that 
currently in use by the running version of Creator.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>keyName</I></DT><DD>the name of the key to look up in the Creator 
registry</DD><DT><I>keyString</I></DT><DD>character buffer to hold the key value</DD><DT><I>maxLen</I></DT><DD>maximum number of characters to store in <I>keyString</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if registry string retrieved successfully, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>string</DT><DD>If function is successful, string contains the registry string, otherwise undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetRegistryString>mgSetRegistryString</A>, <A HREF=#mgGetRegistryRoot>mgGetRegistryRoot</A>, 
<A HREF=#mgLoadResource>mgLoadResource</A>, <A HREF=#mgGetModuleHandle>mgGetModuleHandle</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetSelectedTextureCount><H1 CLASS="APISYMBOL">mgGetSelectedTextureCount</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetSelectedTextureCount</B> - gets the number of entries currently 
selected in a texture palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgGetSelectedTextureCount</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetSelectedTextureCount</B> returns the number of entries currently 
selected in the texture palette of database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of selected texture palette entries if successful, 
or returns -1 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSelectTextureIndex>mgSelectTextureIndex</A>, 
<A HREF=#mgDeselectTextureIndex>mgDeselectTextureIndex</A>, 
<A HREF=#mgDeselectAllTextures>mgDeselectAllTextures</A>, 
<A HREF=#mgGetFirstSelectedTexture>mgGetFirstSelectedTexture</A>, 
<A HREF=#mgGetNextSelectedTexture>mgGetNextSelectedTexture</A>, 
<A HREF=#mgIsTextureIndexSelected>mgIsTextureIndexSelected</A>, 
<A HREF=#mgGetTextureCount>mgGetTextureCount</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetSelectList><H1 CLASS="APISYMBOL">mgGetSelectList</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetSelectList</B> - gets the current modeling select list.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgreclist <B>mgGetSelectList</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetSelectList</B> creates a new record list containing all the 
currently selected nodes in the specified database <I>db</I>.  The traversal 
pointer of the record list returned is set to the first item in the list.</P></DD><DD><P>This function returns a record list object that reflects the state 
of the select list when it was called.  Typically call this function, 
examine the contents of the record list returned and then dispose of the 
record list when you are done.  If you retain the record list, its contents 
is not guaranteed to be valid if the modeler subsequently changes the 
select list in Creator or deletes an item that your record list 
contains.</P></DD><DD><P>Note that the order of the nodes in the record list returned 
are "reversed" from how they were selected by the user in Creator. 
That means that for a record list containing N items, the first time 
you call <A HREF=#mgGetNextRecInList>mgGetNextRecInList</A> or call <A HREF=#mgGetNthRecInList>mgGetNthRecInList</A> with 
parameter <I>nth</I> equal to 1, you will receive the  <I>last</I> or <I>Nth</I> 
item selected by the user in Creator, not the <I>first</I>. If you need 
to receive the nodes in the same order as that selected by the user, 
simply use <A HREF=#mgGetNthRecInList>mgGetNthRecInList</A>, starting with <I>nth</I> equal to N 
and ending with 1.</P></DD><DD><P>When you are done accessing the record list returned by this 
function, you should dispose of it using <A HREF=#mgFreeRecList>mgFreeRecList</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to dispose of the record list 
returned in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database to get the select list for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a record list object containing all the currently selected 
nodes in database, <A HREF=#MG_NULL>MG_NULL</A> if nothing is currently selected.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example gets the select list for database <I>db</I> 
and traverses each node it contains.</DT><DT><PRE CLASS="EXAMPLE">mgrec* rec;
mgmatrix selectMatrix;
mgreclist selectList = mgGetSelectList (db);

rec = mgGetNextRecInList (selectList, &selectMatrix);
while (rec)
{
   // do something with rec
   rec = mgGetNextRecInList (selectList, &selectMatrix);
}
// all done with record list, deallocate it
mgFreeRecList (selectList);</PRE></DT></DL></DD></DL>

<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT>The following example gets the select list for database <I>db</I> 
and traverses each node it contains</DT><DT><PRE CLASS="EXAMPLE">selectList = mgGetSelectList (db)
num = mgGetRecListCount (selectList)

for i in range (0, num):
   rec,matrix = mgGetNextRecInList (selectList)

# you don't need to deallocate the record list in Python</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgreclist>mgreclist</A>, <A HREF=#mgFreeRecList>mgFreeRecList</A>, 
<A HREF=#mgResetRecList>mgResetRecList</A>, <A HREF=#mgGetNextRecInList>mgGetNextRecInList</A>, <A HREF=#mgGetNthRecInList>mgGetNthRecInList</A>, 
<A HREF=#mgGetRecListCount>mgGetRecListCount</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetShader><H1 CLASS="APISYMBOL">mgGetShader</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetShader</B> - gets an entry record from a 
database&#146s shader palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetShader</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetShader</B> gets the shader entry record defined by 
<I>index</I> from the shader palette of database node <I>db</I>.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltShaderPalette>fltShaderPalette</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the shader palette index</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the shader entry record if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgIndexOfShader>mgIndexOfShader</A>, <A HREF=#mgNewShader>mgNewShader</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetShaderCount><H1 CLASS="APISYMBOL">mgGetShaderCount</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetShaderCount</B> - gets the number of entries in a 
database&#146s shader palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgGetShaderCount</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a database node, <I>db</I>, <B>mgGetShaderCount</B> gets the number 
of entries in the database&#146s shader palette.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of entries in the database&#146s shader palette.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetFirstShader>mgGetFirstShader</A>, <A HREF=#mgGetNextShader>mgGetNextShader</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetShaderProgramSaveName><H1 CLASS="APISYMBOL">mgGetShaderProgramSaveName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetShaderProgramSaveName</B> - gets the save name of a shader 
program file.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char* <B>mgGetShaderProgramSaveName</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>programFilename</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetShaderProgramSaveName</B> returns the save name of a shader 
program file contained in the shader palette of database <I>db</I>.</P></DD><DD><P>The save name of a shader program is the actual name that is saved 
in the OpenFlight database file for this shader palette entry.  The 
save name may or may not include the full path specification of the 
shader program file.  If the shader program files for a database are 
saved using relative names, the save name of a shader program will 
be a relative name and will begin with the character sequence "./". 
If the shader program files are saved using absolute names, the save 
name will include the full path specification of the shader program. 
If the shader program files are saved with no path, the save 
name will simply be the name of the file.</P></DD><DD><P>You can determine how shader program names are saved using 
the function <A HREF=#mgShaderGetSavePathType>mgShaderGetSavePathType</A>.  Similarly, you can change 
how shader program names are saved using <A HREF=#mgShaderSetSavePathType>mgShaderSetSavePathType</A>.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned string in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>programFilename</I></DT><DD>the shader program file</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the save name of the shader program if found, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgShaderGetSavePathType>mgShaderGetSavePathType</A>, <A HREF=#mgShaderSetSavePathType>mgShaderSetSavePathType</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetSound><H1 CLASS="APISYMBOL">mgGetSound</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetSound</B> - gets an entry record from a database&#146s sound palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetSound</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetSound</B> returns the sound entry record defined by <I>index</I> from the sound 
palette of <I>db</I>. If the requested sound does not exist, <A HREF=#MG_NULL>MG_NULL</A> is returned.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSoundPalette>fltSoundPalette</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the sound to retrieve</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the sound entry record if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">int sndindex;
mgrec *sound, *db;
db = mgOpenDb ("anyfile.flt");
if (sound = mgGetSound (db, 0)) {
   mgGetAttList (sound, fltSndIndex, &sndindex, MG_NULL);
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetSoundCount>mgGetSoundCount</A>, <A HREF=#mgGetFirstSound>mgGetFirstSound</A>, <A HREF=#mgGetNextSound>mgGetNextSound</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetSoundCount><H1 CLASS="APISYMBOL">mgGetSoundCount</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetSoundCount</B> - gets the number of entries in a 
database&#146s sound palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> int <B>mgGetSoundCount</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetSoundCount</B> gets the number of sound entries 
for a given database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of sound entries.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetSound>mgGetSound</A>, <A HREF=#mgGetFirstSound>mgGetFirstSound</A>, <A HREF=#mgGetNextSound>mgGetNextSound</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetSwitchBit><H1 CLASS="APISYMBOL">mgGetSwitchBit</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetSwitchBit</B> - gets the on/off status of a specific bit 
within a switch mask.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetSwitchBit</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maskNo</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>bitNo</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool*</A></TD><TD><I>on</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, on <B>mgGetSwitchBit</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maskNo</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>bitNo</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSwitch>fltSwitch</A>
 node, <I>rec</I>, <B>mgGetSwitchBit</B> checks 
if the bit specified by <I>bitNo</I> within the mask <I>maskNo</I> is on or off. 
The result is returned via <I>on</I>.</P></DD><DD><P>The value of <I>bitNo</I> must be between 0 and the number of 
children of <I>rec</I> minus 1 (the first child is <I>bitNo</I> 0). 
Similarly, the value of <I>maskNo</I> must be between 0 and the 
number of masks of <I>rec</I> minus 1 (the first mask is <I>maskNo</I> 0).</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSwitch>fltSwitch</A>
 node</DD><DT><I>maskNo</I></DT><DD>switch mask number starting from 0</DD><DT><I>bitNo</I></DT><DD>bit number starting from 0</DD><DT><I>on</I></DT><DD>address of value to receive on/off status</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if switch bit retrieved successfully, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.  This function will fail if <I>maskNo</I> does not specify 
a valid mask or <I>bitNo</I> does not specify a valid bit of the mask of <I>rec</I>.</DD><DT>on</DT><DD><A HREF=#mgbool>MG_TRUE</A> if switch bit is on, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetSwitchMaskCount>mgGetSwitchMaskCount</A>, 
<A HREF=#mgGetSwitchMaskNo>mgGetSwitchMaskNo</A>, 
<A HREF=#mgGetSwitchMaskName>mgGetSwitchMaskName</A>, 
<A HREF=#mgAddSwitchMask>mgAddSwitchMask</A>, 
<A HREF=#mgDeleteSwitchMask>mgDeleteSwitchMask</A>, 
<A HREF=#mgInitSwitchMask>mgInitSwitchMask</A>, 
<A HREF=#mgSetSwitchBit>mgSetSwitchBit</A>, 
<A HREF=#mgSetSwitchMaskName>mgSetSwitchMaskName</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetSwitchDistance><H1 CLASS="APISYMBOL">mgGetSwitchDistance</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetSwitchDistance</B> - gets the current switch distance for a 
database<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetSwitchDistance</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>distance</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, distance <B>mgGetSwitchDistance</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetSwitchDistance</B> gets the current switch distance for the database 
<I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>distance</I></DT><DD>address of value to receive distance</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if distance retrieved successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>distance</DT><DD>If function is successful, distance contains the retrieved switch distance, otherwise 
distance is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetSwitchDistance>mgSetSwitchDistance</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetSwitchMaskCount><H1 CLASS="APISYMBOL">mgGetSwitchMaskCount</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetSwitchMaskCount</B> - gets the number of switch masks defined 
for a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSwitch>fltSwitch</A>
 node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgGetSwitchMaskCount</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetSwitchMaskCount</B> returns the number of masks defined for 
the specified <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSwitch>fltSwitch</A>
 node <I>rec</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSwitch>fltSwitch</A>
 node</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of masks defined for <I>rec</I>.  Since 
all <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSwitch>fltSwitch</A>
 nodes have at least one mask, the value returned 
by this function will be at least 1.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetSwitchMaskNo>mgGetSwitchMaskNo</A>, 
<A HREF=#mgGetSwitchBit>mgGetSwitchBit</A>, 
<A HREF=#mgGetSwitchMaskName>mgGetSwitchMaskName</A>, 
<A HREF=#mgAddSwitchMask>mgAddSwitchMask</A>, 
<A HREF=#mgDeleteSwitchMask>mgDeleteSwitchMask</A>, 
<A HREF=#mgInitSwitchMask>mgInitSwitchMask</A>, 
<A HREF=#mgSetSwitchBit>mgSetSwitchBit</A>, 
<A HREF=#mgSetSwitchMaskName>mgSetSwitchMaskName</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetSwitchMaskName><H1 CLASS="APISYMBOL">mgGetSwitchMaskName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetSwitchMaskName</B> - gets the name of a switch mask.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char* <B>mgGetSwitchMaskName</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maskNo</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSwitch>fltSwitch</A>
 node, <I>rec</I>, <B>mgGetSwitchMaskName</B> returns 
the name assigned to the mask <I>maskNo</I>.</P></DD><DD><P>The value of <I>maskNo</I> must be between 0 and the number of masks 
of <I>rec</I> minus 1 (the first mask is <I>maskNo</I> 0).</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned string in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSwitch>fltSwitch</A>
 node</DD><DT><I>maskNo</I></DT><DD>switch mask number starting from 0</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the name of the switch mask if it exists and is named, <A HREF=#MG_NULL>MG_NULL</A> otherwise. 
This function will fail if <I>maskNo</I> does not specify a valid mask of <I>rec</I>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetSwitchMaskName>mgSetSwitchMaskName</A>, 
<A HREF=#mgGetSwitchMaskCount>mgGetSwitchMaskCount</A>, 
<A HREF=#mgGetSwitchMaskNo>mgGetSwitchMaskNo</A>, 
<A HREF=#mgGetSwitchBit>mgGetSwitchBit</A>, 
<A HREF=#mgAddSwitchMask>mgAddSwitchMask</A>, 
<A HREF=#mgDeleteSwitchMask>mgDeleteSwitchMask</A>, 
<A HREF=#mgInitSwitchMask>mgInitSwitchMask</A>, 
<A HREF=#mgSetSwitchBit>mgSetSwitchBit</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetSwitchMaskNo><H1 CLASS="APISYMBOL">mgGetSwitchMaskNo</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetSwitchMaskNo</B> - gets the current mask index of a 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSwitch>fltSwitch</A>
 node.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetSwitchMaskNo</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>maskNo</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, maskNo <B>mgGetSwitchMaskNo</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>A <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSwitch>fltSwitch</A>
 node contains at least one mask.  <B>mgGetSwitchMaskNo</B> 
returns the mask index currently being used to define the on/off display behavior 
of the switch node&#146s children.  The first switch mask is number 0. The mask index is 
set to -1 if unsuccessful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSwitch>fltSwitch</A>
 node</DD><DT><I>maskNo</I></DT><DD>address of value to receive mask number</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if switch mask index retrieved successfully, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>maskNo</DT><DD>If function is successful, maskNo contains the retrieved index, otherwise 
maskNo is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetSwitchMaskCount>mgGetSwitchMaskCount</A>, 
<A HREF=#mgGetSwitchBit>mgGetSwitchBit</A>, 
<A HREF=#mgGetSwitchMaskName>mgGetSwitchMaskName</A>, 
<A HREF=#mgAddSwitchMask>mgAddSwitchMask</A>, 
<A HREF=#mgDeleteSwitchMask>mgDeleteSwitchMask</A>, 
<A HREF=#mgInitSwitchMask>mgInitSwitchMask</A>, 
<A HREF=#mgSetSwitchBit>mgSetSwitchBit</A>, 
<A HREF=#mgSetSwitchMaskName>mgSetSwitchMaskName</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTextString><H1 CLASS="APISYMBOL">mgGetTextString</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextString</B> - gets the string in a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltText>fltText</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char* <B>mgGetTextString</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltText>fltText</A>
 record, <I>rec</I>, <B>mgGetTextString</B> returns the 
string stored in the record.</P></DD><DD><P>Use <A HREF=#mgSetTextString>mgSetTextString</A> to change the string of a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltText>fltText</A>
 record.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned string in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltText>fltText</A>
 string if successful, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetTextString>mgSetTextString</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTextureAttributes><H1 CLASS="APISYMBOL">mgGetTextureAttributes</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextureAttributes</B> - gets the attributes record for 
a texture palette entry.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetTextureAttributes</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetTextureAttributes</B> gets the attributes record for 
a texture palette entry at the specified <I>index</I> contained in 
the texture palette of database <I>db</I>.</P></DD><DD><P>The texture palette maintains a cache of texture attribute records 
(one record in the cache for each of the textures in the palette). 
The record returned from this function is from this cache.  Since the 
record is from this cache you should not deallocate it. When the database 
<I>db</I> is closed, all the texture attribute records in the palette 
cache will be deallocated at that time.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltImage>fltImage</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the texture palette entry</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the texture attributes record if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetTextureAttributes>mgSetTextureAttributes</A>, <A HREF=#mgReadImageAttributes>mgReadImageAttributes</A>, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltImage>fltImage</A>
</DD></DL>
<HR>
<LEFT><A NAME=mgGetTextureCount><H1 CLASS="APISYMBOL">mgGetTextureCount</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextureCount</B> - gets the number of entries contained 
in a texture palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgGetTextureCount</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetTextureCount</B> returns the number of entries contained 
in the texture palette of database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of texture palette entries if successful, or 
returns -1 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetTextureSize>mgGetTextureSize</A>, <A HREF=#mgGetTextureTotalSize>mgGetTextureTotalSize</A>, <A HREF=#mgGetFirstTexture>mgGetFirstTexture</A>, 
<A HREF=#mgGetNextTexture>mgGetNextTexture</A>, 
<A HREF=#mgGetSelectedTextureCount>mgGetSelectedTextureCount</A>, <A HREF=#mgGetFirstSelectedTexture>mgGetFirstSelectedTexture</A>, 
<A HREF=#mgGetNextSelectedTexture>mgGetNextSelectedTexture</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTextureGeoCtlPt><H1 CLASS="APISYMBOL">mgGetTextureGeoCtlPt</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextureGeoCtlPt</B> - gets nth geo reference control 
point from a georeference info object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetTextureGeoCtlPt</B> (</TD><TD><A HREF=#mgimagegeoinfo>mgimagegeoinfo</A></TD><TD><I>geoInfo</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>imageX</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>imageY</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>projX</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>projY</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, imageX, imageY, projX, projY <B>mgGetTextureGeoCtlPt</B> (</TD><TD><A HREF=#mgimagegeoinfo>mgimagegeoinfo</A></TD><TD><I>geoInfo</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetTextureGeoCtlPt</B> gets a specified control point, <I>index</I> used 
to geo reference the image for the specified image geo info object, <I>geoInfo</I>. 
<I>imageX</I> and <I>imageY</I> specify the location of the control point in image 
coordinates relative to the origin specified by <A HREF=#mgGetTextureGeoImageOrigin>mgGetTextureGeoImageOrigin</A>. 
<I>projX</I> and <I>projY</I> specify the location of the control point in the 
projected coordinate system specified by <A HREF=#mgGetTextureGeoProjection>mgGetTextureGeoProjection</A>.  If the 
projection was specified as <A HREF=#MIMG_GEOPROJ_GEODETIC>MIMG_GEOPROJ_GEODETIC</A>, these coordinates will be 
in degrees Longitude and Latitude respectively.  If the projection was specified 
as <A HREF=#MIMG_GEOPROJ_UTM>MIMG_GEOPROJ_UTM</A>, these coordinates will be in meters of Northing and 
Easting respectively.</P></DD><DD><P>The first control point is at index 0.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>geoInfo</I></DT><DD>the georeference info object</DD><DT><I>index</I></DT><DD>the index of control point to get</DD><DT><I>imageX</I></DT><DD>address of double to receive 
image x value</DD><DT><I>imageY</I></DT><DD>address of double to receive 
image y value</DD><DT><I>projX</I></DT><DD>address of double to receive 
projection x value</DD><DT><I>projY</I></DT><DD>address of double to receive 
projection y value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the point was retrieved successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>imageX</DT><DD>If function is successful, imageX contains the retrieved x value, otherwise 
imageX is undefined.</DD><DT>imageY</DT><DD>If function is successful, imageY contains the retrieved y value, otherwise 
imageY is undefined.</DD><DT>projX</DT><DD>If function is successful, projX contains the retrieved x value, otherwise 
projX is undefined.</DD><DT>projY</DT><DD>If function is successful, projY contains the retrieved y value, otherwise 
projY is undefined.</DD></DL></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) illustrate the 
use of <A HREF=#mgReadImageGeoInfo>mgReadImageGeoInfo</A> and <B>mgGetTextureGeoCtlPt</B> to read 
a georeference info object for an image and examine the control points 
it contains.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">int imgError;
int numPoints;
mgbool ok;
int i;
mgimagegeoinfo info = MG_NULL;

imgError = mgReadImageGeoInfo ("c:/MyTextures/TrueMarble.16km.2700x1350.tif", &info);
if (imgError != MIMG_NO_ERROR)
   return;

ok = mgGetTextureGeoNumCtlPts (info, &numPoints)
if (ok != MG_TRUE)
   return;

printf ("Number of Control Points: %d&#92;n", numPoints);
for (i = 0; i &lt numPoints; i++)
{
   int iX, iY, pX, pY;
   ok = mgGetTextureGeoCtlPt (info, i, &iX, &iY, &pX, &pY);
   if (ok == MG_TRUE)
   {
      printf ("Point: %d Image X: %d Image Y: %d Projection X: %d Projection Y: %d&#92;n",
&#32       i, iX, iY, pX, pY);
   }
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">imgError, info = mgReadImageGeoInfo ("c:/MyTextures/TrueMarble.16km.2700x1350.tif")
if (imgError != MIMG_NO_ERROR):
   return

ok, numPoints = mgGetTextureGeoNumCtlPts (info)
if (ok != MG_TRUE):
   return

print "Number of Control Points:", numPoints
for i in range(0, numPoints):
   ok, iX, iY, pX, pY = mgGetTextureGeoCtlPt (info, i)
   if (ok == MG_TRUE):
      print "Point:",i,"Image X:",iX,"Image Y:",iY,"Projection X:",pX,"Projection Y:",pY</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadImageGeoInfo>mgReadImageGeoInfo</A>, <A HREF=#mgGetTextureGeoType>mgGetTextureGeoType</A>, 
<A HREF=#mgGetTextureGeoProjection>mgGetTextureGeoProjection</A>, <A HREF=#mgGetTextureGeoEarthModel>mgGetTextureGeoEarthModel</A>, 
<A HREF=#mgGetTextureGeoUTMZone>mgGetTextureGeoUTMZone</A>, <A HREF=#mgGetTextureGeoUTMHemisphere>mgGetTextureGeoUTMHemisphere</A>, 
<A HREF=#mgGetTextureGeoImageOrigin>mgGetTextureGeoImageOrigin</A>, <A HREF=#mgGetTextureGeoNumCtlPts>mgGetTextureGeoNumCtlPts</A>, 
<A HREF=#mgFreeImageGeoInfo>mgFreeImageGeoInfo</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTextureGeoEarthModel><H1 CLASS="APISYMBOL">mgGetTextureGeoEarthModel</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextureGeoEarthModel</B> - gets Earth model (Ellipsoid) 
from a georeference info object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetTextureGeoEarthModel</B> (</TD><TD><A HREF=#mgimagegeoinfo>mgimagegeoinfo</A></TD><TD><I>geoInfo</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>earthModel</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, earthModel <B>mgGetTextureGeoEarthModel</B> (</TD><TD><A HREF=#mgimagegeoinfo>mgimagegeoinfo</A></TD><TD><I>geoInfo</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetTextureGeoEarthModel</B> gets the Earth model (Ellipsoid) 
from the specified georeference info object <I>geoInfo</I>.</P></DD><DD><P>Valid values for the Earth model attribute 
are <A HREF=#MIMG_GEOEARTH_WGS84>MIMG_GEOEARTH_WGS84</A>, <A HREF=#MIMG_GEOEARTH_WGS72>MIMG_GEOEARTH_WGS72</A>, 
<A HREF=#MIMG_GEOEARTH_BESSEL>MIMG_GEOEARTH_BESSEL</A>, and <A HREF=#MIMG_GEOEARTH_CLARK1866>MIMG_GEOEARTH_CLARK1866</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>geoInfo</I></DT><DD>the georeference info object</DD><DT><I>earthModel</I></DT><DD>address of integer to receive 
earth model value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if model retrieved successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>earthModel</DT><DD>If function is successful, earthModel contains the retrieved model, otherwise 
earthModel is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadImageGeoInfo>mgReadImageGeoInfo</A>, <A HREF=#mgGetTextureGeoType>mgGetTextureGeoType</A>, 
<A HREF=#mgGetTextureGeoProjection>mgGetTextureGeoProjection</A>, <A HREF=#mgGetTextureGeoUTMZone>mgGetTextureGeoUTMZone</A>, 
<A HREF=#mgGetTextureGeoUTMHemisphere>mgGetTextureGeoUTMHemisphere</A>, <A HREF=#mgGetTextureGeoImageOrigin>mgGetTextureGeoImageOrigin</A>, 
<A HREF=#mgGetTextureGeoNumCtlPts>mgGetTextureGeoNumCtlPts</A>, <A HREF=#mgGetTextureGeoCtlPt>mgGetTextureGeoCtlPt</A>, 
<A HREF=#mgFreeImageGeoInfo>mgFreeImageGeoInfo</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTextureGeoImageOrigin><H1 CLASS="APISYMBOL">mgGetTextureGeoImageOrigin</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextureGeoImageOrigin</B> - gets image origin from a 
georeference info object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetTextureGeoImageOrigin</B> (</TD><TD><A HREF=#mgimagegeoinfo>mgimagegeoinfo</A></TD><TD><I>geoInfo</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>imageOrigin</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, imageOrigin <B>mgGetTextureGeoImageOrigin</B> (</TD><TD><A HREF=#mgimagegeoinfo>mgimagegeoinfo</A></TD><TD><I>geoInfo</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetTextureGeoImageOrigin</B> gets the width attribute from the 
specified georeference info object <I>geoInfo</I>.  The image origin 
specifies the origin and the positive y direction used by image 
geographic control points.</P></DD><DD><P>Valid values for the image origin attribute 
are <A HREF=#MIMG_GEOIMAGEORIGIN_LL>MIMG_GEOIMAGEORIGIN_LL</A> (the image origin is in the lower left corner 
and y increases toward the top), and <A HREF=#MIMG_GEOIMAGEORIGIN_UL>MIMG_GEOIMAGEORIGIN_UL</A> (the image 
origin is in the upper left corner of the image and increases toward the bottom).</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>geoInfo</I></DT><DD>the georeference info object</DD><DT><I>imageOrigin</I></DT><DD>address of integer to receive 
image origin value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if image origin retrieved successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>imageOrigin</DT><DD>If function is successful, imageOrigin contains the retrieved image origin, otherwise 
imageOrigin is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadImageGeoInfo>mgReadImageGeoInfo</A>, <A HREF=#mgGetTextureGeoType>mgGetTextureGeoType</A>, 
<A HREF=#mgGetTextureGeoProjection>mgGetTextureGeoProjection</A>, <A HREF=#mgGetTextureGeoEarthModel>mgGetTextureGeoEarthModel</A>, 
<A HREF=#mgGetTextureGeoUTMZone>mgGetTextureGeoUTMZone</A>, <A HREF=#mgGetTextureGeoUTMHemisphere>mgGetTextureGeoUTMHemisphere</A>, 
<A HREF=#mgGetTextureGeoNumCtlPts>mgGetTextureGeoNumCtlPts</A>, <A HREF=#mgGetTextureGeoCtlPt>mgGetTextureGeoCtlPt</A>, 
<A HREF=#mgFreeImageGeoInfo>mgFreeImageGeoInfo</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTextureGeoNumCtlPts><H1 CLASS="APISYMBOL">mgGetTextureGeoNumCtlPts</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextureGeoNumCtlPts</B> - gets number of control points 
from a georeference info object.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetTextureGeoNumCtlPts</B> (</TD><TD><A HREF=#mgimagegeoinfo>mgimagegeoinfo</A></TD><TD><I>geoInfo</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>numCoords</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetTextureGeoNumCtlPts</B> gets the number of control points from 
the specified georeference info object <I>geoInfo</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>geoInfo</I></DT><DD>the georeference info object</DD><DT><I>numCoords</I></DT><DD>address of integer to receive 
number of control points</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadImageGeoInfo>mgReadImageGeoInfo</A>, <A HREF=#mgGetTextureGeoType>mgGetTextureGeoType</A>, 
<A HREF=#mgGetTextureGeoProjection>mgGetTextureGeoProjection</A>, <A HREF=#mgGetTextureGeoEarthModel>mgGetTextureGeoEarthModel</A>, 
<A HREF=#mgGetTextureGeoUTMZone>mgGetTextureGeoUTMZone</A>, <A HREF=#mgGetTextureGeoUTMHemisphere>mgGetTextureGeoUTMHemisphere</A>, 
<A HREF=#mgGetTextureGeoImageOrigin>mgGetTextureGeoImageOrigin</A>, <A HREF=#mgGetTextureGeoCtlPt>mgGetTextureGeoCtlPt</A>, 
<A HREF=#mgFreeImageGeoInfo>mgFreeImageGeoInfo</A></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if numCoords retrieved successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>numCoords</DT><DD>If function is successful, numCoords contains the retrieved number of coords, otherwise 
numCoords is undefined.</DD></DL></DL>
<HR>
<LEFT><A NAME=mgGetTextureGeoProjection><H1 CLASS="APISYMBOL">mgGetTextureGeoProjection</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextureGeoProjection</B> - gets map projection from 
a georeference info object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetTextureGeoProjection</B> (</TD><TD><A HREF=#mgimagegeoinfo>mgimagegeoinfo</A></TD><TD><I>geoInfo</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>projection</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, projection <B>mgGetTextureGeoProjection</B> (</TD><TD><A HREF=#mgimagegeoinfo>mgimagegeoinfo</A></TD><TD><I>geoInfo</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetTextureGeoProjection</B> gets the map projection from the 
specified georeference info object <I>geoInfo</I>.</P></DD><DD><P>Valid values for the projection attribute 
are <A HREF=#MIMG_GEOPROJ_GEODETIC>MIMG_GEOPROJ_GEODETIC</A>, and <A HREF=#MIMG_GEOPROJ_UTM>MIMG_GEOPROJ_UTM</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>geoInfo</I></DT><DD>the georeference info object</DD><DT><I>projection</I></DT><DD>address of integer to receive 
projection value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if projection retrieved successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>projection</DT><DD>If function is successful, projection contains the retrieved projection, otherwise 
projection is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadImageGeoInfo>mgReadImageGeoInfo</A>, <A HREF=#mgGetTextureGeoType>mgGetTextureGeoType</A>, 
<A HREF=#mgGetTextureGeoEarthModel>mgGetTextureGeoEarthModel</A>, <A HREF=#mgGetTextureGeoUTMZone>mgGetTextureGeoUTMZone</A>, 
<A HREF=#mgGetTextureGeoUTMHemisphere>mgGetTextureGeoUTMHemisphere</A>, <A HREF=#mgGetTextureGeoImageOrigin>mgGetTextureGeoImageOrigin</A>, 
<A HREF=#mgGetTextureGeoNumCtlPts>mgGetTextureGeoNumCtlPts</A>, <A HREF=#mgGetTextureGeoCtlPt>mgGetTextureGeoCtlPt</A>, 
<A HREF=#mgFreeImageGeoInfo>mgFreeImageGeoInfo</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTextureGeoType><H1 CLASS="APISYMBOL">mgGetTextureGeoType</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextureGeoType</B> - gets geographic control type from 
a georeference info object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetTextureGeoType</B> (</TD><TD><A HREF=#mgimagegeoinfo>mgimagegeoinfo</A></TD><TD><I>geoInfo</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>type</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, type <B>mgGetTextureGeoType</B> (</TD><TD><A HREF=#mgimagegeoinfo>mgimagegeoinfo</A></TD><TD><I>geoInfo</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetTextureGeoType</B> gets the geographic control type from 
the specified georeference info object <I>geoInfo</I>.</P></DD><DD><P>Valid values for the geographic control type attribute 
are <A HREF=#MIMG_GEOTYPE_CTRLPT>MIMG_GEOTYPE_CTRLPT</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>geoInfo</I></DT><DD>the georeference info object</DD><DT><I>type</I></DT><DD>address of integer to receive 
geographic control type</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if type retrieved successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>type</DT><DD>If function is successful, type contains the retrieved projection, otherwise 
type is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadImageGeoInfo>mgReadImageGeoInfo</A>, <A HREF=#mgGetTextureGeoProjection>mgGetTextureGeoProjection</A>, 
<A HREF=#mgGetTextureGeoEarthModel>mgGetTextureGeoEarthModel</A>, <A HREF=#mgGetTextureGeoUTMZone>mgGetTextureGeoUTMZone</A>, 
<A HREF=#mgGetTextureGeoUTMHemisphere>mgGetTextureGeoUTMHemisphere</A>, <A HREF=#mgGetTextureGeoImageOrigin>mgGetTextureGeoImageOrigin</A>, 
<A HREF=#mgGetTextureGeoNumCtlPts>mgGetTextureGeoNumCtlPts</A>, <A HREF=#mgGetTextureGeoCtlPt>mgGetTextureGeoCtlPt</A>, 
<A HREF=#mgFreeImageGeoInfo>mgFreeImageGeoInfo</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTextureGeoUTMHemisphere><H1 CLASS="APISYMBOL">mgGetTextureGeoUTMHemisphere</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextureGeoUTMHemisphere</B> - gets hemisphere from a 
georeference info object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetTextureGeoUTMHemisphere</B> (</TD><TD><A HREF=#mgimagegeoinfo>mgimagegeoinfo</A></TD><TD><I>geoInfo</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>hemisphere</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, hemisphere <B>mgGetTextureGeoUTMHemisphere</B> (</TD><TD><A HREF=#mgimagegeoinfo>mgimagegeoinfo</A></TD><TD><I>geoInfo</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetTextureGeoUTMHemisphere</B> gets the hemisphere from the 
specified image info object <I>geoInfo</I>.</P></DD><DD><P>Valid values for the hemisphere attribute 
are <A HREF=#MIMG_GEOHEMISPHERE_NORTH>MIMG_GEOHEMISPHERE_NORTH</A>, and <A HREF=#MIMG_GEOHEMISPHERE_SOUTH>MIMG_GEOHEMISPHERE_SOUTH</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>geoInfo</I></DT><DD>the georeference info object</DD><DT><I>hemisphere</I></DT><DD>address of integer to receive 
UTM hemisphere value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if hemisphere retrieved successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>hemisphere</DT><DD>If function is successful, hemisphere contains the retrieved projection, otherwise 
hemisphere is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadImageGeoInfo>mgReadImageGeoInfo</A>, <A HREF=#mgGetTextureGeoType>mgGetTextureGeoType</A>, 
<A HREF=#mgGetTextureGeoProjection>mgGetTextureGeoProjection</A>, <A HREF=#mgGetTextureGeoEarthModel>mgGetTextureGeoEarthModel</A>, 
<A HREF=#mgGetTextureGeoUTMZone>mgGetTextureGeoUTMZone</A>, <A HREF=#mgGetTextureGeoImageOrigin>mgGetTextureGeoImageOrigin</A>, 
<A HREF=#mgGetTextureGeoNumCtlPts>mgGetTextureGeoNumCtlPts</A>, <A HREF=#mgGetTextureGeoCtlPt>mgGetTextureGeoCtlPt</A>, 
<A HREF=#mgFreeImageGeoInfo>mgFreeImageGeoInfo</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTextureGeoUTMZone><H1 CLASS="APISYMBOL">mgGetTextureGeoUTMZone</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextureGeoUTMZone</B> - gets UTM zone from a 
georeference info object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetTextureGeoUTMZone</B> (</TD><TD><A HREF=#mgimagegeoinfo>mgimagegeoinfo</A></TD><TD><I>geoInfo</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>zone</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, zone <B>mgGetTextureGeoUTMZone</B> (</TD><TD><A HREF=#mgimagegeoinfo>mgimagegeoinfo</A></TD><TD><I>geoInfo</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetTextureGeoUTMZone</B> gets the UTM zone from the specified 
georeference info object <I>geoInfo</I>.</P></DD><DD><P>Valid values for the UTM zone attribute are 1 through 60.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>geoInfo</I></DT><DD>the georeference info object</DD><DT><I>zone</I></DT><DD>address of integer to receive 
UTM zone value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if zone retrieved successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>zone</DT><DD>If function is successful, zone contains the retrieved projection, otherwise 
zone is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadImageGeoInfo>mgReadImageGeoInfo</A>, <A HREF=#mgGetTextureGeoType>mgGetTextureGeoType</A>, 
<A HREF=#mgGetTextureGeoProjection>mgGetTextureGeoProjection</A>, <A HREF=#mgGetTextureGeoEarthModel>mgGetTextureGeoEarthModel</A>, 
<A HREF=#mgGetTextureGeoUTMHemisphere>mgGetTextureGeoUTMHemisphere</A>, <A HREF=#mgGetTextureGeoImageOrigin>mgGetTextureGeoImageOrigin</A>, 
<A HREF=#mgGetTextureGeoNumCtlPts>mgGetTextureGeoNumCtlPts</A>, <A HREF=#mgGetTextureGeoCtlPt>mgGetTextureGeoCtlPt</A>, 
<A HREF=#mgFreeImageGeoInfo>mgFreeImageGeoInfo</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTextureHeight><H1 CLASS="APISYMBOL">mgGetTextureHeight</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextureHeight</B> - gets height attribute from an image 
info object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetTextureHeight</B> (</TD><TD><A HREF=#mgimageinfo>mgimageinfo</A></TD><TD><I>textureInfo</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>height</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, height <B>mgGetTextureHeight</B> (</TD><TD><A HREF=#mgimageinfo>mgimageinfo</A></TD><TD><I>textureInfo</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetTextureHeight</B> gets the height attribute from the specified 
image info object <I>textureInfo</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>textureInfo</I></DT><DD>the image info object</DD><DT><I>height</I></DT><DD>address of integer to receive height 
attribute</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if height retrieved successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>height</DT><DD>If function is successful, height contains the retrieved height, otherwise 
height is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadImageInfo>mgReadImageInfo</A>, <A HREF=#mgGetTextureWidth>mgGetTextureWidth</A>, 
<A HREF=#mgGetTextureType>mgGetTextureType</A>, <A HREF=#mgGetTextureSampleSize>mgGetTextureSampleSize</A>, <A HREF=#mgGetTextureTiledFlag>mgGetTextureTiledFlag</A>, 
<A HREF=#mgGetTextureMinMax>mgGetTextureMinMax</A>, <A HREF=#mgHasTextureTransparentValue>mgHasTextureTransparentValue</A>, 
<A HREF=#mgGetTextureTransparentValue>mgGetTextureTransparentValue</A>, <A HREF=#mgGetTextureSignedFlag>mgGetTextureSignedFlag</A>, 
<A HREF=#mgFreeImageInfo>mgFreeImageInfo</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTextureIndex><H1 CLASS="APISYMBOL">mgGetTextureIndex</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextureIndex</B> - gets the index of a texture palette entry 
from its name.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgGetTextureIndex</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>textureName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetTextureIndex</B> returns the index of the texture palette entry whose 
file name matches <I>textureName</I>. If no such entry is found and <I>textureName</I> 
is a relative path, this function returns the index of the texture palette entry 
whose file name matches the full path of <I>textureName</I>, which is the 
concatenation of the database's directory and <I>textureName</I>. If no such entry 
is found still, this function returns the smallest index of the entries whose 
file names end with <I>textureName</I>.</P></DD><DD><P>If a texture is read using <A HREF=#mgReadTextureAndAlpha>mgReadTextureAndAlpha</A> or 
<A HREF=#mgInsertTextureAndAlpha>mgInsertTextureAndAlpha</A>, this function returns its index when the specified 
<I>mergeName</I> is passed in as <I>textureName</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>textureName</I></DT><DD>the name of the texture palette entry</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the index of the texture palette entry if found, or returns -1 otherwise.
</DD></DL><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples load a few textures and print out the indices that correspond 
to various inputs. Suppose the directory of the current database is C:/folder.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* db = mgGetCurrentDb ();

// load the texture at the specified path and assign its index to 0
mgReadTexture (db, "C:/A.rgb", 0, 0, 0);

// load the texture at the specified path and assign its index to 1
mgReadTexture (db, "C:/folder/A.rgb", 1, 0, 0);

// load the texture at the specified path and assign its index to 2
mgReadTexture (db, "C:/folder2/B.rgb", 2, 0, 0);

// load the texture at the specified path and assign its index to 3
mgReadTexture (db, "C:/B.rgb", 3, 0, 0);

printf ("%d", mgGetTextureIndex (db, "C:/A.rgb"));
printf ("%d", mgGetTextureIndex (db, "A.rgb"));
printf ("%d", mgGetTextureIndex (db, "B.rgb"));</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">db = mgGetCurrentDb ()

# load the texture at the specified path and assign its index to 0
mgReadTexture (db, "C:/A.rgb", 0, 0, 0)

# load the texture at the specified path and assign its index to 1
mgReadTexture (db, "C:/folder/A.rgb", 1, 0, 0)

# load the texture at the specified path and assign its index to 2
mgReadTexture (db, "C:/folder2/B.rgb", 2, 0, 0)

# load the texture at the specified path and assign its index to 3
mgReadTexture (db, "C:/B.rgb", 3, 0, 0)

print mgGetTextureIndex (db, "C:/A.rgb")
print mgGetTextureIndex (db, "A.rgb")
print mgGetTextureIndex (db, "B.rgb")</PRE></DT></DL></DD></DL>
<DL><DT><H3>EXAMPLE OUTPUT</H3></DT><DD><DL><DT>The following is the output produced by the examples above. The first output is 0 as expected. 
To determine the index of A.rgb, first we look for a loaded texture whose path is an exact match. 
Since none of the loaded textures satisfies that condition, we look for a loaded texture whose path 
matches the full path of A.rgb, which is C:/folder/A.rgb as the directory of the current database 
is C:/folder. Thus, the second output is 1. As for B.rgb, there is not a loaded texture whose path 
matches it or its full path, so we look for textures whose tail matches it. The last output is 2 
because it is the smallest of all the indices of such textures.</DT><DT><PRE CLASS="EXAMPLE">0 
1 
2</PRE></DT></DL></DD></DL>


<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetTextureName>mgGetTextureName</A>, <A HREF=#mgGetFirstTexture>mgGetFirstTexture</A>, <A HREF=#mgGetNextTexture>mgGetNextTexture</A>, 
<A HREF=#mgIsTextureInPalette>mgIsTextureInPalette</A>, <A HREF=#mgIsTextureIndexInPalette>mgIsTextureIndexInPalette</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTextureMapping><H1 CLASS="APISYMBOL">mgGetTextureMapping</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextureMapping</B> - gets an entry record from a 
database&#146s texture mapping palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetTextureMapping</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetTextureMapping</B> gets the texture mapping entry record 
defined by <I>index</I> from the texture mapping palette of database 
node <I>db</I>.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltTextureMapping>fltTextureMapping</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the texture mapping palette index</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the texture mapping entry record if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgIndexOfTextureMapping>mgIndexOfTextureMapping</A>, <A HREF=#mgNewTextureMapping>mgNewTextureMapping</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTextureMappingCount><H1 CLASS="APISYMBOL">mgGetTextureMappingCount</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextureMappingCount</B> - gets the number of entries in a 
database&#146s texture mapping palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgGetTextureMappingCount</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a database node, <I>db</I>, <B>mgGetTextureMappingCount</B> gets 
the number of entries in the database&#146s texture mapping palette.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of entries in the database&#146s texture 
mapping palette.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetFirstTextureMapping>mgGetFirstTextureMapping</A>, <A HREF=#mgGetNextTextureMapping>mgGetNextTextureMapping</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTextureMappingMatrix><H1 CLASS="APISYMBOL">mgGetTextureMappingMatrix</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextureMappingMatrix</B> - gets the matrix of a 3-point put 
or 4-point put texture mapping.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetTextureMappingMatrix</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>textureMappingMatrix</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, textureMappingMatrix <B>mgGetTextureMappingMatrix</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetTextureMappingMatrix</B> gets the mapping defined by <I>index</I>, 
and puts the mapping&#146s matrix into <I>matrix</I>. The result is suitable for 
use with OpenGL&#146s <B>glTexGen</B> function linear mappings.</P></DD><DD><P>Note: The matrix is only valid for 3-point put and 4-point put 
mappings.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the mapping</DD><DT><I>textureMappingMatrix</I></DT><DD>the matrix of the 3-point 
put or 4-point put texture mapping.</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if a valid matrix is found, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>textureMappingMatrix</DT><DD>If function is successful, textureMappingMatrix contains the retrieved matrix, otherwise 
textureMappingMatrix is undefined.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">int index;
mgrec* db;
mgmatrix matrix;
if ( (mgGetTextureMappingType (db, index) == 1) ||
     (mgGetTextureMappingType (db, index) == 2) )
{
   if (mgGetTextureMappingMatrix (db, index, &matrix))
   {
      // Do Stuff
   }
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetTextureMappingName>mgGetTextureMappingName</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTextureMappingName><H1 CLASS="APISYMBOL">mgGetTextureMappingName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextureMappingName</B> - gets the name of a texture mapping.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char* <B>mgGetTextureMappingName</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a database node <I>db</I>, and an index into the database&#146s 
texture mapping palette, <I>index</I>, <B>mgGetTextureMappingName</B> returns 
a copy of the name of the texture mapping defined by <I>index</I>.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned string in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the texture mapping entry</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a copy of the mapping name if a mapping is found and 
the mapping has a name, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetTextureMappingType>mgGetTextureMappingType</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTextureMappingType><H1 CLASS="APISYMBOL">mgGetTextureMappingType</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextureMappingType</B> - gets the type of a texture mapping.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgGetTextureMappingType</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a database node, <I>db</I>, and an index into the database&#146s 
texture mapping palette, <B>mgGetTextureMappingType</B> gets the texture 
mapping type of the mapping defined by <I>index</I>.  The possible types are:</P></DD><DL><DT></DT><DD>0 = Error <BR> 
1 = 3 point put <BR> 
2 = 4 point put <BR> 
4 = Spherical project <BR> 
5 = Radial project <BR> 
6 = Environment <BR></DD></DL>
</DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the mapping</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the type of the texture mapping if found, 0 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetTextureMappingName>mgGetTextureMappingName</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTextureMinMax><H1 CLASS="APISYMBOL">mgGetTextureMinMax</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextureMinMax</B> - gets the minimum and maximum texel 
values from an image info object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetTextureMinMax</B> (</TD><TD><A HREF=#mgimageinfo>mgimageinfo</A></TD><TD><I>textureInfo</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>min</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>max</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, min, max <B>mgGetTextureMinMax</B> (</TD><TD><A HREF=#mgimageinfo>mgimageinfo</A></TD><TD><I>textureInfo</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetTextureMinMax</B> gets the minimum and maximum texel values 
from the specified image info object <I>textureInfo</I>.  These values can 
be used to scale non-8bit images to 8 bits.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>textureInfo</I></DT><DD>the image info object</DD><DT><I>min</I></DT><DD>address of float to receive 
minimum texel value</DD><DT><I>max</I></DT><DD>address of float to receive 
maximum texel value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the texture attributes are found, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>min</DT><DD>If function is successful, min contains the retrieved minimum texel value, otherwise 
min is undefined.</DD><DT>max</DT><DD>If function is successful, max contains the retrieved maximum texel value, otherwise 
max is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadImageInfo>mgReadImageInfo</A>, <A HREF=#mgGetTextureWidth>mgGetTextureWidth</A>, <A HREF=#mgGetTextureHeight>mgGetTextureHeight</A>, 
<A HREF=#mgGetTextureType>mgGetTextureType</A>, <A HREF=#mgGetTextureSampleSize>mgGetTextureSampleSize</A>, <A HREF=#mgGetTextureTiledFlag>mgGetTextureTiledFlag</A>, 
<A HREF=#mgHasTextureTransparentValue>mgHasTextureTransparentValue</A>, 
<A HREF=#mgGetTextureTransparentValue>mgGetTextureTransparentValue</A>, <A HREF=#mgGetTextureSignedFlag>mgGetTextureSignedFlag</A>, 
<A HREF=#mgFreeImageInfo>mgFreeImageInfo</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTextureName><H1 CLASS="APISYMBOL">mgGetTextureName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextureName</B> - gets the full name of a texture 
palette entry from its index.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char* <B>mgGetTextureName</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetTextureName</B> returns the full name of a texture palette 
entry at the specified <I>index</I> contained in the texture palette of 
database <I>db</I>.</P></DD><DD><P>If the texture was located when it was loaded, the full name 
includes the full path specification of the file where it was found 
on disk.  If the texture was not located at load time, the name 
returned by this function will be the same name returned by 
<A HREF=#mgGetTextureSaveName>mgGetTextureSaveName</A>.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned string in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the texture palette entry</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the name of the texture palette entry if found, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetTextureIndex>mgGetTextureIndex</A>, <A HREF=#mgGetFirstTexture>mgGetFirstTexture</A>, <A HREF=#mgGetNextTexture>mgGetNextTexture</A>, 
<A HREF=#mgGetTextureSaveName>mgGetTextureSaveName</A>, <A HREF=#mgTextureGetSavePathType>mgTextureGetSavePathType</A>, <A HREF=#mgFree>mgFree</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTexturePosition><H1 CLASS="APISYMBOL">mgGetTexturePosition</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTexturePosition</B> - gets the position of a texture 
palette entry.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetTexturePosition</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>y</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, x, y <B>mgGetTexturePosition</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetTexturePosition</B> gets the position of the texture palette 
entry at the specified <I>index</I> contained in the texture palette of 
database <I>db</I>.</P></DD><DD><P>The position of a texture palette entry is the lower left corner 
where it is displayed in the texture palette.  This position is measured 
in pixels.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the texture palette entry</DD><DT><I>x</I></DT><DD>address to receive x coordinate of position</DD><DT><I>y</I></DT><DD>address to receive y coordinate of position</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if position retrieved successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>x</DT><DD>If function is successful, x contains the retrieved x position, otherwise 
x is undefined.</DD><DT>y</DT><DD>If function is successful, y contains the retrieved y position, otherwise 
y is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetTexturePosition>mgSetTexturePosition</A>, <A HREF=#mgGetTextureName>mgGetTextureName</A>, 
<A HREF=#mgGetFirstTexture>mgGetFirstTexture</A>, <A HREF=#mgGetNextTexture>mgGetNextTexture</A>, <A HREF=#mgReadTexture>mgReadTexture</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTextureSampleSize><H1 CLASS="APISYMBOL">mgGetTextureSampleSize</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextureSampleSize</B> - gets sample size attribute from 
an image info object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetTextureSampleSize</B> (</TD><TD><A HREF=#mgimageinfo>mgimageinfo</A></TD><TD><I>textureInfo</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>sampleSize</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, sampleSize <B>mgGetTextureSampleSize</B> (</TD><TD><A HREF=#mgimageinfo>mgimageinfo</A></TD><TD><I>textureInfo</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetTextureSampleSize</B> gets the sample size attribute from the 
specified image info object <I>textureInfo</I>.  The sample size specifies 
the number of bits per texel per component.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>textureInfo</I></DT><DD>the image info object</DD><DT><I>sampleSize</I></DT><DD>address of integer to receive 
sample size attribute</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if size retrieved successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>sampleSize</DT><DD>If function is successful, sampleSize contains the retrieved size, otherwise 
sampleSize is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadImageInfo>mgReadImageInfo</A>, <A HREF=#mgGetTextureWidth>mgGetTextureWidth</A>, <A HREF=#mgGetTextureHeight>mgGetTextureHeight</A>, 
<A HREF=#mgGetTextureType>mgGetTextureType</A>, <A HREF=#mgGetTextureTiledFlag>mgGetTextureTiledFlag</A>, 
<A HREF=#mgGetTextureMinMax>mgGetTextureMinMax</A>, <A HREF=#mgHasTextureTransparentValue>mgHasTextureTransparentValue</A>, 
<A HREF=#mgGetTextureTransparentValue>mgGetTextureTransparentValue</A>, <A HREF=#mgGetTextureSignedFlag>mgGetTextureSignedFlag</A>, 
<A HREF=#mgFreeImageInfo>mgFreeImageInfo</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTextureSaveName><H1 CLASS="APISYMBOL">mgGetTextureSaveName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextureSaveName</B> - gets the save name of a texture 
palette entry from its index.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char* <B>mgGetTextureSaveName</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetTextureSaveName</B> returns the save name of a texture palette 
entry at the specified <I>index</I> contained in the texture palette of 
database <I>db</I>.</P></DD><DD><P>The save name of a texture is the actual name that is saved 
in the OpenFlight database file for this texture palette entry.  The 
save name may or may not include the full path specification of the 
texture file.  If the texture files for a database are 
saved using relative texture names, the save name of a texture will 
be a relative name and will begin with the character sequence "./". 
If the texture files are saved using absolute 
texture names, the save name will include the full path specification 
of the texture.  If the texture files are saved with no path, the save 
name will simply be the name of the file.</P></DD><DD><P>You can determine how texture names are saved using the function 
<A HREF=#mgTextureGetSavePathType>mgTextureGetSavePathType</A>.  Similarly, you can change how texture 
names are saved using <A HREF=#mgTextureSetSavePathType>mgTextureSetSavePathType</A>.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned string in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the texture palette entry</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the save name of the texture palette entry if found, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetTextureIndex>mgGetTextureIndex</A>, <A HREF=#mgGetFirstTexture>mgGetFirstTexture</A>, <A HREF=#mgGetNextTexture>mgGetNextTexture</A>, 
<A HREF=#mgGetTextureName>mgGetTextureName</A>, <A HREF=#mgFree>mgFree</A>, <A HREF=#mgTextureGetSavePathType>mgTextureGetSavePathType</A>, 
<A HREF=#mgTextureSetSavePathType>mgTextureSetSavePathType</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTextureSignedFlag><H1 CLASS="APISYMBOL">mgGetTextureSignedFlag</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextureSignedFlag</B> - gets signed flag attribute from 
an image info object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetTextureSignedFlag</B> (</TD><TD><A HREF=#mgimageinfo>mgimageinfo</A></TD><TD><I>textureInfo</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool*</A></TD><TD><I>isSigned</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, isSigned <B>mgGetTextureSignedFlag</B> (</TD><TD><A HREF=#mgimageinfo>mgimageinfo</A></TD><TD><I>textureInfo</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetTextureSignedFlag</B> gets the signed flag attribute from the 
specified image info object <I>textureInfo</I>.  The signed flag specifies 
whether or not the image texels should be interpreted as signed values.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>textureInfo</I></DT><DD>the image info object</DD><DT><I>isSigned</I></DT><DD>address of boolean to receive 
is signed flag</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if flag retrieved successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>isSigned</DT><DD>If function is successful, isSigned contains the retrieved flag, otherwise 
isSigned is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadImageInfo>mgReadImageInfo</A>, <A HREF=#mgGetTextureWidth>mgGetTextureWidth</A>, <A HREF=#mgGetTextureHeight>mgGetTextureHeight</A>, 
<A HREF=#mgGetTextureType>mgGetTextureType</A>, <A HREF=#mgGetTextureSampleSize>mgGetTextureSampleSize</A>, <A HREF=#mgGetTextureTiledFlag>mgGetTextureTiledFlag</A>, 
<A HREF=#mgGetTextureMinMax>mgGetTextureMinMax</A>, <A HREF=#mgHasTextureTransparentValue>mgHasTextureTransparentValue</A>, 
<A HREF=#mgGetTextureTransparentValue>mgGetTextureTransparentValue</A>, <A HREF=#mgFreeImageInfo>mgFreeImageInfo</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTextureSize><H1 CLASS="APISYMBOL">mgGetTextureSize</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextureSize</B> - gets the size of a texture 
palette entry.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgGetTextureSize</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetTextureSize</B> returns the size (in bytes) of the texture palette 
entry at the specified <I>index</I> contained in the texture palette of 
database <I>db</I>.</P></DD><DD><P>The position of a texture palette entry is the lower left corner 
where it is displayed in the texture palette.  This position is measured 
in pixels.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the texture palette entry</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the size of the texture palette entry (in bytes) if found, 
-1 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetTextureCount>mgGetTextureCount</A>, <A HREF=#mgGetTextureTotalSize>mgGetTextureTotalSize</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTextureTexels><H1 CLASS="APISYMBOL">mgGetTextureTexels</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextureTexels</B> - gets the texels for 
a texture palette entry.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>unsigned char* <B>mgGetTextureTexels</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetTextureTexels</B> gets the texels for 
a texture palette entry at the specified <I>index</I> contained in 
the texture palette of database <I>db</I>.</P></DD><DD><P>Note: The texels returned are the actual texels, not a copy. 
For that reason, you should not modify them, free them or assign them to 
another texture in the database using <A HREF=#mgSetTextureTexels>mgSetTextureTexels</A>.  Doing 
any of these will lead to unexpected results and may cause a crash.</P></DD><DD><P>See <A HREF=#mgReadImage>mgReadImage</A> for a description of the memory layout 
for the texels returned.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the texture palette entry</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the pointer to the texels of the texture palette 
entry if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.  This pointer should not 
be freed by the caller.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetTextureTexels>mgSetTextureTexels</A>, <A HREF=#mgReadImage>mgReadImage</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTextureTiledFlag><H1 CLASS="APISYMBOL">mgGetTextureTiledFlag</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextureTiledFlag</B> - gets tiled flag attribute from 
an image info object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetTextureTiledFlag</B> (</TD><TD><A HREF=#mgimageinfo>mgimageinfo</A></TD><TD><I>textureInfo</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool*</A></TD><TD><I>isTiled</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, isTiled <B>mgGetTextureTiledFlag</B> (</TD><TD><A HREF=#mgimageinfo>mgimageinfo</A></TD><TD><I>textureInfo</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetTextureTiledFlag</B> gets the tiled flag attribute from the 
specified image info object <I>textureInfo</I>.  The tiled flag specifies 
whether or not the image is stored in memory in a tiled format.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>textureInfo</I></DT><DD>the image info object</DD><DT><I>isTiled</I></DT><DD>address of boolean to receive 
tiled flag attribute</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if flag retrieved successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>isTiled</DT><DD>If function is successful, isTiled contains the retrieved flag, otherwise 
isTiled is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadImageInfo>mgReadImageInfo</A>, <A HREF=#mgGetTextureWidth>mgGetTextureWidth</A>, <A HREF=#mgGetTextureHeight>mgGetTextureHeight</A>, 
<A HREF=#mgGetTextureType>mgGetTextureType</A>, <A HREF=#mgGetTextureSampleSize>mgGetTextureSampleSize</A>, 
<A HREF=#mgGetTextureMinMax>mgGetTextureMinMax</A>, <A HREF=#mgHasTextureTransparentValue>mgHasTextureTransparentValue</A>, 
<A HREF=#mgGetTextureTransparentValue>mgGetTextureTransparentValue</A>, <A HREF=#mgGetTextureSignedFlag>mgGetTextureSignedFlag</A>, 
<A HREF=#mgFreeImageInfo>mgFreeImageInfo</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTextureTotalSize><H1 CLASS="APISYMBOL">mgGetTextureTotalSize</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextureTotalSize</B> - gets the total size of the 
all the textures in a palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgGetTextureTotalSize</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetTextureTotalSize</B> returns the total size (in bytes) of all 
entries contained in the texture palette of database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the total size of all texture palette entries (in bytes) if 
successful, or returns -1 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetTextureCount>mgGetTextureCount</A>, <A HREF=#mgGetTextureSize>mgGetTextureSize</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTextureTransparentValue><H1 CLASS="APISYMBOL">mgGetTextureTransparentValue</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextureTransparentValue</B> - gets transparent value 
attribute from an image info object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetTextureTransparentValue</B> (</TD><TD><A HREF=#mgimageinfo>mgimageinfo</A></TD><TD><I>textureInfo</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>transparentValue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, transparentValue <B>mgGetTextureTransparentValue</B> (</TD><TD><A HREF=#mgimageinfo>mgimageinfo</A></TD><TD><I>textureInfo</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetTextureTransparentValue</B> gets the transparent value 
attribute from the specified image info object <I>textureInfo</I>.  If the 
transparent value flag obtained from <A HREF=#mgHasTextureTransparentValue>mgHasTextureTransparentValue</A> 
is <A HREF=#mgbool>MG_FALSE</A> the value returned by this function 
should be ignored.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>textureInfo</I></DT><DD>the image info object</DD><DT><I>transparentValue</I></DT><DD>address of integer to receive 
transparent texel value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if value retrieved successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>transparentValue</DT><DD>If function is successful, transparentValue contains the retrieved value, otherwise 
transparentValue is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadImageInfo>mgReadImageInfo</A>, <A HREF=#mgGetTextureWidth>mgGetTextureWidth</A>, <A HREF=#mgGetTextureHeight>mgGetTextureHeight</A>, 
<A HREF=#mgGetTextureType>mgGetTextureType</A>, <A HREF=#mgGetTextureSampleSize>mgGetTextureSampleSize</A>, <A HREF=#mgGetTextureTiledFlag>mgGetTextureTiledFlag</A>, 
<A HREF=#mgGetTextureMinMax>mgGetTextureMinMax</A>, <A HREF=#mgHasTextureTransparentValue>mgHasTextureTransparentValue</A>, 
<A HREF=#mgGetTextureSignedFlag>mgGetTextureSignedFlag</A>, <A HREF=#mgFreeImageInfo>mgFreeImageInfo</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTextureType><H1 CLASS="APISYMBOL">mgGetTextureType</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextureType</B> - gets type attribute from an image info 
object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetTextureType</B> (</TD><TD><A HREF=#mgimageinfo>mgimageinfo</A></TD><TD><I>textureInfo</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>type</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, type <B>mgGetTextureType</B> (</TD><TD><A HREF=#mgimageinfo>mgimageinfo</A></TD><TD><I>textureInfo</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetTextureType</B> gets the type attribute from the specified 
image info object <I>textureInfo</I>.</P></DD><DD><P>Valid values for the image type attribute returned in <I>type</I> 
are <A HREF=#MIMG_INT>MIMG_INT</A>, <A HREF=#MIMG_INTA>MIMG_INTA</A>, 
<A HREF=#MIMG_RGB>MIMG_RGB</A>, and <A HREF=#MIMG_RGBA>MIMG_RGBA</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>textureInfo</I></DT><DD>the image info object</DD><DT><I>type</I></DT><DD>address of integer to receive type 
attribute</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if type retrieved successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>type</DT><DD>If function is successful, type contains the retrieved type, otherwise 
type is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadImageInfo>mgReadImageInfo</A>, <A HREF=#mgGetTextureWidth>mgGetTextureWidth</A>, <A HREF=#mgGetTextureHeight>mgGetTextureHeight</A>, 
<A HREF=#mgGetTextureSampleSize>mgGetTextureSampleSize</A>, <A HREF=#mgGetTextureTiledFlag>mgGetTextureTiledFlag</A>, 
<A HREF=#mgGetTextureMinMax>mgGetTextureMinMax</A>, <A HREF=#mgHasTextureTransparentValue>mgHasTextureTransparentValue</A>, 
<A HREF=#mgGetTextureTransparentValue>mgGetTextureTransparentValue</A>, <A HREF=#mgGetTextureSignedFlag>mgGetTextureSignedFlag</A>, 
<A HREF=#mgFreeImageInfo>mgFreeImageInfo</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTextureWidth><H1 CLASS="APISYMBOL">mgGetTextureWidth</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTextureWidth</B> - gets width attribute from an image 
info object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetTextureWidth</B> (</TD><TD><A HREF=#mgimageinfo>mgimageinfo</A></TD><TD><I>textureInfo</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>width</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, width <B>mgGetTextureWidth</B> (</TD><TD><A HREF=#mgimageinfo>mgimageinfo</A></TD><TD><I>textureInfo</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetTextureWidth</B> gets the width attribute from the specified 
image info object <I>textureInfo</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>textureInfo</I></DT><DD>the image info object</DD><DT><I>width</I></DT><DD>address of integer to receive width 
attribute</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if width retrieved successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>width</DT><DD>If function is successful, width contains the retrieved width, otherwise 
width is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadImageInfo>mgReadImageInfo</A>, <A HREF=#mgGetTextureHeight>mgGetTextureHeight</A>, 
<A HREF=#mgGetTextureType>mgGetTextureType</A>, <A HREF=#mgGetTextureSampleSize>mgGetTextureSampleSize</A>, <A HREF=#mgGetTextureTiledFlag>mgGetTextureTiledFlag</A>, 
<A HREF=#mgGetTextureMinMax>mgGetTextureMinMax</A>, <A HREF=#mgHasTextureTransparentValue>mgHasTextureTransparentValue</A>, 
<A HREF=#mgGetTextureTransparentValue>mgGetTextureTransparentValue</A>, <A HREF=#mgGetTextureSignedFlag>mgGetTextureSignedFlag</A>, 
<A HREF=#mgFreeImageInfo>mgFreeImageInfo</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetTitle><H1 CLASS="APISYMBOL">mgGetTitle</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTitle</B> - retrieves the title string for a dialog.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgGetTitle</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>dialog</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>string</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maxLen</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetTitle</B> retrieves the title string of the specified <I>dialog</I>.</P></DD><DD><P>The title is truncated and 
null terminated if it is longer than <I>maxLen</I> characters.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>dialog</I></DT><DD>the dialog to get title string for</DD><DT><I>string</I></DT><DD>character buffer to hold title retrieved</DD><DT><I>maxLen</I></DT><DD>the maximum number of characters to store in <I>string</I></DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetTitle>mgSetTitle</A>, <A HREF=#mgGetCaption>mgGetCaption</A>, <A HREF=#mgSetCaption>mgSetCaption</A></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgstatus</DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.</DD><DT>string</DT><DD>If function is successful, string contains the title, otherwise undefined.</DD></DL></DL>
<HR>
<LEFT><A NAME=mgGetTriangleList><H1 CLASS="APISYMBOL">mgGetTriangleList</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetTriangleList</B> - gets the triangles composing 
a polygon in a database.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgreclist <B>mgGetTriangleList</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>poly</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetTriangleList</B> decomposes the given <I>poly</I> into 
triangles and returns a list of vertex records representing those 
resulting triangles.</P></DD><DD><P>The record list returned contains N*3 vertex records where N 
is the number of unique triangles composing <I>poly</I>.  Vertex 1, 2 
and 3 in the list form the first triangle, vertex 4, 5 and 6, the 
second triangle and so forth.  The vertex records in the list are 
the actual vertex records (not copies) from <I>poly</I> so a vertex 
may appear in the list multiple times.</P></DD><DD><P>When you are done accessing the record list returned by this 
function, you should dispose of it using <A HREF=#mgFreeRecList>mgFreeRecList</A>.  Since 
the vertices in the list are owned by <I>poly</I>, you do not need to 
dispose of them (unless you intend to affect the original polygon).</P></DD><DD><P>Note: This function works for convex or concave polygons 
with at least 3 vertices.  For polygons with less than 3 vertices, 
this function will return <A HREF=#MG_NULL>MG_NULL</A>.  For convex polygons with 3 
vertices, this function will return a list containing 3 
vertices representing the original polygon (triangle).</P></DD><DD><P>Examples of polygons for which this function will fail include:<BR> 
Polygons with less than 3 vertices<BR> 
Polygons with no area<BR> 
Polygons whose "front" side cannot be determined</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to dispose of the record list returned in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>poly</I></DT><DD>the polygon to decompose into triangles</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a record list object containing vertex record triples 
composing the triangles of the input <I>poly</I>, <A HREF=#MG_NULL>MG_NULL</A> if <I>poly</I> 
is not a valid polygon (see examples above) or does not contain at 
least 3 vertices.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example builds a new polygon for each of the 
triangles contained in an input polygon.</DT><DT><PRE CLASS="EXAMPLE">mgrec* vtx;
mgrec* newPoly;
mgrec* newVtx;
mgreclist recList = mgGetTriangleList (poly);
int numVtx = mgGetRecListCount (recList);
int numTris = numVtx / 3;
int i, j, tri;
i = 1;

// for each triangle returned, build a new polgyon
for (tri = 1; tri &lt= numTris; tri++) {
   newPoly = mgNewRec (fltPolygon);
   // 3 vertices in a row define this triangle
   for (j = 1; j &lt= 3; j++) {
      vtx = mgGetNthRecInList (recList, MG_NULL, i);
      // vtx is owned by poly, make a copy for new polygon
      newVtx = mgDuplicate (vtx);
      // append this vertex to preserve ordering of original poly
      mgAppend (newPoly, newVtx);
      i++;
   }
   // don't forget to attach newPoly somewhere!!
}
// all done with list, dispose of it to prevent memory leak
mgFreeRecList (recList);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgreclist>mgreclist</A>, <A HREF=#mgFreeRecList>mgFreeRecList</A>, <A HREF=#mgResetRecList>mgResetRecList</A>, 
<A HREF=#mgGetNextRecInList>mgGetNextRecInList</A>, <A HREF=#mgGetNthRecInList>mgGetNthRecInList</A>, <A HREF=#mgGetRecListCount>mgGetRecListCount</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetUserData><H1 CLASS="APISYMBOL">mgGetUserData</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetUserData</B> - returns the user data pointer of a record.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void* <B>mgGetUserData</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a pointer to the user data of the record <I>rec</I>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetUserData>mgSetUserData</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetVector><H1 CLASS="APISYMBOL">mgGetVector</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetVector</B> - gets values out of a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVector>fltVector</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetVector</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>vectorCode</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>i</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>j</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>k</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, i, j, k <B>mgGetVector</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>vectorCode</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a record <I>rec</I>, <B>mgGetVector</B> gets the values of <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVector>fltVector</A>
 
attribute record <I>vectorCode</I> from <I>rec</I> and stores them in <I>i</I>, <I>j</I>, 
and <I>k</I>.</P></DD><DD><P>For retrieving vertex normals, it is much more efficient to call the 
convenience function <A HREF=#mgGetVtxNormal>mgGetVtxNormal</A>.</P></DD><DD><P>You do not have to provide addresses for all <I>i</I>, <I>j</I>, and <I>k</I> values.  For 
example, if you only want to receive the i and j components (but not k), specify valid 
addresses for <I>i</I> and <I>j</I> and leave <I>k</I> NULL.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record from which to get the 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVector>fltVector</A>
 attribute record</DD><DT><I>vectorCode</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVector>fltVector</A>
 attribute record code</DD><DT><I>i</I></DT><DD>address of value to receive i component</DD><DT><I>j</I></DT><DD>address of value to receive j component</DD><DT><I>k</I></DT><DD>address of value to receive k component</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the vector was retrieved successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>i</DT><DD>If function is successful, i contains the retrieved i coordinate, otherwise 
i is undefined.</DD><DT>j</DT><DD>If function is successful, j contains the retrieved j coordinate, otherwise 
j is undefined.</DD><DT>k</DT><DD>If function is successful, k contains the retrieved k coordinate, otherwise 
k is undefined.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* eyeRec;
float i, j, k;

db = mgOpenDb ("file.flt");

// create eyepoint rec
eyeRec = UserMakeEyeRec (db);

mgGetVector (eyeRec, fltEyeEyeDir, &i, &j, &k);</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetAttList>mgGetAttList</A>, <A HREF=#mgGetAttBuf>mgGetAttBuf</A>, <A HREF=#mgGetVtxNormal>mgGetVtxNormal</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetVectord><H1 CLASS="APISYMBOL">mgGetVectord</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetVectord</B> - gets values out of a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVectord>fltVectord</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetVectord</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>vectorCode</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>i</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>j</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>k</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, i, j, k <B>mgGetVectord</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>vectorCode</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a record <I>rec</I>, <B>mgGetVectord</B> gets the values of <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVectord>fltVectord</A>
 
attribute record <I>vectorCode</I> from <I>rec</I> and stores them in <I>i</I>, <I>j</I>, 
and <I>k</I>.</P></DD><DD><P>You do not have to provide addresses for all <I>i</I>, <I>j</I>, and <I>k</I> values.  For 
example, if you only want to receive the i and j components (but not k), specify valid 
addresses for <I>i</I> and <I>j</I> and leave <I>k</I> NULL.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record from which to get the 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVectord>fltVectord</A>
 attribute record</DD><DT><I>vectorCode</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVectord>fltVectord</A>
 attribute record code</DD><DT><I>i</I></DT><DD>address of value to receive i component</DD><DT><I>j</I></DT><DD>address of value to receive j component</DD><DT><I>k</I></DT><DD>address of value to receive k component</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the vector was retrieved successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>i</DT><DD>If function is successful, i contains the retrieved i coordinate, otherwise 
i is undefined.</DD><DT>j</DT><DD>If function is successful, j contains the retrieved j coordinate, otherwise 
j is undefined.</DD><DT>k</DT><DD>If function is successful, k contains the retrieved k coordinate, otherwise 
k is undefined.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* torsionRec;
double i, j, k;

mgGetVectord (torsionRec, fltTorsionVector, &i, &j, &k);</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetAttList>mgGetAttList</A>, <A HREF=#mgGetAttBuf>mgGetAttBuf</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetVersion><H1 CLASS="APISYMBOL">mgGetVersion</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetVersion</B> - returns the current OpenFlight API version running.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetVersion</B> (</TD><TD>char*</TD><TD><I>version</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maxLen</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, string <B>mgGetVersion</B> (  )
</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetVersion</B> returns the current OpenFlight API version loaded in the 
program runtime environment.  The version is returned in <I>version</I> 
as a character string of the form "X.Y.Z" where:</P></DD><DD><P><B>X</B> is the major revision number <BR> 
<B>Y</B> is the minor revision number <BR> 
<B>Z</B> is the sub release number</P></DD><DD><P>Use this function to determine, at runtime, which version of the OpenFlight API 
is loaded.  Use the macro <A HREF=#MVERSION_API>MVERSION_API</A> to determine which version of the API your c 
ode is compiled and linked against.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>version</I></DT><DD>address of string to receive version string</DD><DT><I>maxLen</I></DT><DD>maximum number of characters to store in 
<I>version</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if version retrieved successfully, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>string</DT><DD>If function is successful, string contains the version, otherwise undefined.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>In this example, the code was compiled against version 2.5.1 of the OpenFlight API 
and is running with version 2.6.0.</DT><DT><PRE CLASS="EXAMPLE">char runTimeVersion [20];
char linkTimeVersion [20];

// runTimeVersion will contain "2.6.0"
mgGetVersion (runTimeVersion, 20);

// linkTimeVersion will contain "2.5.1"
strncpy (linkTimeVersion, MVERSION_API, 20);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#MVERSION_API>MVERSION_API</A>, <A HREF=#mgGetOpenFlightVersion>mgGetOpenFlightVersion</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetVtxBackColorRGB><H1 CLASS="APISYMBOL">mgGetVtxBackColorRGB</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetVtxBackColorRGB</B> - gets the RGB back color values out 
of a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetVtxBackColorRGB</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>vtx</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>red</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>green</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>blue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, red, green, blue <B>mgGetVtxBackColorRGB</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>vtx</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record, <I>vtx</I>, <B>mgGetVtxBackColorRGB</B> gets the red, green, 
and blue values of its back bolor (if applicable).</P></DD><DD><P>Colors set in index mode are automatically converted to RGB values.  The color values 
returned are in the range 0..255.</P></DD><DD><P>You do not have to provide addresses for all <I>red</I>, <I>green</I>, and <I>blue</I> values. 
For example, if you only want to receive the red and blue components (but not green), specify 
valid addresses for <I>red</I> and <I>blue</I> and leave <I>green</I> NULL.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>vtx</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record from which to get the color values</DD><DT><I>red</I></DT><DD>the red component</DD><DT><I>green</I></DT><DD>the green component</DD><DT><I>blue</I></DT><DD>the blue component</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>red</DT><DD>If function is successful, red contains the retrieved value, otherwise 
red is undefined.</DD><DT>green</DT><DD>If function is successful, green contains the retrieved value, otherwise 
green is undefined.</DD><DT>blue</DT><DD>If function is successful, blue contains the retrieved value, otherwise 
blue is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetVtxColorRGBA>mgGetVtxColorRGBA</A>, <A HREF=#mgSetVtxColorRGB>mgSetVtxColorRGB</A>, <A HREF=#mgSetVtxColorRGBA>mgSetVtxColorRGBA</A>, 
<A HREF=#mgGetPolyColorRGB>mgGetPolyColorRGB</A>, <A HREF=#mgSetPolyColorRGB>mgSetPolyColorRGB</A>, 
<A HREF=#mgGetPolyAltColorRGB>mgGetPolyAltColorRGB</A>, <A HREF=#mgSetPolyAltColorRGB>mgSetPolyAltColorRGB</A>, 
<A HREF=#mgGetAttList>mgGetAttList</A>, <A HREF=#mgGetAttBuf>mgGetAttBuf</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetVtxColorName><H1 CLASS="APISYMBOL">mgGetVtxColorName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetVtxColorName</B> - gets the color name of a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char* <B>mgGetVtxColorName</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>vtx</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record, <I>vtx</I>, <B>mgGetVtxColorName</B> returns the 
color name for the vertex.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned string in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>vtx</I></DT><DD>a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the color name for the vertex if successful, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetVtxColorName>mgSetVtxColorName</A>, <A HREF=#mgGetPolyColorName>mgGetPolyColorName</A>, 
<A HREF=#mgGetPolyAltColorName>mgGetPolyAltColorName</A>, <A HREF=#mgNewColorName>mgNewColorName</A>, <A HREF=#mgGetNextColorName>mgGetNextColorName</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetVtxColorRGB><H1 CLASS="APISYMBOL">mgGetVtxColorRGB</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetVtxColorRGB</B> - gets the RGB color values out of a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetVtxColorRGB</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>vtx</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>red</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>green</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>blue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, red, green, blue <B>mgGetVtxColorRGB</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>vtx</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record, <I>vtx</I>, <B>mgGetVtxColorRGB</B> gets the red, green, 
and blue values of its <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVColor</A>
 attribute.</P></DD><DD><P>Colors set in index mode are automatically converted to RGB values.  The color values 
returned are in the range 0..255.</P></DD><DD><P>You do not have to provide addresses for all <I>red</I>, <I>green</I>, and <I>blue</I> values. 
For example, if you only want to receive the red and blue components (but not green), specify 
valid addresses for <I>red</I> and <I>blue</I> and leave <I>green</I> NULL.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>vtx</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record from which to get the color values</DD><DT><I>red</I></DT><DD>the red component</DD><DT><I>green</I></DT><DD>the green component</DD><DT><I>blue</I></DT><DD>the blue component</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>red</DT><DD>If function is successful, red contains the retrieved value, otherwise 
red is undefined.</DD><DT>green</DT><DD>If function is successful, green contains the retrieved value, otherwise 
green is undefined.</DD><DT>blue</DT><DD>If function is successful, blue contains the retrieved value, otherwise 
blue is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetVtxColorRGBA>mgGetVtxColorRGBA</A>, <A HREF=#mgSetVtxColorRGB>mgSetVtxColorRGB</A>, <A HREF=#mgSetVtxColorRGBA>mgSetVtxColorRGBA</A>, 
<A HREF=#mgGetVtxBackColorRGB>mgGetVtxBackColorRGB</A>, 
<A HREF=#mgGetPolyColorRGB>mgGetPolyColorRGB</A>, <A HREF=#mgSetPolyColorRGB>mgSetPolyColorRGB</A>, 
<A HREF=#mgGetPolyAltColorRGB>mgGetPolyAltColorRGB</A>, <A HREF=#mgSetPolyAltColorRGB>mgSetPolyAltColorRGB</A>, 
<A HREF=#mgGetAttList>mgGetAttList</A>, <A HREF=#mgGetAttBuf>mgGetAttBuf</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetVtxColorRGBA><H1 CLASS="APISYMBOL">mgGetVtxColorRGBA</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetVtxColorRGBA</B> - gets the RGBA color values out of a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetVtxColorRGBA</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>vtx</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>red</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>green</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>blue</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>alpha</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record, <I>vtx</I>, <B>mgGetVtxColorRGBA</B> gets the red, green, blue, 
and alpha values of its <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVColor</A>
 attribute.</P></DD><DD><P>Colors set in index mode are automatically converted to RGB values.  The color 
values returned are in the range 0..255.</P></DD><DD><P>You do not have to provide addresses for all <I>red</I>, <I>green</I>, <I>blue</I>, and <I>alpha</I> values. 
For example, if you only want to receive the red and blue components (but not green or alpha), specify valid 
addresses for <I>red</I> and <I>blue</I> and leave <I>green</I> and <I>alpha</I> NULL.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>vtx</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record from which to get the color values</DD><DT><I>red</I></DT><DD>the red component</DD><DT><I>green</I></DT><DD>the green component</DD><DT><I>blue</I></DT><DD>the blue component</DD><DT><I>alpha</I></DT><DD>the alpha component</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetVtxColorRGB>mgGetVtxColorRGB</A>, <A HREF=#mgSetVtxColorRGB>mgSetVtxColorRGB</A>, <A HREF=#mgSetVtxColorRGBA>mgSetVtxColorRGBA</A>, 
<A HREF=#mgGetVtxBackColorRGB>mgGetVtxBackColorRGB</A>, 
<A HREF=#mgGetPolyColorRGB>mgGetPolyColorRGB</A>, <A HREF=#mgSetPolyColorRGB>mgSetPolyColorRGB</A>, 
<A HREF=#mgGetPolyAltColorRGB>mgGetPolyAltColorRGB</A>, <A HREF=#mgSetPolyAltColorRGB>mgSetPolyAltColorRGB</A>, 
<A HREF=#mgGetAttList>mgGetAttList</A>, <A HREF=#mgGetAttBuf>mgGetAttBuf</A></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>red</DT><DD>If function is successful, red contains the retrieved value, otherwise 
red is undefined.</DD><DT>green</DT><DD>If function is successful, green contains the retrieved value, otherwise 
green is undefined.</DD><DT>blue</DT><DD>If function is successful, blue contains the retrieved value, otherwise 
blue is undefined.</DD><DT>alpha</DT><DD>If function is successful, alpha contains the retrieved value, otherwise 
alpha is undefined.</DD></DL></DL>
<HR>
<LEFT><A NAME=mgGetVtxCoord><H1 CLASS="APISYMBOL">mgGetVtxCoord</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetVtxCoord</B> - retrieves the x,y,z coordinate from a vertex record.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetVtxCoord</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>y</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>z</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, x, y, z <B>mgGetVtxCoord</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetVtxCoord</B> retrieves the <I>x</I>, <I>y</I>, and <I>z</I> values of the 
vertex coordinate from a vertex record <I>rec</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>a vertex record</DD><DT><I>x</I></DT><DD>address of value to receive x coordinate</DD><DT><I>y</I></DT><DD>address of value to receive y coordinate</DD><DT><I>z</I></DT><DD>address of value to receive z coordinate</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the coord was retrieved successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>x</DT><DD>If function is successful, x contains the retrieved x coordinate, otherwise 
x is undefined.</DD><DT>y</DT><DD>If function is successful, y contains the retrieved y coordinate, otherwise 
y is undefined.</DD><DT>z</DT><DD>If function is successful, z contains the retrieved z coordinate, otherwise 
z is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetVtxCoord>mgSetVtxCoord</A>, <A HREF=#mgGetCoord3d>mgGetCoord3d</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetVtxNormal><H1 CLASS="APISYMBOL">mgGetVtxNormal</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetVtxNormal</B> - retrieves the normal vector from a vertex record.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGetVtxNormal</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>i</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>j</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>k</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, i, j, k <B>mgGetVtxNormal</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetVtxNormal</B> retrieves the <I>i</I>, <I>j</I>, and <I>k</I> values of the 
vertex normal vector from a vertex record <I>rec</I>.</P></DD><DD><P>You do not have to provide addresses for all <I>i</I>, <I>j</I>, and <I>k</I> values.  For 
example, if you only want to receive the i and j components (but not k), specify valid 
addresses for <I>i</I> and <I>j</I> and leave <I>k</I> NULL.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>a vertex record</DD><DT><I>i</I></DT><DD>address of value to receive i component of normal vector</DD><DT><I>j</I></DT><DD>address of value to receive j component of normal vector</DD><DT><I>k</I></DT><DD>address of value to receive k component of normal vector</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the vertex has a normal vector, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>i</DT><DD>If function is successful, i contains the retrieved value, otherwise 
i is undefined.</DD><DT>j</DT><DD>If function is successful, j contains the retrieved value, otherwise 
j is undefined.</DD><DT>k</DT><DD>If function is successful, k contains the retrieved value, otherwise 
k is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetPolyNormal>mgGetPolyNormal</A>, <A HREF=#mgSetVtxNormal>mgSetVtxNormal</A>, <A HREF=#mgRemoveVtxNormal>mgRemoveVtxNormal</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetXform><H1 CLASS="APISYMBOL">mgGetXform</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetXform</B> - gets the first transformation of a node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgGetXform</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetXform</B> returns the first transformation of the specified 
node <I>rec</I>.  To get successive transformations of a node, use <A HREF=#mgGetNext>mgGetNext</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to get first transformation for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the first transformation node if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise
</DD></DL><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) traverse each transformation associated to node <I>rec</I>.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* xForm;
mgxfllcode xType;
if (mgHasXform (rec)) {
   xForm = mgGetXform (rec);
   while (xForm) {
      // Do something with xForm
      xType = mgGetXformType (xForm);
      xForm = mgGetNext (xForm);
   }
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">if (mgHasXform (rec)):
   xForm = mgGetXform (rec)
   while (xForm != None):
      # Do something with xForm
      xType = mgGetXformType (xForm)
      xForm = mgGetNext (xForm)</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgHasXform>mgHasXform</A>, <A HREF=#mgGetXformType>mgGetXformType</A>, <A HREF=#mgCountXform>mgCountXform</A>, <A HREF=#mgGetNext>mgGetNext</A></DD></DL>
<HR>
<LEFT><A NAME=mgGetXformType><H1 CLASS="APISYMBOL">mgGetXformType</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGetXformType</B> - determines the type of a transformation node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgxfllcode <B>mgGetXformType</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGetXformType</B> determines the type of the specified transformation node, 
<I>rec</I>.  The returned transformation type will be one of the following: <BR> 
<A HREF=#mgxfllcode>MXLL_TRANSLATE</A><BR> 
<A HREF=#mgxfllcode>MXLL_SCALE</A><BR> 
<A HREF=#mgxfllcode>MXLL_ROTEDGE</A><BR> 
<A HREF=#mgxfllcode>MXLL_ROTPT</A><BR> 
<A HREF=#mgxfllcode>MXLL_PUT</A><BR> 
<A HREF=#mgxfllcode>MXLL_TOPOINT</A><BR> 
<A HREF=#mgxfllcode>MXLL_GENERAL</A></P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the transformation node</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the type of the transformation node.  Note that if <I>rec</I> is not 
a transformation node, the return value of this function is not defined.
</DD></DL><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) examine the first transformation 
(and its type) associated to node <I>rec</I>.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">if (mgHasXform (rec)) {
&#32     mgrec* xForm = mgGetXform (rec);
&#32     mgxfllcode xType = mgGetXformType (xForm);
&#32     switch (xType)
&#32     {
&#32     case MXLL_TRANSLATE:
&#32&#32     printf ("MXLL_TRANSLATE\\n");
&#32&#32     break;
&#32     case MXLL_SCALE:
&#32&#32     printf ("MXLL_SCALE\\n");
&#32&#32     break;
&#32     case MXLL_ROTEDGE:
&#32&#32     printf ("MXLL_ROTEDGE\\n");
&#32&#32     break;
&#32     case MXLL_ROTPT:
&#32&#32     printf ("MXLL_ROTPT\\n");
&#32&#32     break;
&#32     case MXLL_PUT:
&#32&#32     printf ("MXLL_PUT\\n");
&#32&#32     break;
&#32     case MXLL_TOPOINT:
&#32&#32     printf ("MXLL_TOPOINT\\n");
&#32&#32     break;
&#32     case MXLL_GENERAL:
&#32&#32     printf ("MXLL_GENERAL\\n");
&#32&#32     break;
&#32     }
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">if (mgHasXform (rec)):
   xForm = mgGetXform (rec)
   xType = mgGetXformType (xForm)
&#32     if xType == MXLL_TRANSLATE:
&#32&#32     print "MXLL_TRANSLATE"
&#32     elif xType == MXLL_SCALE:
&#32&#32     print "MXLL_SCALE"
&#32     elif xType == MXLL_ROTEDGE:
&#32&#32     print "MXLL_ROTEDGE"
&#32     elif xType == MXLL_ROTPT:
&#32&#32     print "MXLL_ROTPT"
&#32     elif xType == MXLL_PUT:
&#32&#32     print "MXLL_PUT"
&#32     elif xType == MXLL_TOPOINT:
&#32&#32     print "MXLL_TOPOINT"
&#32     elif xType == MXLL_GENERAL:
&#32&#32     print "MXLL_GENERAL"</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgHasXform>mgHasXform</A>, <A HREF=#mgGetXform>mgGetXform</A>, <A HREF=#mgCountXform>mgCountXform</A>, <A HREF=#mgxfllcode>mgxfllcode</A></DD></DL>
<HR>
<LEFT><A NAME=mgGLColor3><H1 CLASS="APISYMBOL">mgGLColor3</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGLColor3</B> - specifies a color for GL rendering.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGLColor3</B> (</TD><TD><A HREF=#mgglcontext>mgglcontext</A></TD><TD><I>glContext</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>red</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>green</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>blue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGLColor3</B> sets the current color for GL rendering to that 
specified by the <I>red</I>, <I>green</I> and <I>blue</I> color 
components.</P></DD><DD><P>This function loads the specified red, green and blue color 
components in preparation for rendering into GL controls.  It is 
the equivalent of calling the OpenGL routine <B>glColor3*()</B>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>glContext</I></DT><DD>Gl rendering context into which color 
is to be loaded</DD><DT><I>red</I></DT><DD>red component of color to load</DD><DT><I>green</I></DT><DD>green component of color to load</DD><DT><I>blue</I></DT><DD>blue component of color to load</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if color could be loaded successfully, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGLColor4>mgGLColor4</A>, <A HREF=#mgGLColorIndex>mgGLColorIndex</A>, <A HREF=#mgGLMaterialIndex>mgGLMaterialIndex</A>, 
<A HREF=#mgGLTextureIndex>mgGLTextureIndex</A>, <A HREF=#mgSetGuiCallback>mgSetGuiCallback</A>, <A HREF=#MGCB_DRAW>MGCB_DRAW</A>, 
<A HREF=#mgGetCurrentColorRGB>mgGetCurrentColorRGB</A>, <A HREF=#mgGetCurrentAltColorRGB>mgGetCurrentAltColorRGB</A></DD></DL>
<HR>
<LEFT><A NAME=mgGLColor4><H1 CLASS="APISYMBOL">mgGLColor4</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGLColor4</B> - specifies a color for GL rendering.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGLColor4</B> (</TD><TD><A HREF=#mgglcontext>mgglcontext</A></TD><TD><I>glContext</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>red</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>green</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>blue</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>alpha</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGLColor4</B> sets the current color for GL rendering to that 
specified by the <I>red</I>, <I>green</I>, <I>blue</I> and <I>alpha</I> color 
components.</P></DD><DD><P>This function loads the specified red, green, blue and alpha color 
components in preparation for rendering into GL controls.  It is 
the equivalent of calling the OpenGL routine <B>glColor4*()</B>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>glContext</I></DT><DD>Gl rendering context into which color 
is to be loaded</DD><DT><I>red</I></DT><DD>red component of color to load</DD><DT><I>green</I></DT><DD>green component of color to load</DD><DT><I>blue</I></DT><DD>blue component of color to load</DD><DT><I>alpha</I></DT><DD>alpha component of color to load</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if color could be loaded successfully, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGLColor3>mgGLColor3</A>, <A HREF=#mgGLColorIndex>mgGLColorIndex</A>, <A HREF=#mgGLMaterialIndex>mgGLMaterialIndex</A>, 
<A HREF=#mgGLTextureIndex>mgGLTextureIndex</A>, <A HREF=#mgSetGuiCallback>mgSetGuiCallback</A>, <A HREF=#MGCB_DRAW>MGCB_DRAW</A>, 
<A HREF=#mgGetCurrentColorRGB>mgGetCurrentColorRGB</A>, <A HREF=#mgGetCurrentAltColorRGB>mgGetCurrentAltColorRGB</A></DD></DL>
<HR>
<LEFT><A NAME=mgGLColorIndex><H1 CLASS="APISYMBOL">mgGLColorIndex</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGLColorIndex</B> - specifies a color for GL rendering.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGLColorIndex</B> (</TD><TD><A HREF=#mgglcontext>mgglcontext</A></TD><TD><I>glContext</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>intensity</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGLColorIndex</B> sets the current color for GL rendering to that 
specified by palette <I>index</I> and <I>intensity</I>, in database <I>db</I>.</P></DD><DD><P>This function loads the red, green and blue color components associated 
with the specified color in preparation for rendering into GL controls.  It is 
the equivalent of calling the OpenGL routine <B>glColor3*()</B>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>glContext</I></DT><DD>Gl rendering context into which color 
is to be loaded</DD><DT><I>db</I></DT><DD>database whose color palette defines 
the color to load</DD><DT><I>index</I></DT><DD>index of color in database's palette to 
load</DD><DT><I>intensity</I></DT><DD>intensity of color to load</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if color could be loaded successfully, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGLColor3>mgGLColor3</A>, <A HREF=#mgGLColor4>mgGLColor4</A>, <A HREF=#mgGLTextureIndex>mgGLTextureIndex</A>, <A HREF=#mgGLMaterialIndex>mgGLMaterialIndex</A>, 
<A HREF=#mgSetGuiCallback>mgSetGuiCallback</A>, <A HREF=#MGCB_DRAW>MGCB_DRAW</A>, <A HREF=#mgGetCurrentColor>mgGetCurrentColor</A>, <A HREF=#mgGetCurrentAltColor>mgGetCurrentAltColor</A></DD></DL>
<HR>
<LEFT><A NAME=mgGLMaterialIndex><H1 CLASS="APISYMBOL">mgGLMaterialIndex</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGLMaterialIndex</B> - specifies a material for GL rendering.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGLMaterialIndex</B> (</TD><TD><A HREF=#mgglcontext>mgglcontext</A></TD><TD><I>glContext</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGLMaterialIndex</B> sets the current material for GL rendering to 
that specified by palette <I>index</I>, in database <I>db</I>.</P></DD><DD><P>This function loads the material definition associated with the specified 
material in preparation for rendering into GL controls.  It is the equivalent of 
calling the OpenGL routine <B>glMaterial*()</B> for each of the material components 
<B>GL_SHININESS</B>, <B>GL_AMBIENT</B>, <B>GL_DIFFUSE</B>, <B>GL_SPECULAR</B> and <B>GL_EMISSION</B>.</P></DD><DD><P>If you are rendering into a user defined GL control, you must explicitly 
enable lighting before <B>mgGLMaterialIndex</B> will have any affect. 
If you are rendering into a graphics view, material and lighting rendering will 
be enabled according to the settings of the viewing parameters of that graphic 
view.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>glContext</I></DT><DD>Gl rendering context into which 
material is to be loaded</DD><DT><I>db</I></DT><DD>database whose material palette defines 
the material to load</DD><DT><I>index</I></DT><DD>index of material in database's palette to 
load</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if material could be loaded successfully, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGLTextureIndex>mgGLTextureIndex</A>, <A HREF=#mgGLColorIndex>mgGLColorIndex</A>, <A HREF=#mgSetGuiCallback>mgSetGuiCallback</A>, 
<A HREF=#MGCB_DRAW>MGCB_DRAW</A>, <A HREF=#mgGetCurrentMaterial>mgGetCurrentMaterial</A></DD></DL>
<HR>
<LEFT><A NAME=mgglmousefunc><H1 CLASS="APISYMBOL">mgglmousefunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgglmousefunc</B> - GL mouse function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus (*<B>mgglmousefunc</B>) ( <TD><A HREF=#mggui>mggui</A> <TD><I>control</I>, 
<TR><TD></TD><TD><A HREF=#mgcontrolid>mgcontrolid</A> <TD><I>controlId</I>, 
<TR><TD></TD><TD><A HREF=#mgglmouseaction>mgglmouseaction</A> <TD><I>mouseAction</I>, 
<TR><TD></TD><TD>void* <TD><I>userData</I>, 
<TR><TD></TD><TD>void* <TD><I>callData</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for GL mouse functions. 
If a GL control is to accept mouse input from the user, you will provide a 
GL mouse function of this form that will be called to notify your GL control 
of the actions from the user via the mouse.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the gl control</DD><DT><I>controlId</I></DT><DD>the identifier of the control</DD><DT><I>mouseAction</I></DT><DD>the mouse action that triggered the function</DD><DT><I>userData</I></DT><DD>user defined data specified when function assigned to control</DD><DT><I>callData</I></DT><DD>callback specific data - you can always safely 
cast this pointer to a pointer to an object of type 
<A HREF=#mgglmousedatarec>mgglmousedatarec</A> to determine the type of call 
data this object really is</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Currently, the value returned by <A HREF=#mgglmousefunc>mgglmousefunc</A> is ignored and 
reserved for future enhancement.  For now always return <A HREF=#MSTAT_OK>MSTAT_OK</A>.
</DD></DL><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGLSetMouseFunc>mgGLSetMouseFunc</A>, <A HREF=#mgSetGuiCallback>mgSetGuiCallback</A></DD></DL>
<HR>
<LEFT><A NAME=mgGLSetMouseFunc><H1 CLASS="APISYMBOL">mgGLSetMouseFunc</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGLSetMouseFunc</B> - sets mouse function for GL control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgGLSetMouseFunc</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>actionMask</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgglmousefunc>mgglmousefunc</A></TD><TD><I>mouseFunc</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGLSetMouseFunc</B> assigns a GL mouse function to the specified 
GL <I>control</I>.</P></DD><DD><P>You select which mouse events the callback function is to be called 
for using the parameter <I>actionMask</I>.  The value for this parameter may be 
any bitwise combination of <A HREF=#MGMA_BUTTON>MGMA_BUTTON</A>, <A HREF=#MGMA_DOUBLECLICK>MGMA_DOUBLECLICK</A>, 
<A HREF=#MGMA_MOTION>MGMA_MOTION</A> and <A HREF=#MGMA_WHEEL>MGMA_WHEEL</A>.</P></DD><DD><P>GL mouse functions are called to notify your GL control that the user 
has entered some form of mouse input into the GL control.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the GL control</DD><DT><I>actionMask</I></DT><DD>mask indicating which mouse actions are selected 
for mouse function</DD><DT><I>mouseFunc</I></DT><DD>the GL mouse function</DD><DT><I>userData</I></DT><DD>user data to be passed to mouse function when it 
is called</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetGuiCallback>mgSetGuiCallback</A>, <A HREF=#mgglmousefunc>mgglmousefunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgGLTextureIndex><H1 CLASS="APISYMBOL">mgGLTextureIndex</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGLTextureIndex</B> - specifies a texture image for GL rendering.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGLTextureIndex</B> (</TD><TD><A HREF=#mgglcontext>mgglcontext</A></TD><TD><I>glContext</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGLTextureIndex</B> sets the current texture image for GL rendering to 
that specified by palette <I>index</I>, in database <I>db</I>.</P></DD><DD><P>This function loads the texels associated with the specified texture 
image in preparation for rendering into GL controls.  It is the equivalent of 
calling the OpenGL routine <B>glTexImage2D</B>.</P></DD><DD><P>If you are rendering into a user defined GL control, you must explicitly 
enable texture rendering using the OpenGL routine <B>glEnable(GL_TEXTURE_2D)</B>, 
before <B>mgGLTextureIndex</B> will have any affect. 
If you are rendering into a graphics view, texture rendering will be enabled 
according to the settings of the viewing parameters of that graphics view.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>glContext</I></DT><DD>Gl rendering context into which texture 
image is to be loaded</DD><DT><I>db</I></DT><DD>database whose texture palette defines 
the texture to load</DD><DT><I>index</I></DT><DD>index of texture in database's palette to 
load</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if texture image could be loaded successfully, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGLMaterialIndex>mgGLMaterialIndex</A>, <A HREF=#mgGLColorIndex>mgGLColorIndex</A>, <A HREF=#mgSetGuiCallback>mgSetGuiCallback</A>, 
<A HREF=#MGCB_DRAW>MGCB_DRAW</A>, <A HREF=#mgGetCurrentTexture>mgGetCurrentTexture</A></DD></DL>
<HR>
<LEFT><A NAME=mggraphicdrawfunc><H1 CLASS="APISYMBOL">mggraphicdrawfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mggraphicdrawfunc</B> - Graphic Draw function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus (*<B>mggraphicdrawfunc</B>) ( <TD><A HREF=#mgrec>mgrec*</A> <TD><I>db</I>, 
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A> <TD><I>rec</I>, 
<TR><TD></TD><TD><A HREF=#mggraphicviewdata>mggraphicviewdata*</A> <TD><I>viewData</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for graphic draw (extension node helper) functions. 
If your data extension declares one or more new node types, you may assign 
a graphic draw function for each new node type you have.  If you have assigned 
such a function for a node type, it will be called when a node of that type is 
being drawn in the graphics view.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database to which the node belongs</DD><DT><I>rec</I></DT><DD>the node to draw</DD><DT><I>viewData</I></DT><DD>the graphic rendering context in 
which the draw function is being called</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>The value returned by <A HREF=#mggraphicdrawfunc>mggraphicdrawfunc</A> controls how to continue 
drawing the graphic scene with respect to nodes below your extension node. 
The following are valid return values for the graphic draw function.<BR> 
<A HREF=#MSTAT_OK>MSTAT_OK</A> - continue drawing nodes below the extension node<BR> 
<A HREF=#MGD_DONTDRAWBELOW>MGD_DONTDRAWBELOW</A> - do NOT draw nodes below the extension node
</DD></DL><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterSite>mgRegisterSite</A>, <A HREF=#mgRegisterGraphicDraw>mgRegisterGraphicDraw</A></DD></DL>
<HR>
<LEFT><A NAME=mgGraphicsViewSettingGetDouble><H1 CLASS="APISYMBOL">mgGraphicsViewSettingGetDouble</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGraphicsViewSettingGetDouble</B> - gets an double view setting 
value from the current graphics view.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGraphicsViewSettingGetDouble</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgsettingname>mgsettingname</A></TD><TD><I>settingName</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>settingValue</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, settingValue <B>mgGraphicsViewSettingGetDouble</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgsettingname>mgsettingname</A></TD><TD><I>settingName</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>defaultValue</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGraphicsViewSettingGetDouble</B> retrieves an double value from a 
named graphics view setting, <I>settingName</I>, and stores it in 
<I>settingValue</I>.  If <I>settingName</I> does not exist, the 
value specified by <I>defaultValue</I> is returned.</P></DD><DD><P>Currently only a small subset of the graphics view settings 
are accessible.  For a complete list, see <A HREF=#mgsettingname>mgsettingname</A>.</P></DD><DD><P>Note that the prefix of the setting name, either <B>MGVD</B> or <B>MGVI</B>, 
indicates whether the corresponding setting value is double or integer, 
respectively.  If the value is double, use 
<B>mgGraphicsViewSettingGetDouble</B> and <A HREF=#mgGraphicsViewSettingSetDouble>mgGraphicsViewSettingSetDouble</A> 
to get and set the value, respectively.  If the value is integer, use 
<A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A> and <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>settingName</I></DT><DD>the graphics view setting name</DD><DT><I>settingValue</I></DT><DD>storage location for the setting value</DD><DT><I>defaultValue</I></DT><DD>default value returned if <I>settingName</I> 
not found</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if there is a graphics view visible 
in Creator, <I>settingName</I> represents a valid graphics view 
setting and the value can be represented by a double 
value, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>settingValue</DT><DD>If function is successful, settingValue contains the retrieved value, otherwise 
settingValue is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingSetDouble>mgGraphicsViewSettingSetDouble</A>, 
<A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A></DD></DL>
<HR>
<LEFT><A NAME=mgGraphicsViewSettingGetInteger><H1 CLASS="APISYMBOL">mgGraphicsViewSettingGetInteger</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGraphicsViewSettingGetInteger</B> - gets an integer view setting 
value from the current graphics view.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGraphicsViewSettingGetInteger</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgsettingname>mgsettingname</A></TD><TD><I>settingName</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>settingValue</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, settingValue <B>mgGraphicsViewSettingGetInteger</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgsettingname>mgsettingname</A></TD><TD><I>settingName</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>defaultValue</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGraphicsViewSettingGetInteger</B> retrieves an integer value from a 
named graphics view setting, <I>settingName</I>, and stores it in 
<I>settingValue</I>.  If <I>settingName</I> does not exist, the 
value specified by <I>defaultValue</I> is returned.</P></DD><DD><P>Currently only a small subset of the graphics view settings 
are accessible.  For a complete list, see <A HREF=#mgsettingname>mgsettingname</A>.</P></DD><DD><P>Note that the prefix of the setting name, either <B>MGVD</B> or <B>MGVI</B>, 
indicates whether the corresponding setting value is double or integer, 
respectively.  If the value is double, use 
<A HREF=#mgGraphicsViewSettingGetDouble>mgGraphicsViewSettingGetDouble</A> and <A HREF=#mgGraphicsViewSettingSetDouble>mgGraphicsViewSettingSetDouble</A> 
to get and set the value, respectively.  If the value is integer, use 
<B>mgGraphicsViewSettingGetInteger</B> and <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>settingName</I></DT><DD>the graphics view setting name</DD><DT><I>settingValue</I></DT><DD>storage location for the setting value</DD><DT><I>defaultValue</I></DT><DD>default value returned if <I>settingName</I> 
not found</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if there is a graphics view visible 
in Creator, <I>settingName</I> represents a valid graphics view 
setting and the value can be represented by an integer 
value, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>settingValue</DT><DD>If function is successful, settingValue contains the retrieved value, otherwise 
settingValue is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgGraphicsViewSettingGetDouble>mgGraphicsViewSettingGetDouble</A>, <A HREF=#mgGraphicsViewSettingSetDouble>mgGraphicsViewSettingSetDouble</A></DD></DL>
<HR>
<LEFT><A NAME=mgGraphicsViewSettingGetMatrix><H1 CLASS="APISYMBOL">mgGraphicsViewSettingGetMatrix</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGraphicsViewSettingGetMatrix</B> - gets a matrix view setting 
value from the current graphics view.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGraphicsViewSettingGetMatrix</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgsettingname>mgsettingname</A></TD><TD><I>settingName</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>settingValue</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, settingValue <B>mgGraphicsViewSettingGetMatrix</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgsettingname>mgsettingname</A></TD><TD><I>settingName</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>defaultValue</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGraphicsViewSettingGetMatrix</B> retrieves an <A HREF=#mgmatrix>mgmatrix</A> value from a 
named graphics view setting, <I>settingName</I>, and stores it in <I>settingValue</I>. 
If <I>settingName</I> does not exist, the value specified by <I>defaultValue</I> is 
returned.</P></DD><DD><P>Currently only a small subset of the graphics view settings 
are accessible.  For a complete list, see <A HREF=#mgsettingname>mgsettingname</A>.</P></DD><DD><P>Note that the prefix of the setting name, either <B>MGVD</B>, <B>MGVI</B>, 
or <B>MGVM</B> indicates whether the corresponding setting value is double, integer 
or <A HREF=#mgmatrix>mgmatrix</A>, respectively.  If the value is double, use 
<A HREF=#mgGraphicsViewSettingGetDouble>mgGraphicsViewSettingGetDouble</A> and <A HREF=#mgGraphicsViewSettingSetDouble>mgGraphicsViewSettingSetDouble</A> 
to get and set the value, respectively.  If the value is integer, use 
<A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A> and <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>. 
If the value is mgmatrix, use <B>mgGraphicsViewSettingGetMatrix</B> and 
<A HREF=#mgGraphicsViewSettingSetMatrix>mgGraphicsViewSettingSetMatrix</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>settingName</I></DT><DD>the graphics view setting name</DD><DT><I>settingValue</I></DT><DD>storage location for the setting value</DD><DT><I>defaultValue</I></DT><DD>default value returned if <I>settingName</I> 
not found</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if there is a graphics view visible 
in Creator, <I>settingName</I> represents a valid graphics view 
setting and the value can be represented by a <A HREF=#mgmatrix>mgmatrix</A> 
value, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>settingValue</DT><DD>If function is successful, settingValue contains the retrieved value, otherwise 
settingValue is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingSetMatrix>mgGraphicsViewSettingSetMatrix</A>, 
<A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>. 
<A HREF=#mgGraphicsViewSettingGetDouble>mgGraphicsViewSettingGetDouble</A>, <A HREF=#mgGraphicsViewSettingSetDouble>mgGraphicsViewSettingSetDouble</A></DD></DL>
<HR>
<LEFT><A NAME=mgGraphicsViewSettingSetDouble><H1 CLASS="APISYMBOL">mgGraphicsViewSettingSetDouble</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGraphicsViewSettingSetDouble</B> - sets a double view setting 
on one or more graphics views.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGraphicsViewSettingSetDouble</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgsettingname>mgsettingname</A></TD><TD><I>settingName</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>settingValue</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>setMask</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGraphicsViewSettingSetDouble</B> sets the value of a named graphics 
view setting, <I>settingName</I>, to the value specified by <I>settingValue</I>. 
Depending on the value of <I>setMask</I>, this function will set the value on 
either the current graphics view or all the graphics views of <I>db</I>.  To set 
the value on the current graphics view only, specify <A HREF=#MGVSM_SETCURRENT>MGVSM_SETCURRENT</A> for 
<I>setMask</I>.  To set the value on all graphics views of <I>db</I> specify 
<A HREF=#MGVSM_SETALL>MGVSM_SETALL</A>.</P></DD><DD><P>Currently only a small subset of the graphics view settings 
are accessible.  For a complete list, see <A HREF=#mgsettingname>mgsettingname</A>.</P></DD><DD><P>Note that the prefix of the setting name, either <B>MGVD</B> or <B>MGVI</B>, 
indicates whether the corresponding setting value is double or integer, 
respectively.  If the value is double, use 
<A HREF=#mgGraphicsViewSettingGetDouble>mgGraphicsViewSettingGetDouble</A> and <B>mgGraphicsViewSettingSetDouble</B> 
to get and set the value, respectively.  If the value is integer, use 
<A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A> and <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>settingName</I></DT><DD>the graphics view setting name</DD><DT><I>settingValue</I></DT><DD>the value to set</DD><DT><I>setMask</I></DT><DD>the mask specifying which graphics 
views to set</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if there is a graphics view visible 
in Creator, <I>settingName</I> represents a valid double graphics view 
setting and the value was set successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetDouble>mgGraphicsViewSettingGetDouble</A>, 
<A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A></DD></DL>
<HR>
<LEFT><A NAME=mgGraphicsViewSettingSetInteger><H1 CLASS="APISYMBOL">mgGraphicsViewSettingSetInteger</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGraphicsViewSettingSetInteger</B> - sets an integer view setting 
on one or more graphics views.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGraphicsViewSettingSetInteger</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgsettingname>mgsettingname</A></TD><TD><I>settingName</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>settingValue</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>setMask</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGraphicsViewSettingSetInteger</B> sets the value of a named graphics 
view setting, <I>settingName</I>, to the value specified by <I>settingValue</I>. 
Depending on the value of <I>setMask</I>, this function will set the value on 
either the current graphics view or all the graphics views of <I>db</I>.  To set 
the value on the current graphics view only, specify <A HREF=#MGVSM_SETCURRENT>MGVSM_SETCURRENT</A> for 
<I>setMask</I>.  To set the value on all graphics views of <I>db</I> specify 
<A HREF=#MGVSM_SETALL>MGVSM_SETALL</A>.</P></DD><DD><P>Currently only a small subset of the graphics view settings 
are accessible.  For a complete list, see <A HREF=#mgsettingname>mgsettingname</A>.</P></DD><DD><P>Note that the prefix of the setting name, either <B>MGVD</B> or <B>MGVI</B>, 
indicates whether the corresponding setting value is double or integer, 
respectively.  If the value is double, use 
<A HREF=#mgGraphicsViewSettingGetDouble>mgGraphicsViewSettingGetDouble</A> and <A HREF=#mgGraphicsViewSettingSetDouble>mgGraphicsViewSettingSetDouble</A> 
to get and set the value, respectively.  If the value is integer, use 
<A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A> and <B>mgGraphicsViewSettingSetInteger</B>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>settingName</I></DT><DD>the graphics view setting name</DD><DT><I>settingValue</I></DT><DD>the value to set</DD><DT><I>setMask</I></DT><DD>the mask specifying which graphics 
views to set</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if there is a graphics view visible 
in Creator, <I>settingName</I> represents a valid integer graphics view 
setting, and the value was set successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, 
<A HREF=#mgGraphicsViewSettingGetDouble>mgGraphicsViewSettingGetDouble</A>, <A HREF=#mgGraphicsViewSettingSetDouble>mgGraphicsViewSettingSetDouble</A></DD></DL>
<HR>
<LEFT><A NAME=mgGraphicsViewSettingSetMatrix><H1 CLASS="APISYMBOL">mgGraphicsViewSettingSetMatrix</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGraphicsViewSettingSetMatrix</B> - sets a matrix view setting 
on one or more graphics views.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGraphicsViewSettingSetMatrix</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgsettingname>mgsettingname</A></TD><TD><I>settingName</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>settingValue</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>setMask</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGraphicsViewSettingSetMatrix</B> sets the value of a named graphics 
view setting, <I>settingName</I>, to the value specified by <I>settingValue</I>. 
Depending on the value of <I>setMask</I>, this function will set the value on 
either the current graphics view or all the graphics views of <I>db</I>.  To set 
the value on the current graphics view only, specify <A HREF=#MGVSM_SETCURRENT>MGVSM_SETCURRENT</A> for 
<I>setMask</I>.  To set the value on all graphics views of <I>db</I> specify 
<A HREF=#MGVSM_SETALL>MGVSM_SETALL</A>.</P></DD><DD><P>Currently only a small subset of the graphics view settings 
are accessible.  For a complete list, see <A HREF=#mgsettingname>mgsettingname</A>.</P></DD><DD><P>Note that the prefix of the setting name, either <B>MGVD</B>, <B>MGVI</B>, 
or <B>MGVM</B> indicates whether the corresponding setting value is double, integer 
or <A HREF=#mgmatrix>mgmatrix</A>, respectively.  If the value is double, use 
<A HREF=#mgGraphicsViewSettingGetDouble>mgGraphicsViewSettingGetDouble</A> and <A HREF=#mgGraphicsViewSettingSetDouble>mgGraphicsViewSettingSetDouble</A> 
to get and set the value, respectively.  If the value is integer, use 
<A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A> and <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>. 
If the value is mgmatrix, use <A HREF=#mgGraphicsViewSettingGetMatrix>mgGraphicsViewSettingGetMatrix</A> and 
<B>mgGraphicsViewSettingSetMatrix</B>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>settingName</I></DT><DD>the graphics view setting name</DD><DT><I>settingValue</I></DT><DD>the value to set</DD><DT><I>setMask</I></DT><DD>the mask specifying which graphics 
views to set</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if there is a graphics view visible 
in Creator, <I>settingName</I> represents a valid <A HREF=#mgmatrix>mgmatrix</A> graphics view 
setting, and the value was set successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetMatrix>mgGraphicsViewSettingGetMatrix</A>, 
<A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgGraphicsViewSettingGetDouble>mgGraphicsViewSettingGetDouble</A>, <A HREF=#mgGraphicsViewSettingSetDouble>mgGraphicsViewSettingSetDouble</A>,</DD></DL>
<HR>
<LEFT><A NAME=mgGuiDeleteProperty><H1 CLASS="APISYMBOL">mgGuiDeleteProperty</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGuiDeleteProperty</B> - deletes user defined data 
associated with a gui item.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgGuiDeleteProperty</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>gui</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgpropertyname>mgpropertyname</A></TD><TD><I>propName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Use <B>mgGuiDeleteProperty</B> to delete the data named <I>propName</I> 
that was associated with the control or dialog <I>gui</I> using <A HREF=#mgGuiPutProperty>mgGuiPutProperty</A>.</P></DD><DD><P>Note that this function does not free or otherwise affect the actual data 
that was associated.  If this data was dynamically allocated, it is the 
callers responsibility to deallocate it.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>gui</I></DT><DD>the gui item</DD><DT><I>propName</I></DT><DD>the name of the property to delete</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGuiPutProperty>mgGuiPutProperty</A>, <A HREF=#mgGuiGetProperty>mgGuiGetProperty</A></DD></DL>
<HR>
<LEFT><A NAME=mgguifunc><H1 CLASS="APISYMBOL">mgguifunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgguifunc</B> - Control callback function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus (*<B>mgguifunc</B>) ( <TD><A HREF=#mggui>mggui</A> <TD><I>control</I>, 
<TR><TD></TD><TD><A HREF=#mgcontrolid>mgcontrolid</A> <TD><I>controlId</I>, 
<TR><TD></TD><TD><A HREF=#mgguicallbackreason>mgguicallbackreason</A> <TD><I>callbackReason</I>, 
<TR><TD></TD><TD>void* <TD><I>userData</I>, 
<TR><TD></TD><TD>void* <TD><I>callData</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for control callback functions. 
You can define the behavior of controls in your dialog instances 
by assigning control callbacks to them of this form.  Control 
callback functions are called to notify your plug-in tool of 
significant control events.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the control</DD><DT><I>controlId</I></DT><DD>the identifier of the control</DD><DT><I>callbackReason</I></DT><DD>the control event that triggered the callback</DD><DT><I>userData</I></DT><DD>user defined data specified when callback assigned 
to control</DD><DT><I>callData</I></DT><DD>callback specific data - you can always safely 
cast this pointer to a pointer to an object of type 
<A HREF=#mgguicallbackrec>mgguicallbackrec</A> to determine the type of call 
data this object really is</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Currently the value returned by <A HREF=#mgguifunc>mgguifunc</A> is ignored and 
reserved for future enhancement.  For now always return <A HREF=#MSTAT_OK>MSTAT_OK</A>.
</DD></DL><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetGuiCallback>mgSetGuiCallback</A></DD></DL>
<HR>
<LEFT><A NAME=mgGuiGetId><H1 CLASS="APISYMBOL">mgGuiGetId</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGuiGetId</B> - retrieves the id of a control or dialog.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcontrolid <B>mgGuiGetId</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>gui</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGuiGetId</B> returns the identifier of the control or dialog 
specified by <I>gui</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>gui</I></DT><DD>the gui or dialog to get the id for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the identifier if found, 0 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<HR>
<LEFT><A NAME=mgGuiGetPos><H1 CLASS="APISYMBOL">mgGuiGetPos</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGuiGetPos</B> - retrieves the position of a control or dialog.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgGuiGetPos</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>gui</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>left</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>top</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGuiGetPos</B> returns the <I>left</I> and/or <I>top</I> position 
of the specified control or dialog, <I>gui</I>, measured in pixels.</P></DD><DD><P>The position of a control is measured relative to the upper left corner 
of the parent dialog's "view" area.  The upper left corner of a dialog's 
view area is at position (0, 0).  Remember that the view area of a dialog 
does not include the margin or the title bar of the dialog.</P></DD><DD><P>The position of a dialog is measured relative to the upper left 
corner of the screen.  The upper left corner of the screen is at position 
(0, 0).</P></DD><DD><P>If either of the position parameters are <A HREF=#MG_NULL>MG_NULL</A>, that 
particular position will not be returned.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>gui</I></DT><DD>the control or dialog whose position is 
to be returned</DD><DT><I>left</I></DT><DD>address of value to receive left position</DD><DT><I>top</I></DT><DD>address of value to receive top position</DD></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows how to use this function 
to get the position of controls and dialogs.</DT><DT><PRE CLASS="EXAMPLE">mgstatus status;
int left, top;

// get JUST the left position of a dialog
status = mgGuiGetPos (dialog, &left, MG_NULL);

// get JUST the top position of a dialog
status = mgGuiGetPos (dialog, MG_NULL, &top);

// get BOTH the left and top positions of a control
status = mgGuiGetPos (control, &left, &top);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGuiSetPos>mgGuiSetPos</A>, <A HREF=#mgGuiGetSize>mgGuiGetSize</A>, <A HREF=#mgGuiSetSize>mgGuiSetSize</A>, <A HREF=#mgGuiGetViewSize>mgGuiGetViewSize</A></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgstatus</DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.</DD><DT>left</DT><DD>If function is successful, left contains the left position, otherwise undefined.</DD><DT>top</DT><DD>If function is successful, top contains the top position, otherwise undefined.</DD></DL></DL>
<HR>
<LEFT><A NAME=mgGuiGetProperty><H1 CLASS="APISYMBOL">mgGuiGetProperty</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGuiGetProperty</B> - retrieves user defined data 
associated with a gui item.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgpropertyvalue <B>mgGuiGetProperty</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>gui</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgpropertyname>mgpropertyname</A></TD><TD><I>propName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Use <B>mgGuiGetProperty</B> to retrieve the data named <I>propName</I> 
that was associated with the control or dialog <I>gui</I> using <A HREF=#mgGuiPutProperty>mgGuiPutProperty</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>gui</I></DT><DD>the gui item to get property for</DD><DT><I>propName</I></DT><DD>the name of the property to get</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the user defined data if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGuiPutProperty>mgGuiPutProperty</A>, <A HREF=#mgGuiDeleteProperty>mgGuiDeleteProperty</A></DD></DL>
<HR>
<LEFT><A NAME=mgGuiGetSize><H1 CLASS="APISYMBOL">mgGuiGetSize</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGuiGetSize</B> - retrieves the dimensions of a control 
or dialog.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgGuiGetSize</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>gui</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>width</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>height</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGuiGetSize</B> returns the <I>width</I> and/or <I>height</I> of the 
specified control or dialog, <I>gui</I>, measured in pixels.</P></DD><DD><P>For both controls and dialogs, the dimensions returned define the 
"outer" dimensions of the gui item.  The outer dimensions include the margin, 
or in the case of dialogs, the title bar dimensions.  For most controls, the 
outer dimensions are identical to the "inner" or "view" dimensions of the control. 
For dialogs, the outer dimensions are almost always larger than the view dimensions. 
As stated above, this is due to margins and the title bar of the dialog.</P></DD><DD><P>If either of the dimension parameters are <A HREF=#MG_NULL>MG_NULL</A>, that 
particular dimension will not be returned.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>gui</I></DT><DD>the control or dialog whose dimensions 
are to be returned</DD><DT><I>width</I></DT><DD>address of value to receive width dimension</DD><DT><I>height</I></DT><DD>address of value to receive height dimension</DD></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows how to use this function 
to get the dimensions of controls and dialogs.</DT><DT><PRE CLASS="EXAMPLE">mgstatus status;
int width, height;

// get JUST the height of a dialog
status = mgGuiGetSize (dialog, MG_NULL, &height);

// get JUST the width of a dialog
status = mgGuiGetSize (dialog, &width, MG_NULL);

// get BOTH the width and height of a control
status = mgGuiGetSize (control, &width, &height);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGuiSetSize>mgGuiSetSize</A>, <A HREF=#mgGuiGetViewSize>mgGuiGetViewSize</A>, <A HREF=#mgGuiGetPos>mgGuiGetPos</A>, <A HREF=#mgGuiSetPos>mgGuiSetPos</A></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgstatus</DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.</DD><DT>width</DT><DD>If function is successful, width contains the width, otherwise undefined.</DD><DT>height</DT><DD>If function is successful, height contains the height, otherwise undefined.</DD></DL></DL>
<HR>
<LEFT><A NAME=mgGuiGetViewSize><H1 CLASS="APISYMBOL">mgGuiGetViewSize</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGuiGetViewSize</B> - retrieves the view dimensions of 
a control or dialog.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgGuiGetViewSize</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>gui</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>width</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>height</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGuiGetViewSize</B> returns the view <I>width</I> and/or <I>height</I> 
of the specified control or dialog, <I>gui</I>, measured in pixels.</P></DD><DD><P>For both controls and dialogs, the dimensions returned define the 
"inner" or "view" dimensions of the gui item.  The view dimensions do not 
include the margin, or in the case of dialogs, the title bar dimensions. 
For most controls, the view dimensions are identical to the outer dimensions 
of the control.  For dialogs, the view dimensions are almost always smaller 
than the view dimensions.  As stated above, this is due to margins and the 
title bar of the dialog.</P></DD><DD><P>If either of the dimension parameters are <A HREF=#MG_NULL>MG_NULL</A>, that 
particular dimension will not be returned.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>gui</I></DT><DD>the control or dialog whose view dimensions 
are to be returned</DD><DT><I>width</I></DT><DD>address of value to receive width dimension</DD><DT><I>height</I></DT><DD>address of value to receive height dimension</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGuiGetSize>mgGuiGetSize</A>, <A HREF=#mgGuiSetSize>mgGuiSetSize</A>, <A HREF=#mgGuiGetPos>mgGuiGetPos</A>, <A HREF=#mgGuiSetPos>mgGuiSetPos</A></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgstatus</DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.</DD><DT>width</DT><DD>If function is successful, width contains the width, otherwise undefined.</DD><DT>height</DT><DD>If function is successful, height contains the height, otherwise undefined.</DD></DL></DL>
<HR>
<LEFT><A NAME=mgGuiPutProperty><H1 CLASS="APISYMBOL">mgGuiPutProperty</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGuiPutProperty</B> - associates user defined data with a gui 
item.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgGuiPutProperty</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>gui</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgpropertyname>mgpropertyname</A></TD><TD><I>propName</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgpropertyvalue>mgpropertyvalue</A></TD><TD><I>propValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGuiPutProperty</B> allows you to associate data of any 
type, <I>propValue</I>, with a dialog or control.  The user defined data is 
associated with a gui item, <I>gui</I>, and identified by a property name 
string, <I>propName</I>, allowing any number of data records to be associated 
with the gui item, as long as all property names are unique.</P></DD><DD><P>After using this function to associate user data to a gui item, 
use the function <A HREF=#mgGuiGetProperty>mgGuiGetProperty</A> to retrieve the data.  Then when 
you no longer need the data associated to the gui item, use 
<A HREF=#mgGuiDeleteProperty>mgGuiDeleteProperty</A> to disassociate the data from the gui item. 
Note that <A HREF=#mgGuiDeleteProperty>mgGuiDeleteProperty</A> does not free or otherwise affect 
the actual data that was associated.  If this data was dynamically 
allocated, it is the callers responsibility to deallocate it.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>gui</I></DT><DD>the gui item to put property on</DD><DT><I>propName</I></DT><DD>the name of the property to assign</DD><DT><I>propValue</I></DT><DD>the value of the property to assign</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example associates a string property to a control 
in a dialog, retrieves the string and prints it out.  Finally, it 
deletes the property from the control.</DT><DT><PRE CLASS="EXAMPLE">#define PROPERTY_NAME   "My String Property"
#define USER_STRING     "This String is associated to my control"

char* string;

// allocate the string to be associated to the control
string = mgMalloc (strlen (USER_STRING) + 1);
strcpy (string, USER_STRING);

// associate the string as a property of the control
mgGuiPutProperty (gui, PROPERTY_NAME, string);

// Then later, retrieve the string property, print it out

char* string;

// Retrieve the string property from the control
string = (char*) mgGuiGetProperty (gui, PROPERTY_NAME);
printf ("%s: %s", PROPERTY_NAME, string);

// Output is:
// My String Property: This String is associated to my control

// Then finally, when you no longer need the string to be
// associated to the control

char* string;

// Retrieve the string property from the control (need to free it)
string = (char*) mgGuiGetProperty (gui, PROPERTY_NAME);
mgFree (string);
mgGuiDeleteProperty (gui, PROPERTY_NAME);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGuiGetProperty>mgGuiGetProperty</A>, <A HREF=#mgGuiDeleteProperty>mgGuiDeleteProperty</A></DD></DL>
<HR>
<LEFT><A NAME=mgGuiSetFixedFont><H1 CLASS="APISYMBOL">mgGuiSetFixedFont</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGuiSetFixedFont</B> - applies a fixed width font to a control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgGuiSetFixedFont</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGuiSetFixedFont</B> sets the font of the specified <I>control</I> to a 
suitable fixed width font (one whose character glyphs are all the same width).<P>
You can apply a bold or italic font style to a control using the function 
<A HREF=#mgControlSetAttribute>mgControlSetAttribute</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the control to get the fixed width font</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgControlSetAttribute>mgControlSetAttribute</A></DD></DL>
<HR>
<LEFT><A NAME=mgGuiSetHelpContext><H1 CLASS="APISYMBOL">mgGuiSetHelpContext</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGuiSetHelpContext</B> - set a help context for a 
dialog or control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgGuiSetHelpContext</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>gui</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mghelpcontext>mghelpcontext</A></TD><TD><I>helpContext</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGuiSetHelpContext</B> associates the named help context, 
<I>helpContext</I>, to the specified dialog or control, <I>gui</I>.</P></DD><DD><P>If a help file is registered for a plug-in module and a valid help 
context exists in that help file, you can associate that help context to 
a dialog or control using this function.  If you do so, Creator will 
automatically display the help context in the Creator Online Help system 
when the user requests context sensitive help for the plug-in tool.</P></DD><DD><P>Any control that does not have an explicit help context assigned, 
will inherit the help context of the control's parent dialog.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>gui</I></DT><DD>the dialog or control to 
associate the help context with</DD><DT><I>helpContext</I></DT><DD>the help context</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterHelpFile>mgRegisterHelpFile</A>, <A HREF=#mgPluginSetHelpContext>mgPluginSetHelpContext</A>, 
<A HREF=#mgShowHelpContext>mgShowHelpContext</A>, <A HREF=#MTA_HELPCONTEXT>MTA_HELPCONTEXT</A></DD></DL>
<HR>
<LEFT><A NAME=mgGuiSetPos><H1 CLASS="APISYMBOL">mgGuiSetPos</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGuiSetPos</B> - sets the position of a control or dialog.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgGuiSetPos</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>gui</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>left</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>top</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGuiSetPos</B> sets the <I>left</I> and/or <I>top</I> position 
of the specified control or dialog, <I>gui</I>, measured in pixels.</P></DD><DD><P>The position of a control is measured relative to the upper left corner 
of the parent dialog's "view" area.  The upper left corner of a dialog's 
view area is at position (0, 0).  Remember that the view area of a dialog 
does not include the margin or the title bar of the dialog.</P></DD><DD><P>The position of a dialog is measured relative to the upper left 
corner of the screen.  The upper left corner of the screen is at position 
(0, 0).</P></DD><DD><P>If either of the input parameters are <A HREF=#MGSP_DONOTCHANGE>MGSP_DONOTCHANGE</A>, that 
particular position will not be changed.  In this way, you can set one 
position without having to respecify the value for the other.  For example, 
if you specify a value for <I>top</I>, but <A HREF=#MGSP_DONOTCHANGE>MGSP_DONOTCHANGE</A> for <I>left</I>, 
the top position of the gui item will be changed, but the left position 
will not be affected.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>gui</I></DT><DD>the control or dialog whose position is 
to be set</DD><DT><I>left</I></DT><DD>new left position</DD><DT><I>top</I></DT><DD>new top position</DD></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows how to use this function 
to set the position of controls and dialogs.</DT><DT><PRE CLASS="EXAMPLE">mgstatus status;

// set the top position of a dialog, leave the left position as is
status = mgGuiSetPos (dialog, MGSP_DONOTCHANGE, 200);

// set the left position of a dialog, leave the top position as is
status = mgGuiSetPos (dialog, 100, MGSP_DONOTCHANGE);

// set BOTH the left and top positions of a control
status = mgGuiSetPos (control, 20, 10);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGuiGetPos>mgGuiGetPos</A>, <A HREF=#mgGuiGetSize>mgGuiGetSize</A>, <A HREF=#mgGuiSetSize>mgGuiSetSize</A>, <A HREF=#mgGuiGetViewSize>mgGuiGetViewSize</A></DD></DL>
<HR>
<LEFT><A NAME=mgGuiSetSize><H1 CLASS="APISYMBOL">mgGuiSetSize</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGuiSetSize</B> - sets the dimensions of a control or dialog.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgGuiSetSize</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>gui</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>width</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>height</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGuiSetSize</B> sets the <I>width</I> and/or <I>height</I> of the 
specified control or dialog, <I>gui</I>, measured in pixels.</P></DD><DD><P>For both controls and dialogs, the dimensions set by this function 
are the "outer" dimensions of the gui item.  The outer dimensions include 
the margin, or in the case of dialogs, the title bar dimensions.  For most 
controls, the outer dimensions are identical to the "inner" or "view" 
dimensions of the control.  For dialogs, the outer dimensions are almost 
always larger than the view dimensions.  As stated above, this is due to 
margins and the title bar of the dialog.</P></DD><DD><P>If either of the input parameters are <A HREF=#MGSP_DONOTCHANGE>MGSP_DONOTCHANGE</A>, that 
particular dimension will not be changed.  In this way, you can set one 
dimension without having to respecify the value for the other.  For example, 
if you specify a value for <I>width</I>, but <A HREF=#MGSP_DONOTCHANGE>MGSP_DONOTCHANGE</A> for <I>height</I>, 
the width of the gui item will be changed, but the height will not be affected.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>gui</I></DT><DD>the control or dialog whose dimensions 
are to be set</DD><DT><I>width</I></DT><DD>new width dimension</DD><DT><I>height</I></DT><DD>new height dimension</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows how to use this function 
to set the dimensions of controls and dialogs.</DT><DT><PRE CLASS="EXAMPLE">mgstatus status;

// set the height of a dialog, leave the width as is
status = mgGuiSetSize (dialog, MGSP_DONOTCHANGE, 400);

// set the width of a dialog, leave the height as is
status = mgGuiSetSize (dialog, 200, MGSP_DONOTCHANGE);

// set BOTH the width and height of a control
status = mgGuiSetSize (control, 100, 20);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGuiGetSize>mgGuiGetSize</A>, <A HREF=#mgGuiGetViewSize>mgGuiGetViewSize</A>, <A HREF=#mgGuiGetPos>mgGuiGetPos</A>, <A HREF=#mgGuiSetPos>mgGuiSetPos</A></DD></DL>
<HR>
<LEFT><A NAME=mgGuiSetToolTip><H1 CLASS="APISYMBOL">mgGuiSetToolTip</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgGuiSetToolTip</B> - assigns a tool tip string for a control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgGuiSetToolTip</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>toolTip</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgGuiSetToolTip</B> will assign the specified tool tip string <I>toolTip</I> 
to the given control <I>control</I>.  This tool tip string will automatically 
be displayed when the user positions the mouse over the control.</P></DD><DD><P>To clear the tool tip string of a control, set <I>toolTip</I> to <A HREF=#MG_NULL>MG_NULL</A> 
or the empty string.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the control whose tool tip will be set</DD><DT><I>toolTip</I></DT><DD>the tool tip string</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example assigns the tool tip to a control using a string 
that is stored in a plug-in resource.  The id of the string is <I>tooltipId</I>.</DT><DT><PRE CLASS="EXAMPLE">mggui control;
mgstringid tooltipId;
mgresource resource;&#32&#32// loaded by mgLoadResource
char toolTip[100];

// load the string from the plug-in module resource
mgResourceGetString (resource, tooltipId, toolTip, 100);
mgGuiSetToolTip (control, toolTip);

// or you can simply pass string literals
mgGuiSetToolTip (control, "Show this when user hovers over control");</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCaption>mgSetCaption</A>, <A HREF=#mgSetPixmap>mgSetPixmap</A>, <A HREF=#mgResourceGetString>mgResourceGetString</A></DD></DL>
<HR>
<LEFT><A NAME=mgguiwindowfunc><H1 CLASS="APISYMBOL">mgguiwindowfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgguiwindowfunc</B> - GUI Window function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int (*<B>mgguiwindowfunc</B>) ( <TD><A HREF=#mggui>mggui</A> <TD><I>control</I>, 
<TR><TD></TD><TD><A HREF=#mgcontrolid>mgcontrolid</A> <TD><I>controlId</I>, 
<TR><TD></TD><TD><A HREF=#mgguihandle>mgguihandle</A> <TD><I>guiHandle</I>, 
<TR><TD></TD><TD>int <TD><I>uMsg</I>, 
<TR><TD></TD><TD><A HREF=#mguint_ptr>mguint_ptr</A> <TD><I>wParam</I>, 
<TR><TD></TD><TD><A HREF=#mglong_ptr>mglong_ptr</A> <TD><I>lParam</I>, 
<TR><TD></TD><TD>void* <TD><I>defWindowProc</I>, 
<TR><TD></TD><TD>void* <TD><I>userData</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for Window functions for GUI controls or dialogs.</P></DD><DD><P>When you subclass a control or dialog on Windows, using 
<A HREF=#mgControlSubclass>mgControlSubclass</A> or <A HREF=#mgDialogSubclass>mgDialogSubclass</A>, respectively, you will 
provide a Window function of this form.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the control</DD><DT><I>controlId</I></DT><DD>the identifier of the control</DD><DT><I>guiHandle</I></DT><DD>native control handle, on Windows, this is type HWND</DD><DT><I>uMsg</I></DT><DD>the Windows message to process</DD><DT><I>wParam</I></DT><DD>Specifies additional message information. 
The contents of this parameter depend on the value of the uMsg parameter.</DD><DT><I>lParam</I></DT><DD>Specifies additional message information. 
The contents of this parameter depend on the value of the uMsg parameter.</DD><DT><I>defWindowProc</I></DT><DD>The old window procedure should you need to call it</DD><DT><I>userData</I></DT><DD>user defined data specified when window function was assigned to control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Return 0 is your Window function handles the message.
</DD></DL><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgControlSubclass>mgControlSubclass</A>, <A HREF=#mgDialogSubclass>mgDialogSubclass</A></DD></DL>
<HR>
<LEFT><A NAME=mgHasAtt><H1 CLASS="APISYMBOL">mgHasAtt</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgHasAtt</B> - determines whether an attribute record exists in its parent record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgHasAtt</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>parentRec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>rcode</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgHasAtt</B> checks if an attribute record with code <I>rcode</I> exists in <I>parentRec</I></P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>parentRec</I></DT><DD>the parent record</DD><DT><I>rcode</I></DT><DD>the attribute record code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if <I>parentRec</I> has an atribute record with code <I>rcode</I>; 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=mgHasTextureTransparentValue><H1 CLASS="APISYMBOL">mgHasTextureTransparentValue</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgHasTextureTransparentValue</B> - gets transparent value flag 
attribute from an image info object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgHasTextureTransparentValue</B> (</TD><TD><A HREF=#mgimageinfo>mgimageinfo</A></TD><TD><I>textureInfo</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool*</A></TD><TD><I>hasTransparentValue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, hasTransparentValue <B>mgHasTextureTransparentValue</B> (</TD><TD><A HREF=#mgimageinfo>mgimageinfo</A></TD><TD><I>textureInfo</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgHasTextureTransparentValue</B> gets the transparent value flag 
attribute from the specified image info object <I>textureInfo</I>.  The 
transparent value flag specifies whether or not the image 
has a value marked as transparent.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>textureInfo</I></DT><DD>the image info object</DD><DT><I>hasTransparentValue</I></DT><DD>address of boolean to receive 
transparent value flag attribute</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if value retrieved successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>hasTransparentValue</DT><DD>If function is successful, hasTransparentValue contains the retrieved value, otherwise 
hasTransparentValue is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadImageInfo>mgReadImageInfo</A>, <A HREF=#mgGetTextureWidth>mgGetTextureWidth</A>, <A HREF=#mgGetTextureHeight>mgGetTextureHeight</A>, 
<A HREF=#mgGetTextureType>mgGetTextureType</A>, <A HREF=#mgGetTextureSampleSize>mgGetTextureSampleSize</A>, <A HREF=#mgGetTextureTiledFlag>mgGetTextureTiledFlag</A>, 
<A HREF=#mgGetTextureMinMax>mgGetTextureMinMax</A>, 
<A HREF=#mgGetTextureTransparentValue>mgGetTextureTransparentValue</A>, <A HREF=#mgGetTextureSignedFlag>mgGetTextureSignedFlag</A>, 
<A HREF=#mgFreeImageInfo>mgFreeImageInfo</A></DD></DL>
<HR>
<LEFT><A NAME=mgHasXform><H1 CLASS="APISYMBOL">mgHasXform</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgHasXform</B> - determines whether a node has a transformation associated with it.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgHasXform</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgHasXform</B> determines whether a node <I>rec</I> has a transformation associated with it.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to check for transformations</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if there is at least one associated transformation, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetXform>mgGetXform</A>, <A HREF=#mgGetXformType>mgGetXformType</A></DD></DL>
<HR>
<LEFT><A NAME=mgHideDialog><H1 CLASS="APISYMBOL">mgHideDialog</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgHideDialog</B> - hides a dialog.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgHideDialog</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>dialog</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgHideDialog</B> removes a dialog from the screen.</P></DD><DD><P>If the hide dialog event has been selected for the dialog function, it 
is sent.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>dialog</I></DT><DD>dialog to hide</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgHideDialogCallback>mgHideDialogCallback</A>, <A HREF=#mgShowDialog>mgShowDialog</A>, 
<A HREF=#mgDestroyDialog>mgDestroyDialog</A>, <A HREF=#mgRefreshDialog>mgRefreshDialog</A></DD></DL>
<HR>
<LEFT><A NAME=mgHideDialogCallback><H1 CLASS="APISYMBOL">mgHideDialogCallback</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgHideDialogCallback</B> - built-in callback function to hide 
a dialog when a control is activated.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgHideDialogCallback</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>gui</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcontrolid>mgcontrolid</A></TD><TD><I>controlId</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgguicallbackreason>mgguicallbackreason</A></TD><TD><I>callbackReason</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>callData</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgHideDialogCallback</B> can be passed to <A HREF=#mgSetGuiCallback>mgSetGuiCallback</A> 
for a control whose <A HREF=#MGCB_ACTIVATE>MGCB_ACTIVATE</A> event causes the dialog containing 
the control to be hidden.</P></DD><DD><P>This function is not meant to be called directly, only passed to 
<A HREF=#mgSetGuiCallback>mgSetGuiCallback</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>gui</I></DT><DD>control in the dialog to hide</DD><DT><I>controlId</I></DT><DD>the identifier of gui</DD><DT><I>callbackReason</I></DT><DD>the control event that 
triggered the callback</DD><DT><I>userData</I></DT><DD>user data passed through</DD><DT><I>callData</I></DT><DD>call data passed through</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>In both of the following examples, a dialog contains a "Close" button 
that when pressed will cause the dialog to be hidden.  Both examples show 
alternate implementations for setting up this behavior.  Both are functionally 
equivalent.<BR><BR> 
In this first example, the plug-in defines and assigns an explicit control 
callback function to the button control.  This callback function hides the 
dialog containing the control when the <A HREF=#MGCB_ACTIVATE>MGCB_ACTIVATE</A> event is sent to 
the button control.</DT><DT><PRE CLASS="EXAMPLE">static mgstatus CloseCallback (mggui gui, mgcontrolid controlId,
&#32&#32&#32&#32mgguicallbackreason callbackReason,
&#32&#32&#32&#32void* userData, void* callData)
{
   if (callbackReason == MGCB_ACTIVATE)
      mgHideDialog (gui);
   return (MSTAT_OK);
}

static void InitializeControls (mggui dialog)
{
   mggui gui = mgFindGuiById (dialog, IDC_CLOSE);
   mgSetGuiCallback (gui, MGCB_ACTIVATE, CloseCallback, MG_NULL);
}</PRE></DT><DT>In this next example, the plug-in assigns the built-in control callback 
function <B>mgHideDialogCallback</B> to the button control.  This built-in callback 
hides the dialog when the <A HREF=#MGCB_ACTIVATE>MGCB_ACTIVATE</A> event is sent to the button control. 
In this way, defining an explicit callback function is not required.</DT><DT><PRE CLASS="EXAMPLE">static void InitializeControls ( mggui dialog )
{
   mggui gui = mgFindGuiById (dialog, IDC_CLOSE);
   // Note: You must select the MGCB_ACTIVATE event.
   //       If you select any other events, they are ignored.
   //       You must pass MG_NULL as the user data.
   mgSetGuiCallback (gui, MGCB_ACTIVATE, mgHideDialogCallback, MG_NULL);
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetGuiCallback>mgSetGuiCallback</A>, <A HREF=#mgHideDialog>mgHideDialog</A>, 
<A HREF=#mgDestroyDialogCallback>mgDestroyDialogCallback</A>, <A HREF=#mgRefreshDialogCallback>mgRefreshDialogCallback</A></DD></DL>
<HR>
<LEFT><A NAME=mghierarchydrawfunc><H1 CLASS="APISYMBOL">mghierarchydrawfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mghierarchydrawfunc</B> - Hierarchy Draw function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus (*<B>mghierarchydrawfunc</B>) ( <TD><A HREF=#mgrec>mgrec*</A> <TD><I>db</I>, 
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A> <TD><I>rec</I>, 
<TR><TD></TD><TD><A HREF=#mghierarchyviewdata>mghierarchyviewdata*</A> <TD><I>viewData</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for hierarchy draw (extension node helper) functions. 
If your data extension declares one or more new node types, you may assign 
a hierarchy draw function for each new node type you have.  If you have assigned 
such a function for a node type, it will be called when a node of that type is 
being drawn in the hierarchy view.</P></DD><DD><P>The hierarchy draw function will be passed the extents of the rectangle 
in which the extension node is to be drawn.  The draw function should not draw 
outside the bounds of this rectangle.  The coordinates of this rectangle are 
measured relative to the lower left corner (0,0) of the enclosing hierarchy view.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database to which the node belongs</DD><DT><I>rec</I></DT><DD>the node to draw</DD><DT><I>viewData</I></DT><DD>the hierarchy rendering context in 
which draw function is being called</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Currently, the value returned by <A HREF=#mghierarchydrawfunc>mghierarchydrawfunc</A> is ignored and 
reserved for future enhancement.  For now always return <A HREF=#MSTAT_OK>MSTAT_OK</A>.
</DD></DL><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterSite>mgRegisterSite</A>, <A HREF=#mgRegisterHierarchyDraw>mgRegisterHierarchyDraw</A></DD></DL>
<HR>
<LEFT><A NAME=mgimageclosefunc><H1 CLASS="APISYMBOL">mgimageclosefunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgimageclosefunc</B> - Image Close function for Image Importer Tools<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus (*<B>mgimageclosefunc</B>) ( <TD><A HREF=#mgplugintool>mgplugintool</A> <TD><I>pluginTool</I>, 
<TR><TD></TD><TD>void* <TD><I>userData</I>, 
<TR><TD></TD><TD>int <TD><I>imageid</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for image close functions. 
When you register an image importer plug-in tool, provide a close function 
of this form that is called when the OpenFlight API needs your tool to close an image file.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginTool</I></DT><DD>the plug-in tool</DD><DT><I>userData</I></DT><DD>user defined data specified when tool registered</DD><DT><I>imageid</I></DT><DD>image identifier indicating which image to close - 
this is the value returned by the image open function when 
the image was first opened</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#MIMG_NO_ERROR>MIMG_NO_ERROR</A> if successful, otherwise returns applicable texture error code.
</DD></DL><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgSetReadImageGeoInfoFunc>mgSetReadImageGeoInfoFunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgimagegetgeoinfofunc><H1 CLASS="APISYMBOL">mgimagegetgeoinfofunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgimagegetgeoinfofunc</B> - Image Get GeoInfo function for Image Importer Tools<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus (*<B>mgimagegetgeoinfofunc</B>) ( <TD><A HREF=#mgplugintool>mgplugintool</A> <TD><I>pluginTool</I>, 
<TR><TD></TD><TD>void* <TD><I>userData</I>, 
<TR><TD></TD><TD>int <TD><I>imageid</I>, 
<TR><TD></TD><TD><A HREF=#mgimagegeoinfo>mgimagegeoinfo</A> <TD><I>imageGeoInfo</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for image get geoinfo functions. 
When you register an image importer plug-in tool, you can add a get geoinfo function 
of this form that is called when the OpenFlight API needs to get georeferencing information about an image 
that your tool has opened.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginTool</I></DT><DD>the plug-in tool</DD><DT><I>userData</I></DT><DD>user defined data specified when tool is registered</DD><DT><I>imageid</I></DT><DD>image identifier indicating which image to get info for - 
this is the value returned by the image open function when 
the image was first opened</DD><DT><I>imageGeoInfo</I></DT><DD>image geoinfo object that your tool loads values into 
for geo info attributes Latitude, Longitude, type, 
map projection, etc corresponding to the specified image</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#MIMG_NO_ERROR>MIMG_NO_ERROR</A> if successful, otherwise returns applicable texture error code. 
If successful, the parameter <I>imageGeoInfo</I> should be filled in with all pertinent 
image information using the <B>mgSetTextureXXX</B> functions listed below.  If not successful, 
no georeferencing data will be added to the imported image.
</DD></DL><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgSetReadImageGeoInfoFunc>mgSetReadImageGeoInfoFunc</A>, 
<A HREF=#mgSetTextureGeoType>mgSetTextureGeoType</A>, <A HREF=#mgSetTextureGeoProjection>mgSetTextureGeoProjection</A>, 
<A HREF=#mgSetTextureGeoEarthModel>mgSetTextureGeoEarthModel</A>, <A HREF=#mgSetTextureGeoUTMZone>mgSetTextureGeoUTMZone</A>, <A HREF=#mgSetTextureGeoUTMHemisphere>mgSetTextureGeoUTMHemisphere</A>, 
<A HREF=#mgSetTextureGeoImageOrigin>mgSetTextureGeoImageOrigin</A>, 
<A HREF=#mgSetTextureGeoNumCtlPts>mgSetTextureGeoNumCtlPts</A>, <A HREF=#mgSetTextureGeoCtlPt>mgSetTextureGeoCtlPt</A></DD></DL>
<HR>
<LEFT><A NAME=mgimagegetinfofunc><H1 CLASS="APISYMBOL">mgimagegetinfofunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgimagegetinfofunc</B> - Image Get Info function for Image Importer Tools<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus (*<B>mgimagegetinfofunc</B>) ( <TD><A HREF=#mgplugintool>mgplugintool</A> <TD><I>pluginTool</I>, 
<TR><TD></TD><TD>void* <TD><I>userData</I>, 
<TR><TD></TD><TD>int <TD><I>imageid</I>, 
<TR><TD></TD><TD><A HREF=#mgimageinfo>mgimageinfo</A> <TD><I>imageInfo</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for image get info functions. 
When you register an image importer plug-in tool, provide a get info function 
of this form that is called when the OpenFlight API needs to get information about an image 
that your tool has opened.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginTool</I></DT><DD>the plug-in tool</DD><DT><I>userData</I></DT><DD>user defined data specified when tool is registered</DD><DT><I>imageid</I></DT><DD>image identifier indicating which image to get info for - 
this is the value returned by the image open function when 
the image was first opened</DD><DT><I>imageInfo</I></DT><DD>image info object that your tool loads values into 
for info attributes width, height, type, etc corresponding to 
the specified image</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#MIMG_NO_ERROR>MIMG_NO_ERROR</A> if successful, otherwise returns applicable texture error code. 
If successful, the parameter <I>imageInfo</I> should be filled in with all pertinent 
image information using the <B>mgSetTextureXXX</B> functions listed below.
</DD></DL><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgSetReadImageGeoInfoFunc>mgSetReadImageGeoInfoFunc</A>, 
<A HREF=#mgSetTextureWidth>mgSetTextureWidth</A>, <A HREF=#mgSetTextureHeight>mgSetTextureHeight</A>, 
<A HREF=#mgSetTextureType>mgSetTextureType</A>, <A HREF=#mgSetTextureSampleSize>mgSetTextureSampleSize</A>, <A HREF=#mgSetTextureTiledFlag>mgSetTextureTiledFlag</A>, 
<A HREF=#mgSetTextureMinMax>mgSetTextureMinMax</A>, <A HREF=#mgSetTextureTransparentValue>mgSetTextureTransparentValue</A>, <A HREF=#mgSetTextureSignedFlag>mgSetTextureSignedFlag</A></DD></DL>
<HR>
<LEFT><A NAME=mgimagegettexelsfunc><H1 CLASS="APISYMBOL">mgimagegettexelsfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgimagegettexelsfunc</B> - Image Get Texels function for Image Importer Tools<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus (*<B>mgimagegettexelsfunc</B>) ( <TD><A HREF=#mgplugintool>mgplugintool</A> <TD><I>pluginTool</I>, 
<TR><TD></TD><TD>void* <TD><I>userData</I>, 
<TR><TD></TD><TD>int <TD><I>imageid</I>, 
<TR><TD></TD><TD>int <TD><I>resolution</I>, 
<TR><TD></TD><TD>unsigned char* <TD><I>texels</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for image get texels functions. 
When you register an image importer plug-in tool, provide a get texels function 
of this form that is called when the OpenFlight API needs to get the texels for all or part 
of an image that your tool has opened.</P></DD><DD><P>The format of the texels returned is described in the OpenFlight API Developer Guide 
(volume 2).</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginTool</I></DT><DD>the plug-in tool</DD><DT><I>userData</I></DT><DD>user defined data specified when tool registered</DD><DT><I>imageid</I></DT><DD>image identifier indicating which image to get texels for - 
this is the value returned by the image open function when 
the image was first opened</DD><DT><I>resolution</I></DT><DD>the reduction factor of the texels to be returned 
(reserved for future enhancement), currently always 1</DD><DT><I>texels</I></DT><DD>the texels extracted from the image</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#MIMG_NO_ERROR>MIMG_NO_ERROR</A> if successful, otherwise returns applicable texture error code. 
If successful, the parameter <I>texels</I> should be filled in with the 
texels extracted from the image.
</DD></DL><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgSetReadImageGeoInfoFunc>mgSetReadImageGeoInfoFunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgimageopenfunc><H1 CLASS="APISYMBOL">mgimageopenfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgimageopenfunc</B> - Image Open function for Image Importer Tools<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus (*<B>mgimageopenfunc</B>) ( <TD><A HREF=#mgplugintool>mgplugintool</A> <TD><I>pluginTool</I>, 
<TR><TD></TD><TD>void* <TD><I>userData</I>, 
<TR><TD></TD><TD>const char* <TD><I>filename</I>, 
<TR><TD></TD><TD>const char* <TD><I>filemode</I>, 
<TR><TD></TD><TD>int* <TD><I>imageid</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for image open functions. 
When you register an image importer plug-in tool, provide an open function 
of this form that is called when the OpenFlight API needs your tool to open an image file.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginTool</I></DT><DD>the plug-in tool</DD><DT><I>userData</I></DT><DD>user defined data specified when tool registered</DD><DT><I>filename</I></DT><DD>name of image file to open</DD><DT><I>filemode</I></DT><DD>mode to open file 'r for read, 'w' for write, 
currently only 'r' supported for image importers</DD><DT><I>imageid</I></DT><DD>address of image identifier filled in by 
image importer to identify this image for subsequent 
interactions between the OpenFlight API and the tool</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Return <A HREF=#MIMG_NO_ERROR>MIMG_NO_ERROR</A> if successful, otherwise applicable texture error code. 
If successful, the parameter <I>imageId</I> should be filled in with a unique integer 
value that will be used to identify the opened image in subsequent interactions 
between the OpenFlight API and your image importer tool.
</DD></DL><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgSetReadImageGeoInfoFunc>mgSetReadImageGeoInfoFunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgImageToXYZMatrix><H1 CLASS="APISYMBOL">mgImageToXYZMatrix</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgImageToXYZMatrix</B> - projects georeferenced image coordinates 
to georeferenced database coordinates.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgImageToXYZMatrix</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>imgRec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgimagegeoinfo>mgimagegeoinfo</A></TD><TD><I>geoinfo</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgmatrix <B>mgImageToXYZMatrix</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>imgRec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgimagegeoinfo>mgimagegeoinfo</A></TD><TD><I>geoinfo</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgImageToXYZMatrix</B> projects georeferenced image coordinates to 
georeferenced database coordinates</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the resulting matrix into the output 
parameter <I>matrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the resulting matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>imgRec</I></DT><DD>image attribute record</DD><DT><I>geoinfo</I></DT><DD>image georeference information</DD><DT><I>db</I></DT><DD>database containing the projection to use</DD><DT><I>matrix</I></DT><DD>address of matrix to receive result</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgmatrix</DT><DD>the matrix that converts image coords to database coords</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgprojcoord>mgprojcoord</A>, <A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgUnproject>mgUnproject</A>, <A HREF=#mgProject>mgProject</A></DD></DL>
<HR>
<LEFT><A NAME=mgIndex2RGB><H1 CLASS="APISYMBOL">mgIndex2RGB</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIndex2RGB</B> - returns red, green, and blue values for a 
given color palette index and intensity.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgIndex2RGB</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>intensity</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>red</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>green</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>blue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, red, green, blue <B>mgIndex2RGB</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>intensity</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a database node <I>db</I>, color palette index, <I>index</I>, 
and intensity, <I>intensity</I>, <B>mgIndex2RGB</B> returns the <I>red</I>, 
<I>green</I>, and <I>blue</I> values associated with them in the database&#146s 
color palette.  The color values returned are in the range 0..255.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index into the color palette</DD><DT><I>intensity</I></DT><DD>the intensity component of the color (0.0-1.0)</DD><DT><I>red</I></DT><DD>address of value to receive red component of color</DD><DT><I>green</I></DT><DD>address of value to receive green component of color</DD><DT><I>blue</I></DT><DD>address of value to receive blue component of color</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the index could be converted successfully, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>red</DT><DD>If function is successful, red contains the retrieved red component, otherwise 
red is undefined.</DD><DT>green</DT><DD>If function is successful, green contains the retrieved green component, otherwise 
green is undefined.</DD><DT>blue</DT><DD>If function is successful, blue contains the retrieved blue component, otherwise 
blue is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRGB2Index>mgRGB2Index</A></DD></DL>
<HR>
<LEFT><A NAME=mgIndexOfLightPointAnimation><H1 CLASS="APISYMBOL">mgIndexOfLightPointAnimation</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIndexOfLightPointAnimation</B> - gets the index of a named 
entry in the light point appearance palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgIndexOfLightPointAnimation</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>name</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgIndexOfLightPointAnimation</B> returns the index of the entry 
named <I>name</I> in the light point appearance palette for database <I>db</I>. 
If the entry is not found, -1 is returned.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>name</I></DT><DD>the name of the entry to look up</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the index of the palette entry if found, -1 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetLightPointAppearance>mgGetLightPointAppearance</A>, 
<A HREF=#mgGetLightPointAppearanceCount>mgGetLightPointAppearanceCount</A>, 
<A HREF=#mgNameOfLightPointAppearance>mgNameOfLightPointAppearance</A>, 
<A HREF=#mgGetFirstLightPointAppearance>mgGetFirstLightPointAppearance</A>, 
<A HREF=#mgGetNextLightPointAppearance>mgGetNextLightPointAppearance</A>, 
<A HREF=#mgGetLightPointAnimation>mgGetLightPointAnimation</A>, 
<A HREF=#mgGetLightPointAnimationCount>mgGetLightPointAnimationCount</A>, 
<A HREF=#mgNameOfLightPointAnimation>mgNameOfLightPointAnimation</A>, 
<A HREF=#mgGetFirstLightPointAnimation>mgGetFirstLightPointAnimation</A>, 
<A HREF=#mgGetNextLightPointAnimation>mgGetNextLightPointAnimation</A></DD></DL>
<HR>
<LEFT><A NAME=mgIndexOfLightPointAppearance><H1 CLASS="APISYMBOL">mgIndexOfLightPointAppearance</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIndexOfLightPointAppearance</B> - gets the index of a named 
entry in the light point appearance palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgIndexOfLightPointAppearance</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>name</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgIndexOfLightPointAppearance</B> returns the index of the entry 
named <I>name</I> in the light point appearance palette for database <I>db</I>. 
If the entry is not found, -1 is returned.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>name</I></DT><DD>the name of the entry to look up</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the index of the palette entry if found, -1 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetLightPointAppearance>mgGetLightPointAppearance</A>, 
<A HREF=#mgGetLightPointAppearanceCount>mgGetLightPointAppearanceCount</A>, 
<A HREF=#mgNameOfLightPointAppearance>mgNameOfLightPointAppearance</A>, 
<A HREF=#mgGetFirstLightPointAppearance>mgGetFirstLightPointAppearance</A>, 
<A HREF=#mgGetNextLightPointAppearance>mgGetNextLightPointAppearance</A>, 
<A HREF=#mgGetLightPointAnimation>mgGetLightPointAnimation</A>, 
<A HREF=#mgGetLightPointAnimationCount>mgGetLightPointAnimationCount</A>, 
<A HREF=#mgIndexOfLightPointAnimation>mgIndexOfLightPointAnimation</A>, 
<A HREF=#mgNameOfLightPointAnimation>mgNameOfLightPointAnimation</A>, 
<A HREF=#mgGetFirstLightPointAnimation>mgGetFirstLightPointAnimation</A>, 
<A HREF=#mgGetNextLightPointAnimation>mgGetNextLightPointAnimation</A></DD></DL>
<HR>
<LEFT><A NAME=mgIndexOfLightSource><H1 CLASS="APISYMBOL">mgIndexOfLightSource</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIndexOfLightSource</B> - gets the index of a named light 
source palette entry.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgIndexOfLightSource</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>name</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgIndexOfLightSource</B> returns the index of the light source 
entry record named <I>name</I> in the light source palette of  <I>db</I>. 
If the named light source is not found, -1 is returned.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>name</I></DT><DD>the name of the light source entry 
to search for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the index of the named light source palette entry if found, 
-1 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetLightSource>mgGetLightSource</A>, <A HREF=#mgNameOfLightSource>mgNameOfLightSource</A></DD></DL>
<HR>
<LEFT><A NAME=mgIndexOfMaterial><H1 CLASS="APISYMBOL">mgIndexOfMaterial</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIndexOfMaterial</B> - gets the index of a named 
material palette entry.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgIndexOfMaterial</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>name</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><I>mgIndexOfMaterial</I> returns the index of the material palette 
entry record named <I>name</I> in the material table of database node 
<I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>name</I></DT><DD>the name of the material entry to search for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the index of the named material palette entry, 
or -1 if no entry is found.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetMaterial>mgGetMaterial</A>, <A HREF=#mgNewMaterial>mgNewMaterial</A></DD></DL>
<HR>
<LEFT><A NAME=mgIndexOfShader><H1 CLASS="APISYMBOL">mgIndexOfShader</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIndexOfShader</B> - gets the index of a named 
shader palette entry.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgIndexOfShader</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>name</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><I>mgIndexOfShader</I> returns the index of the shader palette 
entry record named <I>name</I> in the shader table of database node 
<I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>name</I></DT><DD>the name of the shader entry to search for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the index of the named shader palette entry, 
or -1 if no entry is found.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetShader>mgGetShader</A>, <A HREF=#mgNewShader>mgNewShader</A></DD></DL>
<HR>
<LEFT><A NAME=mgIndexOfSound><H1 CLASS="APISYMBOL">mgIndexOfSound</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIndexOfSound</B> - gets the index of a named sound palette entry.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgIndexOfSound</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>name</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgIndexOfSound</B> returns the index of the sound 
entry record named <I>name</I> in the sound palette of <I>db</I>. 
If the named sound is not found, -1 is returned.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>name</I></DT><DD>the name of the sound entry</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the index of the named sound palette entry or -1 if no entry is found.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetSound>mgGetSound</A>, <A HREF=#mgNameOfSound>mgNameOfSound</A></DD></DL>
<HR>
<LEFT><A NAME=mgIndexOfTextureMapping><H1 CLASS="APISYMBOL">mgIndexOfTextureMapping</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIndexOfTextureMapping</B> - gets the index of a named 
texture mapping palette entry.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgIndexOfTextureMapping</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>name</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><I>mgIndexOfTextureMapping</I> returns the index of the texture mapping 
palette entry record named <I>name</I> in the texture mapping table of database 
node <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>name</I></DT><DD>the name of the texture mapping entry to search for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the index of the named texture mapping palette entry, 
or -1 if no entry is found.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetTextureMapping>mgGetTextureMapping</A>, <A HREF=#mgNewTextureMapping>mgNewTextureMapping</A></DD></DL>
<HR>
<LEFT><A NAME=mgInit><H1 CLASS="APISYMBOL">mgInit</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgInit</B> - initializes the OpenFlight API software 
development environment.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgInit</B> (</TD><TD>int*</TD><TD><I>argc</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>argv[]</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgInit</B> initializes the OpenFlight API. In general this is the first 
function an application should call. This function performs the proper 
initialization of internal memory, the default palettes (color, material, 
light source, texture, etc), and loads the OpenFlight Data Dictionary. 
It is a mandatory call to activate the OpenFlight API programming environment.</P></DD><DD><P>There are some functions you can call in the OpenFlight API before 
this function. For example, your application can call <A HREF=#mgSetMessagesEnabled>mgSetMessagesEnabled</A> 
to control what messages are displayed by <B>mgInit</B> when it is called. 
Also, if your stand-alone application specifies a custom folder from which 
plug-ins are to be loaded, you must call <A HREF=#mgSetPluginFolder>mgSetPluginFolder</A> before <B>mgInit</B>.</P></DD><DD><P>Note: This function is for use in stand-alone applications only, 
and should not be called from inside a plug-in.  Doing so may yield 
undefined results.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>argc</I></DT><DD>pointer to an int containing the number of 
command line arguments</DD><DT><I>argv[]</I></DT><DD>the array of command line argument strings</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgOpenDb>mgOpenDb</A>, <A HREF=#mgIsInitialized>mgIsInitialized</A>, <A HREF=#mgExit>mgExit</A></DD></DL>
<HR>
<LEFT><A NAME=mgInitSwitchMask><H1 CLASS="APISYMBOL">mgInitSwitchMask</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgInitSwitchMask</B> - resets every bit of the mask of a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSwitch>fltSwitch</A>
 node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgInitSwitchMask</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maskNo</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>on</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgInitSwitchMask</B> locates the mask of <I>maskNo</I> in a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSwitch>fltSwitch</A>
 node 
of <I>rec</I> and turns all bits on or off based on the value of <I>on</I>.</P></DD><DD><P>The value of <I>maskNo</I> must be between 0 and the number of masks 
of <I>rec</I> minus 1 (the first mask is <I>maskNo</I> 0).</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSwitch>fltSwitch</A>
 node</DD><DT><I>maskNo</I></DT><DD>mask index starting from 0</DD><DT><I>on</I></DT><DD>value to set all bits to</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetSwitchMaskCount>mgGetSwitchMaskCount</A>, 
<A HREF=#mgGetSwitchMaskNo>mgGetSwitchMaskNo</A>, 
<A HREF=#mgGetSwitchBit>mgGetSwitchBit</A>, 
<A HREF=#mgGetSwitchMaskName>mgGetSwitchMaskName</A>, 
<A HREF=#mgAddSwitchMask>mgAddSwitchMask</A>, 
<A HREF=#mgDeleteSwitchMask>mgDeleteSwitchMask</A>, 
<A HREF=#mgSetSwitchBit>mgSetSwitchBit</A>, 
<A HREF=#mgSetSwitchMaskName>mgSetSwitchMaskName</A></DD></DL>
<HR>
<LEFT><A NAME=mgInputDeviceGetButtonStatus><H1 CLASS="APISYMBOL">mgInputDeviceGetButtonStatus</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgInputDeviceGetButtonStatus</B> - gets the state of a button on 
an input device.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgmousestate <B>mgInputDeviceGetButtonStatus</B> (</TD><TD><A HREF=#mginputdevice>mginputdevice</A></TD><TD><I>inputDevice</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>buttonNo</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgInputDeviceGetButtonStatus</B> gets the state of the button <I>buttonNo</I> 
from the input device <I>inputDevice</I>.</P></DD><DD><P>Note: The mouse pointer device does not set button states.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>inputDevice</I></DT><DD>the input device</DD><DT><I>buttonNo</I></DT><DD>the button number</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the state of the button <I>buttonNo</I> on the input device.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgInputDeviceSetButtonStatus>mgInputDeviceSetButtonStatus</A>, <A HREF=#mgvertexinputdata>mgvertexinputdata</A>, <A HREF=#mgmousestate>mgmousestate</A></DD></DL>
<HR>
<LEFT><A NAME=mgInputDeviceGetDeviceData><H1 CLASS="APISYMBOL">mgInputDeviceGetDeviceData</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgInputDeviceGetDeviceData</B> - gets the device data from an input device.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgdeviceinputdata* <B>mgInputDeviceGetDeviceData</B> (</TD><TD><A HREF=#mginputdevice>mginputdevice</A></TD><TD><I>inputDevice</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgInputDeviceGetDeviceData</B> gets any device specific data set on the input 
device <I>inputDevice</I>.</P></DD><DD><P>Note: The mouse pointer device does not set device specific data.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>inputDevice</I></DT><DD>the input device</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the device specific data set (if any) on the input device.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgdeviceinputdata>mgdeviceinputdata</A></DD></DL>
<HR>
<LEFT><A NAME=mgInputDeviceGetHandle><H1 CLASS="APISYMBOL">mgInputDeviceGetHandle</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgInputDeviceGetHandle</B> - requests the device handle 
to report events.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mginputdevice <B>mgInputDeviceGetHandle</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>pluginTool</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgInputDeviceGetHandle</B> tries to give focus to the specified plug-in 
input device <I>pluginTool</I> and returns the device handle if successful. 
The OpenFlight API maintains device handles to ensure that input from different 
devices are treated properly.  A plug-in device must obtain a device handle before 
sending an event.</P></DD><DD><P>A device (say the mouse) has focus while it is in the middle of 
a <A HREF=#mgmousestate>MMSS_START</A> - <A HREF=#mgmousestate>MMSS_CONTINUE</A> - 
<A HREF=#mgmousestate>MMSS_STOP</A> event sequence.  A device must re-acquire 
the device handle each time it calls <A HREF=#mgInputDeviceSendEvent>mgInputDeviceSendEvent</A>. 
No other devices can obtain the device handle until the device that 
has focus reports the button state <A HREF=#mgmousestate>MMSS_STOP</A>.</P></DD><DD><P>The device handle must not be stored, since it may become invalid 
some time later (after it has lost focus).</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginTool</I></DT><DD>the input device plug-in tool</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the device handle if plug-in device can get focus, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgInputDeviceSetPoint>mgInputDeviceSetPoint</A>, <A HREF=#mgInputDeviceSetButtonStatus>mgInputDeviceSetButtonStatus</A>, 
<A HREF=#mgInputDeviceSetVertex>mgInputDeviceSetVertex</A>, <A HREF=#mgInputDeviceSendEvent>mgInputDeviceSendEvent</A></DD></DL>
<HR>
<LEFT><A NAME=mgInputDeviceSendEvent><H1 CLASS="APISYMBOL">mgInputDeviceSendEvent</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgInputDeviceSendEvent</B> - sends the current event to the tool.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgInputDeviceSendEvent</B> (</TD><TD><A HREF=#mginputdevice>mginputdevice</A></TD><TD><I>inputDevice</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgInputDeviceSendEvent</B> sends the events specified by any <A HREF=#mgInputDeviceSetVertex>mgInputDeviceSetVertex</A>, 
<A HREF=#mgInputDeviceSetPoint>mgInputDeviceSetPoint</A>, <A HREF=#mgInputDeviceSetButtonStatus>mgInputDeviceSetButtonStatus</A>, <A HREF=#mgInputDeviceSetVertex>mgInputDeviceSetVertex</A> and 
<A HREF=#mgInputDeviceSetDeviceData>mgInputDeviceSetDeviceData</A> calls to the requesting tool.  The device 
<I>inputDevice</I> must have been previously obtained by <A HREF=#mgInputDeviceGetHandle>mgInputDeviceGetHandle</A></P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>inputDevice</I></DT><DD>the input device obtained from <A HREF=#mgInputDeviceGetHandle>mgInputDeviceGetHandle</A></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgInputDeviceSetVertex>mgInputDeviceSetVertex</A>, <A HREF=#mgInputDeviceSetPoint>mgInputDeviceSetPoint</A>, <A HREF=#mgInputDeviceSetButtonStatus>mgInputDeviceSetButtonStatus</A>, 
<A HREF=#mgInputDeviceSetDeviceData>mgInputDeviceSetDeviceData</A>, <A HREF=#mgInputDeviceGetHandle>mgInputDeviceGetHandle</A></DD></DL>
<HR>
<LEFT><A NAME=mgInputDeviceSetButtonStatus><H1 CLASS="APISYMBOL">mgInputDeviceSetButtonStatus</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgInputDeviceSetButtonStatus</B> - sets the state of a button on an input device.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgInputDeviceSetButtonStatus</B> (</TD><TD><A HREF=#mginputdevice>mginputdevice</A></TD><TD><I>inputDevice</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>button</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgmousestate>mgmousestate</A></TD><TD><I>state</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgInputDeviceSetButtonStatus</B> sets the state of a button <I>button</I> to <I>state</I> on the 
input device <I>inputDevice</I> obtained by <A HREF=#mgInputDeviceGetHandle>mgInputDeviceGetHandle</A>.  The event is sent by calling 
<A HREF=#mgInputDeviceSendEvent>mgInputDeviceSendEvent</A>.  There can be a maximum of 128 buttons.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>inputDevice</I></DT><DD>the input device obtained from <A HREF=#mgInputDeviceGetHandle>mgInputDeviceGetHandle</A></DD><DT><I>button</I></DT><DD>the button number</DD><DT><I>state</I></DT><DD>state of the button - one of <A HREF=#mgmousestate>MMSS_START</A>, 
<A HREF=#mgmousestate>MMSS_CONTINUE</A> or <A HREF=#mgmousestate>MMSS_STOP</A></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgInputDeviceSendEvent>mgInputDeviceSendEvent</A>, <A HREF=#mgInputDeviceGetHandle>mgInputDeviceGetHandle</A>, <A HREF=#mgInputDeviceSetVertex>mgInputDeviceSetVertex</A>, 
<A HREF=#mgInputDeviceSetPoint>mgInputDeviceSetPoint</A></DD></DL>
<HR>
<LEFT><A NAME=mgInputDeviceSetDeviceData><H1 CLASS="APISYMBOL">mgInputDeviceSetDeviceData</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgInputDeviceSetDeviceData</B> - sets device specific data on an input device.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgInputDeviceSetDeviceData</B> (</TD><TD><A HREF=#mginputdevice>mginputdevice</A></TD><TD><I>inputDevice</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>deviceData</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgInputDeviceSetDeviceData</B> sets device specific data <I>deviceData</I> on the 
input device <I>inputDevice</I> obtained by <A HREF=#mgInputDeviceGetHandle>mgInputDeviceGetHandle</A>.  The event is sent 
by calling <A HREF=#mgInputDeviceSendEvent>mgInputDeviceSendEvent</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>inputDevice</I></DT><DD>the input device obtained from <A HREF=#mgInputDeviceGetHandle>mgInputDeviceGetHandle</A></DD><DT><I>deviceData</I></DT><DD>device specific data</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgInputDeviceSendEvent>mgInputDeviceSendEvent</A>, <A HREF=#mgInputDeviceGetHandle>mgInputDeviceGetHandle</A></DD></DL>
<HR>
<LEFT><A NAME=mginputdevicesetinputtypefunc><H1 CLASS="APISYMBOL">mginputdevicesetinputtypefunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mginputdevicesetinputtypefunc</B> - Input Device Set Input Type function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus (*<B>mginputdevicesetinputtypefunc</B>) ( <TD><A HREF=#mginputdevice>mginputdevice</A> <TD><I>inputDevice</I>, 
<TR><TD></TD><TD>int <TD><I>inputFlags</I>, 
<TR><TD></TD><TD>void* <TD><I>userData</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for set input type functions for input device 
plug-in tools. 
When you register an input device plug-in tool, you will provide a function of 
this form that will be called to notify your tool that a different type of device 
input is desired from your device.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>inputDevice</I></DT><DD>the input device</DD><DT><I>inputFlags</I></DT><DD>the type of input desired - one of 
<A HREF=#mgmouseinputtype>MMSI_VERTEXINPUT</A>, 
<A HREF=#mgmouseinputtype>MMSI_POINTINPUT</A>, and 
<A HREF=#mgmouseinputtype>MMSI_DEVICEINPUT</A></DD><DT><I>userData</I></DT><DD>user defined data specified when input 
device plug-in was registered</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Return <A HREF=#MSTAT_OK>MSTAT_OK</A> to indicate that the input device can send the 
specified type of input.  Return any other non-zero value to represent 
a device specific error code.
</DD></DL><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterInputDevice>mgRegisterInputDevice</A>, 
<A HREF=#mginputdevicestartfunc>mginputdevicestartfunc</A>, 
<A HREF=#mginputdevicestopfunc>mginputdevicestopfunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgInputDeviceSetPoint><H1 CLASS="APISYMBOL">mgInputDeviceSetPoint</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgInputDeviceSetPoint</B> - sets a point on an input device.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgInputDeviceSetPoint</B> (</TD><TD><A HREF=#mginputdevice>mginputdevice</A></TD><TD><I>inputDevice</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>y</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgInputDeviceSetPoint</B> sets a 2D point with coordinates <I>x</I>, <I>y</I> on the 
input device <I>inputDevice</I> obtained by <A HREF=#mgInputDeviceGetHandle>mgInputDeviceGetHandle</A>.  The event is sent 
by calling <A HREF=#mgInputDeviceSendEvent>mgInputDeviceSendEvent</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>inputDevice</I></DT><DD>the input device obtained from <A HREF=#mgInputDeviceGetHandle>mgInputDeviceGetHandle</A></DD><DT><I>x</I></DT><DD>x coordinate of the point</DD><DT><I>y</I></DT><DD>y coordinate of the point</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgInputDeviceSendEvent>mgInputDeviceSendEvent</A>, <A HREF=#mgInputDeviceGetHandle>mgInputDeviceGetHandle</A>, <A HREF=#mgInputDeviceSetVertex>mgInputDeviceSetVertex</A></DD></DL>
<HR>
<LEFT><A NAME=mgInputDeviceSetVertex><H1 CLASS="APISYMBOL">mgInputDeviceSetVertex</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgInputDeviceSetVertex</B> - sets a vertex on an input device.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgInputDeviceSetVertex</B> (</TD><TD><A HREF=#mginputdevice>mginputdevice</A></TD><TD><I>inputDevice</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>y</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>z</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgInputDeviceSetVertex</B> sets a vertex with coordinates <I>x</I>, <I>y</I>, <I>z</I> on the 
input device <I>inputDevice</I> obtained by <A HREF=#mgInputDeviceGetHandle>mgInputDeviceGetHandle</A>.  The event is sent 
by calling <A HREF=#mgInputDeviceSendEvent>mgInputDeviceSendEvent</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>inputDevice</I></DT><DD>the input device obtained from <A HREF=#mgInputDeviceGetHandle>mgInputDeviceGetHandle</A></DD><DT><I>x</I></DT><DD>x coordinate of the vertex</DD><DT><I>y</I></DT><DD>y coordinate of the vertex</DD><DT><I>z</I></DT><DD>z coordinate of the vertex</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgInputDeviceSendEvent>mgInputDeviceSendEvent</A>, <A HREF=#mgInputDeviceGetHandle>mgInputDeviceGetHandle</A>, <A HREF=#mgInputDeviceSetPoint>mgInputDeviceSetPoint</A></DD></DL>
<HR>
<LEFT><A NAME=mginputdevicestartfunc><H1 CLASS="APISYMBOL">mginputdevicestartfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mginputdevicestartfunc</B> - Input Device Start function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus (*<B>mginputdevicestartfunc</B>) ( <TD><A HREF=#mginputdevice>mginputdevice</A> <TD><I>inputDevice</I>, 
<TR><TD></TD><TD>int <TD><I>inputFlags</I>, 
<TR><TD></TD><TD>void* <TD><I>userData</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for input device start functions for input device 
plug-in tools. 
When you register an input device plug-in tool, you will provide a function 
of this form that will be called to notify your tool that device input is desired.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>inputDevice</I></DT><DD>the input device</DD><DT><I>inputFlags</I></DT><DD>the type of input desired - one of 
<A HREF=#mgmouseinputtype>MMSI_VERTEXINPUT</A>, 
<A HREF=#mgmouseinputtype>MMSI_POINTINPUT</A>, and 
<A HREF=#mgmouseinputtype>MMSI_DEVICEINPUT</A></DD><DT><I>userData</I></DT><DD>user defined data specified when input 
device plug-in was registered</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Return <A HREF=#MSTAT_OK>MSTAT_OK</A> to indicate that the input device started correctly. 
Return any other non-zero value to represent a device specific error code.
</DD></DL><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterInputDevice>mgRegisterInputDevice</A>, 
<A HREF=#mginputdevicestopfunc>mginputdevicestopfunc</A>, 
<A HREF=#mginputdevicesetinputtypefunc>mginputdevicesetinputtypefunc</A></DD></DL>
<HR>
<LEFT><A NAME=mginputdevicestopfunc><H1 CLASS="APISYMBOL">mginputdevicestopfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mginputdevicestopfunc</B> - Input Device Stop function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus (*<B>mginputdevicestopfunc</B>) ( <TD><A HREF=#mginputdevice>mginputdevice</A> <TD><I>inputDevice</I>, 
<TR><TD></TD><TD>void* <TD><I>userData</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for input device stop functions for input device 
plug-in tools. 
When you register an input device plug-in tool, you will provide a function 
of this form that will be called to notify your tool that device input is no 
longer desired from your device.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>inputDevice</I></DT><DD>the input device</DD><DT><I>userData</I></DT><DD>user defined data specified when input 
device plug-in was registered</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Return <A HREF=#MSTAT_OK>MSTAT_OK</A> to indicate that the input device stopped correctly. 
Return any other non-zero value to represent a device specific error code.
</DD></DL><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterInputDevice>mgRegisterInputDevice</A>, 
<A HREF=#mginputdevicestartfunc>mginputdevicestartfunc</A>, 
<A HREF=#mginputdevicesetinputtypefunc>mginputdevicesetinputtypefunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgInsert><H1 CLASS="APISYMBOL">mgInsert</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgInsert</B> - inserts a node or transformation record into the database hierarchy.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgInsert</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>sibling</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>node</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a sibling record <I>sibling</I>, <B>mgInsert</B> inserts <I>node</I> after <I>sibling</I> in 
the database hierarchy.</P></DD><DD><P>If <I>sibling</I> and <I>node</I> are both node records, the resulting hierarchy has 
<I>node</I> as the next sibling of <I>sibling</I>.  Note that <I>node</I> will retain its original 
children nodes.</P></DD><DD><P>Similarly, if <I>sibling</I> and <I>node</I> are both transformation records, the resulting 
hierarchy has <I>node</I> as the next transformation after <I>sibling</I>.</P></DD><DD><P>Alternatively, you can use <A HREF=#mgAttach>mgAttach</A> to attach a child as the first child of a parent or 
<B>mgInsert</B> to insert a node after a sibling.</P></DD><DD><P>Note: <I>sibling</I> and <I>node</I> must either both be node records or both be transformation 
records.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>sibling</I></DT><DD>the sibling node or transformation record</DD><DT><I>node</I></DT><DD>the node or transformation record 
to be linked into the hierarchy</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show the differences when using <A HREF=#mgAttach>mgAttach</A>, 
<A HREF=#mgAppend>mgAppend</A>, and <B>mgInsert</B> to attach new polygons to an object in the database.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">static void MakeNewPolys (mgrec* object)
{
   mgrec* poly1 = mgNewRec (fltPolygon);
   mgrec* poly2 = mgNewRec (fltPolygon);
   mgrec* poly3 = mgNewRec (fltPolygon);
   mgAttach (object, poly1);  // poly1 becomes first child of object
   mgAppend (object, poly2);  // poly2 becomes last child of object
   mgInsert (poly1, poly3);   // poly3 is inserted after poly1
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">def MakeNewPolys (object):
   poly1 = mgNewRec (fltPolygon)
   poly2 = mgNewRec (fltPolygon)
   poly3 = mgNewRec (fltPolygon)
   mgAttach (object, poly1)   # poly1 becomes first child of object
   mgAppend (object, poly2)   # poly2 becomes last child of object
   mgInsert (poly1, poly3)    # poly3 is inserted after poly1</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgAttach>mgAttach</A>, <A HREF=#mgAppend>mgAppend</A>, <A HREF=#mgReference>mgReference</A></DD></DL>
<HR>
<LEFT><A NAME=mgInsertTexture><H1 CLASS="APISYMBOL">mgInsertTexture</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgInsertTexture</B> - loads a texture and creates a new entry 
in a database's texture palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgInsertTexture</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>textureName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgInsertTexture</B> loads a texture from file 
<I>textureName</I> into the texture palette for database <I>db</I>. 
The created palette entry is automatically positioned in the palette such 
that no other textures are covered.  The index of the new texture is 
also automatically assigned.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>textureName</I></DT><DD>the name of the texture file to load</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the index assigned to the new palette entry if successful, -1 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadTexture>mgReadTexture</A>,  <A HREF=#mgInsertTextureAndAlpha>mgInsertTextureAndAlpha</A>,  <A HREF=#mgReadTextureAndAlpha>mgReadTextureAndAlpha</A>, 
<A HREF=#mgWriteTexture>mgWriteTexture</A></DD></DL>
<HR>
<LEFT><A NAME=mgInsertTextureAndAlpha><H1 CLASS="APISYMBOL">mgInsertTextureAndAlpha</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgInsertTextureAndAlpha</B> - loads a texture and alpha mask as a 
single texture palette entry.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgInsertTextureAndAlpha</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>textureName</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>alphaName</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>mergeName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgInsertTextureAndAlpha</B> loads a texture and alpha mask from files 
<I>textureName</I> and <I>alphaName</I>, respectively, into the texture 
palette for database <I>db</I>.  The created palette entry is automatically 
positioned in the palette such that no other textures are covered. 
The index of the new texture is also automatically assigned.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>textureName</I></DT><DD>the name of the texture file on disk</DD><DT><I>alphaName</I></DT><DD>the name of the alpha mask file on disk</DD><DT><I>mergeName</I></DT><DD>the name to associate with the merged 
texture in the palette</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the index assigned to the new palette entry if successful, or returns -1 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadTexture>mgReadTexture</A>,  <A HREF=#mgInsertTexture>mgInsertTexture</A>,  <A HREF=#mgReadTextureAndAlpha>mgReadTextureAndAlpha</A>, 
<A HREF=#mgWriteTexture>mgWriteTexture</A></DD></DL>
<HR>
<LEFT><A NAME=mgIsCode><H1 CLASS="APISYMBOL">mgIsCode</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIsCode</B> - determines if a record is of a given code type.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgIsCode</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgIsCode</B> determines if the specified record <I>rec</I> is of code, <I>code</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record to check</DD><DT><I>code</I></DT><DD>the code to compare</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the records code is <B>code</B>, <A HREF=#mgbool>MG_FALSE</A> 
otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* poly;
mgrec* mesh;
mgbool isPoly;
mgbool isMesh;

poly = mgNewRec (fltPolygon);
mesh = mgNewRec (fltMesh);
isPoly = mgIsCode (poly, fltPolygon);&#32&#32// MG_TRUE
isMesh = mgIsCode (poly, fltPolygon);&#32&#32// MG_FALSE</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCode>mgGetCode</A></DD></DL>
<HR>
<LEFT><A NAME=mgIsDb><H1 CLASS="APISYMBOL">mgIsDb</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIsDb</B> - checks if a file is an OpenFlight database file.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgIsDb</B> (</TD><TD>const char*</TD><TD><I>fileName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgIsDb</B> determines whether the file named by <I>fileName</I> is 
an OpenFlight database file.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>fileName</I></DT><DD>the name of the file to be checked</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the specified file is an OpenFlight 
database file, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewDb>mgNewDb</A>, <A HREF=#mgOpenDb>mgOpenDb</A>, <A HREF=#mgCloseDb>mgCloseDb</A></DD></DL>
<HR>
<LEFT><A NAME=mgIsDbModified><H1 CLASS="APISYMBOL">mgIsDbModified</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIsDbModified</B> - checks if a database has been modified 
since the last "save" operation.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgIsDbModified</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgIsDbModified</B> determines whether the database <I>db</I> has been 
modified since it was last written out to disk.</P></DD><DD><P>Note: This function is only applicable in the Creator modeler environment. 
If called from the stand application environment, the value returned is not 
reliable.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database to check</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the specified database has been modified 
since it was last saved, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetDbModified>mgSetDbModified</A>, <A HREF=#mgIsDbUntitled>mgIsDbUntitled</A>, <A HREF=#mgIsFileOnDesktop>mgIsFileOnDesktop</A></DD></DL>
<HR>
<LEFT><A NAME=mgIsDbOnDesktop><H1 CLASS="APISYMBOL">mgIsDbOnDesktop</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIsDbOnDesktop</B> - checks if a database is open on the 
Creator desktop.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgIsDbOnDesktop</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgIsDbOnDesktop</B> determines whether the database <I>db</I> is open 
on the Creator desktop.</P></DD><DD><P>Note: This function is only applicable in the Creator modeler environment 
and will always return <A HREF=#mgbool>MG_FALSE</A> when called by a stand-alone application.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database to check</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the specified database is open on the 
Creator desktop, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgIsFileOnDesktop>mgIsFileOnDesktop</A>, <A HREF=#mgGetDbOnDesktop>mgGetDbOnDesktop</A>, <A HREF=#mgIsDbUntitled>mgIsDbUntitled</A>, <A HREF=#mgIsDbModified>mgIsDbModified</A></DD></DL>
<HR>
<LEFT><A NAME=mgIsDbUntitled><H1 CLASS="APISYMBOL">mgIsDbUntitled</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIsDbUntitled</B> - checks if a database has a valid name.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgIsDbUntitled</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgIsDbUntitled</B> determines whether the database <I>db</I> has yet 
been "named".  In Creator, when a user creates a new database, it does not 
have a valid name until it has been saved to disk.</P></DD><DD><P>Prior to being saved, the name of the database (returned by 
<A HREF=#mgRec2Filename>mgRec2Filename</A>) is a "temporary" one and should not be used for 
locating relative textures, external references, and shaders.  Only after a 
database has been saved to an explicit file will its name be valid.</P></DD><DD><P>Note: This function is only applicable in the Creator modeler environment. 
Since databases in the stand-alone application environment are always explicitly 
named, this function will always return <A HREF=#mgbool>MG_FALSE</A> when called by a 
stand-alone application.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database to check</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the specified database has not yet 
been named, <A HREF=#mgbool>MG_FALSE</A> otherwise.  This function will also return 
<A HREF=#mgbool>MG_FALSE</A> if <I>db</I> is not a valid database node.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRec2Filename>mgRec2Filename</A>, <A HREF=#mgIsDbModified>mgIsDbModified</A>, <A HREF=#mgIsFileOnDesktop>mgIsFileOnDesktop</A></DD></DL>
<HR>
<LEFT><A NAME=mgIsEnabled><H1 CLASS="APISYMBOL">mgIsEnabled</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIsEnabled</B> - determine if a control in a dialog is enabled.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgIsEnabled</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgIsEnabled</B> determines if a control in a dialog is enabled. 
Controls that are enabled can accept user input.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the control is enabled, <A HREF=#mgbool>MG_FALSE</A> 
otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetEnabled>mgSetEnabled</A>, <A HREF=#mgSetVisible>mgSetVisible</A>, <A HREF=#mgIsVisible>mgIsVisible</A></DD></DL>
<HR>
<LEFT><A NAME=mgIsFileOnDesktop><H1 CLASS="APISYMBOL">mgIsFileOnDesktop</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIsFileOnDesktop</B> - checks if an OpenFlight file is open 
on the Creator desktop.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgIsFileOnDesktop</B> (</TD><TD>const char*</TD><TD><I>fileName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgIsFileOnDesktop</B> determines whether the OpenFlight file 
<I>fileName</I> is open on the Creator desktop.</P></DD><DD><P>Note: This function is only applicable in the Creator modeler environment 
and will always return <A HREF=#mgbool>MG_FALSE</A> when called by a stand-alone application.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>fileName</I></DT><DD>the name of the file to check</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the specified file is open on the 
Creator desktop, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgIsDbOnDesktop>mgIsDbOnDesktop</A>, <A HREF=#mgGetDbOnDesktop>mgGetDbOnDesktop</A>, <A HREF=#mgIsDbUntitled>mgIsDbUntitled</A>, <A HREF=#mgIsDbModified>mgIsDbModified</A></DD></DL>
<HR>
<LEFT><A NAME=mgIsFirstInstance><H1 CLASS="APISYMBOL">mgIsFirstInstance</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIsFirstInstance</B> - determines if a node is the first instance of 
its referenced node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgIsFirstInstance</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgIsFirstInstance</B> determines if a node <I>rec</I> is the 
first instance node of its reference node.  This routine is useful when used 
with <A HREF=#mgGetFirstInstance>mgGetFirstInstance</A> and <A HREF=#mgGetNextInstance>mgGetNextInstance</A> to visit all instances 
of a node, or when used by itself to visit only the first instance.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>an instance node</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if <I>rec</I> is the first instance of its referenced node, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReference>mgReference</A>, <A HREF=#mgDeReference>mgDeReference</A>, <A HREF=#mgGetFirstInstance>mgGetFirstInstance</A>, 
<A HREF=#mgGetNextInstance>mgGetNextInstance</A></DD></DL>
<HR>
<LEFT><A NAME=mgIsFlagOn><H1 CLASS="APISYMBOL">mgIsFlagOn</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIsFlagOn</B> - determines if a node is <B>On</B>.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgIsFlagOn</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgIsFlagOn</B> determines if the node <I>rec</I> is <B>On</B>. 
Nodes are turned <B>On</B> and <B>Off</B> to distinguish between 
different levels of detail.  Nodes belonging to the current 
level of detail are, by default, <B>On</B>. Additionally, non-vertex 
nodes can be explicitly toggled <B>On</B> and <B>Off</B> by the modeler 
using the <B>Toggle Display</B> command. On the other hand, vertex 
nodes are always <B>On</B>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to check</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the node is <B>On</B>, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMoreDetail>mgMoreDetail</A>, <A HREF=#mgLessDetail>mgLessDetail</A>, <A HREF=#mgMostDetail>mgMostDetail</A>, 
<A HREF=#mgLeastDetail>mgLeastDetail</A>, <A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A></DD></DL>
<HR>
<LEFT><A NAME=mgIsInitialized><H1 CLASS="APISYMBOL">mgIsInitialized</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIsInitialized</B> - checks if the OpenFlight API software 
development environment has been initialized.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> void <B>mgIsInitialized</B> ( void ) </DD>
</DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if <A HREF=#mgInit>mgInit</A> has been called, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgOpenDb>mgOpenDb</A>, <A HREF=#mgInit>mgInit</A>, <A HREF=#mgExit>mgExit</A></DD></DL>
<HR>
<LEFT><A NAME=mgIsInstance><H1 CLASS="APISYMBOL">mgIsInstance</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIsInstance</B> - determines if a node is an instance node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgIsInstance</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgIsInstance</B> determines if the node <I>rec</I> is one of the instance nodes 
of a reference node.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node in question</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the node is an instance, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetReference>mgGetReference</A>, <A HREF=#mgReference>mgReference</A>, <A HREF=#mgDeReference>mgDeReference</A>, <A HREF=#mgIsReference>mgIsReference</A>, 
<A HREF=#mgIsFirstInstance>mgIsFirstInstance</A>, <A HREF=#mgGetFirstInstance>mgGetFirstInstance</A>, <A HREF=#mgGetNextInstance>mgGetNextInstance</A></DD></DL>
<HR>
<LEFT><A NAME=mgIsModelingModeEdge><H1 CLASS="APISYMBOL">mgIsModelingModeEdge</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIsModelingModeEdge</B> - checks if the current modeling mode is edge.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgIsModelingModeEdge</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgIsModelingModeEdge</B> checks if the current modeling mode for the 
specified database <I>db</I> is edge.  The edge modeling mode is a special case 
of vertex mode.  In edge mode, <A HREF=#mgGetModelingMode>mgGetModelingMode</A> will return <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 
(since there is no "edge" type in OpenFlight) and this function will return 
<A HREF=#mgbool>MG_TRUE</A>.  In vertex mode <A HREF=#mgGetModelingMode>mgGetModelingMode</A> will return <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 
and this function will return <A HREF=#mgbool>MG_FALSE</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database to check modeling mode for</DD></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">// check if modeling mode is edge mode
// if mgIsModelingModeEdge() returns MG_TRUE
// you don't have to check mgGetModelingMode()
mgbool isEdgeMode = mgIsModelingModeEdge (db);

// check if modeling mode is vertex mode
// mgGetModelingMode() is ambiguous if it returns fltVertex
// must also check that it mgIsModelingModeEdge() is MG_FALSE
// to know it is vertex mode
mgbool isVertexMode = (
   (mgGetModelingMode (db) == fltVertex) &&
   (mgIsModelingModeEdge (db) == MG_FALSE)
   ) ? MG_TRUE : MG_FALSE;</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetActivationDb>mgGetActivationDb</A>, 
<A HREF=#mgGetModelingMode>mgGetModelingMode</A>, <A HREF=#mgSetModelingMode>mgSetModelingMode</A>, <A HREF=#mgSetModelingModeEdge>mgSetModelingModeEdge</A>, 
<A HREF=#mgGetModelingParent>mgGetModelingParent</A>, <A HREF=#mgGetModelingParentMatrix>mgGetModelingParentMatrix</A>, <A HREF=#mgGetDefaultModelingParent>mgGetDefaultModelingParent</A>, <A HREF=#mgSetModelingParent>mgSetModelingParent</A></DD></DL>
<HR>
<LEFT><A NAME=mgIsPolyConcave><H1 CLASS="APISYMBOL">mgIsPolyConcave</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIsPolyConcave</B> - determines if a polygon 
is concave.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgIsPolyConcave</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 record <I>poly</I>, <B>mgIsPolyConcave</B> determines 
if this polygon is concave.  If any line on the plane of the polygon 
crosses more than two edges of the polygon, then the polygon is concave.</P></DD><DD><P>Note: By convention, a polygon with no vertices is NOT considered concave 
by this function.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the polygon to check</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the polygon is concave, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgIsPolyCoplanar>mgIsPolyCoplanar</A></DD></DL>
<HR>
<LEFT><A NAME=mgIsPolyCoplanar><H1 CLASS="APISYMBOL">mgIsPolyCoplanar</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIsPolyCoplanar</B> - determines if a polygon is coplanar.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgIsPolyCoplanar</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 record <I>poly</I>, <B>mgIsPolyCoplanar</B> 
determines if this polygon is coplanar.  A polygon is colplanar if all its 
vertices lie on the same plane.</P></DD><DD><P>Note: By convention, a polygon with no vertices is considered planar 
by this function.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the polygon to check</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the polygon is coplanar, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgIsPolyConcave>mgIsPolyConcave</A></DD></DL>
<HR>
<LEFT><A NAME=mgIsReadOnly><H1 CLASS="APISYMBOL">mgIsReadOnly</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIsReadOnly</B> - determines if a node is <B>Read-Only</B>.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgIsReadOnly</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgIsReadOnly</B> determines if the node <I>rec</I> is <B>Read-Only</B>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to check</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the node is <B>Read-Only</B>, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=mgIsRecInList><H1 CLASS="APISYMBOL">mgIsRecInList</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIsRecInList</B> - determines if a node is in a record list.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgIsRecInList</B> (</TD><TD><A HREF=#mgreclist>mgreclist</A></TD><TD><I>recList</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>node</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgIsRecInList</B> determines whether or not the specified <I>node</I> 
is contained in the specified record list <I>recList</I>.</P></DD><DD><P>This function does not affect the traversal pointer of the record list.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>recList</I></DT><DD>the record list to check</DD><DT><I>node</I></DT><DD>node to look for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the item is found in the record list, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResetRecList>mgResetRecList</A>, <A HREF=#mgGetNthRecInList>mgGetNthRecInList</A></DD></DL>
<HR>
<LEFT><A NAME=mgIsReference><H1 CLASS="APISYMBOL">mgIsReference</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIsReference</B> - determines if a node is a reference node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgIsReference</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgIsReference</B> determines if a node <I>rec</I> is a reference node. 
A reference node is one that is referenced by other nodes.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node in question</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the node is a reference, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetReference>mgGetReference</A>, <A HREF=#mgReference>mgReference</A>, <A HREF=#mgDeReference>mgDeReference</A>, <A HREF=#mgIsInstance>mgIsInstance</A>, 
<A HREF=#mgIsFirstInstance>mgIsFirstInstance</A>, <A HREF=#mgGetFirstInstance>mgGetFirstInstance</A>, <A HREF=#mgGetNextInstance>mgGetNextInstance</A></DD></DL>
<HR>
<LEFT><A NAME=mgIsRelated><H1 CLASS="APISYMBOL">mgIsRelated</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIsRelated</B> - determines if a node is related 
to another node in the hierarchy.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgIsRelated</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>parent</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>child</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgIsRelated</B> determines if the node <I>child</I> is a descendant 
of node <I>parent</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>parent</I></DT><DD>the parent node record</DD><DT><I>child</I></DT><DD>the node or transformation record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the <I>child</I> is a descendant 
of <I>parent</I>, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=mgIsSelected><H1 CLASS="APISYMBOL">mgIsSelected</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIsSelected</B> - determines if a node is selected.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgIsSelected</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgIsSelected</B> determines if the specified node record 
<I>rec</I> is currently selected.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to check for selection</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if node is selected, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgIsSelectedEdge>mgIsSelectedEdge</A>, <A HREF=#mgSelectOne>mgSelectOne</A>, <A HREF=#mgSelectOneEx>mgSelectOneEx</A>, <A HREF=#mgSelectOneEdge>mgSelectOneEdge</A>, 
<A HREF=#mgDeselectOne>mgDeselectOne</A>, <A HREF=#mgDeselectAll>mgDeselectAll</A>, <A HREF=#mgSelectList>mgSelectList</A></DD></DL>
<HR>
<LEFT><A NAME=mgIsSelectedEdge><H1 CLASS="APISYMBOL">mgIsSelectedEdge</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIsSelectedEdge</B> - determines if an edge is selected.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgIsSelectedEdge</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgIsSelectedEdge</B> determines if the specified vertex node record 
<I>rec</I> is currently selected as an edge.</P></DD><DD><P>When a vertex node is selected, it may be selected as a vertex or 
as an edge.  Use this function to distinguish between these two situations.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the vertex node to check for selection 
as an edge</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if <I>rec</I> is a vertex node and is 
selected as an edge, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgIsSelected>mgIsSelected</A>, <A HREF=#mgSelectOne>mgSelectOne</A>, <A HREF=#mgSelectOneEx>mgSelectOneEx</A>, <A HREF=#mgSelectOneEdge>mgSelectOneEdge</A>, 
<A HREF=#mgDeselectOne>mgDeselectOne</A>, <A HREF=#mgDeselectAll>mgDeselectAll</A>, <A HREF=#mgSelectList>mgSelectList</A></DD></DL>
<HR>
<LEFT><A NAME=mgIsTextureDefault><H1 CLASS="APISYMBOL">mgIsTextureDefault</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIsTextureDefault</B> - determines if the default texture 
pattern has been substituted for a texture palette entry.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgIsTextureDefault</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When a texture palette entry is loaded into the texture palette, the 
file containing the image may or may not be found.  In either case, the palette 
still contains the entry but when the image file is not found or cannot be 
read, the texels and/or attributes will be unknown. 
When this happens for a texture palette entry, a default pattern (a black X on 
a white background) is substituted in the palette for the missing texels.<P>
<B>mgIsTextureDefault</B> determines whether the texels for a texture palette 
entry at the specified <I>index</I> contained in the texture palette of 
database <I>db</I> have been substituted by the default pattern texels.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the texture palette entry</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the texels for the entry have been substituted 
by the default pattern, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgIsTextureInPalette>mgIsTextureInPalette</A></DD></DL>
<HR>
<LEFT><A NAME=mgIsTextureIndexInPalette><H1 CLASS="APISYMBOL">mgIsTextureIndexInPalette</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIsTextureIndexInPalette</B> - determines if a texture index 
is in a palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgIsTextureIndexInPalette</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgIsTextureIndexInPalette</B> determines whether or not the texture 
with the specified <I>index</I> is contained in the texture palette of the 
database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the texture palette entry 
to lookup</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the texture palette entry is found, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgIsTextureDefault>mgIsTextureDefault</A>, <A HREF=#mgGetTextureCount>mgGetTextureCount</A>, <A HREF=#mgIsTextureInPalette>mgIsTextureInPalette</A>, 
<A HREF=#mgGetTextureIndex>mgGetTextureIndex</A></DD></DL>
<HR>
<LEFT><A NAME=mgIsTextureIndexSelected><H1 CLASS="APISYMBOL">mgIsTextureIndexSelected</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIsTextureIndexSelected</B> - determines if a texture index 
is selected in a palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgIsTextureIndexSelected</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgIsTextureIndexSelected</B> determines whether or not the texture 
with the specified <I>index</I> is selected in the texture palette of the 
database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the texture palette entry 
to lookup</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the texture palette entry is found 
and is selected, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSelectTextureIndex>mgSelectTextureIndex</A>, 
<A HREF=#mgDeselectTextureIndex>mgDeselectTextureIndex</A>, 
<A HREF=#mgDeselectAllTextures>mgDeselectAllTextures</A>, 
<A HREF=#mgGetFirstSelectedTexture>mgGetFirstSelectedTexture</A>, 
<A HREF=#mgGetNextSelectedTexture>mgGetNextSelectedTexture</A>, 
<A HREF=#mgGetSelectedTextureCount>mgGetSelectedTextureCount</A>, 
<A HREF=#mgIsTextureIndexInPalette>mgIsTextureIndexInPalette</A></DD></DL>
<HR>
<LEFT><A NAME=mgIsTextureInPalette><H1 CLASS="APISYMBOL">mgIsTextureInPalette</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIsTextureInPalette</B> - determines if a texture is in a 
palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgIsTextureInPalette</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>textureName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgIsTextureInPalette</B> determines whether or not the named texture 
palette entry <I>textureName</I> is contained in the texture palette of the 
database <I>db</I>. For convenience, <I>textureName</I> need not be the full path. 
In cases where an ambiguity may occur, you may avoid it by specifying the 
full path.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>textureName</I></DT><DD>the name of the texture palette entry 
to lookup</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the texture palette entry is found, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgIsTextureDefault>mgIsTextureDefault</A>, <A HREF=#mgGetTextureCount>mgGetTextureCount</A>, <A HREF=#mgIsTextureIndexInPalette>mgIsTextureIndexInPalette</A>, 
<A HREF=#mgGetTextureIndex>mgGetTextureIndex</A></DD></DL>
<HR>
<LEFT><A NAME=mgIsTextureMappingInPalette><H1 CLASS="APISYMBOL">mgIsTextureMappingInPalette</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIsTextureMappingInPalette</B> - determines if a texture 
mapping is in a database&#146s palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgIsTextureMappingInPalette</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a database node, <I>db</I>, and an index into the database&#146s 
texture mapping palette, <I>index</I>, <B>mgIsTextureMappingInPalette</B> 
reports when a mapping with the given index is in the database&#146s texture 
mapping palette.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the mapping</DD></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">int index;
mgrec* db;
if (mgIsTextureMappingInPalette (db, index))
{
   // Do Stuff
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetFirstTextureMapping>mgGetFirstTextureMapping</A>, <A HREF=#mgGetNextTextureMapping>mgGetNextTextureMapping</A>, <A HREF=#mgGetTextureMappingCount>mgGetTextureMappingCount</A></DD></DL>
<HR>
<LEFT><A NAME=mgIsVisible><H1 CLASS="APISYMBOL">mgIsVisible</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIsVisible</B> - determines if a control in a dialog is visible.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgIsVisible</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgIsVisible</B> determines if a control in a dialog is displayed. 
Controls can be displayed or hidden.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the control is displayed, <A HREF=#mgbool>MG_FALSE</A> 
otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetEnabled>mgSetEnabled</A>, <A HREF=#mgSetVisible>mgSetVisible</A>, <A HREF=#mgIsEnabled>mgIsEnabled</A></DD></DL>
<HR>
<LEFT><A NAME=mgIsXformEmpty><H1 CLASS="APISYMBOL">mgIsXformEmpty</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIsXformEmpty</B> - determines whether a transformation node has no effect.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgIsXformEmpty</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgIsXformEmpty</B> determines whether a transformation <I>rec</I> has no effect.  For 
example, a translate <A HREF=#mgxfllcode>MXLL_TRANSLATE</A> transformation that has zero delta has 
no effect and can be safely deleted without changing the position or orientation of the 
corresponding geometry.</P></DD><DD><P>Note: <I>rec</I> is assumed to be a valid transformation record.  If it is not, the 
results of this function are undefined.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the transformation node to check</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the transformation node does not have any effect. 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetXform>mgGetXform</A>, <A HREF=#mgHasXform>mgHasXform</A>, <A HREF=#mgCountXform>mgCountXform</A>, <A HREF=#mgGetXformType>mgGetXformType</A></DD></DL>
<HR>
<LEFT><A NAME=mgIterateRecList><H1 CLASS="APISYMBOL">mgIterateRecList</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgIterateRecList</B> - iterates the nodes in a record list.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgIterateRecList</B> (</TD><TD><A HREF=#mgreclist>mgreclist</A></TD><TD><I>recList</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgwalkfunc>mgwalkfunc</A></TD><TD><I>iterateFunc</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgIterateRecList</B> iterates the nodes contained in <I>recList</I>, 
calling a specified iteration callback function <I>iterateFunc</I> for each.</P></DD><DD><P>Note: <B>mgIterateRecList</B> does not traverse the children of 
the nodes in <I>recList</I>.  If you want to iterate the nodes and traverse 
their children, use <A HREF=#mgWalkRecList>mgWalkRecList</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>recList</I></DT><DD>the record list to iterate</DD><DT><I>iterateFunc</I></DT><DD>the function that is invoked 
for each node in the record list</DD><DT><I>userData</I></DT><DD>pointer to user defined data 
that will be passed to <I>iterateFunc</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if iteration successful, 
<A HREF=#mgbool>MG_FALSE</A> if iteration unsuccessful, <I>recList</I> is empty 
or if terminated by <I>iterateFunc</I>.
</DD></DL><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) iterate the selected nodes 
of a database <I>db</I> and print out the name of each node as they are iterated.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">static mgbool IterateFunc (mgrec* db, mgrec* parent, mgrec* rec, void* userData)
{
   char* name = mgGetName (rec);
   int* numNodesIteratedH = (int*) userData;
   *numNodesIteratedH = *numNodesIteratedH + 1;
   printf ("IterateFunc : %s&#92;n", name);
   mgFree (name);
   return (MG_TRUE);
}

mgreclist selectList = mgGetSelectList (db);
int numNodesIterated = 0;
mgIterateRecList (selectList, IterateFunc, &numNodesIterated);
mgFreeRecList (selectList);
printf ("Number of nodes: %d&#92;n", numNodesIterated);</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">class numNodesIterated:
   pass

def IterateFunc (db, parent, rec, i):
   print mgGetName(parent)
   print "IterateFunc :",mgGetName(rec)
   i.count = i.count + 1
   return MG_TRUE

db = mgGetCurrentDb ()
selectList = mgGetSelectList (db)
i = numNodesIterated()
i.count = 0

mgIterateRecList (selectList, IterateFunc, i)
print "Number of nodes:",i.count</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWalkRecList>mgWalkRecList</A>, <A HREF=#mgGetSelectList>mgGetSelectList</A>, <A HREF=#mgGetRecListCount>mgGetRecListCount</A>, 
<A HREF=#mgResetRecList>mgResetRecList</A>, <A HREF=#mgGetNextRecInList>mgGetNextRecInList</A>, 
<A HREF=#mgGetNthRecInList>mgGetNthRecInList</A>, <A HREF=#mgIsRecInList>mgIsRecInList</A></DD></DL>
<HR>
<LEFT><A NAME=mgLeastDetail><H1 CLASS="APISYMBOL">mgLeastDetail</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgLeastDetail</B> - changes the level of detail (LOD) for a database to the lowest level.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgLeastDetail</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgLeastDetail</B> changes the current switch-in distance of the database to the highest value (effectively 
moving the eyepoint very far from the model) such that the lowest level of detail becomes visible in the scene. 
The function then changes the visibility of each LOD node according to whether or not it would be 
visible at this new switch-in (eyepoint) distance.  The visibility of the LOD node is 
set or unset using the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltIOn>fltIOn</A>
 attribute of the node.</P></DD><DD><P>If there are no LOD nodes in the database, <B>mgLeastDetail</B> does nothing and returns 
<A HREF=#mgbool>MG_TRUE</A>, since the database is already at the lowest (and highest) level of detail. 
If <I>db</I> is not a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHeader</A>
 node, <B>mgLeastDetail</B> will return <A HREF=#mgbool>MG_FALSE</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>See <A HREF=#mgMoreDetail>mgMoreDetail</A> for an example of how you might use <B>mgLeastDetail</B> and 
<A HREF=#mgMoreDetail>mgMoreDetail</A> in conjunction to determine which nodes are visible in the scene at 
each level of detail.</DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgLessDetail>mgLessDetail</A>, <A HREF=#mgMoreDetail>mgMoreDetail</A>, <A HREF=#mgMostDetail>mgMostDetail</A>, <A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A></DD></DL>
<HR>
<LEFT><A NAME=mgLessDetail><H1 CLASS="APISYMBOL">mgLessDetail</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgLessDetail</B> - changes the level of detail (LOD) for a database to the next lower level.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgLessDetail</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgLessDetail</B> changes the current switch-in distance of the database to a larger value (effectively 
moving the eyepoint farther from the model) such that the next lower level of detail becomes visible in the scene. 
The function then changes the visibility of each LOD node according to whether or not it would be 
visible at this new switch-in (eyepoint) distance.  The visibility of the LOD node is 
set or unset using the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltIOn>fltIOn</A>
 attribute of the node.</P></DD><DD><P><B>mgLessDetail</B> returns <A HREF=#mgbool>MG_FALSE</A> if there is no lower level of detail or if the <I>db</I> 
provided is not a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHeader</A>
 node.  If the database does not contain any LOD nodes, the first call 
to <B>mgLessDetail</B> returns <A HREF=#mgbool>MG_TRUE</A>, while subsequent calls return <A HREF=#mgbool>MG_FALSE</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> if there is no lower level 
of detail or if <I>db</I> is not a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHeader</A>
 node.
</DD></DL><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show how you might use <A HREF=#mgMoreDetail>mgMoreDetail</A> to determine 
which nodes are visible in the scene at each level of detail.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">static mgbool
PrintNodeNameInLOD (mgrec* db, mgrec* parent, mgrec* rec, void* userData)
{
   // prints the name of each node visited.
   int* lodNumPtr = (int*) userData;
   int lodNum = *lodNumPtr;

   char* name = mgGetName (rec);
   printf ("Node: %s, is part of LOD %d", name, lodNum);
   mgFree (name);
   return (MG_TRUE);
}

// first count the LODs
mgLeastDetail (db);
int numLODs = 0;
while (mgMoreDetail (db)) {
   numLODs++;
}

// start at the highest level of detail
int lodNumber = numLODs;
mgMostDetail (db);
// print names of nodes that are "visible" in this level of detail
mgWalk (db, PrintNodeNameInLOD, MG_NULL, &lodNumber, MWALK_ON);

// go to next lower level of detail
while (mgLessDetail (db)) {
   lodNumber--;
   // print names of nodes that are "visible" in this level of detail
   mgWalk (db, PrintNodeNameInLOD, MG_NULL, &lodNumber, MWALK_ON);
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">def PrintNodeNameInLOD (db, parent, rec, lodNum):
   # prints the name of each node visited.
   name = mgGetName (rec)
   print "Node:", name, "is part of LOD", lodNum
   return MG_TRUE

# first count the LODs
db = mgGetCurrentDb()
mgLeastDetail (db)
numLODs = 0
while (mgMoreDetail (db)):
   numLODs = numLODs + 1

# start at the highest level of detail
lodNumber = numLODs
mgMostDetail (db)
# print names of nodes that are "visible" in this level of detail
mgWalk (db, PrintNodeNameInLOD, None, lodNumber, MWALK_ON)

# go to next lower level of detail
while (mgLessDetail (db)):
   lodNumber = lodNumber - 1
   # print names of nodes that are "visible" in this level of detail
   mgWalk (db, PrintNodeNameInLOD, None, lodNumber, MWALK_ON)</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgLeastDetail>mgLeastDetail</A>, <A HREF=#mgMoreDetail>mgMoreDetail</A>, <A HREF=#mgMostDetail>mgMostDetail</A>, <A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A></DD></DL>
<HR>
<LEFT><A NAME=mgLightPointAnimationSequenceGet><H1 CLASS="APISYMBOL">mgLightPointAnimationSequenceGet</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgLightPointAnimationSequenceGet</B> - gets the sequence items from 
a light point animation record.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgLightPointAnimationSequenceGet</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>lpaRec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mglightpointanimationsequencedata>mglightpointanimationsequencedata</A></TD><TD><I>sequenceData[]</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>arrayLen</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>numSequences, sequenceData <B>mgLightPointAnimationSequenceGet</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>lpaRec</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgLightPointAnimationSequenceGet</B> gets the animation sequence data 
of the specified light point animation record (of type <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLpAnimationPalette>fltLpAnimationPalette</A>
).</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P><B>mgLightPointAnimationSequenceGet</B> writes the data into the output 
parameter <I>sequenceData</I>. The size of the array is specified by <I>arrayLen</I>. 
The number of sequences actually written into the array is returned.  You can 
determine the actual number of  sequences contained in a light point 
animation record by querying the attribute <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLpAnimationPalette>fltLpSequenceLength</A>
.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P><B>mgLightPointAnimationSequenceGet</B> returns the animation sequence data. 
The number of sequences included is also returned.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>lpaRec</I></DT><DD>the light point animation attribute record</DD><DT><I>sequenceData[]</I></DT><DD>the array of sequence records to be filled in</DD><DT><I>arrayLen</I></DT><DD>the size of the array <I>sequenceData</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>numSequences</DT><DD>The number of sequence records being returned.</DD><DT>sequenceData</DT><DD>The records returned.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* lpaRec = mgGetLightPointAnimation (db, lpaIndex);
int seqLength;
mgGetAttList (lpaRec, fltLpSequenceLength, &seqLength, MG_NULL);
if ( seqLength &gt 0 ) {
   int num;
   mglightpointanimationsequencedata* seqData;
   seqData = (mglightpointanimationsequencedata*)
      mgMalloc (seqLength * sizeof(mglightpointanimationsequencedata));
   num = mgLightPointAnimationSequenceGet (lpaRec, seqData, seqLength);
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">lpaRec = mgGetLightPointAnimation (db, lpaIndex)
num,sequences = mgLightPointAnimationSequenceGet (lpaRec)
print "Number of Light Point Animation Sequences:",num
for i in range (0, num):
   print "Light Point Animation Sequence",i+1,":"
   sequence = sequences[i]
   print "   state,duration,colorIndex,colorIntensity:", \\
      sequence.state, sequence.duration, \\
      sequence.colorIndex, sequence.colorIntensity</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgLightPointAnimationSequenceSet>mgLightPointAnimationSequenceSet</A></DD></DL>
<HR>
<LEFT><A NAME=mgLightPointAnimationSequenceSet><H1 CLASS="APISYMBOL">mgLightPointAnimationSequenceSet</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgLightPointAnimationSequenceSet</B> - sets the sequence items of 
a light point animation record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgLightPointAnimationSequenceSet</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>lpaRec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mglightpointanimationsequencedata>mglightpointanimationsequencedata</A></TD><TD><I>sequenceData[]</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>n</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgLightPointAnimationSequenceSet</B> sets the items of an animation 
sequence of a light point animation record from an array <I>sequenceData</I>. 
The size of the array is specified by <I>n</I>.  The number of items actually 
set is returned.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>lpaRec</I></DT><DD>the light point animation record</DD><DT><I>sequenceData[]</I></DT><DD>the array of sequence records to use to set</DD><DT><I>n</I></DT><DD>the number of items in <I>sequenceData</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of sequence items set.  If successful, this number 
should be equal to the input parameter <I>n</I>.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* lpaRec = mgGetLightPointAnimation (db, lpaIndex);
mglightpointanimationsequencedata sequences[4];

// set the data for each element of the sequence
sequences[0].state = 1;
sequences[0].duration = 0.2f;
sequences[0].colorIndex = 27;
sequences[0].colorIntensity = 0.5f;

sequences[1].state = 0;
sequences[1].duration = 0.5f;
sequences[1].colorIndex = 4;
sequences[1].colorIntensity = 0.5f;

sequences[2].state = 1;
sequences[2].duration = 0.2f;
sequences[2].colorIndex = 27;
sequences[2].colorIntensity = 1.0f;

sequences[3].state = 0;
sequences[3].duration = 1.0f;
sequences[3].colorIndex = 4;
sequences[3].colorIntensity = 0.5f;

// attach this sequence to the light point entry
mgLightPointAnimationSequenceSet (lpaRec, sequences, 4);</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">lpaRec = mgGetLightPointAnimation (db, lpaIndex)
# allocate 4 elements in the sequence
sequences = mglightpointanimationsequencedata(4)

# set the data for each element of the sequence
sequences[0].state = 1
sequences[0].duration = 0.2
sequences[0].colorIndex = 27
sequences[0].colorIntensity = 0.5

sequences[1].state = 0
sequences[1].duration = 0.5
sequences[1].colorIndex = 4
sequences[1].colorIntensity = 0.5

sequences[2].state = 1
sequences[2].duration = 0.2
sequences[2].colorIndex = 27
sequences[2].colorIntensity = 1.0

sequences[3].state = 0
sequences[3].duration = 1.0
sequences[3].colorIndex = 4
sequences[3].colorIntensity = 0.5

# attach this sequence to the light point entry
mgLightPointAnimationSequenceSet (lpaRec, sequences, 4)</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgLightPointAnimationSequenceGet>mgLightPointAnimationSequenceGet</A></DD></DL>
<HR>
<LEFT><A NAME=mgListAddItem><H1 CLASS="APISYMBOL">mgListAddItem</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListAddItem</B> - adds an item to a list control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgListAddItem</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>itemString</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>itemPos</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>select</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgListAddItem</B> adds the specified <I>itemString</I> to the specified 
list <I>control</I> at the specified position <I>itemPos</I>.</P></DD><DD><P>If the list <I>control</I> has the LBS_SORT style, this function does 
not cause the list to be sorted.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD><DT><I>itemString</I></DT><DD>the string to add</DD><DT><I>itemPos</I></DT><DD>the position of the new item in the list - a 
value of 1 makes the new item the first item in the 
list, 2 makes it the second item and so on - 
a value of 0 (zero) makes the new 
item the last item in the list</DD><DT><I>select</I></DT><DD>enum mgbool <A HREF=#mgbool>MG_TRUE</A> to make new 
item selected, <A HREF=#mgbool>MG_FALSE</A> to make new item 
unselected</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListAppendItem>mgListAppendItem</A>, <A HREF=#mgListReplaceItem>mgListReplaceItem</A></DD></DL>
<HR>
<LEFT><A NAME=mgListAddItemData><H1 CLASS="APISYMBOL">mgListAddItemData</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListAddItemData</B> - adds an item to a list control 
and associates user defined data to that item.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgListAddItemData</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>itemString</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>itemData</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>itemPos</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>select</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgListAddItemData</B> adds the specified <I>itemString</I> to the specified 
list <I>control</I> at the specified position <I>itemPos</I> and associates the 
user defined data <I>itemData</I> to the item.  This data can be retrieved 
later using <A HREF=#mgListGetItemDataAtPos>mgListGetItemDataAtPos</A>.</P></DD><DD><P>If <I>itemData</I> is a pointer to dynamically allocated memory, it is 
the responsibility of the caller to make sure it is deallocated at the 
appropriate time.  The list control does nothing with this data when 
the control is destroyed or when the corresponding list item is 
otherwise removed from the list.</P></DD><DD><P>If the list <I>control</I> has the LBS_SORT style, this function does 
not cause the list to be sorted.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD><DT><I>itemString</I></DT><DD>the string to add</DD><DT><I>itemData</I></DT><DD>user defined data to associate with list item</DD><DT><I>itemPos</I></DT><DD>the position of the new item in the list - a 
value of 1 makes the new item the first item in the 
list, 2 makes it the second item and so on - 
a value of 0 (zero) makes the new 
item the last item in the list</DD><DT><I>select</I></DT><DD>enum mgbool <A HREF=#mgbool>MG_TRUE</A> to make new 
item selected, <A HREF=#mgbool>MG_FALSE</A> to make new item 
unselected</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>Calling <B>mgListAddItemData</B> is equivalent to the following:</DT><DT><PRE CLASS="EXAMPLE">mgListAddItem (list, "Item 10", 10, MG_FALSE);
mgListSetItemData (list, 10, itemData);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListAddItem>mgListAddItem</A>, <A HREF=#mgListAppendItem>mgListAppendItem</A>, <A HREF=#mgListReplaceItem>mgListReplaceItem</A>, 
<A HREF=#mgListGetItemDataAtPos>mgListGetItemDataAtPos</A></DD></DL>
<HR>
<LEFT><A NAME=mgListAppendItem><H1 CLASS="APISYMBOL">mgListAppendItem</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListAppendItem</B> - appends an item to the end of a list control<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgListAppendItem</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>itemString</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>select</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgListAppendItem</B> appends the specified <I>itemString</I> to the end 
of the specified list <I>control</I>.</P></DD><DD><P>If the list <I>control</I> has the LBS_SORT style, this function does 
not cause the list to be sorted.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD><DT><I>itemString</I></DT><DD>the string to add</DD><DT><I>select</I></DT><DD>enum mgbool <A HREF=#mgbool>MG_TRUE</A> to make new 
item selected, <A HREF=#mgbool>MG_FALSE</A> to make new item 
unselected</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListAppendItemData>mgListAppendItemData</A>, <A HREF=#mgListAddItem>mgListAddItem</A>, <A HREF=#mgListReplaceItem>mgListReplaceItem</A></DD></DL>
<HR>
<LEFT><A NAME=mgListAppendItemData><H1 CLASS="APISYMBOL">mgListAppendItemData</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListAppendItemData</B> - appends an item to the end of a 
list control and associates user defined data to that item.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgListAppendItemData</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>itemString</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>itemData</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>select</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgListAppendItemData</B> appends the specified <I>itemString</I> to the end 
of the specified list <I>control</I> and associates the user defined data 
<I>itemData</I> to the item.  This data can be retrieved 
later using <A HREF=#mgListGetItemDataAtPos>mgListGetItemDataAtPos</A>.</P></DD><DD><P>If <I>itemData</I> is a pointer to dynamically allocated memory, it is 
the responsibility of the caller to make sure it is deallocated at the 
appropriate time.  The list control does nothing with this data when 
the control is destroyed or when the corresponding list item is 
otherwise removed from the list.</P></DD><DD><P>If the list <I>control</I> has the LBS_SORT style, this function does 
not cause the list to be sorted.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD><DT><I>itemString</I></DT><DD>the string to add</DD><DT><I>itemData</I></DT><DD>user defined data to associate with list item</DD><DT><I>select</I></DT><DD>enum mgbool <A HREF=#mgbool>MG_TRUE</A> to make new 
item selected, <A HREF=#mgbool>MG_FALSE</A> to make new item 
unselected</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>Calling <B>mgListAppendItemData</B> is equivalent to the following:</DT><DT><PRE CLASS="EXAMPLE">mgListAppendItem (list, "Item 10", MG_FALSE);
int numItems = mgListGetItemCount (list);
mgListSetItemData (list, numItems, itemData);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListAppendItem>mgListAppendItem</A>, <A HREF=#mgListAddItem>mgListAddItem</A>, <A HREF=#mgListReplaceItem>mgListReplaceItem</A>, 
<A HREF=#mgListGetItemDataAtPos>mgListGetItemDataAtPos</A></DD></DL>
<HR>
<LEFT><A NAME=mgListDeleteAllItems><H1 CLASS="APISYMBOL">mgListDeleteAllItems</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListDeleteAllItems</B> - deletes all items from a list control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgListDeleteAllItems</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgListDeleteAllItems</B> deletes all the items from the specified 
list <I>control</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListDeleteItem>mgListDeleteItem</A>, <A HREF=#mgListDeleteItemAtPos>mgListDeleteItemAtPos</A>, <A HREF=#mgListDeleteSelectedItems>mgListDeleteSelectedItems</A></DD></DL>
<HR>
<LEFT><A NAME=mgListDeleteItem><H1 CLASS="APISYMBOL">mgListDeleteItem</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListDeleteItem</B> - deletes an item from a list control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgListDeleteItem</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>itemString</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgListDeleteItem</B> deletes the first item in the specified list 
<I>control</I> that matches the specified text string <I>itemString</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD><DT><I>itemString</I></DT><DD>the text of the item to delete</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListDeleteItemAtPos>mgListDeleteItemAtPos</A>, <A HREF=#mgListDeleteAllItems>mgListDeleteAllItems</A>, <A HREF=#mgListDeleteSelectedItems>mgListDeleteSelectedItems</A></DD></DL>
<HR>
<LEFT><A NAME=mgListDeleteItemAtPos><H1 CLASS="APISYMBOL">mgListDeleteItemAtPos</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListDeleteItemAtPos</B> - deletes an item from a list control 
at a specified position.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgListDeleteItemAtPos</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>itemPos</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgListDeleteItemAtPos</B> deletes the item at the specified position 
<I>itemPos</I> from the specified list <I>control</I>.</P></DD><DD><P>Position 1 indicates the first item in the control.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD><DT><I>itemPos</I></DT><DD>the position of item in list to delete</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListDeleteItem>mgListDeleteItem</A>, <A HREF=#mgListDeleteAllItems>mgListDeleteAllItems</A>, <A HREF=#mgListDeleteSelectedItems>mgListDeleteSelectedItems</A></DD></DL>
<HR>
<LEFT><A NAME=mgListDeleteSelectedItems><H1 CLASS="APISYMBOL">mgListDeleteSelectedItems</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListDeleteSelectedItems</B> - deletes all selected items 
from a list control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgListDeleteSelectedItems</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgListDeleteSelectedItems</B> deletes all selected items from 
the specified list <I>control</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListDeleteItem>mgListDeleteItem</A>, <A HREF=#mgListDeleteItemAtPos>mgListDeleteItemAtPos</A>, <A HREF=#mgListDeleteAllItems>mgListDeleteAllItems</A></DD></DL>
<HR>
<LEFT><A NAME=mgListDeselectAllItems><H1 CLASS="APISYMBOL">mgListDeselectAllItems</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListDeselectAllItems</B> - deselects all items in a list control<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgListDeselectAllItems</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgListDeselectAllItems</B> deselects all the items in the specified 
list <I>control</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListSelectItemAtPos>mgListSelectItemAtPos</A>, <A HREF=#mgListSelectItem>mgListSelectItem</A>, <A HREF=#mgListDeselectItemAtPos>mgListDeselectItemAtPos</A></DD></DL>
<HR>
<LEFT><A NAME=mgListDeselectItemAtPos><H1 CLASS="APISYMBOL">mgListDeselectItemAtPos</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListDeselectItemAtPos</B> - deselects an item in a list control 
at a specified position.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgListDeselectItemAtPos</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>itemPos</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgListDeselectItemAtPos</B> selects the item at the specified position 
<I>itemPos</I> in the specified list <I>control</I>.</P></DD><DD><P>The <A HREF=#MGCB_ACTIVATE>MGCB_ACTIVATE</A> control event is not sent when this function 
is called.</P></DD><DD><P>Position 1 indicates the first item in the control.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD><DT><I>itemPos</I></DT><DD>the position of item in list to select</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListSelectItemAtPos>mgListSelectItemAtPos</A>, <A HREF=#mgListDeselectAllItems>mgListDeselectAllItems</A></DD></DL>
<HR>
<LEFT><A NAME=mgListGetItemCount><H1 CLASS="APISYMBOL">mgListGetItemCount</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListGetItemCount</B> - counts the number of items in a 
list control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgListGetItemCount</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgListGetItemCount</B> returns the number of items contained in the 
specified list <I>control</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of items contained in the control, 0 if none.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListGetSelectedItemCount>mgListGetSelectedItemCount</A></DD></DL>
<HR>
<LEFT><A NAME=mgListGetItemDataAtPos><H1 CLASS="APISYMBOL">mgListGetItemDataAtPos</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListGetItemDataAtPos</B> - retrieves user defined data associated 
with an item in a list control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void* <B>mgListGetItemDataAtPos</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>itemPos</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Use <B>mgListGetItemDataAtPos</B> to retrieve the user defined data 
associated with the item at position <I>itemPos</I> of list control <I>control</I>. 
The data was set using <A HREF=#mgListSetItemDataAtPos>mgListSetItemDataAtPos</A>, <A HREF=#mgListAddItemData>mgListAddItemData</A> or 
<A HREF=#mgListAppendItemData>mgListAppendItemData</A>.</P></DD><DD><P>Position 1 indicates the first item in the control.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD><DT><I>itemPos</I></DT><DD>the position of item in list to get data for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the user defined data if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListSetItemDataAtPos>mgListSetItemDataAtPos</A></DD></DL>
<HR>
<LEFT><A NAME=mgListGetItemStringAtPos><H1 CLASS="APISYMBOL">mgListGetItemStringAtPos</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListGetItemStringAtPos</B> - retrieves text of an item 
in a list control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgListGetItemStringAtPos</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>itemPos</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>itemString</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maxLen</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgListGetItemStringAtPos</B> retrieves the text string of the 
item at the specified position <I>itemPos</I>, in the specified list <I>control</I>.</P></DD><DD><P>The string is truncated and 
null terminated if it is longer than <I>maxLen</I> characters.</P></DD><DD><P>Position 1 indicates the first item in the control.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD><DT><I>itemPos</I></DT><DD>the position of item in list to get</DD><DT><I>itemString</I></DT><DD>character buffer to hold text of item</DD><DT><I>maxLen</I></DT><DD>the maximum number of characters to store in <I>itemString</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.  If function 
is successful, <I>itemString</I> is loaded with the text of the item. 
Otherwise, <I>itemString</I> is undefined.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListGetSelectedItemString>mgListGetSelectedItemString</A></DD></DL>
<HR>
<LEFT><A NAME=mgListGetSelectedItemCount><H1 CLASS="APISYMBOL">mgListGetSelectedItemCount</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListGetSelectedItemCount</B> - counts the number of selected 
items in a list control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgListGetSelectedItemCount</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgListGetSelectedItemCount</B> returns the number of selected items 
contained in the specified list <I>control</I>.  For single select list controls 
there is at most 1 item selected.  For multi-select list controls, there 
may be 0 or more items selected.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of selected items contained in the control,  0 if none.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListGetItemCount>mgListGetItemCount</A></DD></DL>
<HR>
<LEFT><A NAME=mgListGetSelectedItemPos><H1 CLASS="APISYMBOL">mgListGetSelectedItemPos</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListGetSelectedItemPos</B> - retrieves position of 
selected item in a listcontrol.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgListGetSelectedItemPos</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>itemPos</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgListGetSelectedItemPos</B> retrieves the position of the selected 
item in the specified list <I>control</I>.</P></DD><DD><P>For multi-select list controls with more than one item currently 
selected, the position retrieved is the position of the first item 
selected.</P></DD><DD><P>Position 1 indicates the first item in the control.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD><DT><I>itemPos</I></DT><DD>address of value to receive selected position</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListGetSelectedItemString>mgListGetSelectedItemString</A>, <A HREF=#mgListSelectItemAtPos>mgListSelectItemAtPos</A></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgstatus</DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.</DD><DT>itemPos</DT><DD>If function 
is successful, itemPos contains the position of the selected item. Otherwise, 
itemPos is undefined.</DD></DL></DL>
<HR>
<LEFT><A NAME=mgListGetSelectedItemString><H1 CLASS="APISYMBOL">mgListGetSelectedItemString</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListGetSelectedItemString</B> - retrieves text of selected item 
in a list control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgListGetSelectedItemString</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>itemString</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maxLen</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgListGetSelectedItemString</B> retrieves the text string of the selected 
item in the specified list <I>control</I>.</P></DD><DD><P>For multi-select list controls with more than one item currently 
selected, the string retrieved is the text of the first item 
selected.</P></DD><DD><P>The string is truncated and 
null terminated if it is longer than <I>maxLen</I> characters.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD><DT><I>itemString</I></DT><DD>character buffer to hold text of selected item retrieved</DD><DT><I>maxLen</I></DT><DD>the maximum number of characters to store in <I>itemString</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.  If function 
is successful, <I>itemString</I> is loaded with the text of the selected item. 
Otherwise, <I>itemString</I> is undefined.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListGetSelectedItemPos>mgListGetSelectedItemPos</A></DD></DL>
<HR>
<LEFT><A NAME=mgListGetSelectedStrings><H1 CLASS="APISYMBOL">mgListGetSelectedStrings</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListGetSelectedStrings</B> - retrieves the text of all selected 
items in a list control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstringlist <B>mgListGetSelectedStrings</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgListGetSelectedStrings</B> returns a <A HREF=#MG_NULL>MG_NULL</A> terminated array 
of character 
strings representing all the selected items in the specified list <I>control</I>.</P></DD><DD><P>The string list returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFreeStringList>mgFreeStringList</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#MG_NULL>MG_NULL</A> terminated array of character strings, 
<A HREF=#MG_NULL>MG_NULL</A> if list is empty.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example prints out each selected item from a 
list control <I>list</I>.</DT><DT><PRE CLASS="EXAMPLE">mgstringlist strings;
if (strings = mgListGetSelectedStrings (list))
{
   int i = 1;
   mgstringlist thisString = strings;
   while (thisString && *thisString)
   {
      printf ("Item number %d : %s&#92;", i, *thisString);
      thisString++;
      i++;
   }
   mgFreeStringList (strings);
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListGetStrings>mgListGetStrings</A>, <A HREF=#mgFreeStringList>mgFreeStringList</A></DD></DL>
<HR>
<LEFT><A NAME=mgListGetStrings><H1 CLASS="APISYMBOL">mgListGetStrings</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListGetStrings</B> - retrieves the text of all items in 
a list control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstringlist <B>mgListGetStrings</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgListGetStrings</B> returns a <A HREF=#MG_NULL>MG_NULL</A> terminated array of character 
strings representing all the items in the specified list <I>control</I>.</P></DD><DD><P>The string list returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFreeStringList>mgFreeStringList</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#MG_NULL>MG_NULL</A> terminated array of character strings, 
<A HREF=#MG_NULL>MG_NULL</A> if list is empty.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example prints out each item from a list control <I>list</I>.</DT><DT><PRE CLASS="EXAMPLE">mgstringlist strings;
if (strings = mgListGetStrings (list))
{
   int i = 1;
   mgstringlist thisString = strings;
   while (thisString && *thisString)
   {
      printf ("Item number %d : %s&#92;", i, *thisString);
      thisString++;
      i++;
   }
   mgFreeStringList (strings);
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListGetSelectedStrings>mgListGetSelectedStrings</A>, <A HREF=#mgFreeStringList>mgFreeStringList</A></DD></DL>
<HR>
<LEFT><A NAME=mgListGetTopPos><H1 CLASS="APISYMBOL">mgListGetTopPos</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListGetTopPos</B> - returns the first visible item in the list<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgListGetTopPos</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>itemPos</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgListGetTopPos</B> returns the position of the first visible item 
in the specified list <I>control</I>.</P></DD><DD><P>Position 1 indicates the first item in the control.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD><DT><I>itemPos</I></DT><DD>address of value to receive position 
of first visible item</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success. 
If function is successful, <I>itemPos</I> contains the position of the first 
visible item.  Otherwise, <I>itemPos</I> is undefined.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListSetTopPos>mgListSetTopPos</A></DD></DL>
<HR>
<LEFT><A NAME=mgListIsItemAtPosSelected><H1 CLASS="APISYMBOL">mgListIsItemAtPosSelected</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListIsItemAtPosSelected</B> - determines if an item at a 
specified position in a list control is selected.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgListIsItemAtPosSelected</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>itemPos</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgListIsItemAtPosSelected</B> checks if the item at a specified 
position <I>itemPos</I> is selected in the specified list <I>control</I>.</P></DD><DD><P>Position 1 indicates the first item in the control.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD><DT><I>itemPos</I></DT><DD>the position of the item to check</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if item at specified position in list is selected. 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListSelectItemAtPos>mgListSelectItemAtPos</A></DD></DL>
<HR>
<LEFT><A NAME=mgListIsItemInList><H1 CLASS="APISYMBOL">mgListIsItemInList</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListIsItemInList</B> - determines if an item is in a 
list control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgListIsItemInList</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>itemString</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgListIsItemInList</B> checks if a text string <I>itemString</I> 
is present in the specified list <I>control</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD><DT><I>itemString</I></DT><DD>the text of the item whose presence is checked</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if specified text string is in the list, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<HR>
<LEFT><A NAME=mgListReplaceItem><H1 CLASS="APISYMBOL">mgListReplaceItem</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListReplaceItem</B> - replaces an item in a list control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgListReplaceItem</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>oldItemString</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>newItemString</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgListReplaceItem</B> replaces the specified <I>oldItemString</I> 
with a new string <I>newItemString</I> in the specified list <I>control</I>.</P></DD><DD><P>If the item being replaced is currently selected, the new item will 
also be selected.  Also, if the item being replaced has user data associated 
to it, that data is not affected.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD><DT><I>oldItemString</I></DT><DD>the item to be replaced</DD><DT><I>newItemString</I></DT><DD>the string to replace <I>oldItemString</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListAddItem>mgListAddItem</A>, <A HREF=#mgListAppendItem>mgListAppendItem</A>, <A HREF=#mgListReplaceItemAtPos>mgListReplaceItemAtPos</A></DD></DL>
<HR>
<LEFT><A NAME=mgListReplaceItemAtPos><H1 CLASS="APISYMBOL">mgListReplaceItemAtPos</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListReplaceItemAtPos</B> - replaces an item in a list control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgListReplaceItemAtPos</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>itemPos</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>itemString</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgListReplaceItemAtPos</B> replaces the item at position <I>itemPos</I> 
with a new string <I>itemString</I> in the specified list <I>control</I>.</P></DD><DD><P>If the item being replaced is currently selected, the new item will 
be selected.  Also, if the item being replaced has user data associated 
to it, that data is not affected.</P></DD><DD><P>Position 1 specifies the first item in the control.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD><DT><I>itemPos</I></DT><DD>the position of the item to be replaced</DD><DT><I>itemString</I></DT><DD>the string to replace the item</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListAddItem>mgListAddItem</A>, <A HREF=#mgListAppendItem>mgListAppendItem</A>, <A HREF=#mgListReplaceItem>mgListReplaceItem</A></DD></DL>
<HR>
<LEFT><A NAME=mgListSelectAllItems><H1 CLASS="APISYMBOL">mgListSelectAllItems</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListSelectAllItems</B> - selects all items in a list control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgListSelectAllItems</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgListSelectAllItems</B> selects all the items in the specified 
list <I>control</I>.</P></DD><DD><P>The <A HREF=#MGCB_ACTIVATE>MGCB_ACTIVATE</A> control event is not sent when this function 
is called.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListSelectItemAtPos>mgListSelectItemAtPos</A>, <A HREF=#mgListSelectItem>mgListSelectItem</A>, 
<A HREF=#mgListDeselectAllItems>mgListDeselectAllItems</A></DD></DL>
<HR>
<LEFT><A NAME=mgListSelectItem><H1 CLASS="APISYMBOL">mgListSelectItem</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListSelectItem</B> - selects an item in a list control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgListSelectItem</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>itemString</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgListSelectItem</B> selects the first item in the specified list 
<I>control</I> that matches the specified text string <I>itemString</I>.</P></DD><DD><P>The <A HREF=#MGCB_ACTIVATE>MGCB_ACTIVATE</A> control event is not sent when this function 
is called.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD><DT><I>itemString</I></DT><DD>the text of the item to select</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListSelectItemAtPos>mgListSelectItemAtPos</A>, <A HREF=#mgListSelectAllItems>mgListSelectAllItems</A></DD></DL>
<HR>
<LEFT><A NAME=mgListSelectItemAtPos><H1 CLASS="APISYMBOL">mgListSelectItemAtPos</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListSelectItemAtPos</B> - selects an item in a list control 
at a specified position.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgListSelectItemAtPos</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>itemPos</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgListSelectItemAtPos</B> selects the item at the specified position 
<I>itemPos</I> in the specified list <I>control</I>.</P></DD><DD><P>The <A HREF=#MGCB_ACTIVATE>MGCB_ACTIVATE</A> control event is not sent when this function 
is called.</P></DD><DD><P>Position 1 indicates the first item in the control.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD><DT><I>itemPos</I></DT><DD>the position of item in list to select</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListSelectItem>mgListSelectItem</A>, <A HREF=#mgListSelectAllItems>mgListSelectAllItems</A></DD></DL>
<HR>
<LEFT><A NAME=mgListSetBottomItem><H1 CLASS="APISYMBOL">mgListSetBottomItem</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListSetBottomItem</B> - makes a specified item the last visible 
item in the list.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgListSetBottomItem</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>itemString</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>If possible, <B>mgListSetBottomItem</B> makes the item specified 
by <I>itemString</I> the last visible item in the specified list <I>control</I>.</P></DD><DD><P>Calling this function only ensures that the item at the specified position 
is visible in a scrolling list control.  Depending on the configuration of 
the items in the list when this function is called, it may not be possible to 
make the specified item the last item visible, but it is guaranteed to be 
visible.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD><DT><I>itemString</I></DT><DD>the text of the item to make visible</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListSetTopPos>mgListSetTopPos</A>, <A HREF=#mgListSetBottomPos>mgListSetBottomPos</A>, <B>mgListSetBottomItem</B>, 
<A HREF=#mgListSetTopItem>mgListSetTopItem</A></DD></DL>
<HR>
<LEFT><A NAME=mgListSetBottomPos><H1 CLASS="APISYMBOL">mgListSetBottomPos</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListSetBottomPos</B> - makes a specified item the last visible 
item in the list.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgListSetBottomPos</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>itemPos</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>If possible, <B>mgListSetBottomPos</B> makes the item at the specified 
position <I>itemPos</I> the last visible item in the specified list <I>control</I>.</P></DD><DD><P>Calling this function only ensures that the item at the specified position 
is visible in a scrolling list control.  Depending on the configuration of 
the items in the list when this function is called, it may not be possible to 
make the specified item the last item visible, but it is guaranteed to be 
visible.</P></DD><DD><P>Position 1 indicates the first item in the control.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD><DT><I>itemPos</I></DT><DD>the position of the item to make visible</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListSetTopPos>mgListSetTopPos</A>, <B>mgListSetBottomPos</B>, <A HREF=#mgListSetBottomItem>mgListSetBottomItem</A>, 
<A HREF=#mgListSetTopItem>mgListSetTopItem</A></DD></DL>
<HR>
<LEFT><A NAME=mgListSetItemDataAtPos><H1 CLASS="APISYMBOL">mgListSetItemDataAtPos</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListSetItemDataAtPos</B> - associates user defined data with 
an item in a list control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgListSetItemDataAtPos</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>itemPos</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>itemData</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgListSetItemDataAtPos</B> allows you to associate data of any 
type, <I>itemData</I>, with a specific item in a list control.  The user defined 
data is associated with the item at position <I>itemPos</I> of list <I>control</I>. 
The data can be retrieved later using <A HREF=#mgListGetItemDataAtPos>mgListGetItemDataAtPos</A>.</P></DD><DD><P>If <I>itemData</I> is a pointer to dynamically allocated memory, it is 
the responsibility of the caller to make sure it is deallocated at the 
appropriate time.  The list control does nothing with this data when 
the control is destroyed or when the corresponding list item is 
otherwise removed from the list.</P></DD><DD><P>Position 1 indicates the first item in the control.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD><DT><I>itemPos</I></DT><DD>the position of item in list to set data for</DD><DT><I>itemData</I></DT><DD>user defined data to associate with list item</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListGetItemDataAtPos>mgListGetItemDataAtPos</A></DD></DL>
<HR>
<LEFT><A NAME=mgListSetTopItem><H1 CLASS="APISYMBOL">mgListSetTopItem</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListSetTopItem</B> - makes a specified item the first visible 
item in the list.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgListSetTopItem</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>itemString</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>If possible, <B>mgListSetTopItem</B> makes the item specified 
by <I>itemString</I> the first visible item in the specified list <I>control</I>.</P></DD><DD><P>Calling this function only ensures that the item at the specified position 
is visible in a scrolling list control.  Depending on the configuration of 
the items in the list when this function is called, it may not be possible to 
make the specified item the first item visible, but it is guaranteed to be 
visible.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD><DT><I>itemString</I></DT><DD>the text of the item to make visible</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListSetTopPos>mgListSetTopPos</A>, <A HREF=#mgListSetBottomPos>mgListSetBottomPos</A>, <A HREF=#mgListSetBottomItem>mgListSetBottomItem</A>, 
<B>mgListSetTopItem</B></DD></DL>
<HR>
<LEFT><A NAME=mgListSetTopPos><H1 CLASS="APISYMBOL">mgListSetTopPos</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgListSetTopPos</B> - makes a specified item the first visible 
item in the list<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgListSetTopPos</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>itemPos</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>If possible, <B>mgListSetTopPos</B> makes the item at the specified 
position <I>itemPos</I> the first visible item in the specified list <I>control</I>.</P></DD><DD><P>Calling this function only ensures that the item at the specified position 
is visible in a scrolling list control.  Depending on the configuration of 
the items in the list when this function is called, it may not be possible to 
make the specified item the first item visible, but it is guaranteed to be 
visible.</P></DD><DD><P>Position 1 indicates the first item in the control.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the list control</DD><DT><I>itemPos</I></DT><DD>the position of the item to make visible</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListGetTopPos>mgListGetTopPos</A>, <A HREF=#mgListSetTopItem>mgListSetTopItem</A>, <A HREF=#mgListSetBottomPos>mgListSetBottomPos</A>, 
<A HREF=#mgListSetBottomItem>mgListSetBottomItem</A>,</DD></DL>
<HR>
<LEFT><A NAME=mgLoadResource><H1 CLASS="APISYMBOL">mgLoadResource</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgLoadResource</B> - load the resource for a plug-in module.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgresource <B>mgLoadResource</B> (</TD><TD><A HREF=#mgmodulehandle>mgmodulehandle</A></TD><TD><I>moduleHandle</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgLoadResource</B> loads and initializes the resource 
associated with a plug-in module identified by <I>moduleHandle</I>.</P></DD><DD><P>After calling this function, the individual resource items 
(dialog templates, pixmaps, and string definitions) contained 
in the resource become available.  Typically call this 
function one time when your plug-in module initializes.  When you are 
through accessing items contained in the resource, you should 
use <A HREF=#mgUnloadResource>mgUnloadResource</A> to let the API clean up.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>moduleHandle</I></DT><DD>the module handle for your plug-in as 
returned by <A HREF=#mgGetModuleHandle>mgGetModuleHandle</A></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Handle to resource if successful, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetModuleHandle>mgGetModuleHandle</A>, <A HREF=#mgUnloadResource>mgUnloadResource</A>, <A HREF=#mgResourceGetDialog>mgResourceGetDialog</A>, 
<A HREF=#mgResourceModalDialog>mgResourceModalDialog</A>, <A HREF=#mgResourceGetPixmap>mgResourceGetPixmap</A>, <A HREF=#mgResourceGetString>mgResourceGetString</A>, 
<A HREF=#mgGetModuleFilename>mgGetModuleFilename</A></DD></DL>
<HR>
<LEFT><A NAME=mgMakeBox><H1 CLASS="APISYMBOL">mgMakeBox</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMakeBox</B> - makes a box given two (min and max) points.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgboxd <B>mgMakeBox</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>min</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>max</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMakeBox</B> returns a double precision axis aligned box record 
representing the box whose lower left front point is <I>min</I> and whose 
upper right back point is <I>max</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>min</I></DT><DD>address of coordinate that defines the 
lower left point of the box</DD><DT><I>max</I></DT><DD>address of coordinate that defines the 
upper right back point of the box</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision box record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgboxd>mgboxd</A>, <A HREF=#mgBoxExpandCoord3d>mgBoxExpandCoord3d</A>, <A HREF=#mgBoxExpandBox>mgBoxExpandBox</A>, 
<A HREF=#mgBoxContainsCoord3d>mgBoxContainsCoord3d</A>, <A HREF=#mgBoxContainsBox>mgBoxContainsBox</A>, <A HREF=#mgBoxIntersectsBox>mgBoxIntersectsBox</A>, 
<A HREF=#mgBoxGetXSize>mgBoxGetXSize</A>, <A HREF=#mgBoxGetYSize>mgBoxGetYSize</A>, <A HREF=#mgBoxGetZSize>mgBoxGetZSize</A>, <A HREF=#mgBoxGetDiagonalSize>mgBoxGetDiagonalSize</A>, 
<A HREF=#mgBoxGetCenter>mgBoxGetCenter</A>, <A HREF=#mgBoxGetCenterBottom>mgBoxGetCenterBottom</A></DD></DL>
<HR>
<LEFT><A NAME=mgMakeCoord2d><H1 CLASS="APISYMBOL">mgMakeCoord2d</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMakeCoord2d</B> - makes a 2 dimensional double precision 
floating point coordinate from individual values.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord2d <B>mgMakeCoord2d</B> (</TD><TD>double</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>y</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMakeCoord2d</B> returns a 2 dimensional double precision 
floating point record representing the coordinate whose X and Y values 
are <I>x</I> and <I>y</I>, respectively.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>x</I></DT><DD>X value for the coordinate</DD><DT><I>y</I></DT><DD>Y value for the coordinate</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a 2 dimensional double precision floating point coordinate 
record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2d>mgcoord2d</A>, <A HREF=#mgMakeCoord3d>mgMakeCoord3d</A>, <A HREF=#mgMakeCoord3f>mgMakeCoord3f</A></DD></DL>
<HR>
<LEFT><A NAME=mgMakeCoord2i><H1 CLASS="APISYMBOL">mgMakeCoord2i</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMakeCoord2i</B> - makes a 2 dimensional integer 
coordinate from individual values.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord2i <B>mgMakeCoord2i</B> (</TD><TD>int</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>y</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMakeCoord2i</B> returns a 2 dimensional integer record representing 
the coordinate whose X and Y values are <I>x</I> and <I>y</I>, respectively.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>x</I></DT><DD>X value for the coordinate</DD><DT><I>y</I></DT><DD>Y value for the coordinate</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a 2 dimensional integer coordinate 
record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord2i>mgcoord2i</A>, <A HREF=#mgMakeCoord3d>mgMakeCoord3d</A>, <A HREF=#mgMakeCoord2d>mgMakeCoord2d</A>, <A HREF=#mgMakeCoord3f>mgMakeCoord3f</A></DD></DL>
<HR>
<LEFT><A NAME=mgMakeCoord3d><H1 CLASS="APISYMBOL">mgMakeCoord3d</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMakeCoord3d</B> - makes a 3 dimensional double precision 
floating point coordinate from individual values.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgMakeCoord3d</B> (</TD><TD>double</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>y</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>z</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMakeCoord3d</B> returns a 3 dimensional double precision 
floating point record representing the coordinate whose X, Y and Z 
values are <I>x</I>, <I>y</I> and <I>z</I>, respectively.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>x</I></DT><DD>X value for the coordinate</DD><DT><I>y</I></DT><DD>Y value for the coordinate</DD><DT><I>z</I></DT><DD>Z value for the coordinate</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a 3 dimensional double precision floating point coordinate 
record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgMakeCoord2d>mgMakeCoord2d</A>, <A HREF=#mgMakeCoord3f>mgMakeCoord3f</A></DD></DL>
<HR>
<LEFT><A NAME=mgMakeCoord3f><H1 CLASS="APISYMBOL">mgMakeCoord3f</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMakeCoord3f</B> - makes a 3 dimensional single precision 
floating point coordinate from individual values.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3f <B>mgMakeCoord3f</B> (</TD><TD>float</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>y</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>z</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMakeCoord3f</B> returns a 3 dimensional single precision 
floating point record representing the coordinate whose X, Y and Z 
values are <I>x</I>, <I>y</I> and <I>z</I>, respectively.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>x</I></DT><DD>X value for the coordinate</DD><DT><I>y</I></DT><DD>Y value for the coordinate</DD><DT><I>z</I></DT><DD>Z value for the coordinate</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a 3 dimensional single precision floating point coordinate 
record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3f>mgcoord3f</A>, <A HREF=#mgMakeCoord3d>mgMakeCoord3d</A>, <A HREF=#mgMakeCoord2d>mgMakeCoord2d</A></DD></DL>
<HR>
<LEFT><A NAME=mgMakeLine><H1 CLASS="APISYMBOL">mgMakeLine</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMakeLine</B> - makes a line between two points.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mglined <B>mgMakeLine</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMakeLine</B> returns a double precision line record representing 
the line passing through the two specified points, <I>coord1</I> and 
<I>coord2</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord1</I></DT><DD>address of first coordinate that defines the line</DD><DT><I>coord2</I></DT><DD>address of second coordinate that defines the line</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision line record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mglined>mglined</A></DD></DL>
<HR>
<LEFT><A NAME=mgMakePlaned><H1 CLASS="APISYMBOL">mgMakePlaned</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMakePlaned</B> - makes a plane given a point and a unitized normal.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgplaned <B>mgMakePlaned</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>point</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgvectord>mgvectord*</A></TD><TD><I>normal</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMakePlaned</B> returns a double precision plane record 
representing the plane that containes point <I>point</I> and whose 
normal is <I>normal</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>point</I></DT><DD>address of coordinate that defines any 
point on the plane</DD><DT><I>normal</I></DT><DD>address of vector that defines the 
normal of the plane</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision plane record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgplaned>mgplaned</A>, <A HREF=#mgCoord3dProjectOnPlane>mgCoord3dProjectOnPlane</A></DD></DL>
<HR>
<LEFT><A NAME=mgMakeUnitVectord><H1 CLASS="APISYMBOL">mgMakeUnitVectord</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMakeUnitVectord</B> - makes a unitized vector from two points.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgvectord <B>mgMakeUnitVectord</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Like <A HREF=#mgMakeVectord>mgMakeVectord</A>, <B>mgMakeUnitVectord</B> returns a double precision 
vector record representing the vector from <I>coord1</I> to <I>coord2</I>.  The 
vector returned by this function, however, is unitized.</P></DD><DD><P>The original coordinates <I>coord1</I> and <I>coord2</I> are not affected.</P></DD><DD><P>Note: For efficiency, <I>coord1</I> and <I>coord2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord1</I></DT><DD>address of first coordinate that defines the vector</DD><DT><I>coord2</I></DT><DD>address of second coordinate that defines the vector</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a unitized double precision vector record.  If either <I>coord1</I> 
or <I>coord2</I> are <A HREF=#MG_NULL>MG_NULL</A>, the vector returned by this function 
is undefined. 
If the distance from <I>coord1</I> to <I>coord2</I> is less than 0.000000000001, this 
function returns (0,0,1).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectord>mgvectord</A>, <A HREF=#mgMakeVectord>mgMakeVectord</A></DD></DL>
<HR>
<LEFT><A NAME=mgMakeVectord><H1 CLASS="APISYMBOL">mgMakeVectord</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMakeVectord</B> - makes a vector from two points.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgvectord <B>mgMakeVectord</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMakeVectord</B> returns a double precision vector record 
representing the vector from <I>coord1</I> to <I>coord2</I>.  This function does 
not unitize the vector returned as <A HREF=#mgMakeUnitVectord>mgMakeUnitVectord</A> does.</P></DD><DD><P>The original coordinates <I>coord1</I> and <I>coord2</I> are not affected.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord1</I></DT><DD>address of first coordinate that defines the vector</DD><DT><I>coord2</I></DT><DD>address of second coordinate that defines the vector</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision vector record.  If either <I>coord1</I> 
or <I>coord2</I> are <A HREF=#MG_NULL>MG_NULL</A>, the vector returned by this function 
is undefined.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectord>mgvectord</A>, <A HREF=#mgMakeUnitVectord>mgMakeUnitVectord</A></DD></DL>
<HR>
<LEFT><A NAME=mgMalloc><H1 CLASS="APISYMBOL">mgMalloc</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMalloc</B> - allocates a dynamic memory buffer.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void* <B>mgMalloc</B> (</TD><TD><A HREF=#mgsize_t>mgsize_t</A></TD><TD><I>numBytes</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given the number of bytes to allocate, <I>numBytes</I>, <B>mgMalloc</B> 
returns a pointer to a memory buffer of that size. All of the bytes of 
the buffer are preset to zero. The data type of the returned buffer is 
a void pointer. The calling function should use a cast statement to 
convert the buffer to the desired data type. When the buffer is no longer 
needed, use the function <A HREF=#mgFree>mgFree</A> to deallocate it.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>numBytes</I></DT><DD>the number of bytes to allocate</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the pointer to the allocated and zeroed buffer.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgFree>mgFree</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixCompose><H1 CLASS="APISYMBOL">mgMatrixCompose</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixCompose</B> - composes a matrix by specifying its 
3 local axes and a translation.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgMatrixCompose</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>xAxis</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>yAxis</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>zAxis</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>translation</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgmatrix <B>mgMatrixCompose</B> (</TD><TD><A HREF=#mgcoord3d>mgcoord3d</A></TD><TD><I>xAxis</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcoord3d>mgcoord3d</A></TD><TD><I>yAxis</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcoord3d>mgcoord3d</A></TD><TD><I>zAxis</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcoord3d>mgcoord3d</A></TD><TD><I>translation</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixCompose</B> composes a matrix with <I>xAxis</I> as the local 
X axis, <I>yAxis</I> as the local Y axis, <I>zAxis</I> as the local Z axis and 
<I>translation</I> as the translation.</P></DD><DD><P>The original coordinates <I>xAxis</I>, <I>yAxis</I>, <I>zAxis</I> and <I>translation</I> 
are not affected.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the resulting matrix into the output 
parameter <I>matrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the resulting matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>address of matrix to receive result</DD><DT><I>xAxis</I></DT><DD>local X axis to set to</DD><DT><I>yAxis</I></DT><DD>local Y axis to set to</DD><DT><I>zAxis</I></DT><DD>local Z axis to set to</DD><DT><I>translation</I></DT><DD>translation to set to</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgmatrix</DT><DD>the matrix.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixCopy><H1 CLASS="APISYMBOL">mgMatrixCopy</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixCopy</B> - copies one matrix into another.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixCopy</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>dstMatrix</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>srcMatrix</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, mgmatrix <B>mgMatrixCopy</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>srcMatrix</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixCopy</B> gets a copy of a matrix <I>srcMatrix</I>.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the matrix copy into the output 
parameter <I>dstMatrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the matrix copy if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>dstMatrix</I></DT><DD>address of matrix to receive copy</DD><DT><I>srcMatrix</I></DT><DD>matrix to copy</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful,&#32<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>mgmatrix</DT><DD>the matrix copy.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewMatrix>mgNewMatrix</A>, <A HREF=#mgFreeMatrix>mgFreeMatrix</A>, <A HREF=#mgMatrixIdentity>mgMatrixIdentity</A>, 
<A HREF=#mgMatrixIsIdentity>mgMatrixIsIdentity</A>, <A HREF=#mgMatrixInvert>mgMatrixInvert</A>, <A HREF=#mgMatrixMultiply>mgMatrixMultiply</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixEqual><H1 CLASS="APISYMBOL">mgMatrixEqual</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixEqual</B> - checks to see if two matrices are 
exactly equal.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixEqual</B> (</TD><TD>const <A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrixA</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrixB</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixEqual</B> compares two matrices, <I>matrixA</I> and <I>matrixB</I> 
to see if they are exactly equal.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrixA</I></DT><DD>first matrix to check for equality</DD><DT><I>matrixB</I></DT><DD>second matrix to check for equality</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if <I>matrixA</I> and <I>matrixB</I> are equal, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMatrixIdentity>mgMatrixIdentity</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixFormNormal><H1 CLASS="APISYMBOL">mgMatrixFormNormal</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixFormNormal</B> - creates a matrix to transform normals by 
based on the matrix by which the coordinates are transformed.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgMatrixFormNormal</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>geomMatrix</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgmatrix <B>mgMatrixFormNormal</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>geomMatrix</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixFormNormal</B> gets a matrix that can be used 
to transform normals if <I>geomMatrix</I> is the matrix by which coordinates 
are transformed.  Normals transformed 
by the resulting matrix will remain orthogonal to a surface transformed by 
<I>geomMatrix</I> even when <I>geomMatrix</I> is a non rigid transform such as a skew or 
scale (including non uniform scaling). Note that unit normals transformed by 
<I>matrix</I> may not remain unit lengthed on certain transformation such as 
scales and thus in most cases, the resulting normals will most likely need to be 
reunitized. Also note that for rigid transformations such as rotations, translations 
and reflections about an axis, this function is unnecessary and simply transforming 
unit normals by the same matrix without translation will maintain the normals to 
be orthogonal to the surface and of unit length.</P></DD><DD><P>The original matrix <I>geomMatrix</I> is not affected.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the resulting matrix into the output 
parameter <I>matrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the resulting matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>address of matrix to receive result</DD><DT><I>geomMatrix</I></DT><DD>transformation of geometry</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgmatrix</DT><DD>the matrix.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixFormPitchDown90><H1 CLASS="APISYMBOL">mgMatrixFormPitchDown90</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixFormPitchDown90</B> - creates a matrix that will pitch down 90 degrees.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgMatrixFormPitchDown90</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgmatrix <B>mgMatrixFormPitchDown90</B> (  )
</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixFormPitchDown90</B> gets a matrix that will pitch down 90 degrees.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the resulting matrix into the output 
parameter <I>matrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the resulting matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>address of matrix to receive result</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgmatrix</DT><DD>the matrix.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgMatrixPitchDown90>mgMatrixPitchDown90</A>, 
<A HREF=#mgMatrixFormPitchUp90>mgMatrixFormPitchUp90</A>, <A HREF=#mgMatrixPitchUp90>mgMatrixPitchUp90</A>, 
<A HREF=#mgMatrixFormReflectX>mgMatrixFormReflectX</A>, <A HREF=#mgMatrixReflectX>mgMatrixReflectX</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixFormPitchUp90><H1 CLASS="APISYMBOL">mgMatrixFormPitchUp90</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixFormPitchUp90</B> - creates a matrix that will pitch up 90 degrees.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgMatrixFormPitchUp90</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgmatrix <B>mgMatrixFormPitchUp90</B> (  )
</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixFormPitchUp90</B> gets a matrix that will pitch up 90 degrees.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the resulting matrix into the output 
parameter <I>matrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the resulting matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>address of matrix to receive result</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgmatrix</DT><DD>the matrix.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgMatrixFormPitchDown90>mgMatrixFormPitchDown90</A>, <A HREF=#mgMatrixPitchDown90>mgMatrixPitchDown90</A>, 
<A HREF=#mgMatrixPitchUp90>mgMatrixPitchUp90</A>, 
<A HREF=#mgMatrixFormReflectX>mgMatrixFormReflectX</A>, <A HREF=#mgMatrixReflectX>mgMatrixReflectX</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixFormQuadToQuad><H1 CLASS="APISYMBOL">mgMatrixFormQuadToQuad</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixFormQuadToQuad</B> - forms a "quad to quad" transformation 
matrix.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixFormQuadToQuad</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>from1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>from2</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>from3</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>from4</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>to1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>to2</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>to3</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>to4</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, mgmatrix <B>mgMatrixFormQuadToQuad</B> (</TD><TD><A HREF=#mgcoord3d>mgcoord3d</A></TD><TD><I>from1</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcoord3d>mgcoord3d</A></TD><TD><I>from2</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcoord3d>mgcoord3d</A></TD><TD><I>from3</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcoord3d>mgcoord3d</A></TD><TD><I>from4</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcoord3d>mgcoord3d</A></TD><TD><I>to1</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcoord3d>mgcoord3d</A></TD><TD><I>to2</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcoord3d>mgcoord3d</A></TD><TD><I>to3</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcoord3d>mgcoord3d</A></TD><TD><I>to4</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixFormQuadToQuad</B> calculates a transformation matrix that 
transforms one quadrilateral to another.  The "from" quadrilateral is 
specified by four points, <I>from1</I>, <I>from2</I>, <I>from3</I> and <I>from4</I>. 
Similarly, the "to" quadrilateral is specified by <I>to1</I>, <I>to2</I>, <I>to3</I> 
and <I>to4</I>.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the resulting matrix into the output 
parameter <I>matrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the resulting matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>address of matrix to receive result</DD><DT><I>from1</I></DT><DD>first point of the "from" quadrilateral</DD><DT><I>from2</I></DT><DD>second point of the "from" quadrilateral</DD><DT><I>from3</I></DT><DD>third point of the "from" quadrilateral</DD><DT><I>from4</I></DT><DD>third point of the "from" quadrilateral</DD><DT><I>to1</I></DT><DD>first point of the "to" quadrilateral</DD><DT><I>to2</I></DT><DD>second point of the "to" quadrilateral</DD><DT><I>to3</I></DT><DD>third point of the "to" quadrilateral</DD><DT><I>to4</I></DT><DD>third point of the "to" quadrilateral</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful,&#32<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>mgmatrix</DT><DD>If function is successful, the matrix.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMatrixFormTranslate>mgMatrixFormTranslate</A>, <A HREF=#mgMatrixFormScale>mgMatrixFormScale</A>, 
<A HREF=#mgMatrixFormRotate>mgMatrixFormRotate</A>, <A HREF=#mgMatrixFormRotateX>mgMatrixFormRotateX</A>, 
<A HREF=#mgMatrixFormRotateY>mgMatrixFormRotateY</A>, <A HREF=#mgMatrixFormRotateZ>mgMatrixFormRotateZ</A>, 
<A HREF=#mgMatrixRotateX>mgMatrixRotateX</A>, <A HREF=#mgMatrixRotateY>mgMatrixRotateY</A>, <A HREF=#mgMatrixRotateZ>mgMatrixRotateZ</A>, 
<A HREF=#mgMatrixMultiply>mgMatrixMultiply</A>, <A HREF=#mgMatrixFormXYZToUV>mgMatrixFormXYZToUV</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixFormReflect><H1 CLASS="APISYMBOL">mgMatrixFormReflect</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixFormReflect</B> - creates a matrix that will reflect about 
a specified axis.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgMatrixFormReflect</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgmatrix <B>mgMatrixFormReflect</B> (</TD><TD><A HREF=#mgcoord3d>mgcoord3d</A></TD><TD><I>coord</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixFormReflect</B> gets a matrix that will reflect about <I>coord</I>.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the resulting matrix into the output 
parameter <I>matrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the resulting matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>address of matrix to receive result</DD><DT><I>coord</I></DT><DD>address of coordinates of axis to reflect about, should have a length above zero</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgmatrix</DT><DD>the matrix.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgMatrixFormReflectX>mgMatrixFormReflectX</A>, <A HREF=#mgMatrixReflectX>mgMatrixReflectX</A>, 
<A HREF=#mgMatrixFormReflectY>mgMatrixFormReflectY</A>, <A HREF=#mgMatrixReflectY>mgMatrixReflectY</A>, 
<A HREF=#mgMatrixFormReflectZ>mgMatrixFormReflectZ</A>, <A HREF=#mgMatrixReflectZ>mgMatrixReflectZ</A>, 
<A HREF=#mgMatrixReflect>mgMatrixReflect</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixFormReflectX><H1 CLASS="APISYMBOL">mgMatrixFormReflectX</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixFormReflectX</B> - creates a matrix that will reflect 
about the X axis.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgMatrixFormReflectX</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgmatrix <B>mgMatrixFormReflectX</B> (  )
</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixFormReflectX</B> gets a matrix that will reflect about 
the X axis or pitch 180 degrees.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the resulting matrix into the output 
parameter <I>matrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the resulting matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>address of matrix to receive result</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgmatrix</DT><DD>the matrix.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgMatrixReflectX>mgMatrixReflectX</A>, 
<A HREF=#mgMatrixFormReflectY>mgMatrixFormReflectY</A>, <A HREF=#mgMatrixReflectY>mgMatrixReflectY</A>, 
<A HREF=#mgMatrixFormReflectZ>mgMatrixFormReflectZ</A>, <A HREF=#mgMatrixReflectZ>mgMatrixReflectZ</A>, 
<A HREF=#mgMatrixFormReflect>mgMatrixFormReflect</A>, <A HREF=#mgMatrixReflect>mgMatrixReflect</A>, 
<A HREF=#mgMatrixFormPitchDown90>mgMatrixFormPitchDown90</A>, <A HREF=#mgMatrixPitchDown90>mgMatrixPitchDown90</A>, 
<A HREF=#mgMatrixFormPitchUp90>mgMatrixFormPitchUp90</A>, <A HREF=#mgMatrixPitchUp90>mgMatrixPitchUp90</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixFormReflectY><H1 CLASS="APISYMBOL">mgMatrixFormReflectY</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixFormReflectY</B> - creates a matrix that will reflect about the Y axis.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgMatrixFormReflectY</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgmatrix <B>mgMatrixFormReflectY</B> (  )
</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixFormReflectY</B> gets a matrix that will reflect about 
the Y axis or roll 180 degrees.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the resulting matrix into the output 
parameter <I>matrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the resulting matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>address of matrix to receive result</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgmatrix</DT><DD>the matrix.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgMatrixFormReflectX>mgMatrixFormReflectX</A>, <A HREF=#mgMatrixReflectX>mgMatrixReflectX</A>, 
<A HREF=#mgMatrixReflectY>mgMatrixReflectY</A>, 
<A HREF=#mgMatrixFormReflectZ>mgMatrixFormReflectZ</A>, <A HREF=#mgMatrixReflectZ>mgMatrixReflectZ</A>, 
<A HREF=#mgMatrixFormReflect>mgMatrixFormReflect</A>, <A HREF=#mgMatrixReflect>mgMatrixReflect</A>, 
<A HREF=#mgMatrixFormRollLeft90>mgMatrixFormRollLeft90</A>, <A HREF=#mgMatrixRollLeft90>mgMatrixRollLeft90</A>, 
<A HREF=#mgMatrixFormRollRight90>mgMatrixFormRollRight90</A>, <A HREF=#mgMatrixRollRight90>mgMatrixRollRight90</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixFormReflectZ><H1 CLASS="APISYMBOL">mgMatrixFormReflectZ</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixFormReflectZ</B> - creates a matrix that will reflect about the Z axis.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgMatrixFormReflectZ</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgmatrix <B>mgMatrixFormReflectZ</B> (  )
</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixFormReflectZ</B> gets a matrix that will reflect about 
the Z axis or yaw 180 degrees.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the resulting matrix into the output 
parameter <I>matrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the resulting matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>address of matrix to receive result</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgmatrix</DT><DD>the matrix.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgMatrixFormReflectX>mgMatrixFormReflectX</A>, <A HREF=#mgMatrixReflectX>mgMatrixReflectX</A>, 
<A HREF=#mgMatrixFormReflectY>mgMatrixFormReflectY</A>, <A HREF=#mgMatrixReflectY>mgMatrixReflectY</A>, 
<A HREF=#mgMatrixReflectZ>mgMatrixReflectZ</A>, 
<A HREF=#mgMatrixFormReflect>mgMatrixFormReflect</A>, <A HREF=#mgMatrixReflect>mgMatrixReflect</A>, 
<A HREF=#mgMatrixFormYawLeft90>mgMatrixFormYawLeft90</A>, <A HREF=#mgMatrixYawLeft90>mgMatrixYawLeft90</A>, 
<A HREF=#mgMatrixFormYawRight90>mgMatrixFormYawRight90</A>, <A HREF=#mgMatrixYawRight90>mgMatrixYawRight90</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixFormRollLeft90><H1 CLASS="APISYMBOL">mgMatrixFormRollLeft90</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixFormRollLeft90</B> - creates a matrix that will roll left 90 degrees.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgMatrixFormRollLeft90</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgmatrix <B>mgMatrixFormRollLeft90</B> (  )
</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixFormRollLeft90</B> gets a matrix that will roll left 90 degrees.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the resulting matrix into the output 
parameter <I>matrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the resulting matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>address of matrix to receive result</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgmatrix</DT><DD>the matrix.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgMatrixRollLeft90>mgMatrixRollLeft90</A>, 
<A HREF=#mgMatrixFormRollRight90>mgMatrixFormRollRight90</A>, <A HREF=#mgMatrixRollRight90>mgMatrixRollRight90</A>, 
<A HREF=#mgMatrixFormReflectY>mgMatrixFormReflectY</A>, <A HREF=#mgMatrixReflectY>mgMatrixReflectY</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixFormRollRight90><H1 CLASS="APISYMBOL">mgMatrixFormRollRight90</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixFormRollRight90</B> - creates a matrix that will roll right 90 degrees.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgMatrixFormRollRight90</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgmatrix <B>mgMatrixFormRollRight90</B> (  )
</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixFormRollRight90</B> gets a matrix that will roll right 90 degrees.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the resulting matrix into the output 
parameter <I>matrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the resulting matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>address of matrix to receive result</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgmatrix</DT><DD>the matrix.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgMatrixFormRollLeft90>mgMatrixFormRollLeft90</A>, <A HREF=#mgMatrixRollLeft90>mgMatrixRollLeft90</A>, 
<A HREF=#mgMatrixRollRight90>mgMatrixRollRight90</A>, 
<A HREF=#mgMatrixFormReflectY>mgMatrixFormReflectY</A>, <A HREF=#mgMatrixReflectY>mgMatrixReflectY</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixFormRotate><H1 CLASS="APISYMBOL">mgMatrixFormRotate</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixFormRotate</B> - forms a rotation matrix for rotation 
about a vector.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixFormRotate</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>theta</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>a</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>b</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>c</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, mgmatrix <B>mgMatrixFormRotate</B> (</TD><TD>double</TD><TD><I>theta</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>a</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>b</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>c</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixFormRotate</B> gets a matrix for rotation about a vector 
specified as direction cosines.</P></DD><DD><P>The parameters <I>a</I>, <I>b</I>, and <I>c</I> (direction cosines) are the 
unitized components of a vector about which the rotation is applied.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the resulting matrix into the output 
parameter <I>matrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the resulting matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>address of matrix to receive result</DD><DT><I>theta</I></DT><DD>angle to rotate measured counter-clockwise 
in degrees about vector (right hand rule)</DD><DT><I>a</I></DT><DD>unitized x component of vector</DD><DT><I>b</I></DT><DD>unitized y component of vector</DD><DT><I>c</I></DT><DD>unitized z component of vector</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful,&#32<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>mgmatrix</DT><DD>the matrix.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMatrixFormTranslate>mgMatrixFormTranslate</A>, <A HREF=#mgMatrixFormScale>mgMatrixFormScale</A>, 
<A HREF=#mgMatrixFormRotateX>mgMatrixFormRotateX</A>, 
<A HREF=#mgMatrixFormRotateY>mgMatrixFormRotateY</A>, <A HREF=#mgMatrixFormRotateZ>mgMatrixFormRotateZ</A>, 
<A HREF=#mgMatrixFormQuadToQuad>mgMatrixFormQuadToQuad</A>, <A HREF=#mgMatrixMultiply>mgMatrixMultiply</A>, 
<A HREF=#mgMatrixRotateX>mgMatrixRotateX</A>, <A HREF=#mgMatrixRotateY>mgMatrixRotateY</A>, <A HREF=#mgMatrixRotateZ>mgMatrixRotateZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixFormRotateX><H1 CLASS="APISYMBOL">mgMatrixFormRotateX</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixFormRotateX</B> - forms a rotation matrix for rotation 
about the X axis.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixFormRotateX</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>theta</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, mgmatrix <B>mgMatrixFormRotateX</B> (</TD><TD>double</TD><TD><I>theta</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixFormRotateX</B> gets a matrix for rotation about the X axis. 
The parameter <I>theta</I> specifies the angle (in degrees) to rotate 
counter-clockwise (right hand rule).</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the resulting matrix into the output 
parameter <I>matrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the resulting matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>address of matrix to receive result</DD><DT><I>theta</I></DT><DD>angle to rotate measured counter-clockwise 
in degrees about X axis (right hand rule)</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful,&#32<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>mgmatrix</DT><DD>the matrix.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMatrixFormTranslate>mgMatrixFormTranslate</A>, <A HREF=#mgMatrixFormScale>mgMatrixFormScale</A>, 
<A HREF=#mgMatrixFormRotate>mgMatrixFormRotate</A>, 
<A HREF=#mgMatrixFormRotateY>mgMatrixFormRotateY</A>, <A HREF=#mgMatrixFormRotateZ>mgMatrixFormRotateZ</A>, 
<A HREF=#mgMatrixFormQuadToQuad>mgMatrixFormQuadToQuad</A>, <A HREF=#mgMatrixMultiply>mgMatrixMultiply</A>, 
<A HREF=#mgMatrixRotateX>mgMatrixRotateX</A>, <A HREF=#mgMatrixRotateY>mgMatrixRotateY</A>, <A HREF=#mgMatrixRotateZ>mgMatrixRotateZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixFormRotateY><H1 CLASS="APISYMBOL">mgMatrixFormRotateY</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixFormRotateY</B> - forms a rotation matrix for rotation 
about the Y axis.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixFormRotateY</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>theta</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, mgmatrix <B>mgMatrixFormRotateY</B> (</TD><TD>double</TD><TD><I>theta</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixFormRotateY</B> gets a matrix for rotation about the Y axis. 
The parameter <I>theta</I> specifies the angle (in degrees) to rotate 
counter-clockwise (right hand rule).</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the resulting matrix into the output 
parameter <I>matrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the resulting matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>address of matrix to receive result</DD><DT><I>theta</I></DT><DD>angle to rotate measured counter-clockwise 
in degrees about Y axis (right hand rule)</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful,&#32<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>mgmatrix</DT><DD>the matrix.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMatrixFormTranslate>mgMatrixFormTranslate</A>, <A HREF=#mgMatrixFormScale>mgMatrixFormScale</A>, 
<A HREF=#mgMatrixFormRotate>mgMatrixFormRotate</A>, <A HREF=#mgMatrixFormRotateX>mgMatrixFormRotateX</A>, 
<A HREF=#mgMatrixFormRotateZ>mgMatrixFormRotateZ</A>, 
<A HREF=#mgMatrixFormQuadToQuad>mgMatrixFormQuadToQuad</A>, <A HREF=#mgMatrixMultiply>mgMatrixMultiply</A>, 
<A HREF=#mgMatrixRotateX>mgMatrixRotateX</A>, <A HREF=#mgMatrixRotateY>mgMatrixRotateY</A>, <A HREF=#mgMatrixRotateZ>mgMatrixRotateZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixFormRotateZ><H1 CLASS="APISYMBOL">mgMatrixFormRotateZ</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixFormRotateZ</B> - forms a rotation matrix for rotation 
about the Z axis.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixFormRotateZ</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>theta</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, mgmatrix <B>mgMatrixFormRotateZ</B> (</TD><TD>double</TD><TD><I>theta</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixFormRotateZ</B> gets a matrix for rotation about the Z axis. 
The parameter <I>theta</I> specifies the angle (in degrees) to rotate 
counter-clockwise (right hand rule).</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the resulting matrix into the output 
parameter <I>matrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the resulting matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>address of matrix to receive result</DD><DT><I>theta</I></DT><DD>angle to rotate measured counter-clockwise 
in degrees about Z axis (right hand rule)</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful,&#32<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>mgmatrix</DT><DD>the matrix.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMatrixFormTranslate>mgMatrixFormTranslate</A>, <A HREF=#mgMatrixFormScale>mgMatrixFormScale</A>, 
<A HREF=#mgMatrixFormRotate>mgMatrixFormRotate</A>, <A HREF=#mgMatrixFormRotateX>mgMatrixFormRotateX</A>, 
<A HREF=#mgMatrixFormRotateY>mgMatrixFormRotateY</A>, 
<A HREF=#mgMatrixFormQuadToQuad>mgMatrixFormQuadToQuad</A>, <A HREF=#mgMatrixMultiply>mgMatrixMultiply</A>, 
<A HREF=#mgMatrixRotateX>mgMatrixRotateX</A>, <A HREF=#mgMatrixRotateY>mgMatrixRotateY</A>, <A HREF=#mgMatrixRotateZ>mgMatrixRotateZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixFormScale><H1 CLASS="APISYMBOL">mgMatrixFormScale</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixFormScale</B> - forms a scale matrix.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixFormScale</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>y</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>z</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, mgmatrix <B>mgMatrixFormScale</B> (</TD><TD>double</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>y</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>z</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixFormScale</B> gets a matrix for scaling about 
a local origin (0.0, 0.0, 0.0). 
The parameters <I>x</I>, <I>y</I>, and <I>z</I> are the scale factors to 
apply along the coordinate axes, X, Y, and Z, respectively.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the resulting matrix into the output 
parameter <I>matrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the resulting matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>address of matrix to receive result</DD><DT><I>x</I></DT><DD>scale factor in the X direction</DD><DT><I>y</I></DT><DD>scale factor in the Y direction</DD><DT><I>z</I></DT><DD>scale factor in the Z direction</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful,&#32<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>mgmatrix</DT><DD>the matrix.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMatrixFormTranslate>mgMatrixFormTranslate</A>, 
<A HREF=#mgMatrixFormRotate>mgMatrixFormRotate</A>, <A HREF=#mgMatrixFormRotateX>mgMatrixFormRotateX</A>, 
<A HREF=#mgMatrixFormRotateY>mgMatrixFormRotateY</A>, <A HREF=#mgMatrixFormRotateZ>mgMatrixFormRotateZ</A>, 
<A HREF=#mgMatrixFormQuadToQuad>mgMatrixFormQuadToQuad</A>, <A HREF=#mgMatrixMultiply>mgMatrixMultiply</A>, 
<A HREF=#mgMatrixRotateX>mgMatrixRotateX</A>, <A HREF=#mgMatrixRotateY>mgMatrixRotateY</A>, <A HREF=#mgMatrixRotateZ>mgMatrixRotateZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixFormTranslate><H1 CLASS="APISYMBOL">mgMatrixFormTranslate</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixFormTranslate</B> - forms a translation matrix.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixFormTranslate</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>y</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>z</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, mgmatrix <B>mgMatrixFormTranslate</B> (</TD><TD>double</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>y</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>z</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixFormTranslate</B> gets a matrix for 
translating along the coordinate axes X, Y and Z. 
The parameters <I>x</I>, <I>y</I>, and <I>z</I> are the translation values to 
apply along the coordinate axes, X, Y, and Z, respectively.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the resulting matrix into the output 
parameter <I>matrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the resulting matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>address of matrix to receive result</DD><DT><I>x</I></DT><DD>translation in the X direction</DD><DT><I>y</I></DT><DD>translation in the Y direction</DD><DT><I>z</I></DT><DD>translation in the Z direction</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful,&#32<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>mgmatrix</DT><DD>the matrix.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMatrixFormScale>mgMatrixFormScale</A>, 
<A HREF=#mgMatrixFormRotate>mgMatrixFormRotate</A>, <A HREF=#mgMatrixFormRotateX>mgMatrixFormRotateX</A>, 
<A HREF=#mgMatrixFormRotateY>mgMatrixFormRotateY</A>, <A HREF=#mgMatrixFormRotateZ>mgMatrixFormRotateZ</A>, 
<A HREF=#mgMatrixFormQuadToQuad>mgMatrixFormQuadToQuad</A>, <A HREF=#mgMatrixMultiply>mgMatrixMultiply</A>, 
<A HREF=#mgMatrixRotateX>mgMatrixRotateX</A>, <A HREF=#mgMatrixRotateY>mgMatrixRotateY</A>, <A HREF=#mgMatrixRotateZ>mgMatrixRotateZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixFormXYZToUV><H1 CLASS="APISYMBOL">mgMatrixFormXYZToUV</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixFormXYZToUV</B> - creates a matrix that maps xyz space to 
uv space.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixFormXYZToUV</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>poly</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>layer</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, mgmatrix <B>mgMatrixFormXYZToUV</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>poly</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>layer</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixFormXYZToUV</B> gets a matrix that maps the xyz coordinates of <I>poly</I> 
to uv space for texture <I>layer</I>. Note that this xyz to uv matrix assumes that the uvs 
on layer <I>layer</I> of <I>poly</I> have a linear mapping like one provided by three point put. 
Any warping or tapering will not be taken into account by this mapping matrix.</P></DD><DD><P>The original polygon <I>poly</I> is not changed.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the resulting matrix into the output 
parameter <I>matrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the resulting matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>address of matrix to receive result</DD><DT><I>poly</I></DT><DD>textured polygon to generate a mapping for</DD><DT><I>layer</I></DT><DD>layer of the uv coordinates to map</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful,&#32<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>mgmatrix</DT><DD>the matrix.</DD></DL></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show how to transfer 
the texture mapping of one polygon to another polygon in texture layer 0 
using <B>mgMatrixFormXYZToUV</B>. This is similar to the Flow Texture tool 
in Creator.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* vtx;
mgmatrix uvMat;

// get the UV matrix that transforms XYZ coordinates to
// UV texture coordinates for texture layer 0 of poly1
mgMatrixFormXYZToUV (&uvMat, poly1, 0);

// apply this mapping to all vertices of poly2
vtx = mgGetChild (poly2);
while (vtx)
{
   mgcoord3d xyz;
   mgcoord3d uv;

   // get the XYZ of this vertex of poly2
   mgGetVtxCoord (vtx, &xyz.x, &xyz.y, &xyz.z);

   // calculate the UV texture coordinates for this
   // vertex in UV space of poly1
   uv = mgCoord3dTransform (uvMat, &xyz);

   // finally update the UV texture coordinates on
   // the vertex of poly2
   // the U value is in the y coordinate
   // the V value is in the y coordinate
   // the z coordinate is not interesting here
   mgSetAttList (vtx, fltVU, uv.x, fltVV, uv.y, MG_NULL);

   // get ready to process next vertex of poly2
   vtx = mgGetNext (vtx);
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE"># get the UV matrix that transforms XYZ coordinates to
# UV texture coordinates for texture layer 0 of poly1
b, uvMat = mgMatrixFormXYZToUV (poly1, 0)

# apply this mapping to all vertices of poly2
vtx = mgGetChild (poly2)

# create xyz coordinate to store values
xyz = mgcoord3d()

while (vtx):
   # get the XYZ of this vertex of poly2
   b, xyz.x, xyz.y, xyz.z = mgGetVtxCoord (vtx)

   # calculate the UV texture coordinates for this
   # vertex in UV space of poly1
   uv = mgCoord3dTransform (uvMat, xyz)

   # finally update the UV texture coordinates on
   # the vertex of poly2
   # the U value is in the y coordinate
   # the V value is in the y coordinate
   # the z coordinate is not interesting here
   mgSetAttList (vtx, fltVU, uv.x, fltVV, uv.y)

   # get ready to process next vertex of poly2
   vtx = mgGetNext (vtx)</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, <A HREF=#mgMatrixFormQuadToQuad>mgMatrixFormQuadToQuad</A>, 
<A HREF=#mgMatrixFormTranslate>mgMatrixFormTranslate</A>, <A HREF=#mgMatrixFormScale>mgMatrixFormScale</A>, 
<A HREF=#mgMatrixFormRotate>mgMatrixFormRotate</A>, <A HREF=#mgMatrixFormRotateX>mgMatrixFormRotateX</A>, 
<A HREF=#mgMatrixFormRotateY>mgMatrixFormRotateY</A>, <A HREF=#mgMatrixFormRotateZ>mgMatrixFormRotateZ</A>, 
<A HREF=#mgMatrixRotateX>mgMatrixRotateX</A>, <A HREF=#mgMatrixRotateY>mgMatrixRotateY</A>, <A HREF=#mgMatrixRotateZ>mgMatrixRotateZ</A>, 
<A HREF=#mgMatrixMultiply>mgMatrixMultiply</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixFormYawLeft90><H1 CLASS="APISYMBOL">mgMatrixFormYawLeft90</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixFormYawLeft90</B> - creates a matrix that will yaw left 90 degrees.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgMatrixFormYawLeft90</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgmatrix <B>mgMatrixFormYawLeft90</B> (  )
</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixFormYawLeft90</B> gets a matrix that will yaw left 90 degrees.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the resulting matrix into the output 
parameter <I>matrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the resulting matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>address of matrix to receive result</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgmatrix</DT><DD>the matrix.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgMatrixYawLeft90>mgMatrixYawLeft90</A>, 
<A HREF=#mgMatrixFormYawRight90>mgMatrixFormYawRight90</A>, <A HREF=#mgMatrixYawRight90>mgMatrixYawRight90</A>, 
<A HREF=#mgMatrixFormReflectZ>mgMatrixFormReflectZ</A>, <A HREF=#mgMatrixReflectZ>mgMatrixReflectZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixFormYawRight90><H1 CLASS="APISYMBOL">mgMatrixFormYawRight90</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixFormYawRight90</B> - creates a matrix that will yaw right 90 degrees.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgMatrixFormYawRight90</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgmatrix <B>mgMatrixFormYawRight90</B> (  )
</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixFormYawRight90</B> gets a matrix that will yaw right 90 degrees.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the resulting matrix into the output 
parameter <I>matrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the resulting matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>address of matrix to receive result</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgmatrix</DT><DD>the matrix.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgMatrixFormYawLeft90>mgMatrixFormYawLeft90</A>, <A HREF=#mgMatrixYawLeft90>mgMatrixYawLeft90</A>, 
<A HREF=#mgMatrixYawRight90>mgMatrixYawRight90</A>, 
<A HREF=#mgMatrixFormReflectZ>mgMatrixFormReflectZ</A>, <A HREF=#mgMatrixReflectZ>mgMatrixReflectZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixGetTranslation><H1 CLASS="APISYMBOL">mgMatrixGetTranslation</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixGetTranslation</B> - returns the translation of a matrix.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgMatrixGetTranslation</B> (</TD><TD>const <A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixGetTranslation</B> returns the translation of <I>matrix</I>.  The 
translation is composed of the first three elements in the 4th row of the matrix: 
matrix[12], matrix[13] and matrix[14].</P></DD><DD><P>The original matrix <I>matrix</I> is not affected.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to get the translation of</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the translation of <I>matrix</I>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgMatrixGetXAxis>mgMatrixGetXAxis</A>, <A HREF=#mgMatrixGetYAxis>mgMatrixGetYAxis</A>, <A HREF=#mgMatrixGetZAxis>mgMatrixGetZAxis</A>, 
<A HREF=#mgMatrixSetXAxis>mgMatrixSetXAxis</A>, <A HREF=#mgMatrixSetYAxis>mgMatrixSetYAxis</A>, <A HREF=#mgMatrixSetZAxis>mgMatrixSetZAxis</A>, <A HREF=#mgMatrixSetTranslation>mgMatrixSetTranslation</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixGetXAxis><H1 CLASS="APISYMBOL">mgMatrixGetXAxis</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixGetXAxis</B> - returns the local X axis of a matrix.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgMatrixGetXAxis</B> (</TD><TD>const <A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixGetXAxis</B> returns the local X axis of <I>matrix</I>.  The 
X axis is composed of the first three elements in the 1st row of the matrix: 
matrix[0], matrix[1] and matrix[2].</P></DD><DD><P>The original matrix <I>matrix</I> is not affected.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to get the local X axis of</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the local X axis of <I>matrix</I>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgMatrixGetYAxis>mgMatrixGetYAxis</A>, <A HREF=#mgMatrixGetZAxis>mgMatrixGetZAxis</A>, <A HREF=#mgMatrixGetTranslation>mgMatrixGetTranslation</A>, 
<A HREF=#mgMatrixSetXAxis>mgMatrixSetXAxis</A>, <A HREF=#mgMatrixSetYAxis>mgMatrixSetYAxis</A>, <A HREF=#mgMatrixSetZAxis>mgMatrixSetZAxis</A>, <A HREF=#mgMatrixSetTranslation>mgMatrixSetTranslation</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixGetYAxis><H1 CLASS="APISYMBOL">mgMatrixGetYAxis</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixGetYAxis</B> - returns the local Y axis of a matrix.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgMatrixGetYAxis</B> (</TD><TD>const <A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixGetYAxis</B> returns the local Y axis of <I>matrix</I>.  The 
Y axis is composed of the first three elements in the 2nd row of the matrix: 
matrix[4], matrix[5] and matrix[6].</P></DD><DD><P>The original matrix <I>matrix</I> is not affected.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to get the local Y axis of</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the local Y axis of <I>matrix</I>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgMatrixGetXAxis>mgMatrixGetXAxis</A>, <A HREF=#mgMatrixGetZAxis>mgMatrixGetZAxis</A>, <A HREF=#mgMatrixGetTranslation>mgMatrixGetTranslation</A>, 
<A HREF=#mgMatrixSetXAxis>mgMatrixSetXAxis</A>, <A HREF=#mgMatrixSetYAxis>mgMatrixSetYAxis</A>, <A HREF=#mgMatrixSetZAxis>mgMatrixSetZAxis</A>, <A HREF=#mgMatrixSetTranslation>mgMatrixSetTranslation</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixGetZAxis><H1 CLASS="APISYMBOL">mgMatrixGetZAxis</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixGetZAxis</B> - returns the local Z axis of a matrix.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgMatrixGetZAxis</B> (</TD><TD>const <A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixGetZAxis</B> returns the local Z axis of <I>matrix</I>.  The 
Z axis is composed of the first three elements in the 3rd row of the matrix: 
matrix[8], matrix[9] and matrix[10].</P></DD><DD><P>The original matrix <I>matrix</I> is not affected.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to get the local Z axis of</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the local Z axis of <I>matrix</I>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgMatrixGetXAxis>mgMatrixGetXAxis</A>, <A HREF=#mgMatrixGetYAxis>mgMatrixGetYAxis</A>, <A HREF=#mgMatrixGetTranslation>mgMatrixGetTranslation</A>, 
<A HREF=#mgMatrixSetXAxis>mgMatrixSetXAxis</A>, <A HREF=#mgMatrixSetYAxis>mgMatrixSetYAxis</A>, <A HREF=#mgMatrixSetZAxis>mgMatrixSetZAxis</A>, <A HREF=#mgMatrixSetTranslation>mgMatrixSetTranslation</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixIdentity><H1 CLASS="APISYMBOL">mgMatrixIdentity</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixIdentity</B> - forms the identity matrix.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixIdentity</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, mgmatrix <B>mgMatrixIdentity</B> (  )
</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixIdentity</B> creates and returns the identity matrix.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the identity matrix into the output 
parameter <I>matrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>address of matrix to receive result</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful,&#32<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>mgmatrix</DT><DD>the matrix.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewMatrix>mgNewMatrix</A>, <A HREF=#mgFreeMatrix>mgFreeMatrix</A>, <A HREF=#mgMatrixIsIdentity>mgMatrixIsIdentity</A>, 
<A HREF=#mgMatrixInvert>mgMatrixInvert</A>, <A HREF=#mgMatrixMultiply>mgMatrixMultiply</A>, <A HREF=#mgMatrixCopy>mgMatrixCopy</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixInvert><H1 CLASS="APISYMBOL">mgMatrixInvert</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixInvert</B> - forms the inverse of a matrix.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixInvert</B> (</TD><TD>const <A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>resultMatrix</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, mgmatrix <B>mgMatrixInvert</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrix</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixInvert</B> inverts the specified <I>matrix</I>.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the inverse matrix into the output 
parameter <I>resultMatrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the inverse matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to invert</DD><DT><I>resultMatrix</I></DT><DD>address of matrix to receive result</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful,&#32<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>mgmatrix</DT><DD>the matrix inverse.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewMatrix>mgNewMatrix</A>, <A HREF=#mgFreeMatrix>mgFreeMatrix</A>, <A HREF=#mgMatrixIdentity>mgMatrixIdentity</A>, 
<A HREF=#mgMatrixIsIdentity>mgMatrixIsIdentity</A>, <A HREF=#mgMatrixMultiply>mgMatrixMultiply</A>, <A HREF=#mgMatrixCopy>mgMatrixCopy</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixIsIdentity><H1 CLASS="APISYMBOL">mgMatrixIsIdentity</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixIsIdentity</B> - checks to see if a matrix is the 
identity matrix.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixIsIdentity</B> (</TD><TD>const <A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixIsIdentity</B> checks <I>matrix</I> to see if it is the 
identity matrix.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to check</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if <I>matrix</I> is the identity matrix, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewMatrix>mgNewMatrix</A>, <A HREF=#mgFreeMatrix>mgFreeMatrix</A>, <A HREF=#mgMatrixIdentity>mgMatrixIdentity</A>, 
<A HREF=#mgMatrixInvert>mgMatrixInvert</A>, <A HREF=#mgMatrixMultiply>mgMatrixMultiply</A>, <A HREF=#mgMatrixCopy>mgMatrixCopy</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixMultiply><H1 CLASS="APISYMBOL">mgMatrixMultiply</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixMultiply</B> - multiplies two matrices.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixMultiply</B> (</TD><TD>const <A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrixA</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrixB</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>resultMatrix</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, mgmatrix <B>mgMatrixMultiply</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrixA</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrixB</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixMultiply</B> multiplies two matrices <I>matrixA</I> and <I>matrixB</I> 
(<I>matrixA</I> X <I>matrixB</I>). 
This function operates safely when either of the input matrices and the 
output matrix are the same matrix.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the resulting matrix into the output 
parameter <I>resultMatrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the resulting matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrixA</I></DT><DD>matrix to multiply</DD><DT><I>matrixB</I></DT><DD>matrix to multiply</DD><DT><I>resultMatrix</I></DT><DD>address of matrix to receive result</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful,&#32<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>mgmatrix</DT><DD>the matrix result.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewMatrix>mgNewMatrix</A>, <A HREF=#mgFreeMatrix>mgFreeMatrix</A>, <A HREF=#mgMatrixIdentity>mgMatrixIdentity</A>, 
<A HREF=#mgMatrixIsIdentity>mgMatrixIsIdentity</A>, <A HREF=#mgMatrixInvert>mgMatrixInvert</A>, <A HREF=#mgMatrixCopy>mgMatrixCopy</A>, 
<A HREF=#mgMatrixRotateX>mgMatrixRotateX</A>, <A HREF=#mgMatrixRotateY>mgMatrixRotateY</A>, <A HREF=#mgMatrixRotateZ>mgMatrixRotateZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixPitchDown90><H1 CLASS="APISYMBOL">mgMatrixPitchDown90</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixPitchDown90</B> - pitches a matrix down 90 degrees in global space.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgMatrixPitchDown90</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixPitchDown90</B> pitches <I>matrix</I> down 90 degrees in global space.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to transform</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgMatrixFormPitchDown90>mgMatrixFormPitchDown90</A>, 
<A HREF=#mgMatrixFormPitchUp90>mgMatrixFormPitchUp90</A>, <A HREF=#mgMatrixPitchUp90>mgMatrixPitchUp90</A>, 
<A HREF=#mgMatrixFormReflectX>mgMatrixFormReflectX</A>, <A HREF=#mgMatrixReflectX>mgMatrixReflectX</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixPitchUp90><H1 CLASS="APISYMBOL">mgMatrixPitchUp90</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixPitchUp90</B> - pitches a matrix up 90 degrees in global space.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgMatrixPitchUp90</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixPitchUp90</B> pitches <I>matrix</I> up 90 degrees in global space.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to transform</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgMatrixFormPitchDown90>mgMatrixFormPitchDown90</A>, <A HREF=#mgMatrixPitchDown90>mgMatrixPitchDown90</A>, 
<A HREF=#mgMatrixFormPitchUp90>mgMatrixFormPitchUp90</A>, 
<A HREF=#mgMatrixFormReflectX>mgMatrixFormReflectX</A>, <A HREF=#mgMatrixReflectX>mgMatrixReflectX</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixReflect><H1 CLASS="APISYMBOL">mgMatrixReflect</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixReflect</B> - reflects a matrix about a specified axis in 
global space.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgMatrixReflect</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixReflect</B> reflects <I>matrix</I> about <I>coord</I> in global space.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to reflect</DD><DT><I>coord</I></DT><DD>address of coordinates of axis to reflect about, 
should have a length above zero</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgMatrixFormReflectX>mgMatrixFormReflectX</A>, <A HREF=#mgMatrixReflectX>mgMatrixReflectX</A>, 
<A HREF=#mgMatrixFormReflectY>mgMatrixFormReflectY</A>, <A HREF=#mgMatrixReflectY>mgMatrixReflectY</A>, 
<A HREF=#mgMatrixFormReflectZ>mgMatrixFormReflectZ</A>, <A HREF=#mgMatrixReflectZ>mgMatrixReflectZ</A>, 
<A HREF=#mgMatrixFormReflect>mgMatrixFormReflect</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixReflectX><H1 CLASS="APISYMBOL">mgMatrixReflectX</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixReflectX</B> - reflects a matrix about the global X axis.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgMatrixReflectX</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixReflectX</B> reflects <I>matrix</I> about the global X axis or 
pitches 180 degrees.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to transform</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgMatrixFormReflectX>mgMatrixFormReflectX</A>, 
<A HREF=#mgMatrixFormReflectY>mgMatrixFormReflectY</A>, <A HREF=#mgMatrixReflectY>mgMatrixReflectY</A>, 
<A HREF=#mgMatrixFormReflectZ>mgMatrixFormReflectZ</A>, <A HREF=#mgMatrixReflectZ>mgMatrixReflectZ</A>, 
<A HREF=#mgMatrixFormReflect>mgMatrixFormReflect</A>, <A HREF=#mgMatrixReflect>mgMatrixReflect</A>, 
<A HREF=#mgMatrixFormPitchDown90>mgMatrixFormPitchDown90</A>, <A HREF=#mgMatrixPitchDown90>mgMatrixPitchDown90</A>, 
<A HREF=#mgMatrixFormPitchUp90>mgMatrixFormPitchUp90</A>, <A HREF=#mgMatrixPitchUp90>mgMatrixPitchUp90</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixReflectY><H1 CLASS="APISYMBOL">mgMatrixReflectY</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixReflectY</B> - reflects a matrix about the global Y axis.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgMatrixReflectY</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixReflectY</B> reflects <I>matrix</I> about the global Y axis or 
rolls 180 degrees.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to transform</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgMatrixFormReflectX>mgMatrixFormReflectX</A>, <A HREF=#mgMatrixReflectX>mgMatrixReflectX</A>, 
<A HREF=#mgMatrixFormReflectY>mgMatrixFormReflectY</A>, 
<A HREF=#mgMatrixFormReflectZ>mgMatrixFormReflectZ</A>, <A HREF=#mgMatrixReflectZ>mgMatrixReflectZ</A>, 
<A HREF=#mgMatrixFormReflect>mgMatrixFormReflect</A>, <A HREF=#mgMatrixReflect>mgMatrixReflect</A>, 
<A HREF=#mgMatrixFormRollLeft90>mgMatrixFormRollLeft90</A>, <A HREF=#mgMatrixRollLeft90>mgMatrixRollLeft90</A>, 
<A HREF=#mgMatrixFormRollRight90>mgMatrixFormRollRight90</A>, <A HREF=#mgMatrixRollRight90>mgMatrixRollRight90</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixReflectZ><H1 CLASS="APISYMBOL">mgMatrixReflectZ</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixReflectZ</B> - reflects a matrix about the global Z axis.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgMatrixReflectZ</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixReflectZ</B> reflects <I>matrix</I> about the global Z axis or 
yaws 180 degrees.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to transform</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgMatrixFormReflectX>mgMatrixFormReflectX</A>, <A HREF=#mgMatrixReflectX>mgMatrixReflectX</A>, 
<A HREF=#mgMatrixFormReflectY>mgMatrixFormReflectY</A>, <A HREF=#mgMatrixReflectY>mgMatrixReflectY</A>, 
<A HREF=#mgMatrixFormReflectZ>mgMatrixFormReflectZ</A>, 
<A HREF=#mgMatrixFormReflect>mgMatrixFormReflect</A>, <A HREF=#mgMatrixReflect>mgMatrixReflect</A>, 
<A HREF=#mgMatrixFormYawLeft90>mgMatrixFormYawLeft90</A>, <A HREF=#mgMatrixYawLeft90>mgMatrixYawLeft90</A>, 
<A HREF=#mgMatrixFormYawRight90>mgMatrixFormYawRight90</A>, <A HREF=#mgMatrixYawRight90>mgMatrixYawRight90</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixRollLeft90><H1 CLASS="APISYMBOL">mgMatrixRollLeft90</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixRollLeft90</B> - rolls a matrix left 90 degrees in global space.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgMatrixRollLeft90</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixRollLeft90</B> rolls <I>matrix</I> left 90 degrees in global space.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to transform</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgMatrixFormRollLeft90>mgMatrixFormRollLeft90</A>, 
<A HREF=#mgMatrixFormRollRight90>mgMatrixFormRollRight90</A>, <A HREF=#mgMatrixRollRight90>mgMatrixRollRight90</A>, 
<A HREF=#mgMatrixFormReflectY>mgMatrixFormReflectY</A>, <A HREF=#mgMatrixReflectY>mgMatrixReflectY</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixRollRight90><H1 CLASS="APISYMBOL">mgMatrixRollRight90</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixRollRight90</B> - rolls a matrix right 90 degrees in global space.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgMatrixRollRight90</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixRollRight90</B> rolls <I>matrix</I> right 90 degrees in global space.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to transform</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgMatrixFormRollLeft90>mgMatrixFormRollLeft90</A>, <A HREF=#mgMatrixRollLeft90>mgMatrixRollLeft90</A>, 
<A HREF=#mgMatrixFormRollRight90>mgMatrixFormRollRight90</A>, 
<A HREF=#mgMatrixFormReflectY>mgMatrixFormReflectY</A>, <A HREF=#mgMatrixReflectY>mgMatrixReflectY</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixRotateX><H1 CLASS="APISYMBOL">mgMatrixRotateX</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixRotateX</B> - multiply an X-axis rotation matrix 
into the given matrix.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixRotateX</B> (</TD><TD>const <A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>theta</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>resultMatrix</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, mgmatrix <B>mgMatrixRotateX</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>theta</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixRotateX</B> calculates a rotation matrix for rotation 
about the X axis and multiplies that matrix into the given matrix 
<I>matrix</I>.</P></DD><DD><P>Call the rotation matrix representing the rotation of <I>theta</I> 
degrees about the X coordinate axis <I>R</I>.  Call the value (on input) 
of <I>matrix</I> <I>M</I>.  The resulting matrix will be the product 
<I>R</I> X <I>M</I>. 
The parameter <I>theta</I> specifies the angle (in degrees) to rotate 
counter-clockwise (right hand rule). 
This function operates safely when the input and output matrices 
are the same matrix.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the resulting matrix into the output 
parameter <I>resultMatrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the resulting matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to multiply</DD><DT><I>theta</I></DT><DD>angle to rotate measured counter-clockwise 
in degrees about X axis (right hand rule)</DD><DT><I>resultMatrix</I></DT><DD>address of matrix to receive result</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful,&#32<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>mgmatrix</DT><DD>the matrix result.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMatrixFormTranslate>mgMatrixFormTranslate</A>, 
<A HREF=#mgMatrixFormScale>mgMatrixFormScale</A>, 
<A HREF=#mgMatrixFormRotate>mgMatrixFormRotate</A>, 
<A HREF=#mgMatrixFormRotateY>mgMatrixFormRotateY</A>, 
<A HREF=#mgMatrixFormRotateZ>mgMatrixFormRotateZ</A>, 
<A HREF=#mgMatrixFormQuadToQuad>mgMatrixFormQuadToQuad</A>, <A HREF=#mgMatrixMultiply>mgMatrixMultiply</A>, 
<A HREF=#mgMatrixRotateY>mgMatrixRotateY</A>, <A HREF=#mgMatrixRotateZ>mgMatrixRotateZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixRotateY><H1 CLASS="APISYMBOL">mgMatrixRotateY</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixRotateY</B> - multiply a Y-axis rotation matrix 
into the given matrix.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixRotateY</B> (</TD><TD>const <A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>theta</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>resultMatrix</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, mgmatrix <B>mgMatrixRotateY</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>theta</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixRotateY</B> calculates a rotation matrix for rotation 
about the Y axis and multiplies that matrix into the given matrix 
<I>matrix</I>.</P></DD><DD><P>Call the rotation matrix representing the rotation of <I>theta</I> 
degrees about the Y coordinate axis <I>R</I>.  Call the value (on input) 
of <I>matrix</I> <I>M</I>.  The resulting matrix will be the product 
<I>R</I> X <I>M</I>. 
The parameter <I>theta</I> specifies the angle (in degrees) to rotate 
counter-clockwise (right hand rule). 
This function operates safely when the input and output matrices 
are the same matrix.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the resulting matrix into the output 
parameter <I>resultMatrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the resulting matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to multiply</DD><DT><I>theta</I></DT><DD>angle to rotate measured counter-clockwise 
in degrees about Y axis (right hand rule)</DD><DT><I>resultMatrix</I></DT><DD>address of matrix to receive result</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful,&#32<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>mgmatrix</DT><DD>the matrix result.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMatrixFormTranslate>mgMatrixFormTranslate</A>, 
<A HREF=#mgMatrixFormScale>mgMatrixFormScale</A>, 
<A HREF=#mgMatrixFormRotate>mgMatrixFormRotate</A>, 
<A HREF=#mgMatrixFormRotateY>mgMatrixFormRotateY</A>, 
<A HREF=#mgMatrixFormRotateZ>mgMatrixFormRotateZ</A>, 
<A HREF=#mgMatrixFormQuadToQuad>mgMatrixFormQuadToQuad</A>, <A HREF=#mgMatrixMultiply>mgMatrixMultiply</A>, 
<A HREF=#mgMatrixRotateX>mgMatrixRotateX</A>, <A HREF=#mgMatrixRotateZ>mgMatrixRotateZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixRotateZ><H1 CLASS="APISYMBOL">mgMatrixRotateZ</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixRotateZ</B> - multiply a Z-axis rotation matrix 
into the given matrix.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixRotateZ</B> (</TD><TD>const <A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>theta</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>resultMatrix</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, mgmatrix <B>mgMatrixRotateZ</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>theta</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixRotateZ</B> calculates a rotation matrix for rotation 
about the Z axis and multiplies that matrix into the given matrix 
<I>matrix</I>.</P></DD><DD><P>Call the rotation matrix representing the rotation of <I>theta</I> 
degrees about the Z coordinate axis <I>R</I>.  Call the value (on input) 
of <I>matrix</I> <I>M</I>.  The resulting matrix will be the product 
<I>R</I> X <I>M</I>. 
The parameter <I>theta</I> specifies the angle (in degrees) to rotate 
counter-clockwise (right hand rule). 
This function operates safely when the input and output matrices 
are the same matrix.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the resulting matrix into the output 
parameter <I>resultMatrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the resulting matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to multiply</DD><DT><I>theta</I></DT><DD>angle to rotate measured counter-clockwise 
in degrees about Z axis (right hand rule)</DD><DT><I>resultMatrix</I></DT><DD>address of matrix to receive result</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful,&#32<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>mgmatrix</DT><DD>the matrix result.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMatrixFormTranslate>mgMatrixFormTranslate</A>, 
<A HREF=#mgMatrixFormScale>mgMatrixFormScale</A>, 
<A HREF=#mgMatrixFormRotate>mgMatrixFormRotate</A>, 
<A HREF=#mgMatrixFormRotateY>mgMatrixFormRotateY</A>, 
<A HREF=#mgMatrixFormRotateZ>mgMatrixFormRotateZ</A>, 
<A HREF=#mgMatrixFormQuadToQuad>mgMatrixFormQuadToQuad</A>, <A HREF=#mgMatrixMultiply>mgMatrixMultiply</A>, 
<A HREF=#mgMatrixRotateX>mgMatrixRotateX</A>, <A HREF=#mgMatrixRotateY>mgMatrixRotateY</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixScale><H1 CLASS="APISYMBOL">mgMatrixScale</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixScale</B> - multiply a scale matrix into the given matrix.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixScale</B> (</TD><TD>const <A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>y</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>z</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>resultMatrix</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, mgmatrix <B>mgMatrixScale</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>y</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>z</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixScale</B> calculates a scale matrix for scaling about 
a local origin (0.0, 0.0, 0.0) and multiplies that matrix into the 
given matrix <I>matrix</I>.</P></DD><DD><P>Call the scale matrix representing the scale by <I>x</I>, <I>y</I> and <I>z</I> 
along the coordinate axes X, Y and Z, respectively, <I>S</I>.  Call the value 
(on input) of <I>matrix</I> <I>M</I>.  The resulting matrix will be the product 
<I>S</I> X <I>M</I>. 
This function operates safely when the input and output matrices 
are the same matrix.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the resulting matrix into the output 
parameter <I>resultMatrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the resulting matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to multiply</DD><DT><I>x</I></DT><DD>scale factor in the X direction</DD><DT><I>y</I></DT><DD>scale factor in the Y direction</DD><DT><I>z</I></DT><DD>scale factor in the Z direction</DD><DT><I>resultMatrix</I></DT><DD>address of matrix to receive result</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful,&#32<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>mgmatrix</DT><DD>the matrix result.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMatrixFormTranslate>mgMatrixFormTranslate</A>, 
<A HREF=#mgMatrixFormScale>mgMatrixFormScale</A>, 
<A HREF=#mgMatrixFormRotate>mgMatrixFormRotate</A>, 
<A HREF=#mgMatrixFormRotateY>mgMatrixFormRotateY</A>, 
<A HREF=#mgMatrixFormRotateZ>mgMatrixFormRotateZ</A>, 
<A HREF=#mgMatrixFormQuadToQuad>mgMatrixFormQuadToQuad</A>, <A HREF=#mgMatrixMultiply>mgMatrixMultiply</A>, 
<A HREF=#mgMatrixRotateX>mgMatrixRotateX</A>, <A HREF=#mgMatrixRotateY>mgMatrixRotateY</A>, <A HREF=#mgMatrixRotateZ>mgMatrixRotateZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixSetTranslation><H1 CLASS="APISYMBOL">mgMatrixSetTranslation</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixSetTranslation</B> - sets the translation of a matrix.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgMatrixSetTranslation</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixSetTranslation</B> sets the translation of <I>matrix</I>. The 
translation is composed of the first three elements in the 4th row of the matrix: 
matrix[12], matrix[13] and matrix[14].</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to set the translation of</DD><DT><I>coord</I></DT><DD>translation to set to</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgMatrixGetXAxis>mgMatrixGetXAxis</A>, <A HREF=#mgMatrixGetYAxis>mgMatrixGetYAxis</A>, <A HREF=#mgMatrixGetZAxis>mgMatrixGetZAxis</A>, <A HREF=#mgMatrixGetTranslation>mgMatrixGetTranslation</A>, 
<A HREF=#mgMatrixSetXAxis>mgMatrixSetXAxis</A>, <A HREF=#mgMatrixSetYAxis>mgMatrixSetYAxis</A>, <A HREF=#mgMatrixSetZAxis>mgMatrixSetZAxis</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixSetXAxis><H1 CLASS="APISYMBOL">mgMatrixSetXAxis</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixSetXAxis</B> - sets the local X axis of a matrix.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgMatrixSetXAxis</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixSetXAxis</B> sets the local X axis of <I>matrix</I>.  The 
X axis is composed of the first three elements in the 1st row of the matrix: 
matrix[0], matrix[1] and matrix[2].</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to set the local X axis of</DD><DT><I>coord</I></DT><DD>local X axis to set to</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgMatrixGetXAxis>mgMatrixGetXAxis</A>, <A HREF=#mgMatrixGetYAxis>mgMatrixGetYAxis</A>, <A HREF=#mgMatrixGetZAxis>mgMatrixGetZAxis</A>, <A HREF=#mgMatrixGetTranslation>mgMatrixGetTranslation</A>, 
<A HREF=#mgMatrixSetYAxis>mgMatrixSetYAxis</A>, <A HREF=#mgMatrixSetZAxis>mgMatrixSetZAxis</A>, <A HREF=#mgMatrixSetTranslation>mgMatrixSetTranslation</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixSetYAxis><H1 CLASS="APISYMBOL">mgMatrixSetYAxis</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixSetYAxis</B> - sets the local Y axis of a matrix.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgMatrixSetYAxis</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixSetYAxis</B> sets the local Y axis of <I>matrix</I>.  The 
Y axis is composed of the first three elements in the 2nd row of the matrix: 
matrix[4], matrix[5] and matrix[6].</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to set the local Y axis of</DD><DT><I>coord</I></DT><DD>local Y axis to set to</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgMatrixGetXAxis>mgMatrixGetXAxis</A>, <A HREF=#mgMatrixGetYAxis>mgMatrixGetYAxis</A>, <A HREF=#mgMatrixGetZAxis>mgMatrixGetZAxis</A>, <A HREF=#mgMatrixGetTranslation>mgMatrixGetTranslation</A>, 
<A HREF=#mgMatrixSetXAxis>mgMatrixSetXAxis</A>, <A HREF=#mgMatrixSetZAxis>mgMatrixSetZAxis</A>, <A HREF=#mgMatrixSetTranslation>mgMatrixSetTranslation</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixSetZAxis><H1 CLASS="APISYMBOL">mgMatrixSetZAxis</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixSetZAxis</B> - sets the local Z axis of a matrix.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgMatrixSetZAxis</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixSetZAxis</B> sets the local Z axis of <I>matrix</I>.  The 
Z axis is composed of the first three elements in the 3rd row of the matrix: 
matrix[8], matrix[9] and matrix[10].</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>coord</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to set the local Z axis of</DD><DT><I>coord</I></DT><DD>local Z axis to set to</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgMatrixGetXAxis>mgMatrixGetXAxis</A>, <A HREF=#mgMatrixGetYAxis>mgMatrixGetYAxis</A>, <A HREF=#mgMatrixGetZAxis>mgMatrixGetZAxis</A>, <A HREF=#mgMatrixGetTranslation>mgMatrixGetTranslation</A>, 
<A HREF=#mgMatrixSetXAxis>mgMatrixSetXAxis</A>, <A HREF=#mgMatrixSetYAxis>mgMatrixSetYAxis</A>, <A HREF=#mgMatrixSetTranslation>mgMatrixSetTranslation</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixStackGetMatrix><H1 CLASS="APISYMBOL">mgMatrixStackGetMatrix</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixStackGetMatrix</B> - get the current top-of-stack 
matrix from a matrix stack.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixStackGetMatrix</B> (</TD><TD>const <A HREF=#mgmatrixstack>mgmatrixstack</A></TD><TD><I>matrixStack</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, mgmatrix <B>mgMatrixStackGetMatrix</B> (</TD><TD><A HREF=#mgmatrixstack>mgmatrixstack</A></TD><TD><I>matrixStack</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixStackGetMatrix</B> gets the current top-of-stack matrix 
from a specified matrix stack <I>matrixStack</I>.  The top-of-stack matrix 
is returned in the ouput parameter <I>matrix</I>.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the top-of-stack matrix into the output 
parameter <I>matrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the top-of-stack matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrixStack</I></DT><DD>matrix stack to get top matrix from</DD><DT><I>matrix</I></DT><DD>address of matrix to receive top matrix</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful,&#32<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>mgmatrix</DT><DD>the matrix.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, <A HREF=#mgNewMatrixStack>mgNewMatrixStack</A>, <A HREF=#mgFreeMatrixStack>mgFreeMatrixStack</A>, 
<A HREF=#mgMatrixStackPush>mgMatrixStackPush</A>, <A HREF=#mgMatrixStackPop>mgMatrixStackPop</A>, 
<A HREF=#mgMatrixStackLoadIdentity>mgMatrixStackLoadIdentity</A>, <A HREF=#mgMatrixStackIsIdentity>mgMatrixStackIsIdentity</A>, 
<A HREF=#mgMatrixStackLoadMatrix>mgMatrixStackLoadMatrix</A>, 
<A HREF=#mgMatrixStackMultiply>mgMatrixStackMultiply</A>, <A HREF=#mgMatrixStackTranslate>mgMatrixStackTranslate</A>, <A HREF=#mgMatrixStackScale>mgMatrixStackScale</A>, 
<A HREF=#mgMatrixStackRotate>mgMatrixStackRotate</A>, <A HREF=#mgMatrixStackRotateX>mgMatrixStackRotateX</A>, 
<A HREF=#mgMatrixStackRotateY>mgMatrixStackRotateY</A>, <A HREF=#mgMatrixStackRotateZ>mgMatrixStackRotateZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixStackIsIdentity><H1 CLASS="APISYMBOL">mgMatrixStackIsIdentity</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixStackIsIdentity</B> - checks to see if the top-of-stack 
matrix on a matrix stack is the identity matrix.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixStackIsIdentity</B> (</TD><TD>const <A HREF=#mgmatrixstack>mgmatrixstack</A></TD><TD><I>matrixStack</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixStackIsIdentity</B> checks the specified matrix stack, <I>matrixStack</I> 
to see if the top matrix on it is the identity matrix.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrixStack</I></DT><DD>matrix stack to pop</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the top-of-stack matrix on <I>matrixStack</I> 
is the identity matrix, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, <A HREF=#mgNewMatrixStack>mgNewMatrixStack</A>, <A HREF=#mgFreeMatrixStack>mgFreeMatrixStack</A>, 
<A HREF=#mgMatrixStackPush>mgMatrixStackPush</A>, <A HREF=#mgMatrixStackPop>mgMatrixStackPop</A>, 
<A HREF=#mgMatrixStackLoadIdentity>mgMatrixStackLoadIdentity</A>, 
<A HREF=#mgMatrixStackLoadMatrix>mgMatrixStackLoadMatrix</A>, <A HREF=#mgMatrixStackGetMatrix>mgMatrixStackGetMatrix</A>, 
<A HREF=#mgMatrixStackMultiply>mgMatrixStackMultiply</A>, <A HREF=#mgMatrixStackTranslate>mgMatrixStackTranslate</A>, <A HREF=#mgMatrixStackScale>mgMatrixStackScale</A>, 
<A HREF=#mgMatrixStackRotate>mgMatrixStackRotate</A>, <A HREF=#mgMatrixStackRotateX>mgMatrixStackRotateX</A>, 
<A HREF=#mgMatrixStackRotateY>mgMatrixStackRotateY</A>, <A HREF=#mgMatrixStackRotateZ>mgMatrixStackRotateZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixStackLoadIdentity><H1 CLASS="APISYMBOL">mgMatrixStackLoadIdentity</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixStackLoadIdentity</B> - load an identity matrix onto 
a matrix stack.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixStackLoadIdentity</B> (</TD><TD><A HREF=#mgmatrixstack>mgmatrixstack</A></TD><TD><I>matrixStack</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixStackLoadIdentity</B> loads an identity matrix onto the 
specified matrix stack <I>matrixStack</I>.  An identity matrix replaces 
the current top-of-stack matrix in <I>matrixStack</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrixStack</I></DT><DD>matrix stack to load the identity 
matrix onto the top-of-stack</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, <A HREF=#mgNewMatrixStack>mgNewMatrixStack</A>, <A HREF=#mgFreeMatrixStack>mgFreeMatrixStack</A>, 
<A HREF=#mgMatrixStackPush>mgMatrixStackPush</A>, <A HREF=#mgMatrixStackPop>mgMatrixStackPop</A>, 
<A HREF=#mgMatrixStackIsIdentity>mgMatrixStackIsIdentity</A>, 
<A HREF=#mgMatrixStackLoadMatrix>mgMatrixStackLoadMatrix</A>, <A HREF=#mgMatrixStackGetMatrix>mgMatrixStackGetMatrix</A>, 
<A HREF=#mgMatrixStackMultiply>mgMatrixStackMultiply</A>, <A HREF=#mgMatrixStackTranslate>mgMatrixStackTranslate</A>, <A HREF=#mgMatrixStackScale>mgMatrixStackScale</A>, 
<A HREF=#mgMatrixStackRotate>mgMatrixStackRotate</A>, <A HREF=#mgMatrixStackRotateX>mgMatrixStackRotateX</A>, 
<A HREF=#mgMatrixStackRotateY>mgMatrixStackRotateY</A>, <A HREF=#mgMatrixStackRotateZ>mgMatrixStackRotateZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixStackLoadMatrix><H1 CLASS="APISYMBOL">mgMatrixStackLoadMatrix</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixStackLoadMatrix</B> - load a matrix onto a matrix stack.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixStackLoadMatrix</B> (</TD><TD><A HREF=#mgmatrixstack>mgmatrixstack</A></TD><TD><I>matrixStack</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixStackLoadMatrix</B> loads a given <I>matrix</I> onto the 
specified matrix stack <I>matrixStack</I>.  A copy of <I>matrix</I> replaces 
the current top-of-stack matrix in <I>matrixStack</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrixStack</I></DT><DD>matrix stack to apply operation</DD><DT><I>matrix</I></DT><DD>matrix to copy onto the top-of-stack</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, <A HREF=#mgNewMatrixStack>mgNewMatrixStack</A>, <A HREF=#mgFreeMatrixStack>mgFreeMatrixStack</A>, 
<A HREF=#mgMatrixStackPush>mgMatrixStackPush</A>, <A HREF=#mgMatrixStackPop>mgMatrixStackPop</A>, 
<A HREF=#mgMatrixStackLoadIdentity>mgMatrixStackLoadIdentity</A>, <A HREF=#mgMatrixStackIsIdentity>mgMatrixStackIsIdentity</A>, 
<A HREF=#mgMatrixStackGetMatrix>mgMatrixStackGetMatrix</A>, 
<A HREF=#mgMatrixStackMultiply>mgMatrixStackMultiply</A>, <A HREF=#mgMatrixStackTranslate>mgMatrixStackTranslate</A>, <A HREF=#mgMatrixStackScale>mgMatrixStackScale</A>, 
<A HREF=#mgMatrixStackRotate>mgMatrixStackRotate</A>, <A HREF=#mgMatrixStackRotateX>mgMatrixStackRotateX</A>, 
<A HREF=#mgMatrixStackRotateY>mgMatrixStackRotateY</A>, <A HREF=#mgMatrixStackRotateZ>mgMatrixStackRotateZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixStackMultiply><H1 CLASS="APISYMBOL">mgMatrixStackMultiply</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixStackMultiply</B> - multiplies a matrix into a matrix stack.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixStackMultiply</B> (</TD><TD><A HREF=#mgmatrixstack>mgmatrixstack</A></TD><TD><I>matrixStack</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixStackMultiply</B> multiplies the current top-of-stack matrix 
in the specified matrix stack, <I>matrixStack</I> by a given <I>matrix</I>.</P></DD><DD><P>If the top-of-stack matrix is <I>T</I> before this function, the new top-of-stack 
matrix after this function will be the product <I>matrix</I> X <I>T</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrixStack</I></DT><DD>matrix stack to apply operation</DD><DT><I>matrix</I></DT><DD>matrix to multiply into the top-of-stack</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, <A HREF=#mgNewMatrixStack>mgNewMatrixStack</A>, <A HREF=#mgFreeMatrixStack>mgFreeMatrixStack</A>, 
<A HREF=#mgMatrixStackPush>mgMatrixStackPush</A>, <A HREF=#mgMatrixStackPop>mgMatrixStackPop</A>, 
<A HREF=#mgMatrixStackLoadIdentity>mgMatrixStackLoadIdentity</A>, <A HREF=#mgMatrixStackIsIdentity>mgMatrixStackIsIdentity</A>, 
<A HREF=#mgMatrixStackLoadMatrix>mgMatrixStackLoadMatrix</A>, <A HREF=#mgMatrixStackGetMatrix>mgMatrixStackGetMatrix</A>, 
<A HREF=#mgMatrixStackTranslate>mgMatrixStackTranslate</A>, <A HREF=#mgMatrixStackScale>mgMatrixStackScale</A>, 
<A HREF=#mgMatrixStackRotate>mgMatrixStackRotate</A>, <A HREF=#mgMatrixStackRotateX>mgMatrixStackRotateX</A>, 
<A HREF=#mgMatrixStackRotateY>mgMatrixStackRotateY</A>, <A HREF=#mgMatrixStackRotateZ>mgMatrixStackRotateZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixStackPop><H1 CLASS="APISYMBOL">mgMatrixStackPop</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixStackPop</B> - pop a matrix stack.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixStackPop</B> (</TD><TD><A HREF=#mgmatrixstack>mgmatrixstack</A></TD><TD><I>matrixStack</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixStackPop</B> pops the specified matrix stack <I>matrixStack</I>. 
The current top matrix is discarded.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrixStack</I></DT><DD>matrix stack to pop</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, <A HREF=#mgNewMatrixStack>mgNewMatrixStack</A>, <A HREF=#mgFreeMatrixStack>mgFreeMatrixStack</A>, 
<A HREF=#mgMatrixStackPush>mgMatrixStackPush</A>, 
<A HREF=#mgMatrixStackLoadIdentity>mgMatrixStackLoadIdentity</A>, <A HREF=#mgMatrixStackIsIdentity>mgMatrixStackIsIdentity</A>, 
<A HREF=#mgMatrixStackLoadMatrix>mgMatrixStackLoadMatrix</A>, <A HREF=#mgMatrixStackGetMatrix>mgMatrixStackGetMatrix</A>, 
<A HREF=#mgMatrixStackMultiply>mgMatrixStackMultiply</A>, <A HREF=#mgMatrixStackTranslate>mgMatrixStackTranslate</A>, <A HREF=#mgMatrixStackScale>mgMatrixStackScale</A>, 
<A HREF=#mgMatrixStackRotate>mgMatrixStackRotate</A>, <A HREF=#mgMatrixStackRotateX>mgMatrixStackRotateX</A>, 
<A HREF=#mgMatrixStackRotateY>mgMatrixStackRotateY</A>, <A HREF=#mgMatrixStackRotateZ>mgMatrixStackRotateZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixStackPush><H1 CLASS="APISYMBOL">mgMatrixStackPush</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixStackPush</B> - push a matrix stack.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixStackPush</B> (</TD><TD><A HREF=#mgmatrixstack>mgmatrixstack</A></TD><TD><I>matrixStack</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixStackPush</B> pushes the specified matrix stack <I>matrixStack</I>. 
The current top matrix is copied to the new top-of-stack.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrixStack</I></DT><DD>matrix stack to push</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, <A HREF=#mgNewMatrixStack>mgNewMatrixStack</A>, <A HREF=#mgFreeMatrixStack>mgFreeMatrixStack</A>, 
<A HREF=#mgMatrixStackPop>mgMatrixStackPop</A>, 
<A HREF=#mgMatrixStackLoadIdentity>mgMatrixStackLoadIdentity</A>, <A HREF=#mgMatrixStackIsIdentity>mgMatrixStackIsIdentity</A>, 
<A HREF=#mgMatrixStackLoadMatrix>mgMatrixStackLoadMatrix</A>, <A HREF=#mgMatrixStackGetMatrix>mgMatrixStackGetMatrix</A>, 
<A HREF=#mgMatrixStackMultiply>mgMatrixStackMultiply</A>, <A HREF=#mgMatrixStackTranslate>mgMatrixStackTranslate</A>, <A HREF=#mgMatrixStackScale>mgMatrixStackScale</A>, 
<A HREF=#mgMatrixStackRotate>mgMatrixStackRotate</A>, <A HREF=#mgMatrixStackRotateX>mgMatrixStackRotateX</A>, 
<A HREF=#mgMatrixStackRotateY>mgMatrixStackRotateY</A>, <A HREF=#mgMatrixStackRotateZ>mgMatrixStackRotateZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixStackRotate><H1 CLASS="APISYMBOL">mgMatrixStackRotate</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixStackRotate</B> - multiplies a rotation matrix into a 
matrix stack.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixStackRotate</B> (</TD><TD><A HREF=#mgmatrixstack>mgmatrixstack</A></TD><TD><I>matrixStack</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>theta</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>a</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>b</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>c</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixStackRotate</B> calculates a rotation matrix representing the rotation 
of <I>theta</I> degrees about the vector <I>a</I>, <I>b</I>, <I>c</I> and multiplies that matrix 
by the current top-of-stack matrix in the specified matrix stack <I>matrixStack</I>. 
The resulting matrix replaces the top-of-stack matrix in <I>matrixStack</I>.</P></DD><DD><P>The parameter <I>theta</I> specifies the angle (in degrees) to rotate 
counter-clockwise (right hand rule).</P></DD><DD><P>If the top-of-stack matrix is <I>T</I> before this function, 
and the rotation matrix representing the rotation 
of <I>theta</I> degrees about the vector <I>a</I>, <I>b</I>, <I>c</I> is <I>R</I>, the new 
top-of-stack matrix after this function will be the product <I>R</I> X <I>T</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrixStack</I></DT><DD>matrix stack to apply operation</DD><DT><I>theta</I></DT><DD>angle to rotate measured counter-clockwise 
in degrees about vector (right hand rule)</DD><DT><I>a</I></DT><DD>unitized x component of vector</DD><DT><I>b</I></DT><DD>unitized y component of vector</DD><DT><I>c</I></DT><DD>unitized z component of vector</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, <A HREF=#mgNewMatrixStack>mgNewMatrixStack</A>, <A HREF=#mgFreeMatrixStack>mgFreeMatrixStack</A>, 
<A HREF=#mgMatrixStackPush>mgMatrixStackPush</A>, <A HREF=#mgMatrixStackPop>mgMatrixStackPop</A>, 
<A HREF=#mgMatrixStackLoadIdentity>mgMatrixStackLoadIdentity</A>, <A HREF=#mgMatrixStackIsIdentity>mgMatrixStackIsIdentity</A>, 
<A HREF=#mgMatrixStackLoadMatrix>mgMatrixStackLoadMatrix</A>, <A HREF=#mgMatrixStackGetMatrix>mgMatrixStackGetMatrix</A>, 
<A HREF=#mgMatrixStackMultiply>mgMatrixStackMultiply</A>, <A HREF=#mgMatrixStackTranslate>mgMatrixStackTranslate</A>, <A HREF=#mgMatrixStackScale>mgMatrixStackScale</A>, 
<A HREF=#mgMatrixStackRotateX>mgMatrixStackRotateX</A>, 
<A HREF=#mgMatrixStackRotateY>mgMatrixStackRotateY</A>, <A HREF=#mgMatrixStackRotateZ>mgMatrixStackRotateZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixStackRotateX><H1 CLASS="APISYMBOL">mgMatrixStackRotateX</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixStackRotateX</B> - multiplies a rotation matrix into a 
matrix stack.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixStackRotateX</B> (</TD><TD><A HREF=#mgmatrixstack>mgmatrixstack</A></TD><TD><I>matrixStack</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>theta</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixStackRotateX</B> calculates a rotation matrix representing the 
rotation of <I>theta</I> degrees about the X coordinate axis and multiplies that 
matrix by the current top-of-stack matrix in the specified matrix stack 
<I>matrixStack</I>. The resulting matrix replaces the top-of-stack matrix in 
<I>matrixStack</I>.</P></DD><DD><P>The parameter <I>theta</I> specifies the angle (in degrees) to rotate 
counter-clockwise (right hand rule).</P></DD><DD><P>If the top-of-stack matrix is <I>T</I> before this function, 
and the rotation matrix representing the rotation of <I>theta</I> degrees 
about the X coordinate axis is <I>R</I>, the new top-of-stack matrix 
after this function will be the product <I>R</I> X <I>T</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrixStack</I></DT><DD>matrix stack to apply operation</DD><DT><I>theta</I></DT><DD>angle to rotate measured counter-clockwise 
in degrees about vector (right hand rule)</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, <A HREF=#mgNewMatrixStack>mgNewMatrixStack</A>, <A HREF=#mgFreeMatrixStack>mgFreeMatrixStack</A>, 
<A HREF=#mgMatrixStackPush>mgMatrixStackPush</A>, <A HREF=#mgMatrixStackPop>mgMatrixStackPop</A>, 
<A HREF=#mgMatrixStackLoadIdentity>mgMatrixStackLoadIdentity</A>, <A HREF=#mgMatrixStackIsIdentity>mgMatrixStackIsIdentity</A>, 
<A HREF=#mgMatrixStackLoadMatrix>mgMatrixStackLoadMatrix</A>, <A HREF=#mgMatrixStackGetMatrix>mgMatrixStackGetMatrix</A>, 
<A HREF=#mgMatrixStackMultiply>mgMatrixStackMultiply</A>, <A HREF=#mgMatrixStackTranslate>mgMatrixStackTranslate</A>, <A HREF=#mgMatrixStackScale>mgMatrixStackScale</A>, 
<A HREF=#mgMatrixStackRotate>mgMatrixStackRotate</A>, 
<A HREF=#mgMatrixStackRotateY>mgMatrixStackRotateY</A>, <A HREF=#mgMatrixStackRotateZ>mgMatrixStackRotateZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixStackRotateY><H1 CLASS="APISYMBOL">mgMatrixStackRotateY</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixStackRotateY</B> - multiplies a rotation matrix into a 
matrix stack.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixStackRotateY</B> (</TD><TD><A HREF=#mgmatrixstack>mgmatrixstack</A></TD><TD><I>matrixStack</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>theta</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixStackRotateY</B> calculates a rotation matrix representing the 
rotation of <I>theta</I> degrees about the Y coordinate axis and multiplies that 
matrix by the current top-of-stack matrix in the specified matrix stack 
<I>matrixStack</I>. The resulting matrix replaces the top-of-stack matrix in 
<I>matrixStack</I>.</P></DD><DD><P>The parameter <I>theta</I> specifies the angle (in degrees) to rotate 
counter-clockwise (right hand rule).</P></DD><DD><P>If the top-of-stack matrix is <I>T</I> before this function, 
and the rotation matrix representing the rotation of <I>theta</I> degrees 
about the Y coordinate axis is <I>R</I>, the new top-of-stack matrix 
after this function will be the product <I>R</I> X <I>T</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrixStack</I></DT><DD>matrix stack to apply operation</DD><DT><I>theta</I></DT><DD>angle to rotate measured counter-clockwise 
in degrees about vector (right hand rule)</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, <A HREF=#mgNewMatrixStack>mgNewMatrixStack</A>, <A HREF=#mgFreeMatrixStack>mgFreeMatrixStack</A>, 
<A HREF=#mgMatrixStackPush>mgMatrixStackPush</A>, <A HREF=#mgMatrixStackPop>mgMatrixStackPop</A>, 
<A HREF=#mgMatrixStackLoadIdentity>mgMatrixStackLoadIdentity</A>, <A HREF=#mgMatrixStackIsIdentity>mgMatrixStackIsIdentity</A>, 
<A HREF=#mgMatrixStackLoadMatrix>mgMatrixStackLoadMatrix</A>, <A HREF=#mgMatrixStackGetMatrix>mgMatrixStackGetMatrix</A>, 
<A HREF=#mgMatrixStackMultiply>mgMatrixStackMultiply</A>, <A HREF=#mgMatrixStackTranslate>mgMatrixStackTranslate</A>, <A HREF=#mgMatrixStackScale>mgMatrixStackScale</A>, 
<A HREF=#mgMatrixStackRotate>mgMatrixStackRotate</A>, <A HREF=#mgMatrixStackRotateX>mgMatrixStackRotateX</A>, 
<A HREF=#mgMatrixStackRotateZ>mgMatrixStackRotateZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixStackRotateZ><H1 CLASS="APISYMBOL">mgMatrixStackRotateZ</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixStackRotateZ</B> - multiplies a rotation matrix into a 
matrix stack.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixStackRotateZ</B> (</TD><TD><A HREF=#mgmatrixstack>mgmatrixstack</A></TD><TD><I>matrixStack</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>theta</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixStackRotateZ</B> calculates a rotation matrix representing the 
rotation of <I>theta</I> degrees about the Z coordinate axis and multiplies that 
matrix by the current top-of-stack matrix in the specified matrix stack 
<I>matrixStack</I>. The resulting matrix replaces the top-of-stack matrix in 
<I>matrixStack</I>.</P></DD><DD><P>The parameter <I>theta</I> specifies the angle (in degrees) to rotate 
counter-clockwise (right hand rule).</P></DD><DD><P>If the top-of-stack matrix is <I>T</I> before this function, 
and the rotation matrix representing the rotation of <I>theta</I> degrees 
about the Z coordinate axis is <I>R</I>, the new top-of-stack matrix 
after this function will be the product <I>R</I> X <I>T</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrixStack</I></DT><DD>matrix stack to apply operation</DD><DT><I>theta</I></DT><DD>angle to rotate measured counter-clockwise 
in degrees about vector (right hand rule)</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, <A HREF=#mgNewMatrixStack>mgNewMatrixStack</A>, <A HREF=#mgFreeMatrixStack>mgFreeMatrixStack</A>, 
<A HREF=#mgMatrixStackPush>mgMatrixStackPush</A>, <A HREF=#mgMatrixStackPop>mgMatrixStackPop</A>, 
<A HREF=#mgMatrixStackLoadIdentity>mgMatrixStackLoadIdentity</A>, <A HREF=#mgMatrixStackIsIdentity>mgMatrixStackIsIdentity</A>, 
<A HREF=#mgMatrixStackLoadMatrix>mgMatrixStackLoadMatrix</A>, <A HREF=#mgMatrixStackGetMatrix>mgMatrixStackGetMatrix</A>, 
<A HREF=#mgMatrixStackMultiply>mgMatrixStackMultiply</A>, <A HREF=#mgMatrixStackTranslate>mgMatrixStackTranslate</A>, <A HREF=#mgMatrixStackScale>mgMatrixStackScale</A>, 
<A HREF=#mgMatrixStackRotate>mgMatrixStackRotate</A>, <A HREF=#mgMatrixStackRotateX>mgMatrixStackRotateX</A>, 
<A HREF=#mgMatrixStackRotateY>mgMatrixStackRotateY</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixStackScale><H1 CLASS="APISYMBOL">mgMatrixStackScale</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixStackScale</B> - multiplies a scale matrix into a 
matrix stack.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixStackScale</B> (</TD><TD><A HREF=#mgmatrixstack>mgmatrixstack</A></TD><TD><I>matrixStack</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>y</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>z</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixStackScale</B> calculates a scale matrix representing the scale 
factors, <I>x</I>, <I>y</I> and <I>z</I> along the coordinate axes X, Y and Z, respectively, 
and multiplies that matrix by the current top-of-stack matrix in the specified 
matrix stack <I>matrixStack</I>.  The resulting matrix replaces the top-of-stack 
matrix in <I>matrixStack</I>.</P></DD><DD><P>If the top-of-stack matrix is <I>T</I> before this function, 
and the scale matrix representing the scale factors, <I>x</I>, <I>y</I> and <I>z</I> 
along the coordinate axes X, Y and Z, respectively, is <I>S</I>, the new 
top-of-stack matrix after this function will be the product <I>S</I> X <I>T</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrixStack</I></DT><DD>matrix stack to apply operation</DD><DT><I>x</I></DT><DD>scale factor in the X direction</DD><DT><I>y</I></DT><DD>scale factor in the Y direction</DD><DT><I>z</I></DT><DD>scale factor in the Z direction</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, <A HREF=#mgNewMatrixStack>mgNewMatrixStack</A>, <A HREF=#mgFreeMatrixStack>mgFreeMatrixStack</A>, 
<A HREF=#mgMatrixStackPush>mgMatrixStackPush</A>, <A HREF=#mgMatrixStackPop>mgMatrixStackPop</A>, 
<A HREF=#mgMatrixStackLoadIdentity>mgMatrixStackLoadIdentity</A>, <A HREF=#mgMatrixStackIsIdentity>mgMatrixStackIsIdentity</A>, 
<A HREF=#mgMatrixStackLoadMatrix>mgMatrixStackLoadMatrix</A>, <A HREF=#mgMatrixStackGetMatrix>mgMatrixStackGetMatrix</A>, 
<A HREF=#mgMatrixStackMultiply>mgMatrixStackMultiply</A>, <A HREF=#mgMatrixStackTranslate>mgMatrixStackTranslate</A>, 
<A HREF=#mgMatrixStackRotate>mgMatrixStackRotate</A>, <A HREF=#mgMatrixStackRotateX>mgMatrixStackRotateX</A>, 
<A HREF=#mgMatrixStackRotateY>mgMatrixStackRotateY</A>, <A HREF=#mgMatrixStackRotateZ>mgMatrixStackRotateZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixStackTransformCoord><H1 CLASS="APISYMBOL">mgMatrixStackTransformCoord</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixStackTransformCoord</B> - transforms a coordinate using 
the current top-of-stack matrix from a matrix stack.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgMatrixStackTransformCoord</B> (</TD><TD>const <A HREF=#mgmatrixstack>mgmatrixstack</A></TD><TD><I>matrixStack</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixStackTransformCoord</B> applies the top-of-stack matrix in 
the specified matrix stack <I>matrixStack</I> to the specified 3D double 
precision floating point coordinate <I>coord</I> and returns the resulting 
coordinate.</P></DD><DD><P>The original coordinate <I>coord</I> is not affected.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrixStack</I></DT><DD>matrix stack whose top-of-stack matrix 
is to be applied to <I>coord</I></DD><DT><I>coord</I></DT><DD>coordinate to transform</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the transformed double precision 3D coordinate record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgNewMatrixStack>mgNewMatrixStack</A>, <A HREF=#mgFreeMatrixStack>mgFreeMatrixStack</A>, 
<A HREF=#mgMatrixStackPush>mgMatrixStackPush</A>, <A HREF=#mgMatrixStackPop>mgMatrixStackPop</A>, 
<A HREF=#mgMatrixStackLoadIdentity>mgMatrixStackLoadIdentity</A>, <A HREF=#mgMatrixStackIsIdentity>mgMatrixStackIsIdentity</A>, 
<A HREF=#mgMatrixStackLoadMatrix>mgMatrixStackLoadMatrix</A>, <A HREF=#mgMatrixStackGetMatrix>mgMatrixStackGetMatrix</A>, 
<A HREF=#mgMatrixStackMultiply>mgMatrixStackMultiply</A>, <A HREF=#mgMatrixStackScale>mgMatrixStackScale</A>, 
<A HREF=#mgMatrixStackRotate>mgMatrixStackRotate</A>, <A HREF=#mgMatrixStackRotateX>mgMatrixStackRotateX</A>, 
<A HREF=#mgMatrixStackRotateY>mgMatrixStackRotateY</A>, <A HREF=#mgMatrixStackRotateZ>mgMatrixStackRotateZ</A>, 
<A HREF=#mgMatrixStackTransformVector>mgMatrixStackTransformVector</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixStackTransformVector><H1 CLASS="APISYMBOL">mgMatrixStackTransformVector</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixStackTransformVector</B> - transforms a vector using 
the current top-of-stack matrix from a matrix stack.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgvectord <B>mgMatrixStackTransformVector</B> (</TD><TD>const <A HREF=#mgmatrixstack>mgmatrixstack</A></TD><TD><I>matrixStack</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgvectord>mgvectord*</A></TD><TD><I>vec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixStackTransformVector</B> applies the top-of-stack matrix in 
the specified matrix stack <I>matrixStack</I> to the specified double 
precision floating point vector <I>vec</I> and returns the resulting 
vector.</P></DD><DD><P>The original vector <I>vec</I> is not affected.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrixStack</I></DT><DD>matrix stack whose top-of-stack matrix 
is to be applied to <I>vec</I></DD><DT><I>vec</I></DT><DD>address of vector to transform</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the transformed double precision vector record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgNewMatrixStack>mgNewMatrixStack</A>, <A HREF=#mgFreeMatrixStack>mgFreeMatrixStack</A>, 
<A HREF=#mgMatrixStackPush>mgMatrixStackPush</A>, <A HREF=#mgMatrixStackPop>mgMatrixStackPop</A>, 
<A HREF=#mgMatrixStackLoadIdentity>mgMatrixStackLoadIdentity</A>, <A HREF=#mgMatrixStackIsIdentity>mgMatrixStackIsIdentity</A>, 
<A HREF=#mgMatrixStackLoadMatrix>mgMatrixStackLoadMatrix</A>, <A HREF=#mgMatrixStackGetMatrix>mgMatrixStackGetMatrix</A>, 
<A HREF=#mgMatrixStackMultiply>mgMatrixStackMultiply</A>, <A HREF=#mgMatrixStackScale>mgMatrixStackScale</A>, 
<A HREF=#mgMatrixStackRotate>mgMatrixStackRotate</A>, <A HREF=#mgMatrixStackRotateX>mgMatrixStackRotateX</A>, 
<A HREF=#mgMatrixStackRotateY>mgMatrixStackRotateY</A>, <A HREF=#mgMatrixStackRotateZ>mgMatrixStackRotateZ</A>, 
<A HREF=#mgMatrixStackTransformCoord>mgMatrixStackTransformCoord</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixStackTranslate><H1 CLASS="APISYMBOL">mgMatrixStackTranslate</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixStackTranslate</B> - multiplies a translation matrix into a 
matrix stack.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixStackTranslate</B> (</TD><TD><A HREF=#mgmatrixstack>mgmatrixstack</A></TD><TD><I>matrixStack</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>y</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>z</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixStackTranslate</B> calculates a translation matrix representing the 
translations <I>x</I>, <I>y</I> and <I>z</I> along the coordinate axes X, Y and Z, respectively, 
and multiplies that matrix by the current top-of-stack matrix in the specified 
matrix stack <I>matrixStack</I>.  The resulting matrix replaces the top-of-stack 
matrix in <I>matrixStack</I>.</P></DD><DD><P>If the top-of-stack matrix is <I>T</I> before this function, 
and the translation matrix representing the 
translations <I>x</I>, <I>y</I> and <I>z</I> along the coordinate axes X, Y and Z, 
respectively, is <I>D</I>, the new 
top-of-stack matrix after this function will be the product <I>D</I> X <I>T</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrixStack</I></DT><DD>matrix stack to apply operation</DD><DT><I>x</I></DT><DD>translation in the X direction</DD><DT><I>y</I></DT><DD>translation in the Y direction</DD><DT><I>z</I></DT><DD>translation in the Z direction</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, <A HREF=#mgNewMatrixStack>mgNewMatrixStack</A>, <A HREF=#mgFreeMatrixStack>mgFreeMatrixStack</A>, 
<A HREF=#mgMatrixStackPush>mgMatrixStackPush</A>, <A HREF=#mgMatrixStackPop>mgMatrixStackPop</A>, 
<A HREF=#mgMatrixStackLoadIdentity>mgMatrixStackLoadIdentity</A>, <A HREF=#mgMatrixStackIsIdentity>mgMatrixStackIsIdentity</A>, 
<A HREF=#mgMatrixStackLoadMatrix>mgMatrixStackLoadMatrix</A>, <A HREF=#mgMatrixStackGetMatrix>mgMatrixStackGetMatrix</A>, 
<A HREF=#mgMatrixStackMultiply>mgMatrixStackMultiply</A>, <A HREF=#mgMatrixStackScale>mgMatrixStackScale</A>, 
<A HREF=#mgMatrixStackRotate>mgMatrixStackRotate</A>, <A HREF=#mgMatrixStackRotateX>mgMatrixStackRotateX</A>, 
<A HREF=#mgMatrixStackRotateY>mgMatrixStackRotateY</A>, <A HREF=#mgMatrixStackRotateZ>mgMatrixStackRotateZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixTranslate><H1 CLASS="APISYMBOL">mgMatrixTranslate</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixTranslate</B> - multiply a translation matrix into the 
given matrix.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMatrixTranslate</B> (</TD><TD>const <A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>y</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>z</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>resultMatrix</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, mgmatrix <B>mgMatrixTranslate</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>y</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>z</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixTranslate</B> calculates a translation matrix for translating by 
<I>x</I>, <I>y</I> and <I>z</I> and multiplies that matrix into the given matrix <I>matrix</I>.</P></DD><DD><P>Call the translation matrix representing the translations <I>x</I>, <I>y</I> and <I>z</I> 
along the coordinate axes X, Y and Z, respectively, <I>T</I>.  Call the value 
(on input) of <I>matrix</I> <I>M</I>.  The resulting matrix will be the product 
<I>T</I> X <I>M</I>. 
This function operates safely when the input and output matrices 
are the same matrix.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the resulting matrix into the output 
parameter <I>resultMatrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the resulting matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to multiply</DD><DT><I>x</I></DT><DD>translation in the X direction</DD><DT><I>y</I></DT><DD>translation in the Y direction</DD><DT><I>z</I></DT><DD>translation in the Z direction</DD><DT><I>resultMatrix</I></DT><DD>address of matrix to receive result</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful,&#32<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>mgmatrix</DT><DD>the matrix result.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMatrixFormTranslate>mgMatrixFormTranslate</A>, 
<A HREF=#mgMatrixFormScale>mgMatrixFormScale</A>, 
<A HREF=#mgMatrixFormRotate>mgMatrixFormRotate</A>, 
<A HREF=#mgMatrixFormRotateY>mgMatrixFormRotateY</A>, 
<A HREF=#mgMatrixFormRotateZ>mgMatrixFormRotateZ</A>, 
<A HREF=#mgMatrixFormQuadToQuad>mgMatrixFormQuadToQuad</A>, <A HREF=#mgMatrixMultiply>mgMatrixMultiply</A>, 
<A HREF=#mgMatrixRotateX>mgMatrixRotateX</A>, <A HREF=#mgMatrixRotateY>mgMatrixRotateY</A>, <A HREF=#mgMatrixRotateZ>mgMatrixRotateZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixTranspose><H1 CLASS="APISYMBOL">mgMatrixTranspose</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixTranspose</B> - calculates the transpose of a matrix.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgMatrixTranspose</B> (</TD><TD>const <A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>resultMatrix</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgmatrix <B>mgMatrixTranspose</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrix</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixTranspose</B> calculates the transpose of <I>matrix</I>.</P></DD><DD><P>The original matrix <I>matrix</I> is not affected.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>This function writes the transpose matrix into the output 
parameter <I>resultMatrix</I> if successful.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This function returns the transpose matrix if successful.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to transpose</DD><DT><I>resultMatrix</I></DT><DD>address of matrix to receive result</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgmatrix</DT><DD>the matrix inverse.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixYawLeft90><H1 CLASS="APISYMBOL">mgMatrixYawLeft90</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixYawLeft90</B> - yaws a matrix left 90 degrees in global space.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgMatrixYawLeft90</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixYawLeft90</B> yaws <I>matrix</I> left 90 degrees in global space.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to transform</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgMatrixFormYawLeft90>mgMatrixFormYawLeft90</A>, 
<A HREF=#mgMatrixFormYawRight90>mgMatrixFormYawRight90</A>, <A HREF=#mgMatrixYawRight90>mgMatrixYawRight90</A>, 
<A HREF=#mgMatrixFormReflectZ>mgMatrixFormReflectZ</A>, <A HREF=#mgMatrixReflectZ>mgMatrixReflectZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgMatrixYawRight90><H1 CLASS="APISYMBOL">mgMatrixYawRight90</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMatrixYawRight90</B> - yaws a matrix right 90 degrees in global space.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgMatrixYawRight90</B> (</TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMatrixYawRight90</B> yaws <I>matrix</I> right 90 degrees in global space.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to transform</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgMatrixFormYawLeft90>mgMatrixFormYawLeft90</A>, <A HREF=#mgMatrixYawLeft90>mgMatrixYawLeft90</A>, 
<A HREF=#mgMatrixFormYawRight90>mgMatrixFormYawRight90</A>, 
<A HREF=#mgMatrixFormReflectZ>mgMatrixFormReflectZ</A>, <A HREF=#mgMatrixReflectZ>mgMatrixReflectZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgMenuGetState><H1 CLASS="APISYMBOL">mgMenuGetState</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMenuGetState</B> - retrieves the state of a menu item control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgMenuGetState</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMenuGetState</B> retrieves the selection state of the specified 
menu item <I>control</I>.</P></DD><DD><P>In two state menu item controls, 1 indicates that the control is selected 
(or checked), and 0 indicates that it is not.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the menu item control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns 1 if the control is selected, 0 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><B>mgMenuGetState</B>, <A HREF=#mgSetEnabled>mgSetEnabled</A>, <A HREF=#mgIsEnabled>mgIsEnabled</A></DD></DL>
<HR>
<LEFT><A NAME=mgMenuSetState><H1 CLASS="APISYMBOL">mgMenuSetState</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMenuSetState</B> - sets the state of a menu item control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgMenuSetState</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>state</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMenuSetState</B> sets the selection state of the specified 
menu item <I>control</I>.</P></DD><DD><P>In two state menu item controls, 1 indicates that the control 
is selected (or checked), and 0 indicates that it is not.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the menu item control</DD><DT><I>state</I></DT><DD>the state of the control (1 is checked, 0 is not checked)</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMenuGetState>mgMenuGetState</A>, <A HREF=#mgSetEnabled>mgSetEnabled</A>, <A HREF=#mgIsEnabled>mgIsEnabled</A></DD></DL>
<HR>
<LEFT><A NAME=mgMeshCreatePrimitives><H1 CLASS="APISYMBOL">mgMeshCreatePrimitives</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMeshCreatePrimitives</B> - creates the mesh primitives 
for a mesh.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMeshCreatePrimitives</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>num</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This function allocates <I>num</I> mesh primitives and attaches 
them to mesh <I>rec</I>.  After you allocate primitives for a mesh using 
this function you can assign their types with <A HREF=#mgMeshPrimitiveSetType>mgMeshPrimitiveSetType</A> 
and their vertex index arrays with <A HREF=#mgMeshPrimitiveSetVtxIndexArray>mgMeshPrimitiveSetVtxIndexArray</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 node</DD><DT><I>num</I></DT><DD>the number of primitives to create</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the mesh primitives were 
created and attached successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>rec</I> is not a valid mesh node.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshCreateVtxPool>mgMeshCreateVtxPool</A>, <A HREF=#mgMeshPrimitiveSetType>mgMeshPrimitiveSetType</A>, 
<A HREF=#mgMeshPrimitiveSetVtxIndexArray>mgMeshPrimitiveSetVtxIndexArray</A></DD></DL>
<HR>
<LEFT><A NAME=mgMeshCreateVtxPool><H1 CLASS="APISYMBOL">mgMeshCreateVtxPool</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMeshCreateVtxPool</B> - creates the vertex pool for a mesh.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void* <B>mgMeshCreateVtxPool</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>mask</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>num</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This function allocates and attaches a vertex pool to mesh <I>rec</I>. 
The size of the vertex pool allocated is determined by <I>num</I> and <I>mask</I>. 
The value of <I>num</I> specifies how many vertices to allocate.  The value of 
<I>mask</I> is a bitwise combination of Mesh Vertex Mask Bits specifying what 
kind of data to allocate for each vertex in the pool.</P></DD><DD><P>The following describes each of the Mesh Vertex Mask Bits 
that you can combine in <I>mask</I>:</P></DD><DD><P><A HREF=#MMESH_VTXCOORD>MMESH_VTXCOORD</A> - Include this bit if the vertices in 
the vertex pool have coordinate positions (x,y,z).  Use function 
<A HREF=#mgMeshSetVtxCoord>mgMeshSetVtxCoord</A> to set the coordinate position of a vertex 
in the vertex pool.</P></DD><DD><P><A HREF=#MMESH_VTXCOLOR>MMESH_VTXCOLOR</A> - Include this bit if the vertices in the 
vertex pool have colors represented by a color index and intensity. 
Use function <A HREF=#mgMeshSetVtxColor>mgMeshSetVtxColor</A> to set the color index and 
intensity of a vertex in the vertex pool.</P></DD><DD><P><A HREF=#MMESH_VTXCOLORRGB>MMESH_VTXCOLORRGB</A> - Include this bit if the vertices in 
the vertex pool have colors represented by RGB values.  Use function 
<A HREF=#mgMeshSetVtxColorRGB>mgMeshSetVtxColorRGB</A> to set the RGB colors of a vertex in the 
vertex pool.</P></DD><DD><P><A HREF=#MMESH_VTXNORMAL>MMESH_VTXNORMAL</A> - Include this bit if the vertices in 
the vertex pool have normals (i,j,k).  Use function 
<A HREF=#mgMeshSetVtxNormal>mgMeshSetVtxNormal</A> to set the normal of a vertex in the 
vertex pool.</P></DD><DD><P><A HREF=#MMESH_VTXUV0>MMESH_VTXUV0</A> - Include this bit if the vertices in 
the vertex pool have texture coordinates (u,v) for layer 0. 
Use function <A HREF=#mgMeshSetVtxUV>mgMeshSetVtxUV</A> to set the texture coordinates 
of a vertex in the vertex pool.</P></DD><DD><P><A HREF=#MMESH_VTXUV1>MMESH_VTXUV1</A> - Include this bit if the vertices in 
the vertex pool have texture coordinates (u,v) for layer 1. 
Use function <A HREF=#mgMeshSetVtxUV>mgMeshSetVtxUV</A> to set the texture coordinates 
of a vertex in the vertex pool.</P></DD><DD><P><A HREF=#MMESH_VTXUV2>MMESH_VTXUV2</A> - Include this bit if the vertices in 
the vertex pool have texture coordinates (u,v) for layer 2. 
Use function <A HREF=#mgMeshSetVtxUV>mgMeshSetVtxUV</A> to set the texture coordinates 
of a vertex in the vertex pool.</P></DD><DD><P><A HREF=#MMESH_VTXUV3>MMESH_VTXUV3</A> - Include this bit if the vertices in 
the vertex pool have texture coordinates (u,v) for layer 3. 
Use function <A HREF=#mgMeshSetVtxUV>mgMeshSetVtxUV</A> to set the texture coordinates 
of a vertex in the vertex pool.</P></DD><DD><P><A HREF=#MMESH_VTXUV4>MMESH_VTXUV4</A> - Include this bit if the vertices in 
the vertex pool have texture coordinates (u,v) for layer 4. 
Use function <A HREF=#mgMeshSetVtxUV>mgMeshSetVtxUV</A> to set the texture coordinates 
of a vertex in the vertex pool.</P></DD><DD><P><A HREF=#MMESH_VTXUV5>MMESH_VTXUV5</A> - Include this bit if the vertices in 
the vertex pool have texture coordinates (u,v) for layer 5. 
Use function <A HREF=#mgMeshSetVtxUV>mgMeshSetVtxUV</A> to set the texture coordinates 
of a vertex in the vertex pool.</P></DD><DD><P><A HREF=#MMESH_VTXUV6>MMESH_VTXUV6</A> - Include this bit if the vertices in 
the vertex pool have texture coordinates (u,v) for layer 6. 
Use function <A HREF=#mgMeshSetVtxUV>mgMeshSetVtxUV</A> to set the texture coordinates 
of a vertex in the vertex pool.</P></DD><DD><P><A HREF=#MMESH_VTXUV7>MMESH_VTXUV7</A> - Include this bit if the vertices in 
the vertex pool have texture coordinates (u,v) for layer 7. 
Use function <A HREF=#mgMeshSetVtxUV>mgMeshSetVtxUV</A> to set the texture coordinates 
of a vertex in the vertex pool.</P></DD><DD><P>After you allocate a mesh vertex pool using this function 
you can assign values for each the vertices in the pool using 
the functions <A HREF=#mgMeshSetVtxCoord>mgMeshSetVtxCoord</A>, <A HREF=#mgMeshSetVtxColor>mgMeshSetVtxColor</A>, 
<A HREF=#mgMeshSetVtxColorRGB>mgMeshSetVtxColorRGB</A>, <A HREF=#mgMeshSetVtxNormal>mgMeshSetVtxNormal</A>, and 
<A HREF=#mgMeshSetVtxUV>mgMeshSetVtxUV</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 node</DD><DT><I>mask</I></DT><DD>specifies what kind of data each vertex has</DD><DT><I>num</I></DT><DD>the number of vertices to create</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the vertex pool allocated if successful, 
<A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>rec</I> is not a valid mesh node.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshCreatePrimitives>mgMeshCreatePrimitives</A>, <A HREF=#mgMeshPrimitiveSetType>mgMeshPrimitiveSetType</A>, 
<A HREF=#mgMeshPrimitiveSetVtxIndexArray>mgMeshPrimitiveSetVtxIndexArray</A>, 
<A HREF=#mgMeshSetVtxCoord>mgMeshSetVtxCoord</A>, <A HREF=#mgMeshSetVtxColor>mgMeshSetVtxColor</A>, 
<A HREF=#mgMeshSetVtxColorRGBA>mgMeshSetVtxColorRGBA</A>, <A HREF=#mgMeshSetVtxColorRGB>mgMeshSetVtxColorRGB</A>, 
<A HREF=#mgMeshSetVtxColorAlpha>mgMeshSetVtxColorAlpha</A>, <A HREF=#mgMeshSetVtxNormal>mgMeshSetVtxNormal</A>, <A HREF=#mgMeshSetVtxUV>mgMeshSetVtxUV</A></DD></DL>
<HR>
<LEFT><A NAME=mgMeshGetVtxColor><H1 CLASS="APISYMBOL">mgMeshGetVtxColor</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMeshGetVtxColor</B> - retrieves the color index and 
intensity values for a vertex in a mesh.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMeshGetVtxColor</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>vtxIndex</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>intensity</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, index, intensity <B>mgMeshGetVtxColor</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>vtxIndex</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This function retrieves the color <I>index</I> and <I>intensity</I> 
values of the vertex at index <I>vtxIndex</I> in the vertex pool of mesh 
node <I>rec</I>.</P></DD><DD><P>You do not have to provide addresses for both <I>index</I> and <I>intensity</I> values. 
For example, if you only want to receive the index (but not intensity), specify a valid 
address for <I>index</I> and leave <I>intensity</I> NULL.</P></DD><DD><P>Note: The first vertex in the mesh vertex pool is at index 0.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 node</DD><DT><I>vtxIndex</I></DT><DD>the vertex number in the mesh starting at 0</DD><DT><I>index</I></DT><DD>address of value to receive color index</DD><DT><I>intensity</I></DT><DD>address of value to receive intensity</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the vertex data was retrieved 
successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.  This function will fail 
if <I>rec</I> is not a valid mesh node, if the vertex at <I>vtxIndex</I> 
does not exist in the mesh, or if the vertices in the mesh do not 
color values.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved color index, otherwise 
index is undefined.</DD><DT>intensity</DT><DD>If function is successful, intensity contains the retrieved color intensity, otherwise 
intensity is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshPrimitiveGetNumVtx>mgMeshPrimitiveGetNumVtx</A>, 
<A HREF=#mgMeshPrimitiveGetVtxIndexArray>mgMeshPrimitiveGetVtxIndexArray</A>, 
<A HREF=#mgMeshGetVtxCoord>mgMeshGetVtxCoord</A>, 
<A HREF=#mgMeshGetVtxColorRGBA>mgMeshGetVtxColorRGBA</A>, <A HREF=#mgMeshGetVtxColorRGB>mgMeshGetVtxColorRGB</A>, <A HREF=#mgMeshGetVtxColorAlpha>mgMeshGetVtxColorAlpha</A>, 
<A HREF=#mgMeshGetVtxNormal>mgMeshGetVtxNormal</A>, <A HREF=#mgMeshGetVtxUV>mgMeshGetVtxUV</A>, <A HREF=#mgMeshSetVtxColor>mgMeshSetVtxColor</A></DD></DL>
<HR>
<LEFT><A NAME=mgMeshGetVtxColorAlpha><H1 CLASS="APISYMBOL">mgMeshGetVtxColorAlpha</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMeshGetVtxColorAlpha</B> - retrieves the Alpha color value 
for a vertex in a mesh.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMeshGetVtxColorAlpha</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>vtxIndex</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>alpha</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, alpha <B>mgMeshGetVtxColorAlpha</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>vtxIndex</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This function retrieves the alpha <I>alpha</I> color value of the 
vertex at index <I>vtxIndex</I> in the vertex pool of mesh node <I>rec</I>.</P></DD><DD><P>Note: The first vertex in the mesh vertex pool is at index 0.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 node</DD><DT><I>vtxIndex</I></DT><DD>the vertex number in the mesh starting at 0</DD><DT><I>alpha</I></DT><DD>address of value to receive alpha component</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the vertex data was retrieved 
successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.  This function will fail 
if <I>rec</I> is not a valid mesh node, if the vertex at <I>vtxIndex</I> 
does not exist in the mesh, or if the vertices in the mesh do not 
color values.</DD><DT>alpha</DT><DD>If function is successful, alpha contains the retrieved color alpha, otherwise 
alpha is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshPrimitiveGetNumVtx>mgMeshPrimitiveGetNumVtx</A>, 
<A HREF=#mgMeshPrimitiveGetVtxIndexArray>mgMeshPrimitiveGetVtxIndexArray</A>, 
<A HREF=#mgMeshGetVtxCoord>mgMeshGetVtxCoord</A>, <A HREF=#mgMeshGetVtxColor>mgMeshGetVtxColor</A>, 
<A HREF=#mgMeshGetVtxColorRGBA>mgMeshGetVtxColorRGBA</A>, <A HREF=#mgMeshSetVtxColorRGB>mgMeshSetVtxColorRGB</A>, 
<A HREF=#mgMeshGetVtxNormal>mgMeshGetVtxNormal</A>, <A HREF=#mgMeshGetVtxUV>mgMeshGetVtxUV</A>, 
<A HREF=#mgMeshSetVtxColorRGBA>mgMeshSetVtxColorRGBA</A>, <A HREF=#mgMeshSetVtxColorRGB>mgMeshSetVtxColorRGB</A>, <A HREF=#mgMeshSetVtxColorAlpha>mgMeshSetVtxColorAlpha</A></DD></DL>
<HR>
<LEFT><A NAME=mgMeshGetVtxColorRGB><H1 CLASS="APISYMBOL">mgMeshGetVtxColorRGB</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMeshGetVtxColorRGB</B> - retrieves the RGB color values 
for a vertex in a mesh.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMeshGetVtxColorRGB</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>vtxIndex</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>red</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>green</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>blue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, red, green, blue <B>mgMeshGetVtxColorRGB</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>vtxIndex</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This function retrieves the <I>red</I>, <I>green</I>, and <I>blue</I> 
color values of the vertex at index <I>vtxIndex</I> in the vertex pool of 
mesh node <I>rec</I>.</P></DD><DD><P>Note: The first vertex in the mesh vertex pool is at index 0.  The color values 
returned are in the range 0..255.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 node</DD><DT><I>vtxIndex</I></DT><DD>the vertex number in the mesh starting at 0</DD><DT><I>red</I></DT><DD>address of value to receive red component</DD><DT><I>green</I></DT><DD>address of value to receive green component</DD><DT><I>blue</I></DT><DD>address of value to receive blue component</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the vertex data was retrieved 
successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.  This function will fail 
if <I>rec</I> is not a valid mesh node, if the vertex at <I>vtxIndex</I> 
does not exist in the mesh, or if the vertices in the mesh do not 
color values.</DD><DT>red</DT><DD>If function is successful, red contains the retrieved red component, otherwise 
red is undefined.</DD><DT>green</DT><DD>If function is successful, green contains the retrieved green component, otherwise 
green is undefined.</DD><DT>blue</DT><DD>If function is successful, blue contains the retrieved blue component, otherwise 
blue is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshPrimitiveGetNumVtx>mgMeshPrimitiveGetNumVtx</A>, 
<A HREF=#mgMeshPrimitiveGetVtxIndexArray>mgMeshPrimitiveGetVtxIndexArray</A>, 
<A HREF=#mgMeshGetVtxCoord>mgMeshGetVtxCoord</A>, <A HREF=#mgMeshGetVtxColor>mgMeshGetVtxColor</A>, 
<A HREF=#mgMeshGetVtxColorRGBA>mgMeshGetVtxColorRGBA</A>, <A HREF=#mgMeshGetVtxColorAlpha>mgMeshGetVtxColorAlpha</A>, 
<A HREF=#mgMeshGetVtxNormal>mgMeshGetVtxNormal</A>, <A HREF=#mgMeshGetVtxUV>mgMeshGetVtxUV</A>, 
<A HREF=#mgMeshSetVtxColorRGBA>mgMeshSetVtxColorRGBA</A>, <A HREF=#mgMeshSetVtxColorRGB>mgMeshSetVtxColorRGB</A>, <A HREF=#mgMeshSetVtxColorAlpha>mgMeshSetVtxColorAlpha</A></DD></DL>
<HR>
<LEFT><A NAME=mgMeshGetVtxColorRGBA><H1 CLASS="APISYMBOL">mgMeshGetVtxColorRGBA</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMeshGetVtxColorRGBA</B> - retrieves the RGBA color values 
for a vertex in a mesh.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMeshGetVtxColorRGBA</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>vtxIndex</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>red</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>green</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>blue</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>alpha</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, red, green, blue, alpha <B>mgMeshGetVtxColorRGBA</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>vtxIndex</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This function retrieves the <I>red</I>, <I>green</I>, <I>blue</I>, and 
<I>alpha</I> color values of the vertex at index <I>vtxIndex</I> in the vertex 
pool of mesh node  <I>rec</I>.</P></DD><DD><P>Note: The first vertex in the mesh vertex pool is at index 0.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 node</DD><DT><I>vtxIndex</I></DT><DD>the vertex number in the mesh starting at 0</DD><DT><I>red</I></DT><DD>address of value to receive red component</DD><DT><I>green</I></DT><DD>address of value to receive green component</DD><DT><I>blue</I></DT><DD>address of value to receive blue component</DD><DT><I>alpha</I></DT><DD>address of value to receive alpha component</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the vertex data was retrieved 
successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.  This function will fail 
if <I>rec</I> is not a valid mesh node, if the vertex at <I>vtxIndex</I> 
does not exist in the mesh, or if the vertices in the mesh do not 
color values.</DD><DT>red</DT><DD>If function is successful, red contains the retrieved red component, otherwise 
red is undefined.</DD><DT>green</DT><DD>If function is successful, green contains the retrieved green component, otherwise 
green is undefined.</DD><DT>blue</DT><DD>If function is successful, blue contains the retrieved blue component, otherwise 
blue is undefined.</DD><DT>alpha</DT><DD>If function is successful, alpha contains the retrieved alpha component, otherwise 
alpha is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshPrimitiveGetNumVtx>mgMeshPrimitiveGetNumVtx</A>, 
<A HREF=#mgMeshPrimitiveGetVtxIndexArray>mgMeshPrimitiveGetVtxIndexArray</A>, 
<A HREF=#mgMeshGetVtxCoord>mgMeshGetVtxCoord</A>, <A HREF=#mgMeshGetVtxColor>mgMeshGetVtxColor</A>, 
<A HREF=#mgMeshGetVtxNormal>mgMeshGetVtxNormal</A>, <A HREF=#mgMeshGetVtxUV>mgMeshGetVtxUV</A>, 
<A HREF=#mgMeshGetVtxColorRGB>mgMeshGetVtxColorRGB</A>, <A HREF=#mgMeshGetVtxColorAlpha>mgMeshGetVtxColorAlpha</A>, 
<A HREF=#mgMeshSetVtxColorRGBA>mgMeshSetVtxColorRGBA</A>, <A HREF=#mgMeshSetVtxColorRGB>mgMeshSetVtxColorRGB</A>, <A HREF=#mgMeshSetVtxColorAlpha>mgMeshSetVtxColorAlpha</A></DD></DL>
<HR>
<LEFT><A NAME=mgMeshGetVtxCoord><H1 CLASS="APISYMBOL">mgMeshGetVtxCoord</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMeshGetVtxCoord</B> - retrieves the x,y,z coordinate for 
a vertex in a mesh.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMeshGetVtxCoord</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>vtxIndex</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>y</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>z</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, x, y, z <B>mgMeshGetVtxCoord</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>vtxIndex</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This function retrieves the <I>x</I>, <I>y</I>, and <I>z</I> values of the 
vertex at index <I>vtxIndex</I> in the vertex pool of mesh node <I>rec</I>.</P></DD><DD><P>You do not have to provide addresses for all <I>x</I>, <I>y</I>, and <I>z</I> values.  For 
example, if you only want to receive the x and y components (but not z), specify valid 
addresses for <I>x</I> and <I>y</I> and leave <I>z</I> NULL.</P></DD><DD><P>Note: The first vertex in the mesh vertex pool is at index 0.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 node</DD><DT><I>vtxIndex</I></DT><DD>the vertex number in the mesh starting at 0</DD><DT><I>x</I></DT><DD>address of value to receive x component</DD><DT><I>y</I></DT><DD>address of value to receive y component</DD><DT><I>z</I></DT><DD>address of value to receive z component</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the vertex data was retrieved 
successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.  This function will fail 
if <I>rec</I> is not a valid mesh node, if the vertex at <I>vtxIndex</I> 
does not exist in the mesh, or if the vertices in the mesh do not 
color values.</DD><DT>x</DT><DD>If function is successful, x contains the retrieved x component, otherwise 
x is undefined.</DD><DT>y</DT><DD>If function is successful, y contains the retrieved y component, otherwise 
y is undefined.</DD><DT>z</DT><DD>If function is successful, z contains the retrieved z component, otherwise 
z is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshPrimitiveGetNumVtx>mgMeshPrimitiveGetNumVtx</A>, 
<A HREF=#mgMeshPrimitiveGetVtxIndexArray>mgMeshPrimitiveGetVtxIndexArray</A>, 
<A HREF=#mgMeshGetVtxColor>mgMeshGetVtxColor</A>, 
<A HREF=#mgMeshGetVtxColorRGBA>mgMeshGetVtxColorRGBA</A>, <A HREF=#mgMeshGetVtxColorRGB>mgMeshGetVtxColorRGB</A>, <A HREF=#mgMeshGetVtxColorAlpha>mgMeshGetVtxColorAlpha</A>, 
<A HREF=#mgMeshGetVtxNormal>mgMeshGetVtxNormal</A>, <A HREF=#mgMeshGetVtxUV>mgMeshGetVtxUV</A>, <A HREF=#mgMeshSetVtxCoord>mgMeshSetVtxCoord</A></DD></DL>
<HR>
<LEFT><A NAME=mgMeshGetVtxMask><H1 CLASS="APISYMBOL">mgMeshGetVtxMask</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMeshGetVtxMask</B> - gets the vertex mask for a mesh.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>unsigned int <B>mgMeshGetVtxMask</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This function retrieves the vertex mask for mesh <I>rec</I>.  The 
vertex mask of a mesh is a bitwise combination of Mesh Vertex Mask Bits 
specifying what kind of data is defined for the vertices in the mesh.</P></DD><DD><P>Mesh Vertex Mask Bits include:<BR> 
<A HREF=#MMESH_VTXCOORD>MMESH_VTXCOORD</A><BR> 
<A HREF=#MMESH_VTXCOLOR>MMESH_VTXCOLOR</A><BR> 
<A HREF=#MMESH_VTXCOLORRGB>MMESH_VTXCOLORRGB</A><BR> 
<A HREF=#MMESH_VTXNORMAL>MMESH_VTXNORMAL</A><BR> 
<A HREF=#MMESH_VTXUV0>MMESH_VTXUV0</A><BR> 
<A HREF=#MMESH_VTXUV1>MMESH_VTXUV1</A><BR> 
<A HREF=#MMESH_VTXUV2>MMESH_VTXUV2</A><BR> 
<A HREF=#MMESH_VTXUV3>MMESH_VTXUV3</A><BR> 
<A HREF=#MMESH_VTXUV4>MMESH_VTXUV4</A><BR> 
<A HREF=#MMESH_VTXUV5>MMESH_VTXUV5</A><BR> 
<A HREF=#MMESH_VTXUV6>MMESH_VTXUV6</A><BR> 
<A HREF=#MMESH_VTXUV7>MMESH_VTXUV7</A></P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 node</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the vertex mask of mesh <I>rec</I> if successful, 
0 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshGetVtxPool>mgMeshGetVtxPool</A>, <A HREF=#mgMeshGetVtxStride>mgMeshGetVtxStride</A>, <A HREF=#mgMeshGetVtxOffset>mgMeshGetVtxOffset</A>, 
<A HREF=#mgMeshGetVtxCoord>mgMeshGetVtxCoord</A>, <A HREF=#mgMeshGetVtxColor>mgMeshGetVtxColor</A>, 
<A HREF=#mgMeshGetVtxColorRGBA>mgMeshGetVtxColorRGBA</A>, <A HREF=#mgMeshGetVtxColorRGB>mgMeshGetVtxColorRGB</A>, <A HREF=#mgMeshGetVtxColorAlpha>mgMeshGetVtxColorAlpha</A>, 
<A HREF=#mgMeshGetVtxNormal>mgMeshGetVtxNormal</A>, <A HREF=#mgMeshGetVtxUV>mgMeshGetVtxUV</A>, <A HREF=#mgMeshSetVtxMask>mgMeshSetVtxMask</A></DD></DL>
<HR>
<LEFT><A NAME=mgMeshGetVtxNormal><H1 CLASS="APISYMBOL">mgMeshGetVtxNormal</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMeshGetVtxNormal</B> - retrieves the normal vector for 
a vertex in a mesh.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMeshGetVtxNormal</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>vtxIndex</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>i</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>j</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>k</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, i, j, k <B>mgMeshGetVtxNormal</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>vtxIndex</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This function retrieves the <I>i</I>, <I>j</I>, and <I>k</I> values of the 
normal vector of the vertex at index <I>vtxIndex</I> in the vertex pool of 
mesh node <I>rec</I>.</P></DD><DD><P>You do not have to provide addresses for all <I>i</I>, <I>j</I>, and <I>k</I> values.  For 
example, if you only want to receive the i and j components (but not k), specify valid 
addresses for <I>i</I> and <I>j</I> and leave <I>k</I> NULL.</P></DD><DD><P>Note: The first vertex in the mesh vertex pool is at index 0.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 node</DD><DT><I>vtxIndex</I></DT><DD>the vertex number in the mesh starting at 0</DD><DT><I>i</I></DT><DD>address of value to receive i component of normal vector</DD><DT><I>j</I></DT><DD>address of value to receive j component of normal vector</DD><DT><I>k</I></DT><DD>address of value to receive k component of normal vector</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the vertex data was retrieved 
successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.  This function will fail 
if <I>rec</I> is not a valid mesh node, if the vertex at <I>vtxIndex</I> 
does not exist in the mesh, or if the vertices in the mesh do not 
color values.</DD><DT>i</DT><DD>If function is successful, i contains the retrieved i coordinate, otherwise 
i is undefined.</DD><DT>j</DT><DD>If function is successful, j contains the retrieved j coordinate, otherwise 
j is undefined.</DD><DT>k</DT><DD>If function is successful, k contains the retrieved k coordinate, otherwise 
k is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshPrimitiveGetNumVtx>mgMeshPrimitiveGetNumVtx</A>, 
<A HREF=#mgMeshPrimitiveGetVtxIndexArray>mgMeshPrimitiveGetVtxIndexArray</A>, 
<A HREF=#mgMeshGetVtxCoord>mgMeshGetVtxCoord</A>, <A HREF=#mgMeshGetVtxColor>mgMeshGetVtxColor</A>, 
<A HREF=#mgMeshGetVtxColorRGBA>mgMeshGetVtxColorRGBA</A>, <A HREF=#mgMeshGetVtxColorRGB>mgMeshGetVtxColorRGB</A>, <A HREF=#mgMeshGetVtxColorAlpha>mgMeshGetVtxColorAlpha</A>, 
<A HREF=#mgMeshGetVtxUV>mgMeshGetVtxUV</A>, <A HREF=#mgMeshSetVtxNormal>mgMeshSetVtxNormal</A></DD></DL>
<HR>
<LEFT><A NAME=mgMeshGetVtxOffset><H1 CLASS="APISYMBOL">mgMeshGetVtxOffset</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMeshGetVtxOffset</B> - gets the offset for vertex data 
in a mesh.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgMeshGetVtxOffset</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>bit</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This function retrieves the offset for the vertex data 
specified by mesh vertex mask bit <I>bit</I> in the vertex pool 
of mesh <I>rec</I>.</P></DD><DD><P>The vertex data offset for a particular kind of data within 
the mesh vertex pool indicates the number of bytes from the start 
of the vertex pool to the first byte of the data in the first 
vertex.</P></DD><DD><P>Use a single Mesh Vertex Mask Bit for <I>bit</I> to specify 
which data you want the offset for:<BR> 
<A HREF=#MMESH_VTXCOORD>MMESH_VTXCOORD</A>,<BR> 
<A HREF=#MMESH_VTXCOLOR>MMESH_VTXCOLOR</A>,<BR> 
<A HREF=#MMESH_VTXCOLORRGB>MMESH_VTXCOLORRGB</A>,<BR> 
<A HREF=#MMESH_VTXNORMAL>MMESH_VTXNORMAL</A>,<BR> 
<A HREF=#MMESH_VTXUV0>MMESH_VTXUV0</A>,<BR> 
<A HREF=#MMESH_VTXUV1>MMESH_VTXUV1</A>,<BR> 
<A HREF=#MMESH_VTXUV2>MMESH_VTXUV2</A>,<BR> 
<A HREF=#MMESH_VTXUV3>MMESH_VTXUV3</A>,<BR> 
<A HREF=#MMESH_VTXUV4>MMESH_VTXUV4</A>,<BR> 
<A HREF=#MMESH_VTXUV5>MMESH_VTXUV5</A>,<BR> 
<A HREF=#MMESH_VTXUV6>MMESH_VTXUV6</A>, or <BR> 
<A HREF=#MMESH_VTXUV7>MMESH_VTXUV7</A></P></DD><DD><P>You can use the values returned by this function together 
with the vertex stride returned by <A HREF=#mgMeshGetVtxStride>mgMeshGetVtxStride</A> to 
extract data from the mesh vertex pool.  Note: This is not the 
recommended technique for extracting data from the mesh vertex 
pool.  Instead, it is much simpler to use the functions 
<A HREF=#mgMeshGetVtxCoord>mgMeshGetVtxCoord</A>, <A HREF=#mgMeshGetVtxColor>mgMeshGetVtxColor</A>, 
<A HREF=#mgMeshGetVtxColorRGBA>mgMeshGetVtxColorRGBA</A>, <A HREF=#mgMeshGetVtxColorRGB>mgMeshGetVtxColorRGB</A>, <A HREF=#mgMeshGetVtxColorAlpha>mgMeshGetVtxColorAlpha</A>, 
<A HREF=#mgMeshGetVtxNormal>mgMeshGetVtxNormal</A> and <A HREF=#mgMeshGetVtxUV>mgMeshGetVtxUV</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 node</DD><DT><I>bit</I></DT><DD>the mesh vertex mask bit specifying 
the data to get offset for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the offset for the specified data in the 
vertex pool of mesh <I>rec</I> if successful, -1 otherwise. 
This function will fail if <I>rec</I> is not a valid mesh node 
or if the vertices in the mesh do not have the data specified 
by <I>bit</I>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshGetVtxPool>mgMeshGetVtxPool</A>, <A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshGetVtxStride>mgMeshGetVtxStride</A>, 
<A HREF=#mgMeshGetVtxCoord>mgMeshGetVtxCoord</A>, <A HREF=#mgMeshGetVtxColor>mgMeshGetVtxColor</A>, 
<A HREF=#mgMeshGetVtxColorRGBA>mgMeshGetVtxColorRGBA</A>, <A HREF=#mgMeshGetVtxColorRGB>mgMeshGetVtxColorRGB</A>, <A HREF=#mgMeshGetVtxColorAlpha>mgMeshGetVtxColorAlpha</A>, 
<A HREF=#mgMeshGetVtxNormal>mgMeshGetVtxNormal</A>, <A HREF=#mgMeshGetVtxUV>mgMeshGetVtxUV</A></DD></DL>
<HR>
<LEFT><A NAME=mgMeshGetVtxPool><H1 CLASS="APISYMBOL">mgMeshGetVtxPool</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMeshGetVtxPool</B> - gets the vertex pool for a mesh.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void* <B>mgMeshGetVtxPool</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This function retrieves the vertex pool for mesh <I>rec</I>.</P></DD><DD><P>The vertex pool is a packed sequence of values representing the 
vertex data for a mesh.  The values packed in the vertex pool represent 
vertex coordinates (x,y,z), vertex colors (index/intensity or RGB), vertex 
normals (i,j,k) and vertex texture coordinates (u,v).</P></DD><DD><P>How the vertex data is packed in the vertex pool is dependent on 
the vertex mask of the mesh.  This mask, returned by <A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, 
indicates what kind of data is packed in the&#32vertex pool.</P></DD><DD><P>The following defines the format of the packed data corresponding 
to each Mesh Vertex Mask Bit:</P></DD><DD><P><A HREF=#MMESH_VTXCOORD>MMESH_VTXCOORD</A> - 3 8-byte double precision floating point 
values (24 bytes total) representing the coordinate position 
of the vertex.  The x position is first, then y followed by z.</P></DD><DD><P><A HREF=#MMESH_VTXCOLOR>MMESH_VTXCOLOR</A> - 1 4-byte integer value representing the 
color index (integer) and intensity (single precision floating point) 
of the vertex.  The color index and intensity of the vertex is encoded 
in this integer value N as follows.  The color index is the result of 
the ((N & 0x00ffffff-768)/128.  This will be an integer 
value in the range 0..1023.  The intensity is the result of the 
floating point operation (N mod 128)/127.0f.  This will be a 
floating point number in the range 0.0f..1.0f.</P></DD><DD><P><A HREF=#MMESH_VTXCOLORRGB>MMESH_VTXCOLORRGB</A> - 3 1-byte unsigned integer values (4 bytes total 
including 1 byte padding) representing the RGB color of the vertex. 
The red component is first, then green followed by blue.</P></DD><DD><P><A HREF=#MMESH_VTXNORMAL>MMESH_VTXNORMAL</A> - 3 4-byte single precision floating point 
values (12 bytes total) representing the normal of the vertex. 
The i component is first, then j followed by k.</P></DD><DD><P><A HREF=#MMESH_VTXUV0>MMESH_VTXUV0</A> - 2 4-byte single precision floating point 
values (8 bytes total) representing the texture coordinates for 
layer 0 of the vertex. The u component is first followed by v.</P></DD><DD><P><A HREF=#MMESH_VTXUV1>MMESH_VTXUV1</A> - 2 4-byte single precision floating point 
values (8 bytes total) representing the texture coordinates for 
layer 1 of the vertex.  The u component is first followed by v.</P></DD><DD><P><A HREF=#MMESH_VTXUV2>MMESH_VTXUV2</A> - 2 4-byte single precision floating point 
values (8 bytes total) representing the texture coordinates for 
layer 2 of the vertex. The u component is first followed by v.</P></DD><DD><P><A HREF=#MMESH_VTXUV3>MMESH_VTXUV3</A> - 2 4-byte single precision floating point 
values (8 bytes total) representing the texture coordinates for 
layer 3 of the vertex. The u component is first followed by v.</P></DD><DD><P><A HREF=#MMESH_VTXUV4>MMESH_VTXUV4</A> - 2 4-byte single precision floating point 
values (8 bytes total) representing the texture coordinates for 
layer 4 of the vertex. The u component is first followed by v.</P></DD><DD><P><A HREF=#MMESH_VTXUV5>MMESH_VTXUV5</A> - 2 4-byte single precision floating point 
values (8 bytes total) representing the texture coordinates for 
layer 5 of the vertex. The u component is first followed by v.</P></DD><DD><P><A HREF=#MMESH_VTXUV6>MMESH_VTXUV6</A> - 2 4-byte single precision floating point 
values (8 bytes total) representing the texture coordinates for 
layer 6 of the vertex. The u component is first followed by v.</P></DD><DD><P><A HREF=#MMESH_VTXUV7>MMESH_VTXUV7</A> - 2 4-byte single precision floating point 
values (8 bytes total) representing the texture coordinates for 
layer 7 of the vertex. The u component is first followed by v.</P></DD><DD><P>You can extract the data out of the vertex pool using the 
vertex stride and vertex offset values returned by functions 
<A HREF=#mgMeshGetVtxStride>mgMeshGetVtxStride</A> and <A HREF=#mgMeshGetVtxOffset>mgMeshGetVtxOffset</A>, respectively. 
Note: This is not the 
recommended technique for extracting data from the vertex 
pool.  Instead, it is much simpler to use the functions 
<A HREF=#mgMeshGetVtxCoord>mgMeshGetVtxCoord</A>, <A HREF=#mgMeshGetVtxColor>mgMeshGetVtxColor</A>, 
<A HREF=#mgMeshGetVtxColorRGB>mgMeshGetVtxColorRGB</A>, <A HREF=#mgMeshGetVtxColorAlpha>mgMeshGetVtxColorAlpha</A>, 
<A HREF=#mgMeshGetVtxNormal>mgMeshGetVtxNormal</A> and <A HREF=#mgMeshGetVtxUV>mgMeshGetVtxUV</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 node</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the vertex pool of mesh <I>rec</I> if successful, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshPrimitiveGetNumVtx>mgMeshPrimitiveGetNumVtx</A>, 
<A HREF=#mgMeshPrimitiveGetVtxIndexArray>mgMeshPrimitiveGetVtxIndexArray</A>, 
<A HREF=#mgMeshGetVtxCoord>mgMeshGetVtxCoord</A>, <A HREF=#mgMeshGetVtxColor>mgMeshGetVtxColor</A>, 
<A HREF=#mgMeshGetVtxColorRGBA>mgMeshGetVtxColorRGBA</A>, <A HREF=#mgMeshGetVtxColorRGB>mgMeshGetVtxColorRGB</A>, <A HREF=#mgMeshGetVtxColorAlpha>mgMeshGetVtxColorAlpha</A>, 
<A HREF=#mgMeshGetVtxNormal>mgMeshGetVtxNormal</A>, <A HREF=#mgMeshGetVtxUV>mgMeshGetVtxUV</A></DD></DL>
<HR>
<LEFT><A NAME=mgMeshGetVtxStride><H1 CLASS="APISYMBOL">mgMeshGetVtxStride</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMeshGetVtxStride</B> - gets the vertex stride 
for a mesh.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>unsigned int <B>mgMeshGetVtxStride</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This function retrieves the vertex stride for mesh <I>rec</I>. 
The vertex stride of a mesh indicates the number of bytes between 
successive vertices in the mesh vertex pool.  This number is always 
a multiple of 8 to ensure 8 byte alignment for double precision 
floating point coordinates.</P></DD><DD><P>You can use this value together with the vertex data offsets 
returned by <A HREF=#mgMeshGetVtxOffset>mgMeshGetVtxOffset</A> to extract data from a mesh 
vertex pool. Note: This is not the 
recommended technique for extracting data from the mesh vertex pool. 
Instead, it is much simpler to use the functions 
<A HREF=#mgMeshGetVtxCoord>mgMeshGetVtxCoord</A>, <A HREF=#mgMeshGetVtxColor>mgMeshGetVtxColor</A>, 
<A HREF=#mgMeshGetVtxColorRGB>mgMeshGetVtxColorRGB</A>, <A HREF=#mgMeshGetVtxColorAlpha>mgMeshGetVtxColorAlpha</A>, 
<A HREF=#mgMeshGetVtxNormal>mgMeshGetVtxNormal</A> and <A HREF=#mgMeshGetVtxUV>mgMeshGetVtxUV</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 node</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the vertex stride of mesh <I>rec</I> if successful, 
0 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshGetVtxPool>mgMeshGetVtxPool</A>, <A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshGetVtxOffset>mgMeshGetVtxOffset</A>, 
<A HREF=#mgMeshGetVtxCoord>mgMeshGetVtxCoord</A>, <A HREF=#mgMeshGetVtxColor>mgMeshGetVtxColor</A>, 
<A HREF=#mgMeshGetVtxColorRGBA>mgMeshGetVtxColorRGBA</A>, <A HREF=#mgMeshGetVtxColorRGB>mgMeshGetVtxColorRGB</A>, <A HREF=#mgMeshGetVtxColorAlpha>mgMeshGetVtxColorAlpha</A>, 
<A HREF=#mgMeshGetVtxNormal>mgMeshGetVtxNormal</A>, <A HREF=#mgMeshGetVtxUV>mgMeshGetVtxUV</A></DD></DL>
<HR>
<LEFT><A NAME=mgMeshGetVtxUV><H1 CLASS="APISYMBOL">mgMeshGetVtxUV</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMeshGetVtxUV</B> - retrieves the u,v texture coordinate 
for a vertex in a mesh.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMeshGetVtxUV</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>vtxIndex</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>layer</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>u</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>v</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, u, v <B>mgMeshGetVtxUV</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>vtxIndex</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>layer</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This function retrieves the <I>u</I> and <I>v</I> texture coordinate 
values for layer <I>layer</I> of the vertex at index <I>vtxIndex</I> in 
the vertex pool of mesh node <I>rec</I>.</P></DD><DD><P>You do not have to provide addresses for both <I>u</I> and <I>v</I> values. 
For example, if you only want to receive u (but not v), specify a valid 
address for <I>u</I> and leave <I>v</I> NULL.</P></DD><DD><P>Note: The first vertex in the mesh vertex pool is at index 0.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 node</DD><DT><I>vtxIndex</I></DT><DD>the vertex number in the mesh starting at 0</DD><DT><I>layer</I></DT><DD>the layer number 0..7</DD><DT><I>u</I></DT><DD>address of value to receive u texture coordinate</DD><DT><I>v</I></DT><DD>address of value to receive v texture coordinate</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the vertex data was retrieved 
successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.  This function will fail 
if <I>rec</I> is not a valid mesh node, if the vertex at <I>vtxIndex</I> 
does not exist in the mesh, or if the vertices in the mesh do not 
color values.</DD><DT>u</DT><DD>If function is successful, u contains the retrieved u coordinate, otherwise 
u is undefined.</DD><DT>v</DT><DD>If function is successful, v contains the retrieved v coordinate, otherwise 
v is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshPrimitiveGetNumVtx>mgMeshPrimitiveGetNumVtx</A>, 
<A HREF=#mgMeshPrimitiveGetVtxIndexArray>mgMeshPrimitiveGetVtxIndexArray</A>, 
<A HREF=#mgMeshGetVtxCoord>mgMeshGetVtxCoord</A>, <A HREF=#mgMeshGetVtxColor>mgMeshGetVtxColor</A>, 
<A HREF=#mgMeshGetVtxColorRGBA>mgMeshGetVtxColorRGBA</A>, <A HREF=#mgMeshGetVtxColorRGB>mgMeshGetVtxColorRGB</A>, <A HREF=#mgMeshGetVtxColorAlpha>mgMeshGetVtxColorAlpha</A>, 
<A HREF=#mgMeshGetVtxNormal>mgMeshGetVtxNormal</A>, <A HREF=#mgMeshSetVtxUV>mgMeshSetVtxUV</A></DD></DL>
<HR>
<LEFT><A NAME=mgMeshPrimitiveGetNumVtx><H1 CLASS="APISYMBOL">mgMeshPrimitiveGetNumVtx</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMeshPrimitiveGetNumVtx</B> - gets the number of vertices 
contained in a mesh primitive.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgMeshPrimitiveGetNumVtx</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>primNo</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This function gets the number of vertices contained in mesh 
primitive number <I>primNo</I> in mesh <I>rec</I>.</P></DD><DD><P>The first mesh primitive 
in a mesh is number 0.  The <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMeshNumPrimitives</A>
 attribute of a 
mesh node specifies how many primitives are contained in the mesh.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 node</DD><DT><I>primNo</I></DT><DD>the mesh primitive number starting from 0</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of vertices in mesh primitive <I>primNo</I> 
if successful, -1 otherwise.  This function will fail if <I>rec</I> is 
not a valid mesh node or if <I>primNo</I> does not specify a valid 
mesh primitive number.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD>fltf fltMesh.fltMeshNumPrimitives&gt, <A HREF=#mgMeshPrimitiveGetType>mgMeshPrimitiveGetType</A>, 
<A HREF=#mgMeshPrimitiveGetVtxIndexArray>mgMeshPrimitiveGetVtxIndexArray</A>, 
<A HREF=#mgMeshGetVtxCoord>mgMeshGetVtxCoord</A>, <A HREF=#mgMeshGetVtxColor>mgMeshGetVtxColor</A>, 
<A HREF=#mgMeshGetVtxColorRGBA>mgMeshGetVtxColorRGBA</A>, <A HREF=#mgMeshGetVtxColorRGB>mgMeshGetVtxColorRGB</A>, <A HREF=#mgMeshGetVtxColorAlpha>mgMeshGetVtxColorAlpha</A>, 
<A HREF=#mgMeshGetVtxNormal>mgMeshGetVtxNormal</A>, <A HREF=#mgMeshGetVtxUV>mgMeshGetVtxUV</A></DD></DL>
<HR>
<LEFT><A NAME=mgMeshPrimitiveGetType><H1 CLASS="APISYMBOL">mgMeshPrimitiveGetType</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMeshPrimitiveGetType</B> - gets the type of a mesh primitive.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgMeshPrimitiveGetType</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>primNo</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This function gets the type for mesh primitive number <I>primNo</I> 
in mesh <I>rec</I>.  A mesh node is composed of one or more mesh primitives. 
Each mesh primitive is one of four types:</P></DD><DD><P><A HREF=#MPRIM_TRI_STRIP>MPRIM_TRI_STRIP</A> - Triangle Strip<BR> 
<A HREF=#MPRIM_TRI_FAN>MPRIM_TRI_FAN</A> - Triangle Fan<BR> 
<A HREF=#MPRIM_QUAD_STRIP>MPRIM_QUAD_STRIP</A> - Quadrilateral Strip<BR> 
<A HREF=#MPRIM_INDEXED_POLY>MPRIM_INDEXED_POLY</A> - Indexed Polygon</P></DD><DD><P>The first mesh primitive 
in a mesh is number 0.  The <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMeshNumPrimitives</A>
 attribute of a 
mesh node specifies how many primitives are contained in the mesh.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 node</DD><DT><I>primNo</I></DT><DD>the mesh primitive number starting from 0</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the type for mesh primitive <I>primNo</I> if successful, 
0 otherwise.  This function will fail if <I>rec</I> is 
not a valid mesh node or if <I>primNo</I> does not specify a valid 
mesh primitive number.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMeshNumPrimitives</A>
, <A HREF=#mgMeshPrimitiveGetNumVtx>mgMeshPrimitiveGetNumVtx</A>, 
<A HREF=#mgMeshPrimitiveGetVtxIndexArray>mgMeshPrimitiveGetVtxIndexArray</A>, 
<A HREF=#mgMeshGetVtxCoord>mgMeshGetVtxCoord</A>, <A HREF=#mgMeshGetVtxColor>mgMeshGetVtxColor</A>, 
<A HREF=#mgMeshGetVtxColorRGBA>mgMeshGetVtxColorRGBA</A>, <A HREF=#mgMeshGetVtxColorRGB>mgMeshGetVtxColorRGB</A>, <A HREF=#mgMeshGetVtxColorAlpha>mgMeshGetVtxColorAlpha</A>, 
<A HREF=#mgMeshGetVtxNormal>mgMeshGetVtxNormal</A>, <A HREF=#mgMeshGetVtxUV>mgMeshGetVtxUV</A>, <A HREF=#mgMeshPrimitiveSetType>mgMeshPrimitiveSetType</A></DD></DL>
<HR>
<LEFT><A NAME=mgMeshPrimitiveGetVtxIndexArray><H1 CLASS="APISYMBOL">mgMeshPrimitiveGetVtxIndexArray</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMeshPrimitiveGetVtxIndexArray</B> - gets the vertex index 
array for a mesh primitive.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgMeshPrimitiveGetVtxIndexArray</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>primNo</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>indexArray</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maxLen</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>numIndices, array <B>mgMeshPrimitiveGetVtxIndexArray</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>primNo</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This function gets the vertex index array for mesh primitive 
number <I>primNo</I> in mesh <I>rec</I>.  The vertex index array of a mesh 
primitive is an array of integer values that define the vertex ordering 
of the vertices that make up the mesh primitive.  The integer indices 
in the vertex index array refer to vertices stored in the mesh vertex pool.</P></DD><DD><P>Note: The first vertex in the mesh vertex pool is at index 0. 
The function <A HREF=#mgMeshPrimitiveGetNumVtx>mgMeshPrimitiveGetNumVtx</A> can be used to determine the number 
of vertex indices contained in a primitive of a mesh.  This result dictates the 
minimum size of the <I>indexArray</I> you pass in to <B>mgMeshPrimitiveGetVtxIndexArray</B>.</P></DD><DD><P>If successful, the indices of the vertices of the mesh primitive 
are returned in the output parameter <I>indexArray</I>, otherwise it is 
undefined.  You must pass 
a buffer for <I>indexArray</I> that is large enough to receive at 
most <I>maxLen</I> integer values.  The actual number of vertex 
indices returned is the smaller of <I>maxLen</I> and the number 
of vertex indices in the specified mesh primitive.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 node</DD><DT><I>primNo</I></DT><DD>the mesh primitive number starting from 0</DD><DT><I>indexArray</I></DT><DD>the array to receive the vertex indices</DD><DT><I>maxLen</I></DT><DD>the maximum number of indices to write 
into <I>indexArray</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>numIndices</DT><DD>the number of vertex indices being returned in 
<I>indexArray</I> if successful, -1 otherwise.  This function will fail 
if <I>rec</I> is not a valid mesh node or if <I>primNo</I> does not specify 
a valid mesh primitive number.</DD><DT>array</DT><DD>the array</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshPrimitiveGetType>mgMeshPrimitiveGetType</A>, <A HREF=#mgMeshPrimitiveGetNumVtx>mgMeshPrimitiveGetNumVtx</A>, 
<A HREF=#mgMeshGetVtxCoord>mgMeshGetVtxCoord</A>, <A HREF=#mgMeshGetVtxColor>mgMeshGetVtxColor</A>, 
<A HREF=#mgMeshGetVtxColorRGBA>mgMeshGetVtxColorRGBA</A>, <A HREF=#mgMeshGetVtxColorRGB>mgMeshGetVtxColorRGB</A>, <A HREF=#mgMeshGetVtxColorAlpha>mgMeshGetVtxColorAlpha</A>, 
<A HREF=#mgMeshGetVtxNormal>mgMeshGetVtxNormal</A>, <A HREF=#mgMeshGetVtxUV>mgMeshGetVtxUV</A>, 
<A HREF=#mgMeshPrimitiveSetVtxIndexArray>mgMeshPrimitiveSetVtxIndexArray</A></DD></DL>
<HR>
<LEFT><A NAME=mgMeshPrimitiveSetType><H1 CLASS="APISYMBOL">mgMeshPrimitiveSetType</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMeshPrimitiveSetType</B> - sets the type of a mesh primitive.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgMeshPrimitiveSetType</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>primNo</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>type</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This function sets the type for mesh primitive number <I>primNo</I> 
in mesh <I>rec</I>.  A mesh node is composed of one or more mesh primitives. 
Each mesh primitive is one of four types:</P></DD><DD><P><A HREF=#MPRIM_TRI_STRIP>MPRIM_TRI_STRIP</A> - Triangle Strip<BR> 
<A HREF=#MPRIM_TRI_FAN>MPRIM_TRI_FAN</A> - Triangle Fan<BR> 
<A HREF=#MPRIM_QUAD_STRIP>MPRIM_QUAD_STRIP</A> - Quadrilateral Strip<BR> 
<A HREF=#MPRIM_INDEXED_POLY>MPRIM_INDEXED_POLY</A> - Indexed Polygon</P></DD><DD><P>The first mesh primitive 
in a mesh is number 0.  The <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMeshNumPrimitives</A>
 attribute of a 
mesh node specifies how many primitives are contained in the mesh.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 node</DD><DT><I>primNo</I></DT><DD>the mesh primitive number starting from 0</DD><DT><I>type</I></DT><DD>the primitive type</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>rec</I> is 
not a valid mesh node, if <I>primNo</I> does not specify a valid 
mesh primitive number, or <I>type</I> does not specify a valid 
mesh primitive type.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshCreateVtxPool>mgMeshCreateVtxPool</A>, <A HREF=#mgMeshCreatePrimitives>mgMeshCreatePrimitives</A>, 
<A HREF=#mgMeshPrimitiveSetVtxIndexArray>mgMeshPrimitiveSetVtxIndexArray</A>, 
<A HREF=#mgMeshSetVtxCoord>mgMeshSetVtxCoord</A>, <A HREF=#mgMeshSetVtxColor>mgMeshSetVtxColor</A>, 
<A HREF=#mgMeshSetVtxColorRGBA>mgMeshSetVtxColorRGBA</A>, <A HREF=#mgMeshSetVtxColorRGB>mgMeshSetVtxColorRGB</A>, 
<A HREF=#mgMeshSetVtxColorAlpha>mgMeshSetVtxColorAlpha</A>, <A HREF=#mgMeshSetVtxNormal>mgMeshSetVtxNormal</A>, <A HREF=#mgMeshSetVtxUV>mgMeshSetVtxUV</A>, 
<A HREF=#mgMeshPrimitiveGetType>mgMeshPrimitiveGetType</A></DD></DL>
<HR>
<LEFT><A NAME=mgMeshPrimitiveSetVtxIndexArray><H1 CLASS="APISYMBOL">mgMeshPrimitiveSetVtxIndexArray</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMeshPrimitiveSetVtxIndexArray</B> - sets the vertex index 
array for a mesh primitive.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgMeshPrimitiveSetVtxIndexArray</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>primNo</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>indexArray</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>numVtx</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This function creates the vertex index array for mesh primitive 
number <I>primNo</I> in mesh <I>rec</I> and fills in the values of the array 
created using the indices in <I>indexArray</I>.  The vertex index array 
created will be large enough to hold <I>numVtx</I> indices.</P></DD><DD><P>The vertex index array of a mesh primitive is an array of integer 
values that define the vertex ordering of the vertices that make up the 
mesh primitive.  The integer indices in the vertex index array refer to 
vertices stored in the mesh vertex pool.</P></DD><DD><P>Note: The first vertex in the mesh vertex pool is at index 0.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 node</DD><DT><I>primNo</I></DT><DD>the mesh primitive number starting from 0</DD><DT><I>indexArray</I></DT><DD>the vertex indices for this primitive</DD><DT><I>numVtx</I></DT><DD>the number of vertex indices to write 
from <I>indexArray</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of vertex indices that were set if 
successful, -1 otherwise.  This function will fail if <I>rec</I> is 
not a valid mesh node or if <I>primNo</I> does not specify a valid 
mesh primitive number.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshPrimitiveSetType>mgMeshPrimitiveSetType</A>, <A HREF=#mgMeshCreatePrimitives>mgMeshCreatePrimitives</A>, 
<A HREF=#mgMeshSetVtxCoord>mgMeshSetVtxCoord</A>, <A HREF=#mgMeshSetVtxColor>mgMeshSetVtxColor</A>, 
<A HREF=#mgMeshSetVtxColorRGBA>mgMeshSetVtxColorRGBA</A>, <A HREF=#mgMeshSetVtxColorRGB>mgMeshSetVtxColorRGB</A>, <A HREF=#mgMeshSetVtxColorAlpha>mgMeshSetVtxColorAlpha</A>, 
<A HREF=#mgMeshSetVtxNormal>mgMeshSetVtxNormal</A>, <A HREF=#mgMeshSetVtxUV>mgMeshSetVtxUV</A>, <A HREF=#mgMeshPrimitiveGetVtxIndexArray>mgMeshPrimitiveGetVtxIndexArray</A></DD></DL>
<HR>
<LEFT><A NAME=mgMeshSetVtxColor><H1 CLASS="APISYMBOL">mgMeshSetVtxColor</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMeshSetVtxColor</B> - sets the color index and 
intensity values for a vertex in a mesh.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMeshSetVtxColor</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>vtxIndex</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>color</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>intensity</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This function sets the color <I>index</I> and <I>intensity</I> 
values of the vertex at index <I>vtxIndex</I> in the vertex pool of mesh 
node <I>rec</I>.</P></DD><DD><P>Note: The first vertex in the mesh vertex pool is at index 0.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 node</DD><DT><I>vtxIndex</I></DT><DD>the vertex number in the mesh starting at 0</DD><DT><I>color</I></DT><DD>the color index</DD><DT><I>intensity</I></DT><DD>the intensity</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the vertex data was set 
successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.  This function will fail 
if <I>rec</I> is not a valid mesh node, if the vertex at <I>vtxIndex</I> 
does not exist in the mesh, or if the vertex mask for the mesh does 
not specify that the vertices have color values.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshCreateVtxPool>mgMeshCreateVtxPool</A>, <A HREF=#mgMeshCreatePrimitives>mgMeshCreatePrimitives</A>, 
<A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshSetVtxMask>mgMeshSetVtxMask</A>, <A HREF=#mgMeshPrimitiveGetNumVtx>mgMeshPrimitiveGetNumVtx</A>, 
<A HREF=#mgMeshPrimitiveGetVtxIndexArray>mgMeshPrimitiveGetVtxIndexArray</A>, 
<A HREF=#mgMeshSetVtxCoord>mgMeshSetVtxCoord</A>, <A HREF=#mgMeshSetVtxColorRGBA>mgMeshSetVtxColorRGBA</A>, <A HREF=#mgMeshSetVtxColorRGB>mgMeshSetVtxColorRGB</A>, 
<A HREF=#mgMeshSetVtxColorAlpha>mgMeshSetVtxColorAlpha</A>, <A HREF=#mgMeshSetVtxNormal>mgMeshSetVtxNormal</A>, <A HREF=#mgMeshSetVtxUV>mgMeshSetVtxUV</A>, 
<A HREF=#mgMeshGetVtxColor>mgMeshGetVtxColor</A></DD></DL>
<HR>
<LEFT><A NAME=mgMeshSetVtxColorAlpha><H1 CLASS="APISYMBOL">mgMeshSetVtxColorAlpha</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMeshSetVtxColorAlpha</B> - sets the Alpha color value 
for a vertex in a mesh.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMeshSetVtxColorAlpha</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>vtxIndex</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>alpha</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This function sets the alpha <I>a</I> color value 
of the vertex at index <I>vtxIndex</I> in the vertex pool of mesh node 
<I>rec</I>.</P></DD><DD><P>Note: The first vertex in the mesh vertex pool is at index 0.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 node</DD><DT><I>vtxIndex</I></DT><DD>the vertex number in the mesh starting at 0</DD><DT><I>alpha</I></DT><DD>the alpha component</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the vertex data was set 
successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.  This function will fail 
if <I>rec</I> is not a valid mesh node, if the vertex at <I>vtxIndex</I> 
does not exist in the mesh, or if the vertex mask for the mesh does 
not specify that the vertices have color values.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshCreateVtxPool>mgMeshCreateVtxPool</A>, <A HREF=#mgMeshCreatePrimitives>mgMeshCreatePrimitives</A>, 
<A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshSetVtxMask>mgMeshSetVtxMask</A>, <A HREF=#mgMeshPrimitiveGetNumVtx>mgMeshPrimitiveGetNumVtx</A>, 
<A HREF=#mgMeshPrimitiveGetVtxIndexArray>mgMeshPrimitiveGetVtxIndexArray</A>, 
<A HREF=#mgMeshSetVtxCoord>mgMeshSetVtxCoord</A>, <A HREF=#mgMeshSetVtxColor>mgMeshSetVtxColor</A>, <A HREF=#mgMeshSetVtxColorRGBA>mgMeshSetVtxColorRGBA</A>, 
<A HREF=#mgMeshSetVtxColorRGB>mgMeshSetVtxColorRGB</A>, <B>mgMeshSetVtxColorAlpha</B>, 
<A HREF=#mgMeshSetVtxNormal>mgMeshSetVtxNormal</A>, <A HREF=#mgMeshSetVtxUV>mgMeshSetVtxUV</A>, 
<A HREF=#mgMeshGetVtxColorRGBA>mgMeshGetVtxColorRGBA</A>, <A HREF=#mgMeshGetVtxColorRGB>mgMeshGetVtxColorRGB</A>, <A HREF=#mgMeshGetVtxColorAlpha>mgMeshGetVtxColorAlpha</A></DD></DL>
<HR>
<LEFT><A NAME=mgMeshSetVtxColorRGB><H1 CLASS="APISYMBOL">mgMeshSetVtxColorRGB</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMeshSetVtxColorRGB</B> - sets the RGB color values 
for a vertex in a mesh.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMeshSetVtxColorRGB</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>vtxIndex</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>red</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>green</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>blue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This function sets the <I>red</I>, <I>green</I>, and <I>blue</I> color values 
of the vertex at index <I>vtxIndex</I> in the vertex pool of mesh node 
<I>rec</I>.</P></DD><DD><P>Note: The first vertex in the mesh vertex pool is at index 0.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 node</DD><DT><I>vtxIndex</I></DT><DD>the vertex number in the mesh starting at 0</DD><DT><I>red</I></DT><DD>the red component</DD><DT><I>green</I></DT><DD>the green component</DD><DT><I>blue</I></DT><DD>the blue component</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the vertex data was set 
successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.  This function will fail 
if <I>rec</I> is not a valid mesh node, if the vertex at <I>vtxIndex</I> 
does not exist in the mesh, or if the vertex mask for the mesh does 
not specify that the vertices have color values.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshCreateVtxPool>mgMeshCreateVtxPool</A>, <A HREF=#mgMeshCreatePrimitives>mgMeshCreatePrimitives</A>, 
<A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshSetVtxMask>mgMeshSetVtxMask</A>, <A HREF=#mgMeshPrimitiveGetNumVtx>mgMeshPrimitiveGetNumVtx</A>, 
<A HREF=#mgMeshPrimitiveGetVtxIndexArray>mgMeshPrimitiveGetVtxIndexArray</A>, 
<A HREF=#mgMeshSetVtxCoord>mgMeshSetVtxCoord</A>, <A HREF=#mgMeshSetVtxColor>mgMeshSetVtxColor</A>, <A HREF=#mgMeshSetVtxColorRGBA>mgMeshSetVtxColorRGBA</A>, 
<A HREF=#mgMeshSetVtxColorAlpha>mgMeshSetVtxColorAlpha</A>, <A HREF=#mgMeshSetVtxNormal>mgMeshSetVtxNormal</A>, <A HREF=#mgMeshSetVtxUV>mgMeshSetVtxUV</A>, 
<A HREF=#mgMeshGetVtxColorRGBA>mgMeshGetVtxColorRGBA</A>, <A HREF=#mgMeshGetVtxColorRGB>mgMeshGetVtxColorRGB</A>, <A HREF=#mgMeshGetVtxColorAlpha>mgMeshGetVtxColorAlpha</A></DD></DL>
<HR>
<LEFT><A NAME=mgMeshSetVtxColorRGBA><H1 CLASS="APISYMBOL">mgMeshSetVtxColorRGBA</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMeshSetVtxColorRGBA</B> - sets the RGBA color values 
for a vertex in a mesh.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMeshSetVtxColorRGBA</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>vtxIndex</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>red</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>green</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>blue</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>alpha</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This function sets the <I>red</I>, <I>green</I>, <I>blue</I>, and <I>alpha</I> 
color values of the vertex at index <I>vtxIndex</I> in the vertex pool of 
mesh node <I>rec</I>.</P></DD><DD><P>Note: The first vertex in the mesh vertex pool is at index 0.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 node</DD><DT><I>vtxIndex</I></DT><DD>the vertex number in the mesh starting at 0</DD><DT><I>red</I></DT><DD>the red component</DD><DT><I>green</I></DT><DD>the green component</DD><DT><I>blue</I></DT><DD>the blue component</DD><DT><I>alpha</I></DT><DD>the alpha component</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the vertex data was set 
successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.  This function will fail 
if <I>rec</I> is not a valid mesh node, if the vertex at <I>vtxIndex</I> 
does not exist in the mesh, or if the vertex mask for the mesh does 
not specify that the vertices have color values.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshCreateVtxPool>mgMeshCreateVtxPool</A>, <A HREF=#mgMeshCreatePrimitives>mgMeshCreatePrimitives</A>, 
<A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshSetVtxMask>mgMeshSetVtxMask</A>, <A HREF=#mgMeshPrimitiveGetNumVtx>mgMeshPrimitiveGetNumVtx</A>, 
<A HREF=#mgMeshPrimitiveGetVtxIndexArray>mgMeshPrimitiveGetVtxIndexArray</A>, 
<A HREF=#mgMeshSetVtxCoord>mgMeshSetVtxCoord</A>, <A HREF=#mgMeshSetVtxColor>mgMeshSetVtxColor</A>, <A HREF=#mgMeshSetVtxColorRGB>mgMeshSetVtxColorRGB</A>, 
<A HREF=#mgMeshSetVtxColorAlpha>mgMeshSetVtxColorAlpha</A>, <A HREF=#mgMeshSetVtxNormal>mgMeshSetVtxNormal</A>, <A HREF=#mgMeshSetVtxUV>mgMeshSetVtxUV</A>, 
<A HREF=#mgMeshGetVtxColorRGBA>mgMeshGetVtxColorRGBA</A>, <A HREF=#mgMeshGetVtxColorRGB>mgMeshGetVtxColorRGB</A>, <A HREF=#mgMeshGetVtxColorAlpha>mgMeshGetVtxColorAlpha</A></DD></DL>
<HR>
<LEFT><A NAME=mgMeshSetVtxCoord><H1 CLASS="APISYMBOL">mgMeshSetVtxCoord</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMeshSetVtxCoord</B> - sets the x,y,z coordinate for 
a vertex in a mesh.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMeshSetVtxCoord</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>vtxIndex</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>y</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>z</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This function sets the <I>x</I>, <I>y</I>, and <I>z</I> values of the 
vertex at index <I>vtxIndex</I> in the vertex pool of mesh node <I>rec</I>.</P></DD><DD><P>Note: The first vertex in the mesh vertex pool is at index 0.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 node</DD><DT><I>vtxIndex</I></DT><DD>the vertex number in the mesh starting at 0</DD><DT><I>x</I></DT><DD>the x coordinate</DD><DT><I>y</I></DT><DD>the y coordinate</DD><DT><I>z</I></DT><DD>the z coordinate</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the vertex data was set 
successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.  This function will fail 
if <I>rec</I> is not a valid mesh node, if the vertex at <I>vtxIndex</I> 
does not exist in the mesh, or if the vertex mask for the mesh does 
not specify that the vertices have coordinate positions.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshCreateVtxPool>mgMeshCreateVtxPool</A>, <A HREF=#mgMeshCreatePrimitives>mgMeshCreatePrimitives</A>, 
<A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshSetVtxMask>mgMeshSetVtxMask</A>, <A HREF=#mgMeshPrimitiveGetNumVtx>mgMeshPrimitiveGetNumVtx</A>, 
<A HREF=#mgMeshPrimitiveGetVtxIndexArray>mgMeshPrimitiveGetVtxIndexArray</A>, 
<A HREF=#mgMeshSetVtxColor>mgMeshSetVtxColor</A>, 
<A HREF=#mgMeshSetVtxColorRGBA>mgMeshSetVtxColorRGBA</A>, <A HREF=#mgMeshSetVtxColorRGB>mgMeshSetVtxColorRGB</A>, <A HREF=#mgMeshSetVtxColorAlpha>mgMeshSetVtxColorAlpha</A>, 
<A HREF=#mgMeshSetVtxNormal>mgMeshSetVtxNormal</A>, <A HREF=#mgMeshSetVtxUV>mgMeshSetVtxUV</A>, 
<A HREF=#mgMeshGetVtxCoord>mgMeshGetVtxCoord</A></DD></DL>
<HR>
<LEFT><A NAME=mgMeshSetVtxMask><H1 CLASS="APISYMBOL">mgMeshSetVtxMask</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMeshSetVtxMask</B> - sets the vertex mask for a mesh.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMeshSetVtxMask</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>newVtxMask</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This function sets the vertex mask for mesh <I>rec</I> to the 
value specified by <I>newVtxMask</I>, allocates a new vertex pool for 
the mesh according to mask bits set and repacks this new vertex 
pool accordingly.</P></DD><DD><P>Mesh vertex data is efficiently packed in the vertex pool 
according to what kind of data is present for the mesh vertices. 
For example, if a mesh only has coordinate position (x,y,z) data, 
then only enough memory is allocated in the vertex pool for 
three consecutive double precision values per vertex. 
If you need to change what kind of vertex data is defined in 
the vertex pool, you must call this function with the mask representing 
the desired data.  The value of <I>newVtxMask</I> is a bitwise combination 
of Mesh Vertex Mask Bits specifying what kind of data to allocate 
for each vertex in the pool.</P></DD><DD><P>Mesh Vertex Mask Bits include:<BR> 
<A HREF=#MMESH_VTXCOORD>MMESH_VTXCOORD</A><BR> 
<A HREF=#MMESH_VTXCOLOR>MMESH_VTXCOLOR</A><BR> 
<A HREF=#MMESH_VTXCOLORRGB>MMESH_VTXCOLORRGB</A><BR> 
<A HREF=#MMESH_VTXNORMAL>MMESH_VTXNORMAL</A><BR> 
<A HREF=#MMESH_VTXUV0>MMESH_VTXUV0</A><BR> 
<A HREF=#MMESH_VTXUV1>MMESH_VTXUV1</A><BR> 
<A HREF=#MMESH_VTXUV2>MMESH_VTXUV2</A><BR> 
<A HREF=#MMESH_VTXUV3>MMESH_VTXUV3</A><BR> 
<A HREF=#MMESH_VTXUV4>MMESH_VTXUV4</A><BR> 
<A HREF=#MMESH_VTXUV5>MMESH_VTXUV5</A><BR> 
<A HREF=#MMESH_VTXUV6>MMESH_VTXUV6</A><BR> 
<A HREF=#MMESH_VTXUV7>MMESH_VTXUV7</A></P></DD><DD><P>See <A HREF=#mgMeshCreateVtxPool>mgMeshCreateVtxPool</A> for a complete description of these 
mask bits.</P></DD><DD><P>If the mask you specify to this function is identical to the current 
vertex mask of the mesh, this function will do nothing.  If the mask you 
specify is different from the current vertex mask, then this function will 
allocate a new vertex pool of size required by <I>newVtxMask</I>, initialize 
the new vertex pool as described below and then delete the original vertex 
pool.</P></DD><DD><P>The following paragraphs describe how the new vertex pool is initialized 
under different circumstances:</P></DD><DD><P>For each kind of vertex data that was specified by both the original 
vertex mask and the new vertex mask, the corresponding vertex data from the 
original vertex pool is copied to the correct locations in the new vertex 
pool.  In this way, existing vertex data is preserved in the mesh.</P></DD><DD><P>For each kind of vertex data that was specified by the original vertex 
mask but not by the new vertex mask, the corresponding vertex data from the 
original vertex pool is discarded.</P></DD><DD><P>For each kind of vertex data that was specified by the new vertex 
mask but not by the original vertex mask, the corresponding vertex data in the 
new vertex pool is left uninitialized. It is the caller's responsibility to assign 
values for this new vertex data in the vertex pool using functions such as 
<A HREF=#mgMeshSetVtxColor>mgMeshSetVtxColor</A>, <A HREF=#mgMeshSetVtxCoord>mgMeshSetVtxCoord</A>, <A HREF=#mgMeshSetVtxColor>mgMeshSetVtxColor</A>, 
<A HREF=#mgMeshSetVtxColorRGB>mgMeshSetVtxColorRGB</A>, <A HREF=#mgMeshSetVtxNormal>mgMeshSetVtxNormal</A>, <A HREF=#mgMeshSetVtxUV>mgMeshSetVtxUV</A>, etc.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 node</DD><DT><I>newVtxMask</I></DT><DD>the mask specifying what 
kind of data is defined for the 
vertices in the mesh</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the vertex mask was set 
successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.  This function will fail 
if <I>rec</I> is not a valid mesh node, or <I>newVtxMask</I> is 0 or 
does not specify a valid set of bits.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows how to add texture data (UVs) in layer 0 
to a mesh that previously may or may not have been textured.</DT><DT><PRE CLASS="EXAMPLE">// since we want to preserve any existing vertex data, we
// will get the value of the current vertex mask and "OR"
// MMESH_VTXUV0 into it to form the value of the new mask
unsigned int oldMask = mgMeshGetVtxMask (mesh);
unsigned int newMask = oldMask | MMESH_VTXUV0;

// we don't have to do this check, mgMeshSetVtxMask will
// return immediately if old and new masks are identical
if (oldMask != newMask)
{
   // mgMeshSetVtxMask will preserve any existing vertex
   // data and allocate a new vertex pool with space for
   // our UVs for layer 0
   mgMeshSetVtxMask (mesh, newMask);

   // remember, you still have to call mgMeshSetVtxUV to
   // assign UVs for each vertex in the mesh
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshCreateVtxPool>mgMeshCreateVtxPool</A>, <A HREF=#mgMeshCreatePrimitives>mgMeshCreatePrimitives</A>, 
<A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshPrimitiveGetNumVtx>mgMeshPrimitiveGetNumVtx</A>, 
<A HREF=#mgMeshPrimitiveGetVtxIndexArray>mgMeshPrimitiveGetVtxIndexArray</A>, 
<A HREF=#mgMeshSetVtxCoord>mgMeshSetVtxCoord</A>, <A HREF=#mgMeshSetVtxColor>mgMeshSetVtxColor</A>, 
<A HREF=#mgMeshSetVtxColorRGBA>mgMeshSetVtxColorRGBA</A>, <A HREF=#mgMeshSetVtxColorRGB>mgMeshSetVtxColorRGB</A>, <A HREF=#mgMeshSetVtxColorAlpha>mgMeshSetVtxColorAlpha</A>, 
<A HREF=#mgMeshSetVtxNormal>mgMeshSetVtxNormal</A>, <A HREF=#mgMeshGetVtxUV>mgMeshGetVtxUV</A></DD></DL>
<HR>
<LEFT><A NAME=mgMeshSetVtxNormal><H1 CLASS="APISYMBOL">mgMeshSetVtxNormal</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMeshSetVtxNormal</B> - sets the normal vector for 
a vertex in a mesh.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMeshSetVtxNormal</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>vtxIndex</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>i</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>j</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>k</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This function sets the <I>i</I>, <I>j</I>, and <I>k</I> values of the 
normal vector of the vertex at index <I>vtxIndex</I> in the vertex pool of 
mesh node <I>rec</I>.</P></DD><DD><P>Note: The first vertex in the mesh vertex pool is at index 0.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 node</DD><DT><I>vtxIndex</I></DT><DD>the vertex number in the mesh starting at 0</DD><DT><I>i</I></DT><DD>the i component of normal vector</DD><DT><I>j</I></DT><DD>the j component of normal vector</DD><DT><I>k</I></DT><DD>the k component of normal vector</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the vertex data was set 
successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.  This function will fail 
if <I>rec</I> is not a valid mesh node, if the vertex at <I>vtxIndex</I> 
does not exist in the mesh, or if the vertex mask for the mesh does 
not specify that the vertices have normals.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshCreateVtxPool>mgMeshCreateVtxPool</A>, <A HREF=#mgMeshCreatePrimitives>mgMeshCreatePrimitives</A>, 
<A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshSetVtxMask>mgMeshSetVtxMask</A>, <A HREF=#mgMeshPrimitiveGetNumVtx>mgMeshPrimitiveGetNumVtx</A>, 
<A HREF=#mgMeshPrimitiveGetVtxIndexArray>mgMeshPrimitiveGetVtxIndexArray</A>, 
<A HREF=#mgMeshSetVtxCoord>mgMeshSetVtxCoord</A>, <A HREF=#mgMeshSetVtxColor>mgMeshSetVtxColor</A>, <A HREF=#mgMeshSetVtxColorRGBA>mgMeshSetVtxColorRGBA</A>, 
<A HREF=#mgMeshSetVtxColorRGB>mgMeshSetVtxColorRGB</A>, <A HREF=#mgMeshSetVtxColorAlpha>mgMeshSetVtxColorAlpha</A>, <B>mgMeshSetVtxNormal</B>, 
<A HREF=#mgMeshSetVtxUV>mgMeshSetVtxUV</A>, <A HREF=#mgMeshGetVtxNormal>mgMeshGetVtxNormal</A></DD></DL>
<HR>
<LEFT><A NAME=mgMeshSetVtxUV><H1 CLASS="APISYMBOL">mgMeshSetVtxUV</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMeshSetVtxUV</B> - sets the u,v texture coordinate 
for a vertex in a mesh.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMeshSetVtxUV</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>vtxIndex</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>layer</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>u</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>v</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This function sets the <I>u</I> and <I>v</I> texture coordinate 
values for layer <I>layer</I> of the vertex at index <I>vtxIndex</I> in 
the vertex pool of mesh node <I>rec</I>.</P></DD><DD><P>Note: The first vertex in the mesh vertex pool is at index 0.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 node</DD><DT><I>vtxIndex</I></DT><DD>the vertex number in the mesh starting at 0</DD><DT><I>layer</I></DT><DD>the layer number 0..7</DD><DT><I>u</I></DT><DD>the u texture coordinate</DD><DT><I>v</I></DT><DD>the v texture coordinate</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the vertex data was set 
successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.  This function will fail 
if <I>rec</I> is not a valid mesh node, if the vertex at <I>vtxIndex</I> 
does not exist in the mesh, or if the vertex mask for the mesh does 
not specify that the vertices have texture coordinates for layer 
<I>layer</I>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshCreateVtxPool>mgMeshCreateVtxPool</A>, <A HREF=#mgMeshCreatePrimitives>mgMeshCreatePrimitives</A>, 
<A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshSetVtxMask>mgMeshSetVtxMask</A>, <A HREF=#mgMeshPrimitiveGetNumVtx>mgMeshPrimitiveGetNumVtx</A>, 
<A HREF=#mgMeshPrimitiveGetVtxIndexArray>mgMeshPrimitiveGetVtxIndexArray</A>, 
<A HREF=#mgMeshSetVtxCoord>mgMeshSetVtxCoord</A>, <A HREF=#mgMeshSetVtxColor>mgMeshSetVtxColor</A>, <A HREF=#mgMeshSetVtxColorRGBA>mgMeshSetVtxColorRGBA</A>, 
<A HREF=#mgMeshSetVtxColorRGB>mgMeshSetVtxColorRGB</A>, <A HREF=#mgMeshSetVtxColorAlpha>mgMeshSetVtxColorAlpha</A>, 
<A HREF=#mgMeshSetVtxNormal>mgMeshSetVtxNormal</A>, <A HREF=#mgMeshGetVtxUV>mgMeshGetVtxUV</A></DD></DL>
<HR>
<LEFT><A NAME=mgMessageDialog><H1 CLASS="APISYMBOL">mgMessageDialog</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMessageDialog</B> - displays modal message dialog.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgMessageDialog</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>parent</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>title</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>messageText</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>flags</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMessageDialog</B> displays a modal dialog that contains a text 
message, an icon and any combination of push button controls. You 
specify which icon and which combination of push buttons 
using the parameter <I>flags</I>.  The value of <I>flags</I> is the bitwise 
combination of masks as described here.</P></DD><DD><P>Choose one mask from the following group 
to specify which icon to display.</P></DD><DD><P><A HREF=#MMBX_STATUS>MMBX_STATUS</A> displays an informational icon (lower case i in a circle). 
<BR><A HREF=#MMBX_WARNING>MMBX_WARNING</A> displays a warning icon (exclamation point). 
<BR><A HREF=#MMBX_ERROR>MMBX_ERROR</A> displays a warning icon (stop sign). 
<BR><A HREF=#MMBX_QUESTION>MMBX_QUESTION</A> displays a warning icon (question mark).</P></DD><DD><P>Choose one mask from the following group to specify which 
combination of push buttons to display.</P></DD><DD><P><A HREF=#MMBX_OK>MMBX_OK</A> displays a single button "OK". 
<BR><A HREF=#MMBX_OKCANCEL>MMBX_OKCANCEL</A> displays two buttons "OK" and "Cancel". 
<BR><A HREF=#MMBX_YESNO>MMBX_YESNO</A> displays two buttons "Yes" and "No". 
<BR><A HREF=#MMBX_YESNOCANCEL>MMBX_YESNOCANCEL</A> displays three buttons "Yes", "No" and "Cancel".</P></DD><DD><P>You must select one and only one mask from each group listed above.  If 
you do not select a mask from each group or select more than one from either group, 
the results are undefined.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The dialog is created as a child of the specified dialog <I>parent</I>. 
If you specify <I>parent</I> as <A HREF=#MG_NULL>MG_NULL</A>, the dialog is created as a 
child of the Creator main window.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>Currently the <I>parent</I> parameter is reserved for future enhancement 
and should be specified as <B>None</B>.  For now the dialog is created as a child 
of the main Creator main window.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>parent</I></DT><DD>the dialog parent to attach the prompt dialog</DD><DT><I>title</I></DT><DD>the title string for the dialog</DD><DT><I>messageText</I></DT><DD>the message text to display in the dialog</DD><DT><I>flags</I></DT><DD>flags to specify which icon and push button 
controls to display in the dialog</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns integer value indicating which push button was pressed by the user 
to dismiss the dialog.  The return value depends on the push button combination 
you specified in the <I>flags</I> parameter. <BR>
For <A HREF=#MMBX_OK>MMBX_OK</A>, the return value 
is always 1 (OK).  <BR>
For <A HREF=#MMBX_OKCANCEL>MMBX_OKCANCEL</A>, the return value is 
either 1 (OK) or 2 (Cancel).  <BR>
For <A HREF=#MMBX_YESNO>MMBX_YESNO</A>, the return value 
is either 1 (Yes) or 2 (No).  <BR>
For <A HREF=#MMBX_YESNOCANCEL>MMBX_YESNOCANCEL</A>, 
the return value is either 1 (Yes), 2 (No), or 3 (Cancel).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<HR>
<LEFT><A NAME=mgModelingPrefGetDouble><H1 CLASS="APISYMBOL">mgModelingPrefGetDouble</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgModelingPrefGetDouble</B> - gets a double precision floating 
point preference value from the modeling preferences.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgModelingPrefGetDouble</B> (</TD><TD>const <A HREF=#mgmodelingprefname>mgmodelingprefname</A></TD><TD><I>prefName</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>prefValue</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, prefValue <B>mgModelingPrefGetDouble</B> (</TD><TD><A HREF=#mgmodelingprefname>mgmodelingprefname</A></TD><TD><I>prefName</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>defaultValue</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgModelingPrefGetDouble</B> retrieves a double value from a 
named preference key, <I>prefName</I>, and stores it in <I>prefValue</I>. 
If the key <I>prefName</I> does not exist, the value specified by 
<I>defaultValue</I> is returned.</P></DD><DD><P>Currently only a small subset of the modeling preference values 
are accessible.  For a complete list, see <A HREF=#mgmodelingprefname>mgmodelingprefname</A>.</P></DD><DD><P>Note that the prefix of the key, either <B>MPREFD</B> or <B>MPREFI</B>, 
indicates whether the corresponding preference value is double or integer, 
respectively.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>prefName</I></DT><DD>the preference key name</DD><DT><I>prefValue</I></DT><DD>storage location for the preference value</DD><DT><I>defaultValue</I></DT><DD>default value returned if <I>prefName</I> 
not found</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the key <I>prefName</I> represents a 
valid modeling preference and the value can be represented by a double 
value, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>prefValue</DT><DD>If function is successful, prefValue contains the retrieved 
value, otherwise it will contain <I>defaultValue</I>.</DD></DL></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show how to get the Match 
Vertex Tolerance preference value.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgbool ok;
double tolerance;
ok = mgModelingPrefGetDouble (MPREFD_MATCHVERTEXTOLERANCE, &tolerance, 0.001)</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">ok, tolerance = mgModelingPrefGetDouble (MPREFD_MATCHVERTEXTOLERANCE, 0.001)</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A>, <A HREF=#mgmodelingprefname>mgmodelingprefname</A></DD></DL>
<HR>
<LEFT><A NAME=mgModelingPrefGetInteger><H1 CLASS="APISYMBOL">mgModelingPrefGetInteger</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgModelingPrefGetInteger</B> - gets an integer preference 
value from the modeling preferences.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgModelingPrefGetInteger</B> (</TD><TD>const <A HREF=#mgmodelingprefname>mgmodelingprefname</A></TD><TD><I>prefName</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>prefValue</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, prefValue <B>mgModelingPrefGetInteger</B> (</TD><TD><A HREF=#mgmodelingprefname>mgmodelingprefname</A></TD><TD><I>prefName</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>defaultValue</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgModelingPrefGetInteger</B> retrieves an integer value from a 
named preference key, <I>prefName</I>, and stores it in <I>prefValue</I>. 
If the key <I>prefName</I> does not exist, the value specified by 
<I>defaultValue</I> is returned.</P></DD><DD><P>Currently only a small subset of the modeling preference values 
are accessible.  For a complete list, see <A HREF=#mgmodelingprefname>mgmodelingprefname</A>.</P></DD><DD><P>Note that the prefix of the key, either <B>MPREFD</B> or <B>MPREFI</B>, 
indicates whether the corresponding preference value is double or integer, 
respectively.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>prefName</I></DT><DD>the preference key name</DD><DT><I>prefValue</I></DT><DD>storage location for the preference value</DD><DT><I>defaultValue</I></DT><DD>default value returned if <I>prefName</I> 
not found</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the key <I>prefName</I> represents a 
valid modeling preference and the value can be represented by an integer 
value, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>prefValue</DT><DD>If function is successful, prefValue contains the retrieved 
value, otherwise it will contain <I>defaultValue</I>.</DD></DL></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show how to get the Auto 
Apply Material (boolean) preference value.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgbool ok;
int autoApply;
ok = mgModelingPrefGetInteger (MPREFI_AUTOAPPLYMATERIAL, &autoApply, MG_TRUE)</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">ok, autoApply = mgModelingPrefGetInteger (MPREFI_AUTOAPPLYMATERIAL, MG_TRUE)</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgModelingPrefGetDouble>mgModelingPrefGetDouble</A>, <A HREF=#mgmodelingprefname>mgmodelingprefname</A></DD></DL>
<HR>
<LEFT><A NAME=mgModelingPrefSetDouble><H1 CLASS="APISYMBOL">mgModelingPrefSetDouble</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgModelingPrefSetDouble</B> - sets a double precision floating 
point preference value in the modeling preferences.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgModelingPrefSetDouble</B> (</TD><TD>const <A HREF=#mgmodelingprefname>mgmodelingprefname</A></TD><TD><I>prefName</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>prefValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgModelingPrefSetDouble</B> sets the modeling preference named <I>prefName</I> 
to the value <I>prefValue</I>.</P></DD><DD><P>Currently only a small subset of the modeling preference values 
are accessible.  For a complete list, see <A HREF=#mgmodelingprefname>mgmodelingprefname</A>.</P></DD><DD><P>Note that the prefix of the key, either <B>MPREFD</B> or <B>MPREFI</B>, 
indicates whether the corresponding preference value is double or integer, 
respectively.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>prefName</I></DT><DD>the preference key name</DD><DT><I>prefValue</I></DT><DD>the value to set</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the key <I>prefName</I> represents a 
valid modeling preference and the value was set, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgModelingPrefSetInteger>mgModelingPrefSetInteger</A>, 
<A HREF=#mgModelingPrefGetDouble>mgModelingPrefGetDouble</A>, <A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A>, 
<A HREF=#mgmodelingprefname>mgmodelingprefname</A></DD></DL>
<HR>
<LEFT><A NAME=mgModelingPrefSetInteger><H1 CLASS="APISYMBOL">mgModelingPrefSetInteger</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgModelingPrefSetInteger</B> - sets an integer preference 
value in the modeling preferences.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgModelingPrefSetInteger</B> (</TD><TD>const <A HREF=#mgmodelingprefname>mgmodelingprefname</A></TD><TD><I>prefName</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>prefValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgModelingPrefSetInteger</B> sets the modeling preference named 
<I>prefName</I> to the value <I>prefValue</I>.</P></DD><DD><P>Currently only a small subset of the modeling preference values 
are accessible.  For a complete list, see <A HREF=#mgmodelingprefname>mgmodelingprefname</A>.</P></DD><DD><P>Note that the prefix of the key, either <B>MPREFD</B> or <B>MPREFI</B>, 
indicates whether the corresponding preference value is double or integer, 
respectively.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>prefName</I></DT><DD>the preference key name</DD><DT><I>prefValue</I></DT><DD>the value to set</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the key <I>prefName</I> represents a 
valid modeling preference and the value was set, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgModelingPrefSetDouble>mgModelingPrefSetDouble</A>, 
<A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A>, <A HREF=#mgModelingPrefGetDouble>mgModelingPrefGetDouble</A>, 
<A HREF=#mgmodelingprefname>mgmodelingprefname</A></DD></DL>
<HR>
<LEFT><A NAME=mgMoreDetail><H1 CLASS="APISYMBOL">mgMoreDetail</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMoreDetail</B> - changes the level of detail (LOD) for a database to the next higher level.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMoreDetail</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMoreDetail</B> changes the current switch-in distance of the database to a smaller value (effectively 
moving the eyepoint closer to the model) such that the next higher level of detail becomes visible in the scene. 
The function then changes the visibility of each LOD node according to whether or not it would be 
visible at this new switch-in (eyepoint) distance.  The visibility of the LOD node is 
set or unset using the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltIOn>fltIOn</A>
 attribute of the node.</P></DD><DD><P><B>mgMoreDetail</B> returns <A HREF=#mgbool>MG_FALSE</A> if there is no higher level of detail or if the <I>db</I> 
provided is not a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHeader</A>
 node.  If the database does not contain any LOD nodes, the first call 
to <B>mgMoreDetail</B> returns <A HREF=#mgbool>MG_TRUE</A>, while subsequent calls return <A HREF=#mgbool>MG_FALSE</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> if there is no higher level 
of detail or if <I>db</I> is not a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHeader</A>
 node.
</DD></DL><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show how you might use <B>mgMoreDetail</B> to determine 
which nodes are visible in the scene at each level of detail.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">static mgbool
PrintNodeNameInLOD (mgrec* db, mgrec* parent, mgrec* rec, void* userData)
{
   // prints the name of each node visited.
   int* lodNumPtr = (int*) userData;
   int lodNum = *lodNumPtr;

   char* name = mgGetName (rec);
   printf ("Node: %s, is part of LOD %d", name, lodNum);
   mgFree (name);
   return (MG_TRUE);
}

// start at the lowest level of detail
int lodNumber = 0;
mgLeastDetail (db);
// print names of nodes that are "visible" in this level of detail
mgWalk (db, PrintNodeNameInLOD, MG_NULL, &lodNumber, MWALK_ON);

// go to next higher level of detail
while (mgMoreDetail (db)) {
   lodNumber++;
   // print names of nodes that are "visible" in this level of detail
   mgWalk (db, PrintNodeNameInLOD, MG_NULL, &lodNumber, MWALK_ON);
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">def PrintNodeNameInLOD (db, parent, rec, lodNum):
   # prints the name of each node visited.
   name = mgGetName (rec)
   print "Node:", name, "is part of LOD", lodNum
   return MG_TRUE

# start at the lowest level of detail
db = mgGetCurrentDb()
lodNumber = 0
mgLeastDetail (db)
# print names of nodes that are "visible" in this level of detail
mgWalk (db, PrintNodeNameInLOD, None, lodNumber, MWALK_ON)

# go to next higher level of detail
while (mgMoreDetail (db)):
   lodNumber = lodNumber + 1
   # print names of nodes that are "visible" in this level of detail
   mgWalk (db, PrintNodeNameInLOD, None, lodNumber, MWALK_ON)</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgLeastDetail>mgLeastDetail</A>, <A HREF=#mgLessDetail>mgLessDetail</A>, <A HREF=#mgMostDetail>mgMostDetail</A>, <A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A></DD></DL>
<HR>
<LEFT><A NAME=mgMostDetail><H1 CLASS="APISYMBOL">mgMostDetail</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMostDetail</B> - changes the level of detail (LOD) for a database to the highest level.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMostDetail</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMostDetail</B> changes the current switch-in distance of the database to the lowest value (effectively 
moving the eyepoint very close to the model) such that the highest level of detail becomes visible in the scene. 
The function then changes the visibility of each LOD node according to whether or not it would be 
visible at this new switch-in (eyepoint) distance.  The visibility of the LOD node is 
set or unset using the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltIOn>fltIOn</A>
 attribute of the node.</P></DD><DD><P>If there are no LOD nodes in the database, <B>mgMostDetail</B> does nothing and returns 
<A HREF=#mgbool>MG_TRUE</A>, since the database is already at the highest (and lowest) level of detail. 
If <I>db</I> is not a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHeader</A>
 node, <B>mgMostDetail</B> will return <A HREF=#mgbool>MG_FALSE</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>See <A HREF=#mgLessDetail>mgLessDetail</A> for an example of how you might use <B>mgMostDetail</B> in conjunction 
with <A HREF=#mgLessDetail>mgLessDetail</A> to determine which nodes are visible in the scene at each level of detail.</DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgLeastDetail>mgLeastDetail</A>, <A HREF=#mgMoreDetail>mgMoreDetail</A>, <A HREF=#mgLessDetail>mgLessDetail</A>, <A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A></DD></DL>
<HR>
<LEFT><A NAME=mgMoveTexture><H1 CLASS="APISYMBOL">mgMoveTexture</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgMoveTexture</B> - moves a texture palette entry from one 
index to another.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgMoveTexture</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>srcIndex</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>dstIndex</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgMoveTexture</B> moves the texture palette entry specified 
by <I>srcIndex</I> to a different index <I>dstIndex</I> in the texture palette.</P></DD><DD><P>Note that this function does not update any node in the database 
that might be referencing this texture at the old index.  It is the caller's 
responsibility (if desired) to update any corresponding geometry to reflect 
the new texture index.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>srcIndex</I></DT><DD>the index of the texture palette entry to move</DD><DT><I>dstIndex</I></DT><DD>the index to which it move the texture palette entry</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>srcIndex</I> does not refer to a valid texture 
palette entry.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadTexture>mgReadTexture</A>, <A HREF=#mgReplaceTexture>mgReplaceTexture</A>, <A HREF=#mgInsertTexture>mgInsertTexture</A>, <A HREF=#mgDeleteTexture>mgDeleteTexture</A></DD></DL>
<HR>
<LEFT><A NAME=mgNameOfLightPointAnimation><H1 CLASS="APISYMBOL">mgNameOfLightPointAnimation</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNameOfLightPointAnimation</B> - gets the name of an indexed 
entry in the light point appearance palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char* <B>mgNameOfLightPointAnimation</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNameOfLightPointAnimation</B> returns the name of the entry 
specified by <I>index</I> in the light point appearance palette for database 
<I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned string in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the entry to look up</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the name of the entry if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetLightPointAppearance>mgGetLightPointAppearance</A>, 
<A HREF=#mgGetLightPointAppearanceCount>mgGetLightPointAppearanceCount</A>, 
<A HREF=#mgIndexOfLightPointAppearance>mgIndexOfLightPointAppearance</A>, 
<A HREF=#mgGetFirstLightPointAppearance>mgGetFirstLightPointAppearance</A>, 
<A HREF=#mgGetNextLightPointAppearance>mgGetNextLightPointAppearance</A>, 
<A HREF=#mgGetLightPointAnimation>mgGetLightPointAnimation</A>, 
<A HREF=#mgGetLightPointAnimationCount>mgGetLightPointAnimationCount</A>, 
<A HREF=#mgIndexOfLightPointAnimation>mgIndexOfLightPointAnimation</A>, 
<A HREF=#mgGetFirstLightPointAnimation>mgGetFirstLightPointAnimation</A>, 
<A HREF=#mgGetNextLightPointAnimation>mgGetNextLightPointAnimation</A></DD></DL>
<HR>
<LEFT><A NAME=mgNameOfLightPointAppearance><H1 CLASS="APISYMBOL">mgNameOfLightPointAppearance</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNameOfLightPointAppearance</B> - gets the name of an indexed 
entry in the light point appearance palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char* <B>mgNameOfLightPointAppearance</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNameOfLightPointAppearance</B> returns the name of the entry 
specified by <I>index</I> in the light point appearance palette for database 
<I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned string in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the entry to look up</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the name of the entry if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetLightPointAppearance>mgGetLightPointAppearance</A>, 
<A HREF=#mgGetLightPointAppearanceCount>mgGetLightPointAppearanceCount</A>, 
<A HREF=#mgIndexOfLightPointAppearance>mgIndexOfLightPointAppearance</A>, 
<A HREF=#mgGetFirstLightPointAppearance>mgGetFirstLightPointAppearance</A>, 
<A HREF=#mgGetNextLightPointAppearance>mgGetNextLightPointAppearance</A>, 
<A HREF=#mgGetLightPointAnimation>mgGetLightPointAnimation</A>, 
<A HREF=#mgGetLightPointAnimationCount>mgGetLightPointAnimationCount</A>, 
<A HREF=#mgIndexOfLightPointAnimation>mgIndexOfLightPointAnimation</A>, 
<A HREF=#mgNameOfLightPointAnimation>mgNameOfLightPointAnimation</A>, 
<A HREF=#mgGetFirstLightPointAnimation>mgGetFirstLightPointAnimation</A>, 
<A HREF=#mgGetNextLightPointAnimation>mgGetNextLightPointAnimation</A></DD></DL>
<HR>
<LEFT><A NAME=mgNameOfLightSource><H1 CLASS="APISYMBOL">mgNameOfLightSource</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNameOfLightSource</B> - gets the name of a light 
source palette entry.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char* <B>mgNameOfLightSource</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNameOfLightSource</B> returns the name of light 
source entry record <I>index</I> in the light source palette of <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned string in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the light source entry to 
search for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the name of the light source entry if found, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetLightSource>mgGetLightSource</A>, <A HREF=#mgIndexOfLightSource>mgIndexOfLightSource</A></DD></DL>
<HR>
<LEFT><A NAME=mgNameOfMaterial><H1 CLASS="APISYMBOL">mgNameOfMaterial</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNameOfMaterial</B> - gets the name of a material palette entry.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char* <B>mgNameOfMaterial</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><I>mgNameOfMaterial</I> returns the name of the material entry record 
<I>index</I> in the material palette of database node <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned string in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the material palette entry</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the name of the material if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetMaterial>mgGetMaterial</A>, <A HREF=#mgIndexOfMaterial>mgIndexOfMaterial</A>, <A HREF=#mgNewMaterial>mgNewMaterial</A></DD></DL>
<HR>
<LEFT><A NAME=mgNameOfShader><H1 CLASS="APISYMBOL">mgNameOfShader</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNameOfShader</B> - gets the name of a shader palette entry.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char* <B>mgNameOfShader</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><I>mgNameOfShader</I> returns the name of the shader entry record 
<I>index</I> in the shader palette of database node <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned string in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the shader palette entry</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the name of the shader if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetShader>mgGetShader</A>, <A HREF=#mgIndexOfShader>mgIndexOfShader</A>, <A HREF=#mgNewShader>mgNewShader</A></DD></DL>
<HR>
<LEFT><A NAME=mgNameOfSound><H1 CLASS="APISYMBOL">mgNameOfSound</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNameOfSound</B> - gets the name of a sound palette entry.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char* <B>mgNameOfSound</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNameOfSound</B> returns the name of sound entry record with 
<I>index</I> in the sound palette of <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned string in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the sound entry</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the sound entry name if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetSound>mgGetSound</A>, <A HREF=#mgIndexOfSound>mgIndexOfSound</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewColorName><H1 CLASS="APISYMBOL">mgNewColorName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewColorName</B> - adds a name to a color palette 
entry&#146s name list.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgNewColorName</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>name</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a database node, <I>db</I>, and an index into the color palette, 
<I>index</I>, <B>mgNewColorName</B> adds the color name <I>name</I> to the color 
name list for <I>index</I>.  It is assumed that <I>name</I> is not already in 
the color name list of any index, therefore no search is performed.</P></DD><DD><P>Color palette entries can have multiple names assigned, one of which 
is the "current" name for that entry.  The current name of a color palette 
entry is not assigned by default.  You must explicitly call 
<A HREF=#mgSetCurrentColorName>mgSetCurrentColorName</A> to set the current name for a color 
palette entry.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the color palette index</DD><DT><I>name</I></DT><DD>the name to add to the name list of <I>index</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>name</I> is NULL or empty.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgDeleteColorName>mgDeleteColorName</A>, <A HREF=#mgSetCurrentColorName>mgSetCurrentColorName</A>, 
<A HREF=#mgGetPolyColorName>mgGetPolyColorName</A>, <A HREF=#mgSetPolyColorName>mgSetPolyColorName</A>, 
<A HREF=#mgGetPolyAltColorName>mgGetPolyAltColorName</A>, <A HREF=#mgSetPolyAltColorName>mgSetPolyAltColorName</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewConstructEdge><H1 CLASS="APISYMBOL">mgNewConstructEdge</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewConstructEdge</B> - creates a construction edge node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgNewConstructEdge</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNewConstructEdge</B> creates a new construction edge node 
with the specified endpoint coordinates, <I>coord1</I> and <I>coord2</I>. 
The new construction node is created in the database associated 
with the specified editor context, <I>editorContext</I>.</P></DD><DD><P>If either <I>coord1</I> or <I>coord2</I> is <A HREF=#MG_NULL>MG_NULL</A>, the corresponding 
coordinate of the edge is assigned (0.0, 0.0, 0.0).</P></DD><DD><P>A construction edge is actually composed of two construction 
vertex nodes.  This function returns the first vertex node of the edge 
created.  Calling <A HREF=#mgGetNext>mgGetNext</A> for the first vertex of the edge is 
return the second vertex of the edge.</P></DD><DD><P>The attributes of either vertex of a construction edge can be 
accessed like any other <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 node using <A HREF=#mgGetAttList>mgGetAttList</A> and 
<A HREF=#mgSetAttList>mgSetAttList</A>.  The edge returned, however, should not be explicitly 
attached to other geometry nodes in the database.  Doing so will yield 
undefined results.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context used to identify 
the database in which the construction 
edge is to be created</DD><DT><I>coord1</I></DT><DD>address of record containing initial 
coordinates of first vertex of construction edge</DD><DT><I>coord2</I></DT><DD>address of record containing initial 
coordinates of second vertex of construction edge</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns first vertex node of construction edge created if successful, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetConstructEdgeCoords>mgSetConstructEdgeCoords</A>, <A HREF=#mgSetConstructEdgeColor>mgSetConstructEdgeColor</A>, 
<A HREF=#mgDeleteConstructEdge>mgDeleteConstructEdge</A>, <A HREF=#mgNewConstructVertex>mgNewConstructVertex</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewConstructVertex><H1 CLASS="APISYMBOL">mgNewConstructVertex</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewConstructVertex</B> - create a construction vertex node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgNewConstructVertex</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNewConstructVertex</B> creates a new construction vertex node 
with the specified coordinates, <I>coord</I>.  The new construction node 
is created in the database associated with the specified editor 
context, <I>editorContext</I>.</P></DD><DD><P>If <I>coord</I> is <A HREF=#MG_NULL>MG_NULL</A>, the coordinates assigned to the new 
construction vertex will be (0.0, 0.0, 0.0).</P></DD><DD><P>The attributes of the construction vertex node returned can be 
accessed like any other <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 node using <A HREF=#mgGetAttList>mgGetAttList</A> and 
<A HREF=#mgSetAttList>mgSetAttList</A>.  The node returned, however, should not be explicitly 
attached to other geometry nodes in the database.  Doing so yields 
undefined results.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context used to identify 
the database in which the construction 
vertex is to be created</DD><DT><I>coord</I></DT><DD>address of record containing initial 
coordinates of new construction vertex</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns construction node created if successful, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetConstructVertexCoords>mgSetConstructVertexCoords</A>, <A HREF=#mgSetConstructVertexColor>mgSetConstructVertexColor</A>, 
<A HREF=#mgDeleteConstructVertex>mgDeleteConstructVertex</A>, <A HREF=#mgNewConstructEdge>mgNewConstructEdge</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewConvexHullBuilder><H1 CLASS="APISYMBOL">mgNewConvexHullBuilder</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewConvexHullBuilder</B> - creates and returns a 
convex hull builder object.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgconvexhullbuilder <B>mgNewConvexHullBuilder</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNewConvexHullBuilder</B> creates a convex hull builder object that 
can be used to build a convex hull around an arbitrary set of points.</P></DD><DD><P>Use the function <A HREF=#mgConvexHullBuilderExpandCoord3d>mgConvexHullBuilderExpandCoord3d</A> to add points 
used in the calculation of the convex hull. Use <A HREF=#mgConvexHullBuilderClose>mgConvexHullBuilderClose</A> 
after you have "added" all the points you want to use in the construction 
of the convex hull.  Using the points you have added 
<A HREF=#mgConvexHullBuilderClose>mgConvexHullBuilderClose</A> will calculate and return a convex hull object 
around those points.</P></DD><DD><P>Use the function <A HREF=#mgFreeConvexHullBuilder>mgFreeConvexHullBuilder</A> to dispose of the convex 
hull builder object when you are through using it.</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the convex hull builder object if successful, <A HREF=#MG_NULL>MG_NULL</A> otherwise. 
Use the function <A HREF=#mgFreeConvexHull>mgFreeConvexHull</A> to dispose of the convex hull object 
returned when you are through using it.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows how to use a convex hull builder to build 
a convex hull around the unit cube.</DT><DT><PRE CLASS="EXAMPLE">// create a convex hull builder
mgcoord3d p;
mgconvexhull hull;
mgconvexhullbuilder hullBuilder = mgNewConvexHullBuilder ();

// add the points of the unit cube to the convex hull builder

p = mgMakeCoord3d (0.0, 0.0, 0.0);
mgConvexHullBuilderExpandCoord3d (hullBuilder, &p);

p = mgMakeCoord3d (1.0, 0.0, 0.0);
mgConvexHullBuilderExpandCoord3d (hullBuilder, &p);

p = mgMakeCoord3d (1.0, 1.0, 0.0);
mgConvexHullBuilderExpandCoord3d (hullBuilder, &p);

p = mgMakeCoord3d (0.0, 1.0, 0.0);
mgConvexHullBuilderExpandCoord3d (hullBuilder, &p);

p = mgMakeCoord3d (0.0, 0.0, 1.0);
mgConvexHullBuilderExpandCoord3d (hullBuilder, &p);

p = mgMakeCoord3d (1.0, 0.0, 1.0);
mgConvexHullBuilderExpandCoord3d (hullBuilder, &p);

p = mgMakeCoord3d (1.0, 1.0, 1.0);
mgConvexHullBuilderExpandCoord3d (hullBuilder, &p);

p = mgMakeCoord3d (0.0, 1.0, 1.0);
mgConvexHullBuilderExpandCoord3d (hullBuilder, &p);

// all done adding points, close and build convex hull
hull = mgConvexHullBuilderClose (hullBuilder);

// do something with the convex hull here...

// free the convex hull to avoid a memory leak
mgFreeConvexHull (hull);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgConvexHullBuilderExpandCoord3d>mgConvexHullBuilderExpandCoord3d</A>, <A HREF=#mgConvexHullBuilderClose>mgConvexHullBuilderClose</A>, 
<A HREF=#mgFreeConvexHullBuilder>mgFreeConvexHullBuilder</A>, <A HREF=#mgGetConvexHull>mgGetConvexHull</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewDb><H1 CLASS="APISYMBOL">mgNewDb</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewDb</B> - creates a new database.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgNewDb</B> (</TD><TD>const char*</TD><TD><I>fileName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNewDb</B> creates a new database with the specified file 
name <I>fileName</I>. The new database consists of a database node and two 
default group nodes <B>g1</B> and <B>g2</B> as shown here:<BR> 
<IMG SRC="../common/mgNewDb.jpg">
</P></DD><DD><P>The database node is returned by this function.</P></DD><DD><P>The behavior of <B>mgNewDb</B> is affected by the function: 
<A HREF=#mgSetNewOverwriteFlag>mgSetNewOverwriteFlag</A>.</P></DD><DD><P>Note: If your plug-in or script opens a file in the Creator modeling 
environment with this function or <A HREF=#mgOpenDb>mgOpenDb</A>, the file is not opened in an 
active window on the Creator desktop. Your plug-in or script can still access 
the database but must explicitly save and close the file when done.</P></DD><DD><P>Note: If invoked from within the modeler environment, this function 
will fail if the named file is already open in an active window.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>fileName</I></DT><DD>the name of the new database file</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a pointer to the new database node if successful, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example creates a new database.</DT><DT><PRE CLASS="EXAMPLE">mgrec* db;
db = mgNewDb ("newfile.flt");
// note that child of db is g1 and child of g1 is g2.</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgOpenDb>mgOpenDb</A>, <A HREF=#mgWriteDb>mgWriteDb</A>, <A HREF=#mgCloseDb>mgCloseDb</A>, 
<A HREF=#mgSetNewOverwriteFlag>mgSetNewOverwriteFlag</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewEditorContext><H1 CLASS="APISYMBOL">mgNewEditorContext</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewEditorContext</B> - creates an editor context.<P></DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For C)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgeditorcontext <B>mgNewEditorContext</B> (</TD><TD>const char*</TD><TD><I>toolName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNewEditorContext</B> creates an editor context for a script plug-in 
named <I>toolName</I>.</P></DD><DD><P>A unique editor context is required when running an OpenFlight script 
that edits an open database.  Use this function in your script to create and 
return an editor context.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>Note that this function is for OpenFlight Scripts only and should not 
be used by your C language plug-in.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>toolName</I></DT><DD>the name of the tool in your 
plug-in script</DD></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT>The following shows how you might use this function in your script:</DT><DT><PRE CLASS="EXAMPLE">def Delete():
   toolName = "Delete"
   editorContext = mgNewEditorContext(toolName)

   if (not editorContext):
      mgSendMessage (MMSG_ERROR, "Failed creating Editor Context")
      return

   mgSendMessage (MMSG_STATUS, "Editor Context Created");

   db = mgEditorGetDbRec (editorContext)
   geometry = mgGetSelectList (db)
   num = mgGetRecListCount (geometry)

   if (num == 0):
      mgSendMessage (MMSG_ERROR, "Nothing Selected")
      return

   for i in range (1, num+1):
      rec,matrix = mgGetNextRecInList (geometry)
      if (i==1): mgEditorAddUndoForDelete (editorContext, toolName, rec)
      else: mgEditorAppendUndoForDelete (editorContext, rec)

Delete ()</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgEditorGetDbRec>mgEditorGetDbRec</A>, <A HREF=#mgEditorAddUndo>mgEditorAddUndo</A>, 
<A HREF=#mgEditorAppendUndo>mgEditorAppendUndo</A>, <A HREF=#mgEditorResetUndo>mgEditorResetUndo</A>, 
<A HREF=#mgEditorAddRedo>mgEditorAddRedo</A>, <A HREF=#mgEditorAddUndoForRedo>mgEditorAddUndoForRedo</A>, 
<A HREF=#mgEditorAddUndoForCreate>mgEditorAddUndoForCreate</A>, <A HREF=#mgEditorAppendUndoForCreate>mgEditorAppendUndoForCreate</A>, 
<A HREF=#mgEditorAddUndoForDelete>mgEditorAddUndoForDelete</A>, <A HREF=#mgEditorAppendUndoForDelete>mgEditorAppendUndoForDelete</A>, 
<A HREF=#mgEditorAddUndoForMove>mgEditorAddUndoForMove</A>, <A HREF=#mgEditorAppendUndoForMove>mgEditorAppendUndoForMove</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewImageGeoInfo><H1 CLASS="APISYMBOL">mgNewImageGeoInfo</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewImageGeoInfo</B> - reads the georeference information 
from an image file.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgimagegeoinfo <B>mgNewImageGeoInfo</B> (</TD><TD>const char*</TD><TD><I>textureName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNewImageGeoInfo</B> reads the georeference information of an 
image on disk and returns a georeference info object containing the 
information read. &#32The parameter <I>textureName</I> is the name of the image file.</P></DD><DD><P>This function is similar to <A HREF=#mgReadImageGeoInfo>mgReadImageGeoInfo</A> except that it 
returns the georeference info object directly instead of returning it as an 
output parameter as <A HREF=#mgReadImageGeoInfo>mgReadImageGeoInfo</A> does.  Use <A HREF=#mgReadImageGeoInfo>mgReadImageGeoInfo</A> 
if you need the texture error code on failure.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>When you are through with the returned georeference info object, 
you must free it by calling <A HREF=#mgFreeImageGeoInfo>mgFreeImageGeoInfo</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned georeference info object in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>textureName</I></DT><DD>the name of the image file</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns georeference info object if successful, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadImageGeoInfo>mgReadImageGeoInfo</A>, <A HREF=#mgFreeImageGeoInfo>mgFreeImageGeoInfo</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewImageInfo><H1 CLASS="APISYMBOL">mgNewImageInfo</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewImageInfo</B> - reads the header information from 
an image file.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgimageinfo <B>mgNewImageInfo</B> (</TD><TD>const char*</TD><TD><I>textureName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNewImageInfo</B> reads the header of an image on disk and then 
returns an image object with the information read. 
The parameter <I>textureName</I> is the name of the image file.</P></DD><DD><P>This function is similar to <A HREF=#mgReadImageInfo>mgReadImageInfo</A> except that it 
returns the image info object directly instead of returning it as an 
output parameter as <A HREF=#mgReadImageInfo>mgReadImageInfo</A> does.  Use <A HREF=#mgReadImageInfo>mgReadImageInfo</A> 
if you need the texture error code on failure.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>When you are through with the returned image info object, you 
must free it by calling <A HREF=#mgFreeImageInfo>mgFreeImageInfo</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned image info object in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>textureName</I></DT><DD>the name of the image file</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns image info object if successful, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadImageInfo>mgReadImageInfo</A>, <A HREF=#mgFreeImageInfo>mgFreeImageInfo</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewLicense><H1 CLASS="APISYMBOL">mgNewLicense</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewLicense</B> - creates a named license.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mglicense <B>mgNewLicense</B> (</TD><TD>const char*</TD><TD><I>licenseName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNewLicense</B> creates a license identified by <I>licenseName</I>. 
This license is typically created and checked out by a plug-in to verify 
that the plug-in is allowed to run in the Creator modeler environment.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>licenseName</I></DT><DD>the name of the license to create</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Pointer to license if created successfully, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows how a plug-in might use the license 
facility to determine whether or not it can run in the Creator modeler 
environment.</DT><DT><PRE CLASS="EXAMPLE">static mglicense MyLicense = MG_NULL;

// Plug-in initialization function
MGPIDECLARE(mgbool) mgpInit (mgplugin plugin, int* argc, char* argv [ )
{
   mgbool isLicensed = MG_FALSE;
   mgstatus checkoutStatus;

   // create the license...
   MyLicense = mgNewLicense ("myLicenseName");

   // ...try to check it out
   checkoutStatus = mgCheckoutLicense (MyLicense);
   isLicensed = MSTAT_ISOK (checkoutStatus);

   if (isLicensed) {
      // register tools declared by this plug-in
      RegisterMyTools (plugin, argc, argv);
   }
   // return MG_TRUE to continue loading...
   // ...MG_FALSE to tell Creator to unload plug-in
   return (isLicensed);
}

// Plug-in termination function
MGPIDECLARE(void) mgpExit (mgplugin plugin)
{
   mgUnregisterAllTools (plugin);
   // done with license, check it in...
   mgCheckinLicense (MyLicense);
   // ...and free it
   mgFreeLicense (MyLicense);
   MyLicense = MG_NULL;
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mglicense>mglicense</A>, <A HREF=#mgFreeLicense>mgFreeLicense</A>, <A HREF=#mgCheckoutLicense>mgCheckoutLicense</A>, 
<A HREF=#mgCheckinLicense>mgCheckinLicense</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewLightPointAnimation><H1 CLASS="APISYMBOL">mgNewLightPointAnimation</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewLightPointAnimation</B> - creates a new entry in the 
light point animation palette.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgNewLightPointAnimation</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>name</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec, index <B>mgNewLightPointAnimation</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#string>string</A></TD><TD><I>name</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNewLightPointAnimation</B> creates a new light point animation 
palette entry for database <I>db</I>.  The new entry is assigned the specified 
<I>name</I> and returned if created successfully.  The index assigned to the new 
entry is also returned in <I>index</I>.  The attributes of the new entry 
can be set using <A HREF=#mgSetAttList>mgSetAttList</A>.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLpAnimationPalette>fltLpAnimationPalette</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>name</I></DT><DD>name to assign to the new light point animation</DD><DT><I>index</I></DT><DD>address of value to receive index assigned to 
new entry in the palette</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgrec</DT><DD>Returns the new light point animation palette entry record if successful, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.</DD><DT>index</DT><DD>If a palette record is returned, its index will be 
returned in index, otherwise index is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetLightPointAnimation>mgGetLightPointAnimation</A>, 
<A HREF=#mgSetCurrentLightPointAnimation>mgSetCurrentLightPointAnimation</A>, 
<A HREF=#mgNewLightPointAppearance>mgNewLightPointAppearance</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewLightPointAppearance><H1 CLASS="APISYMBOL">mgNewLightPointAppearance</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewLightPointAppearance</B> - creates a new entry in the 
light point appearance palette.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgNewLightPointAppearance</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>name</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec, index <B>mgNewLightPointAppearance</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#string>string</A></TD><TD><I>name</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNewLightPointAppearance</B> creates a new light point appearance 
palette entry for database <I>db</I>.  The new entry is assigned the specified 
<I>name</I> and returned if created successfully.  The index assigned to the new 
entry is also returned in <I>index</I>.  The attributes of the new entry 
can be set using <A HREF=#mgSetAttList>mgSetAttList</A>.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLpAppearancePalette>fltLpAppearancePalette</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>name</I></DT><DD>name to assign to the new light point appearance</DD><DT><I>index</I></DT><DD>address of value to receive index assigned to 
new entry in the palette</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgrec</DT><DD>Returns the new light point appearance palette entry record if successful, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.</DD><DT>index</DT><DD>If a palette record is returned, its index will be 
returned in index, otherwise index is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetLightPointAppearance>mgGetLightPointAppearance</A>, 
<A HREF=#mgSetCurrentLightPointAppearance>mgSetCurrentLightPointAppearance</A>, 
<A HREF=#mgNewLightPointAnimation>mgNewLightPointAnimation</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewLightSource><H1 CLASS="APISYMBOL">mgNewLightSource</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewLightSource</B> - creates a new entry in the light 
source palette.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgNewLightSource</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>name</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec, index <B>mgNewLightSource</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#string>string</A></TD><TD><I>name</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNewLightSource</B> creates a new light source 
palette entry for database <I>db</I>.  The new entry is assigned the specified 
<I>name</I> and returned if created successfully.  The index assigned to the new 
entry is also returned in <I>index</I>.  The attributes of the new entry 
can be set using <A HREF=#mgSetAttList>mgSetAttList</A>.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLightSourcePalette>fltLightSourcePalette</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>name</I></DT><DD>name to assign to the new light source</DD><DT><I>index</I></DT><DD>address of value to receive index assigned to 
new entry in the palette</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgrec</DT><DD>Returns the new light source palette entry record if successful, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.</DD><DT>index</DT><DD>If a palette record is returned, its index will be 
returned in index, otherwise index is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetLightSource>mgGetLightSource</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewLineStyle><H1 CLASS="APISYMBOL">mgNewLineStyle</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewLineStyle</B> - creates a new entry in the light 
source palette.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgNewLineStyle</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec, index <B>mgNewLineStyle</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNewLineStyle</B> creates a new line style 
palette entry for database <I>db</I>.  The new entry is returned if created 
successfully.  The index assigned to the new 
entry is also returned in <I>index</I>.  The attributes of the new entry 
can be set using <A HREF=#mgSetAttList>mgSetAttList</A>.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLineStylePalette>fltLineStylePalette</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>address of value to receive index assigned to 
new entry in the palette</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgrec</DT><DD>Returns the new line style palette entry record if successful, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.</DD><DT>index</DT><DD>If a palette record is returned, its index will be 
returned in index, otherwise index is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetLineStyle>mgGetLineStyle</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewMaterial><H1 CLASS="APISYMBOL">mgNewMaterial</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewMaterial</B> - allocates a new record for an entry 
into a database&#146s material palette.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgNewMaterial</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>name</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec, index <B>mgNewMaterial</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#string>string</A></TD><TD><I>name</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a database node <I>db</I> and a material entry name <I>name</I>, 
<B>mgNewMaterial</B> allocates a record containing a new material palette 
entry, adds it to the database&#146s material palette, and returns the record. 
The index of the new material entry is returned in <I>index</I>. 
The material properties can be set by using <A HREF=#mgSetAttList>mgSetAttList</A> or 
<A HREF=#mgSetNormColor>mgSetNormColor</A> with the returned material record.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltFMaterial>fltFMaterial</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>name</I></DT><DD>the name of the new material 
(may be <A HREF=#mgbool>MG_NULL</A> )</DD><DT><I>index</I></DT><DD>pointer to receive the index assigned to the 
new material palette entry record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgrec</DT><DD>Returns the new material palette entry record if successful, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.</DD><DT>index</DT><DD>If a palette record is returned, its index will be 
returned in index, otherwise index is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgDeleteMaterial>mgDeleteMaterial</A>, <A HREF=#mgSetNormColor>mgSetNormColor</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewMatrix><H1 CLASS="APISYMBOL">mgNewMatrix</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewMatrix</B> - allocates and returns a new matrix.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgmatrix* <B>mgNewMatrix</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNewMatrix</B> allocates and returns a new matrix initialized with 
the identity matrix.</P></DD><DD><P>In most cases it will be sufficient to declare and use an object 
of type <A HREF=#mgmatrix>mgmatrix</A> in local scope, rather then dynamically creating one. 
However, if you do need to dynamically allocate an object of type <A HREF=#mgmatrix>mgmatrix</A>, 
this function should be used.</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a pointer to a newly allocated matrix (initialized with 
the identity matrix) if creation is successful, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, 
<A HREF=#mgFreeMatrix>mgFreeMatrix</A>, <A HREF=#mgMatrixIdentity>mgMatrixIdentity</A>, <A HREF=#mgMatrixIsIdentity>mgMatrixIsIdentity</A>, 
<A HREF=#mgMatrixInvert>mgMatrixInvert</A>, <A HREF=#mgMatrixMultiply>mgMatrixMultiply</A>, <A HREF=#mgMatrixCopy>mgMatrixCopy</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewMatrixStack><H1 CLASS="APISYMBOL">mgNewMatrixStack</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewMatrixStack</B> - creates and returns a matrix 
stack object.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgmatrixstack <B>mgNewMatrixStack</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNewMatrixStack</B> creates and returns a matrix stack object which 
can be used to perform matrix stack operations.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>When you are done with the matrix stack, dispose of it using 
<A HREF=#mgFreeMatrixStack>mgFreeMatrixStack</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned matrix stack in Python.</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a matrix stack object (initialized with the identity matrix) 
if creation is successful, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrixstack>mgmatrixstack</A>, <A HREF=#mgmatrix>mgmatrix</A>, <A HREF=#mgFreeMatrixStack>mgFreeMatrixStack</A>, 
<A HREF=#mgMatrixStackPush>mgMatrixStackPush</A>, <A HREF=#mgMatrixStackPop>mgMatrixStackPop</A>, 
<A HREF=#mgMatrixStackLoadIdentity>mgMatrixStackLoadIdentity</A>, <A HREF=#mgMatrixStackIsIdentity>mgMatrixStackIsIdentity</A>, 
<A HREF=#mgMatrixStackLoadMatrix>mgMatrixStackLoadMatrix</A>, <A HREF=#mgMatrixStackGetMatrix>mgMatrixStackGetMatrix</A>, 
<A HREF=#mgMatrixStackMultiply>mgMatrixStackMultiply</A>, <A HREF=#mgMatrixStackTranslate>mgMatrixStackTranslate</A>, <A HREF=#mgMatrixStackScale>mgMatrixStackScale</A>, 
<A HREF=#mgMatrixStackRotate>mgMatrixStackRotate</A>, <A HREF=#mgMatrixStackRotateX>mgMatrixStackRotateX</A>, 
<A HREF=#mgMatrixStackRotateY>mgMatrixStackRotateY</A>, <A HREF=#mgMatrixStackRotateZ>mgMatrixStackRotateZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewNodeExpressionCallback><H1 CLASS="APISYMBOL">mgNewNodeExpressionCallback</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewNodeExpressionCallback</B> - allocates and returns a new mgnodeexpression 
embodying the function passed in.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgnodeexpression <B>mgNewNodeExpressionCallback</B> (</TD><TD><A HREF=#mgnodeexpressionfunc>mgnodeexpressionfunc</A></TD><TD><I>v</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><A HREF=#mgNewNodeExpressionInteger>mgNewNodeExpressionInteger</A> allocates and returns a new mgnodeexpression 
embodying the function passed in.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>v</I></DT><DD>the function to be embodied</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the allocated mgnodeexpression.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewNodeExpressionOperator>mgNewNodeExpressionOperator</A>, <A HREF=#mgNewNodeExpressionInteger>mgNewNodeExpressionInteger</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewNodeExpressionDouble><H1 CLASS="APISYMBOL">mgNewNodeExpressionDouble</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewNodeExpressionDouble</B> - allocates and returns a new mgnodeexpression 
embodying the value passed in.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgnodeexpression <B>mgNewNodeExpressionDouble</B> (</TD><TD>double</TD><TD><I>v</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNewNodeExpressionDouble</B> allocates and returns a new mgnodeexpression 
embodying the value passed in.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>v</I></DT><DD>the value to be embodied</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the allocated mgnodeexpression.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewNodeExpressionOperator>mgNewNodeExpressionOperator</A>, <A HREF=#mgNewNodeExpressionCallback>mgNewNodeExpressionCallback</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewNodeExpressionGetAtt><H1 CLASS="APISYMBOL">mgNewNodeExpressionGetAtt</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewNodeExpressionGetAtt</B> - allocates and returns a new mgnodeexpression 
embodying a mgGetAttList function for the mgcode passed in.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgnodeexpression <B>mgNewNodeExpressionGetAtt</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNewNodeExpressionGetAtt</B> allocates and returns a new mgnodeexpression 
embodying a mgGetAttList function for the mgcode passed in.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>code</I></DT><DD>the code to be matched</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the allocated mgnodeexpression.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewNodeExpressionOperator>mgNewNodeExpressionOperator</A>, <A HREF=#mgNewNodeExpressionCallback>mgNewNodeExpressionCallback</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewNodeExpressionInteger><H1 CLASS="APISYMBOL">mgNewNodeExpressionInteger</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewNodeExpressionInteger</B> - allocates and returns a new mgnodeexpression 
embodying the value passed in.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgnodeexpression <B>mgNewNodeExpressionInteger</B> (</TD><TD>int</TD><TD><I>v</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNewNodeExpressionInteger</B> allocates and returns a new mgnodeexpression 
embodying the value passed in.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>v</I></DT><DD>the value to be embodied</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the allocated mgnodeexpression.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewNodeExpressionOperator>mgNewNodeExpressionOperator</A>, <A HREF=#mgNewNodeExpressionCallback>mgNewNodeExpressionCallback</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewNodeExpressionOperator><H1 CLASS="APISYMBOL">mgNewNodeExpressionOperator</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewNodeExpressionOperator</B> - allocates and returns a new mgnodeexpression 
embodying the operator passed in.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgnodeexpression <B>mgNewNodeExpressionOperator</B> (</TD><TD><A HREF=#mgnodeexpressionoperator>mgnodeexpressionoperator</A></TD><TD><I>oper</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNewNodeExpressionOperator</B> allocates and returns a new mgnodeexpression 
embodying the operator passed in.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>oper</I></DT><DD>the operation to be embodied</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the allocated mgnodeexpression.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewNodeExpressionInteger>mgNewNodeExpressionInteger</A>, <A HREF=#mgNewNodeExpressionCallback>mgNewNodeExpressionCallback</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewPaneLayout><H1 CLASS="APISYMBOL">mgNewPaneLayout</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewPaneLayout</B> - allocates a new mgpanelayout record.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD> mgpanelayout <B>mgNewPaneLayout</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNewPaneLayout</B> allocates a new <I>mgpanelayout</I> record that can be 
used to store and restore pane settings. Pane settings constitute location of 
splitters and the pane type (graphics view, structure view, etc). Each 
call to <B>mgNewPaneLayout</B> should be matched with a call to <A HREF=#mgFreePaneLayout>mgFreePaneLayout</A> 
in order to prevent memory leaks.</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>If successful a new mgpanelayout record is returned, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgFreePaneLayout>mgFreePaneLayout</A>, <A HREF=#mgGetPaneLayout>mgGetPaneLayout</A>, <A HREF=#mgSetPaneLayout>mgSetPaneLayout</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewParamBlock><H1 CLASS="APISYMBOL">mgNewParamBlock</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewParamBlock</B> - creates a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD> mgparamblock <B>mgNewParamBlock</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNewParamBlock</B> creates a parameter block, typically used to 
define the default tool parameter block for an editor plug-in tool.</P></DD><DD><P>See the example code in <A HREF=#mgPluginToolSetDefaultParamBlock>mgPluginToolSetDefaultParamBlock</A>.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The parameter block is dynamically allocated and (normally) must be 
deallocated by the caller when it is no longer needed using <A HREF=#mgFreeParamBlock>mgFreeParamBlock</A>. 
Note that If you pass the parameter block to <A HREF=#mgPluginToolSetDefaultParamBlock>mgPluginToolSetDefaultParamBlock</A>, you 
transfer ownership of the parameter block to the OpenFlight API and you should 
NOT deallocate the block.  The OpenFlight API will automatically dispose 
of the memory when it is appropriate to do so.</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Pointer to parameter block if created successfully, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgparamblock>mgparamblock</A>, <A HREF=#mgGetParamBlock>mgGetParamBlock</A>, <A HREF=#mgFreeParamBlock>mgFreeParamBlock</A>, 
<A HREF=#mgPluginToolSetDefaultParamBlock>mgPluginToolSetDefaultParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewProjection><H1 CLASS="APISYMBOL">mgNewProjection</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewProjection</B> - creates a new projection object.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgprojection <B>mgNewProjection</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNewProjection</B> creates a new projection object based on the 
projection of the given database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The projection object returned 
is dynamically allocated and must be deallocated by the caller when it is no 
longer needed using <A HREF=#mgFreeProjection>mgFreeProjection</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned projection in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>database containing the projection to use</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the projection object if successful, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgprojcoord>mgprojcoord</A>, <A HREF=#mgcoord3d>mgcoord3d</A>, 
<A HREF=#mgFreeProjection>mgFreeProjection</A>, <A HREF=#mgProjectionConvertLLEtoXYZ>mgProjectionConvertLLEtoXYZ</A>, 
<A HREF=#mgProjectionConvertXYZtoLLE>mgProjectionConvertXYZtoLLE</A>, <A HREF=#mgProject>mgProject</A>, <A HREF=#mgUnproject>mgUnproject</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewPtrArray><H1 CLASS="APISYMBOL">mgNewPtrArray</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewPtrArray</B> - allocate a new pointer array.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD> mgptrarray <B>mgNewPtrArray</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNewPtrArray</B> allocates a new pointer array and returns its 
handle.  The array created is initially empty.</P></DD><DD><P>This function creates and returns a pointer array which can be 
used as a "dynamic" array.  In this way, its length is not statically 
declared.</P></DD><DD><P>Use the function <A HREF=#mgFreePtrArray>mgFreePtrArray</A> to dispose of the pointer 
array when you are through using it.</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the pointer array if successful, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgFreePtrArray>mgFreePtrArray</A>, <A HREF=#mgPtrArrayAppend>mgPtrArrayAppend</A>, <A HREF=#mgPtrArrayInsert>mgPtrArrayInsert</A>, 
<A HREF=#mgPtrArrayReplace>mgPtrArrayReplace</A>, <A HREF=#mgPtrArrayGet>mgPtrArrayGet</A>, <A HREF=#mgPtrArrayRemove>mgPtrArrayRemove</A>, 
<A HREF=#mgPtrArrayClear>mgPtrArrayClear</A>, <A HREF=#mgPtrArrayLength>mgPtrArrayLength</A>, <A HREF=#mgPtrArraySort>mgPtrArraySort</A>, 
<A HREF=#mgPtrArraySearch>mgPtrArraySearch</A>, <A HREF=#mgPtrArrayBSearch>mgPtrArrayBSearch</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewPtrStack><H1 CLASS="APISYMBOL">mgNewPtrStack</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewPtrStack</B> - allocate a new pointer stack.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD> mgptrstack <B>mgNewPtrStack</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNewPtrStack</B> allocates a new pointer stack and returns its 
handle.  The stack created is initially empty.</P></DD><DD><P>This function creates and returns a FILO (first in, last out) stack 
containing pointer data.</P></DD><DD><P>Use the function <A HREF=#mgFreePtrStack>mgFreePtrStack</A> to dispose of the pointer 
stack when you are through using it.</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the pointer stack if successful, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgFreePtrStack>mgFreePtrStack</A>, 
<A HREF=#mgPtrStackPush>mgPtrStackPush</A>, <A HREF=#mgPtrStackPop>mgPtrStackPop</A>, <A HREF=#mgPtrStackClear>mgPtrStackClear</A>, 
<A HREF=#mgPtrStackTop>mgPtrStackTop</A>, <A HREF=#mgPtrStackLength>mgPtrStackLength</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewRec><H1 CLASS="APISYMBOL">mgNewRec</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewRec</B> - allocates a new node record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgNewRec</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>rcode</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a node record code <I>code</I>, <B>mgNewRec</B> allocates 
and initializes a node record of the type defined by <I>code</I>. 
A new node is returned if the action is successful. 
The new node is an orphan, meaning that it is not attached to any 
other node in the hierarchy.  Use <A HREF=#mgAttach>mgAttach</A>, <A HREF=#mgAppend>mgAppend</A> or 
<A HREF=#mgInsert>mgInsert</A> to attach the node into the database hierarchy.</P></DD><DD><P>Valid codes for this function include all node type record 
codes except <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHeader</A>
.  Since <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHeader</A>
 is the root 
of a database, use <A HREF=#mgNewDb>mgNewDb</A> or <A HREF=#mgOpenDb>mgOpenDb</A> to create a 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHeader</A>
 node type.  You can also use this function to create 
transformation node records using the codes <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXmTranslate>fltXmTranslate</A>
, 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXmScale>fltXmScale</A>
, etc.</P></DD><DD><P>When a node is created by <B>mgNewRec</B> it is bound to the current 
database (see <A HREF=#mgSetCurrentDb>mgSetCurrentDb</A> and <A HREF=#mgGetCurrentDb>mgGetCurrentDb</A>). 
After you create a new node using this function you can only attach it 
to other nodes that are contained in the database that was current 
when you called <B>mgNewRec</B>.  To eliminate the dependency on the current 
database, it is recommended to use <A HREF=#mgNewRecDb>mgNewRecDb</A> instead of <B>mgNewRec</B> 
to create new nodes whenever possible.</P></DD><DD><P>Calling <B>mgNewRec</B> is equivalent to calling <A HREF=#mgNewRecDb>mgNewRecDb</A> and passing 
the result of <A HREF=#mgGetCurrentDb>mgGetCurrentDb</A> as the <I>db</I> parameter.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rcode</I></DT><DD>the code for the new record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the pointer to the newly created node record if successful, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) create and attach a new polygon to an object 
in the database.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">static void MakeNewPoly (mgrec* object)
{
   mgrec* poly = mgNewRec (fltPolygon);
   mgAttach (object, poly);  // poly is first child of object
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">def MakeNewPoly (object):
   poly = mgNewRec (fltPolygon)
   mgAttach (object, poly)&#32&#32# poly is first child of object</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewRecDb>mgNewRecDb</A>, <A HREF=#mgDuplicate>mgDuplicate</A>, <A HREF=#mgDuplicateToDb>mgDuplicateToDb</A>, <A HREF=#mgDelete>mgDelete</A>, 
<A HREF=#mgAttach>mgAttach</A>, <A HREF=#mgAppend>mgAppend</A>, <A HREF=#mgInsert>mgInsert</A>, <A HREF=#mgReference>mgReference</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewRecDb><H1 CLASS="APISYMBOL">mgNewRecDb</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewRecDb</B> - allocates a new node record for a specific database.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgNewRecDb</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>rcode</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a node record code <I>code</I> and a database node <I>db</I>, <B>mgNewRecDb</B> 
allocates and initializes a node record of the type defined by <I>code</I>. 
A new node is returned if the action is successful. 
The new node is an orphan, meaning that it is not attached to any 
other node in the hierarchy.  Use <A HREF=#mgAttach>mgAttach</A>, <A HREF=#mgAppend>mgAppend</A> or 
<A HREF=#mgInsert>mgInsert</A> to attach the node into the database hierarchy.</P></DD><DD><P>Valid codes for this function include all node type record 
codes except <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHeader</A>
.  Since <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHeader</A>
 is the root 
of a database, use <A HREF=#mgNewDb>mgNewDb</A> or <A HREF=#mgOpenDb>mgOpenDb</A> to create a 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHeader</A>
 node type.  You can also use this function to create 
transformation node records using the codes <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXmTranslate>fltXmTranslate</A>
, 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXmScale>fltXmScale</A>
, etc.</P></DD><DD><P>The new node created is explicitly bound to the <I>db</I> 
you specify.  After you create a new node using this function you 
can only attach it to other nodes that are contained in <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rcode</I></DT><DD>the code for the new record</DD><DT><I>db</I></DT><DD>the database in which you are going to attach the record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the pointer to the newly created node record if successful, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) create and attach a new polygon to an object 
in the database.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">static void MakeNewPoly (mgrec* object)
{
   mgrec* db = mgRec2Db (object);
   mgrec* poly = mgNewRecDb (fltPolygon, db);
   mgAttach (object, poly);  // poly is first child of object
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">def MakeNewPoly (object):
   db = mgRec2Db (object)
   poly = mgNewRecDb (fltPolygon, db)
   mgAttach (object, poly)&#32&#32# poly is first child of object</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewRec>mgNewRec</A>, <A HREF=#mgDuplicate>mgDuplicate</A>, <A HREF=#mgDuplicateToDb>mgDuplicateToDb</A>, <A HREF=#mgDelete>mgDelete</A>, <A HREF=#mgAttach>mgAttach</A>, 
<A HREF=#mgAppend>mgAppend</A>, <A HREF=#mgInsert>mgInsert</A>, <A HREF=#mgReference>mgReference</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewRecList><H1 CLASS="APISYMBOL">mgNewRecList</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewRecList</B> - create a record list.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgreclist <B>mgNewRecList</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNewRecList</B> creates and returns a new record list.</P></DD><DD><P>To add records to the list, use <A HREF=#mgAppendRecList>mgAppendRecList</A>.<P>
When you are done with the record list, you should dispose 
of it using <A HREF=#mgFreeRecList>mgFreeRecList</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to dispose of the record list 
returned in Python.</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a new record list if successfully created, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgAppendRecList>mgAppendRecList</A>, <A HREF=#mgGetRecListCount>mgGetRecListCount</A>, 
<A HREF=#mgResetRecList>mgResetRecList</A>, <A HREF=#mgGetNextRecInList>mgGetNextRecInList</A>, 
<A HREF=#mgGetNthRecInList>mgGetNthRecInList</A>, <A HREF=#mgIsRecInList>mgIsRecInList</A>, <A HREF=#mgFreeRecList>mgFreeRecList</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewShader><H1 CLASS="APISYMBOL">mgNewShader</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewShader</B> - allocates a new record for an entry 
into a database&#146s shader palette.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgNewShader</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>name</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec, index <B>mgNewShader</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#string>string</A></TD><TD><I>name</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a database node <I>db</I> and a shader entry name <I>name</I>, 
<B>mgNewShader</B> allocates a record containing a new shader palette 
entry, adds it to the database&#146s shader palette, and returns the record. 
The index of the new shader entry is returned in <I>index</I>. 
The shader properties can be set by using <A HREF=#mgSetAttList>mgSetAttList</A> with 
the returned shader record.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltShaderPalette>fltShaderPalette</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>name</I></DT><DD>the name of the new shader 
(may be <A HREF=#mgbool>MG_NULL</A> )</DD><DT><I>index</I></DT><DD>pointer to receive the index assigned to the 
new shader palette entry record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgrec</DT><DD>Returns the new shader palette entry record if successful, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.</DD><DT>index</DT><DD>If a palette record is returned, its index will be 
returned in index, otherwise index is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgDeleteShader>mgDeleteShader</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewSound><H1 CLASS="APISYMBOL">mgNewSound</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewSound</B> - allocates a new record for a sound palette entry.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgNewSound</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>name</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec, index <B>mgNewSound</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#string>string</A></TD><TD><I>name</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a database node db, mgNewSound allocates a sound record with 
the name given and puts it in the database&#146s sound palette. If successful, the 
sound record is returned.  If unsuccessful, <A HREF=#MG_NULL>MG_NULL</A> is returned.  This 
sound attributes can then be set by using <A HREF=#mgSetAttList>mgSetAttList</A> with the returned record. 
The index of the entry in the sound palette is returned in index.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSoundPalette>fltSoundPalette</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>name</I></DT><DD>the name of the sound entry record</DD><DT><I>index</I></DT><DD>the returned index of the sound entry record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgrec</DT><DD>Returns the new sound palette entry record if successful, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.</DD><DT>index</DT><DD>If a palette record is returned, its index will be 
returned in index, otherwise index is undefined.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* sound;
int index;
mgrec* db;
db = mgNewDb ("newfile.flt");
sound = mgNewSound (db, "NewSound", &index);</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetSound>mgGetSound</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewTabRuler><H1 CLASS="APISYMBOL">mgNewTabRuler</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewTabRuler</B> - creates a new tab ruler control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgNewTabRuler</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>...</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNewTabRuler</B> allocates and initializes a new tab ruler <I>control</I>. 
<I>control</I> is the GL control to associate the tab ruler control with.</P></DD><DD><P>The variable arguments are a set of key/value pairs, where key is a 32-bit value. The 
key/value list MUST be terminated with a tag of 'MG_NULL'.</P></DD><DD><P>Use <A HREF=#mgFreeTabRuler>mgFreeTabRuler</A> when you are done with the tab ruler control. 
Typically you will do this when you handle the <A HREF=#MGCB_DESTROY>MGCB_DESTROY</A> dialog event 
for the dialog containing this control.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>GL control to associate with a tab ruler control</DD><DT><I>...</I></DT><DD>optional input parameters in variable 
argument style using <A HREF=#mgtabruleroption>mgtabruleroption</A> as the keys</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success. If the function succeeds, 
the tab ruler control was successfully created and associated with the GL control.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgTabRulerSetOptions>mgTabRulerSetOptions</A>, <A HREF=#mgFreeTabRuler>mgFreeTabRuler</A>, <A HREF=#mgTabRulerGetTabCount>mgTabRulerGetTabCount</A>, <A HREF=#mgTabRulerGetTabPosition>mgTabRulerGetTabPosition</A>, 
<A HREF=#mgTabRulerSetTabPosition>mgTabRulerSetTabPosition</A>, <A HREF=#mgTabRulerSetTabFrozen>mgTabRulerSetTabFrozen</A>, 
<A HREF=#mgTabRulerNewTab>mgTabRulerNewTab</A>, <A HREF=#mgTabRulerDeleteTab>mgTabRulerDeleteTab</A>, 
<A HREF=#mgTabRulerGetSelectedTab>mgTabRulerGetSelectedTab</A>, <A HREF=#mgTabRulerSelectTab>mgTabRulerSelectTab</A>, <A HREF=#mgtabruleroption>mgtabruleroption</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewTexture><H1 CLASS="APISYMBOL">mgNewTexture</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewTexture</B> - creates a new entry in a database's texture 
palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgNewTexture</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>unsigned char*</TD><TD><I>texels</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>textureName</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>imgRec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>y</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a database node <I>db</I>, a texture palette index <I>index</I>, an 
array of texels <I>texels</I>, a texture name <I>textureName</I>, an attribute 
record <I>imgRec</I> (of type <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltImage>fltImage</A>
), and a palette position <I>x</I>, <I>y</I>, 
<B>mgNewTexture</B> creates a new texture in the database&#146s texture palette with 
the specified name, attributes and position.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the new texture palette entry</DD><DT><I>texels</I></DT><DD>the array of texels that make up the texture image</DD><DT><I>textureName</I></DT><DD>the name of the texture</DD><DT><I>imgRec</I></DT><DD>the attribute record describing the new texture</DD><DT><I>x</I></DT><DD>the X position in the texture palette</DD><DT><I>y</I></DT><DD>the Y position in the texture palette</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
If successful, the corresponding texture record is returned in the output parameter, 
<I>imgRec</I>, otherwise it is undefined.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgCopyTexture>mgCopyTexture</A>, <A HREF=#mgDeleteTexture>mgDeleteTexture</A>, <A HREF=#mgReplaceTexture>mgReplaceTexture</A>, 
<A HREF=#mgMoveTexture>mgMoveTexture</A>, <A HREF=#mgInsertTexture>mgInsertTexture</A>, <A HREF=#mgReadTexture>mgReadTexture</A></DD></DL>
<HR>
<LEFT><A NAME=mgNewTextureMapping><H1 CLASS="APISYMBOL">mgNewTextureMapping</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNewTextureMapping</B> - allocates a new record for an entry 
into a database&#146s texture mapping palette.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgNewTextureMapping</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>type</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>name</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec, index <B>mgNewTextureMapping</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>type</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#string>string</A></TD><TD><I>name</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a database node <I>db</I>, a texture mapping type <I>type</I>, 
and a texture mapping entry name <I>name</I>, 
<B>mgNewTextureMapping</B> allocates a record containing a new texture mapping 
palette entry of the specified type, adds it to the database&#146s texture 
mapping palette, and returns the record.  The index of the new texture 
mapping entry is returned in <I>index</I>.</P></DD><DD><P>Texture mapping entries can be any of these types:</P></DD><DL><DT></DT><DD>1 = 3 point put <BR> 
2 = 4 point put <BR> 
4 = Spherical project <BR> 
5 = Radial project <BR> 
6 = Environment <BR></DD></DL>
<DD><P>The texture mapping properties can be set by using <A HREF=#mgSetAttList>mgSetAttList</A> 
with the returned texture mapping record.</P></DD><DD><P>Note: After setting or modifying any field of a texture mapping palette 
entry, you must call <A HREF=#mgUpdateTextureMapping>mgUpdateTextureMapping</A> to make sure the internal data 
in the mapping entry is updated properly.</P></DD><DD><P>The code of the record returned will be <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltTextureMapping>fltTextureMapping</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>type</I></DT><DD>the type of the new texture mapping</DD><DT><I>name</I></DT><DD>the name of the new texture mapping 
(may be <A HREF=#MG_NULL>MG_NULL</A> )</DD><DT><I>index</I></DT><DD>pointer to receive the index assigned to the 
new texture mapping palette entry record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgrec</DT><DD>Returns the new texture mapping palette entry record if successful, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.</DD><DT>index</DT><DD>If a palette record is returned, its index will be 
returned in index, otherwise index is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgDeleteTextureMapping>mgDeleteTextureMapping</A></DD></DL>
<HR>
<LEFT><A NAME=mgNextConstructEdge><H1 CLASS="APISYMBOL">mgNextConstructEdge</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNextConstructEdge</B> - gets the next construction edge 
node associated with an active editor tool instance.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgNextConstructEdge</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>constructEdge</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNextConstructEdge</B> gets the construction edge node 
that follows the specified construction node, <I>constructEdge</I>, 
associated with the editor tool instance identified by 
editor context, <I>editorContext</I>.</P></DD><DD><P>After calling <A HREF=#mgFirstConstructEdge>mgFirstConstructEdge</A> to get the first 
construction edge node associated with an editor tool instance, you 
can call <B>mgNextConstructEdge</B> to get successive construction 
edge nodes.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context from which to 
get the next construction edge node</DD><DT><I>constructEdge</I></DT><DD>the construction edge node 
to get next construction edge for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the next construction edge node if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewConstructEdge>mgNewConstructEdge</A>, <A HREF=#mgFirstConstructEdge>mgFirstConstructEdge</A></DD></DL>
<HR>
<LEFT><A NAME=mgNextConstructVertex><H1 CLASS="APISYMBOL">mgNextConstructVertex</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNextConstructVertex</B> - gets the next construction vertex 
node associated with an active editor tool instance.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgNextConstructVertex</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>constructVtx</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNextConstructVertex</B> gets the construction vertex node 
that follows the specified construction node, <I>constructVtx</I>, 
associated with the editor tool instance identified by 
editor context, <I>editorContext</I>.</P></DD><DD><P>After calling <A HREF=#mgFirstConstructVertex>mgFirstConstructVertex</A> to get the first 
construction vertex node associated with an editor tool instance, you 
can call <B>mgNextConstructVertex</B> to get successive construction 
vertex nodes.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context from which to 
get the next construction vertex node</DD><DT><I>constructVtx</I></DT><DD>the construction vertex node 
to get next construction vertex for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the next construction vertex node if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewConstructVertex>mgNewConstructVertex</A>, <A HREF=#mgFirstConstructVertex>mgFirstConstructVertex</A></DD></DL>
<HR>
<LEFT><A NAME=mgNodeExpressionEvaluateAsBool><H1 CLASS="APISYMBOL">mgNodeExpressionEvaluateAsBool</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNodeExpressionEvaluateAsBool</B> - evaluates a mgnodeexpression.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgNodeExpressionEvaluateAsBool</B> (</TD><TD><A HREF=#mgnodeexpression>mgnodeexpression</A></TD><TD><I>expressionRoot</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNodeExpressionEvaluateAsBool</B> Given an mgnodeexpression, 
this function returns the boolean evaluation of that expression.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>expressionRoot</I></DT><DD>the root expression to evaluate</DD></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example generates an expression from a string, 
sets up the variables in the string, and then evaluates the expression.</DT><DT><PRE CLASS="EXAMPLE">mgnodeexpression exp = mgNodeExpressionLoadFromString("$myVal1 == 2.1 && $myVal2 == -1");
mgNodeExpressionSetVariableDouble (exp, "myVal1", 2.1);
mgNodeExpressionSetVariableInt (exp, "myVal2", -1);
mgbool istrue = mgNodeExpressionEvaluateAsBool (exp);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><B>mgNodeExpressionEvaluateAsBool</B>, <A HREF=#mgNodeExpressionLoadFromString>mgNodeExpressionLoadFromString</A>, 
<A HREF=#mgNodeExpressionSetVariableDouble>mgNodeExpressionSetVariableDouble</A>, <A HREF=#mgNodeExpressionSetVariableInt>mgNodeExpressionSetVariableInt</A>, 
<A HREF=#mgNodeExpressionSetVariableString>mgNodeExpressionSetVariableString</A></DD></DL>
<HR>
<LEFT><A NAME=mgnodeexpressionfunc><H1 CLASS="APISYMBOL">mgnodeexpressionfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgnodeexpressionfunc</B> - Expression tree callback function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgnodeexpression (*<B>mgnodeexpressionfunc</B>) ( <TD><A HREF=#mgrec>mgrec*</A> <TD><I>db</I>, 
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A> <TD><I>parent</I>, 
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A> <TD><I>rec</I>, 
<TR><TD></TD><TD>void* <TD><I>userData</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for expression tree callback functions, embodied 
by the expression returned from <A HREF=#mgNewNodeExpressionCallback>mgNewNodeExpressionCallback</A></P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database containing the node being visited</DD><DT><I>parent</I></DT><DD>the parent of the node being visited (<A HREF=#MG_NULL>MG_NULL</A> if <I>rec</I> is <I>db</I>)</DD><DT><I>rec</I></DT><DD>the node currently being visited</DD><DT><I>userData</I></DT><DD>user defined data specified in call to <A HREF=#mgFind>mgFind</A>, <A HREF=#mgFindEx>mgFindEx</A></DD></DL></DD></DL>
<HR>
<LEFT><A NAME=mgNodeExpressionLoadFromString><H1 CLASS="APISYMBOL">mgNodeExpressionLoadFromString</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNodeExpressionLoadFromString</B> - parses <I>expressionString</I> to generate and return 
a new mgnodeexpression 
be <I>right</I>.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgNodeExpressionLoadFromString</B> (</TD><TD>const <A HREF=#char >char *</A></TD><TD><I>expressionString</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><A HREF=#mgNodeExpressionSetRight>mgNodeExpressionSetRight</A> parses <I>expressionString</I> to generate and return 
a new mgnodeexpression.  Assumes the expressionString is in infix order.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>expressionString</I></DT><DD>infix expression string to parse</DD></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example generates an expression that can be used to collect all polygons 
of material index 2 and alt color -1 in a database.</DT><DT><PRE CLASS="EXAMPLE">mgnodeexpression poly = mgNodeExpressionLoadFromString("fltPolyMaterial == 2 && fltPolyAltColor == -1");</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewNodeExpressionOperator>mgNewNodeExpressionOperator</A>, <A HREF=#mgNewNodeExpressionCallback>mgNewNodeExpressionCallback</A></DD></DL>
<HR>
<LEFT><A NAME=mgNodeExpressionSetLeft><H1 CLASS="APISYMBOL">mgNodeExpressionSetLeft</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNodeExpressionSetLeft</B> - sets the left child of <I>expression</I> to 
be <I>left</I>.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgNodeExpressionSetLeft</B> (</TD><TD><A HREF=#mgnodeexpression>mgnodeexpression</A></TD><TD><I>expression</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgnodeexpression>mgnodeexpression</A></TD><TD><I>left</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNodeExpressionSetLeft</B> sets the left child of <I>expression</I> to 
be <I>left</I>, thus adding <I>left</I> to the expression tree containing <I>expression</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>expression</I></DT><DD>the parent expression</DD><DT><I>left</I></DT><DD>the expression to be the left-hand child</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewNodeExpressionOperator>mgNewNodeExpressionOperator</A>, <A HREF=#mgNewNodeExpressionCallback>mgNewNodeExpressionCallback</A></DD></DL>
<HR>
<LEFT><A NAME=mgNodeExpressionSetRight><H1 CLASS="APISYMBOL">mgNodeExpressionSetRight</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNodeExpressionSetRight</B> - sets the right child of <I>expression</I> to 
be <I>right</I>.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgNodeExpressionSetRight</B> (</TD><TD><A HREF=#mgnodeexpression>mgnodeexpression</A></TD><TD><I>expression</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgnodeexpression>mgnodeexpression</A></TD><TD><I>right</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNodeExpressionSetRight</B> sets the right child of <I>expression</I> to 
be <I>right</I>, thus adding <I>right</I> to the expression tree containing <I>expression</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>expression</I></DT><DD>the parent expression</DD><DT><I>right</I></DT><DD>the expression to be the right-hand child</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewNodeExpressionOperator>mgNewNodeExpressionOperator</A>, <A HREF=#mgNewNodeExpressionCallback>mgNewNodeExpressionCallback</A></DD></DL>
<HR>
<LEFT><A NAME=mgNodeExpressionSetVariableDouble><H1 CLASS="APISYMBOL">mgNodeExpressionSetVariableDouble</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNodeExpressionSetVariableDouble</B> - sets a double variable in an mgnodeexpression<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgNodeExpressionSetVariableDouble</B> (</TD><TD><A HREF=#mgnodeexpression>mgnodeexpression</A></TD><TD><I>node</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>variableName</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>val</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNodeExpressionSetVariableDouble</B> Sets a double variable in an mgnodeexpression. 
If the variable exists the value is overwritten.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>node</I></DT><DD>the expression root to get the variable</DD><DT><I>variableName</I></DT><DD>the variable name</DD><DT><I>val</I></DT><DD>the value of the variable to set</DD></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example generates an expression from a string, 
sets up the variables in the string, and then evaluates the expression.</DT><DT><PRE CLASS="EXAMPLE">mgnodeexpression exp = mgNodeExpressionLoadFromString("$myDbl == 2.1 && $myInt == -1" && $myStr == "foo");
mgNodeExpressionSetVariableDouble (exp, "myVal1", 2.1);
mgNodeExpressionSetVariableInt (exp, "myVal2", -1);
mgNodeExpressionSetVariableString (exp, "myStr", "foo");
mgbool istrue = mgNodeExpressionEvaluateAsBool (exp);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNodeExpressionEvaluateAsBool>mgNodeExpressionEvaluateAsBool</A>, <A HREF=#mgNodeExpressionLoadFromString>mgNodeExpressionLoadFromString</A>, 
<B>mgNodeExpressionSetVariableDouble</B>, <A HREF=#mgNodeExpressionSetVariableInt>mgNodeExpressionSetVariableInt</A>, 
<A HREF=#mgNodeExpressionSetVariableString>mgNodeExpressionSetVariableString</A></DD></DL>
<HR>
<LEFT><A NAME=mgNodeExpressionSetVariableInt><H1 CLASS="APISYMBOL">mgNodeExpressionSetVariableInt</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNodeExpressionSetVariableInt</B> - sets a integer variable in an mgnodeexpression<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgNodeExpressionSetVariableInt</B> (</TD><TD><A HREF=#mgnodeexpression>mgnodeexpression</A></TD><TD><I>node</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>variableName</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>val</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNodeExpressionSetVariableInt</B> Sets a integer variable in an mgnodeexpression. 
If the variable exists the value is overwritten.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>node</I></DT><DD>the expression root to get the variable</DD><DT><I>variableName</I></DT><DD>the variable name</DD><DT><I>val</I></DT><DD>the value of the variable to set</DD></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example generates an expression from a string, 
sets up the variables in the string, and then evaluates the expression.</DT><DT><PRE CLASS="EXAMPLE">mgnodeexpression exp = mgNodeExpressionLoadFromString("$myDbl == 2.1 && $myInt == -1" && $myStr == "foo");
mgNodeExpressionSetVariableDouble (exp, "myVal1", 2.1);
mgNodeExpressionSetVariableInt (exp, "myVal2", -1);
mgNodeExpressionSetVariableString (exp, "myStr", "foo");
mgbool istrue = mgNodeExpressionEvaluateAsBool (exp);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNodeExpressionEvaluateAsBool>mgNodeExpressionEvaluateAsBool</A>, <A HREF=#mgNodeExpressionLoadFromString>mgNodeExpressionLoadFromString</A>, 
<A HREF=#mgNodeExpressionSetVariableDouble>mgNodeExpressionSetVariableDouble</A>, <B>mgNodeExpressionSetVariableInt</B>, 
<A HREF=#mgNodeExpressionSetVariableString>mgNodeExpressionSetVariableString</A></DD></DL>
<HR>
<LEFT><A NAME=mgNodeExpressionSetVariableString><H1 CLASS="APISYMBOL">mgNodeExpressionSetVariableString</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgNodeExpressionSetVariableString</B> - sets a string variable in an mgnodeexpression<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgNodeExpressionSetVariableString</B> (</TD><TD><A HREF=#mgnodeexpression>mgnodeexpression</A></TD><TD><I>node</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>variableName</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>val</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgNodeExpressionSetVariableString</B> Sets a string variable in an mgnodeexpression. 
If the variable exists the value is overwritten.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>node</I></DT><DD>the expression root to get the variable</DD><DT><I>variableName</I></DT><DD>the variable name</DD><DT><I>val</I></DT><DD>the value of the variable to set</DD></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example generates an expression from a string, 
sets up the variables in the string, and then evaluates the expression.</DT><DT><PRE CLASS="EXAMPLE">mgnodeexpression exp = mgNodeExpressionLoadFromString("$myDbl == 2.1 && $myInt == -1" && $myStr == "foo");
mgNodeExpressionSetVariableDouble (exp, "myVal1", 2.1);
mgNodeExpressionSetVariableInt (exp, "myVal2", -1 );
mgNodeExpressionSetVariableString (exp, "myStr", "foo");
mgbool istrue = mgNodeExpressionEvaluateAsBool (exp);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNodeExpressionEvaluateAsBool>mgNodeExpressionEvaluateAsBool</A>, <A HREF=#mgNodeExpressionLoadFromString>mgNodeExpressionLoadFromString</A>, 
<A HREF=#mgNodeExpressionSetVariableDouble>mgNodeExpressionSetVariableDouble</A>, <A HREF=#mgNodeExpressionSetVariableInt>mgNodeExpressionSetVariableInt</A>, 
<B>mgNodeExpressionSetVariableString</B></DD></DL>
<HR>
<LEFT><A NAME=mgnotifyfunc><H1 CLASS="APISYMBOL">mgnotifyfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgnotifyfunc</B> - Notifier callback function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void (*<B>mgnotifyfunc</B>) ( <TD><A HREF=#mgnotifier>mgnotifier</A> <TD><I>notifier</I>, 
<TR><TD></TD><TD><A HREF=#mgnotifierevent>mgnotifierevent</A> <TD><I>event</I>, 
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A> <TD><I>db</I>, 
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A> <TD><I>rec</I>, 
<TR><TD></TD><TD>void* <TD><I>userData</I> );</TABLE></DD>
</DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>notifier</I></DT><DD>the notifier</DD><DT><I>event</I></DT><DD>the notification event that triggered the callback</DD><DT><I>db</I></DT><DD>the database to which or in which the event occurred</DD><DT><I>rec</I></DT><DD>the specific node in the database to which the event occurred</DD><DT><I>userData</I></DT><DD>user defined data specified when notifier registered</DD></DL></DD></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterNotifier>mgRegisterNotifier</A></DD></DL>
<HR>
<LEFT><A NAME=mgOpenDb><H1 CLASS="APISYMBOL">mgOpenDb</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgOpenDb</B> - opens an existing OpenFlight database 
for reading or writing.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgOpenDb</B> (</TD><TD>const char*</TD><TD><I>fileName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgOpenDb</B> opens the file named by <I>fileName</I>. 
It returns the root database node upon successful completion.</P></DD><DD><P>The behavior of this function is affected by the functions: 
<A HREF=#mgSetOpenCreateFlag>mgSetOpenCreateFlag</A>, <A HREF=#mgSetReadExtFlag>mgSetReadExtFlag</A> and <A HREF=#mgSetReadTexturesFlag>mgSetReadTexturesFlag</A>.</P></DD><DD><P>Note: If your plug-in or script opens a file in the Creator modeling 
environment with this function or <A HREF=#mgNewDb>mgNewDb</A>, the file is not opened in an 
active window on the Creator desktop. Your plug-in or script can still access 
the database but must explicitly save and close the file when done.</P></DD><DD><P>Note: If invoked from within the modeler environment, this function 
will fail if the named file is already open in an active window.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>fileName</I></DT><DD>the name of the file to be opened</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a pointer to the opened database node if successful, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example opens an existing database.</DT><DT><PRE CLASS="EXAMPLE">mgrec* db;
db = mgOpenDb ("existingfile.flt");</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewDb>mgNewDb</A>, <A HREF=#mgCloseDb>mgCloseDb</A>, 
<A HREF=#mgSetOpenCreateFlag>mgSetOpenCreateFlag</A>, <A HREF=#mgSetReadExtFlag>mgSetReadExtFlag</A>, <A HREF=#mgSetReadTexturesFlag>mgSetReadTexturesFlag</A>, 
<A HREF=#mgGetDbVersion>mgGetDbVersion</A></DD></DL>
<HR>
<LEFT><A NAME=mgOptionMenuAddItem><H1 CLASS="APISYMBOL">mgOptionMenuAddItem</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgOptionMenuAddItem</B> - adds an item to an option menu control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgOptionMenuAddItem</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>itemString</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgOptionMenuAddItem</B> appends the specified <I>itemString</I> to the end of 
the items already contained in the option menu <I>control</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the option menu control</DD><DT><I>itemString</I></DT><DD>the string to add</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgOptionMenuDeleteAllItems>mgOptionMenuDeleteAllItems</A>, <A HREF=#mgOptionMenuDeleteItem>mgOptionMenuDeleteItem</A>, 
<A HREF=#mgOptionMenuDeleteItemAtPos>mgOptionMenuDeleteItemAtPos</A></DD></DL>
<HR>
<LEFT><A NAME=mgOptionMenuDeleteAllItems><H1 CLASS="APISYMBOL">mgOptionMenuDeleteAllItems</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgOptionMenuDeleteAllItems</B> - deletes all items in an option 
menu control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgOptionMenuDeleteAllItems</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgOptionMenuDeleteAllItems</B> deletes all the items contained in the 
specified option menu <I>control</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the option menu control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgOptionMenuDeleteItem>mgOptionMenuDeleteItem</A>, <A HREF=#mgOptionMenuDeleteItemAtPos>mgOptionMenuDeleteItemAtPos</A></DD></DL>
<HR>
<LEFT><A NAME=mgOptionMenuDeleteItem><H1 CLASS="APISYMBOL">mgOptionMenuDeleteItem</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgOptionMenuDeleteItem</B> - deletes an item from an option 
menu control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgOptionMenuDeleteItem</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>itemString</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgOptionMenuDeleteItem</B> deletes the first item in the specified 
option menu <I>control</I> that matches the specified text string <I>itemString</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the option menu control</DD><DT><I>itemString</I></DT><DD>the text of the item to delete</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgOptionMenuDeleteItemAtPos>mgOptionMenuDeleteItemAtPos</A>, <A HREF=#mgOptionMenuDeleteAllItems>mgOptionMenuDeleteAllItems</A></DD></DL>
<HR>
<LEFT><A NAME=mgOptionMenuDeleteItemAtPos><H1 CLASS="APISYMBOL">mgOptionMenuDeleteItemAtPos</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgOptionMenuDeleteItemAtPos</B> - deletes an item from an 
option menu control at a specified position.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgOptionMenuDeleteItemAtPos</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>itemPos</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgOptionMenuDeleteItemAtPos</B> deletes the item at the specified 
position <I>itemPos</I> from the specified option menu <I>control</I>.</P></DD><DD><P>Position 1 indicates the first item in the control.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the option menu control</DD><DT><I>itemPos</I></DT><DD>the position of item in option menu to delete</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><B>mgOptionMenuDeleteItemAtPos</B>, <A HREF=#mgOptionMenuDeleteAllItems>mgOptionMenuDeleteAllItems</A></DD></DL>
<HR>
<LEFT><A NAME=mgOptionMenuGetItemCount><H1 CLASS="APISYMBOL">mgOptionMenuGetItemCount</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgOptionMenuGetItemCount</B> - counts the number of items in an 
option menu control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgOptionMenuGetItemCount</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgOptionMenuGetItemCount</B> returns the number of items contained in the 
specified option menu <I>control</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the option menu control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of items contained in the control, 0 if none.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<HR>
<LEFT><A NAME=mgOptionMenuGetItemStringAtPos><H1 CLASS="APISYMBOL">mgOptionMenuGetItemStringAtPos</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgOptionMenuGetItemStringAtPos</B> - retrieves text of an item 
in an option menu control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgOptionMenuGetItemStringAtPos</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>itemPos</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>itemString</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maxLen</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgOptionMenuGetItemStringAtPos</B> retrieves the text string of the 
item at the specified position <I>itemPos</I>, in the specified option menu 
<I>control</I>.</P></DD><DD><P>The string is truncated and 
null terminated if it is longer than <I>maxLen</I> characters.</P></DD><DD><P>Position 1 indicates the first item in the control.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the option menu control</DD><DT><I>itemPos</I></DT><DD>the position of item in option menu to get</DD><DT><I>itemString</I></DT><DD>character buffer to hold text of item</DD><DT><I>maxLen</I></DT><DD>the maximum number of characters to store in <I>itemString</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.  If function 
is successful, <I>itemString</I> is loaded with the text of the item. 
Otherwise, <I>itemString</I> is undefined.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgOptionMenuGetSelectedItemString>mgOptionMenuGetSelectedItemString</A></DD></DL>
<HR>
<LEFT><A NAME=mgOptionMenuGetSelectedItemPos><H1 CLASS="APISYMBOL">mgOptionMenuGetSelectedItemPos</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgOptionMenuGetSelectedItemPos</B> - retrieves position of 
selected item in an option menu control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgOptionMenuGetSelectedItemPos</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>itemPos</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgOptionMenuGetSelectedItemPos</B> retrieves the position of the selected 
item in the specified option menu <I>control</I>.</P></DD><DD><P>Position 1 indicates the first item in the control.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the option menu control</DD><DT><I>itemPos</I></DT><DD>address of value to receive selected position</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.  If function 
is successful, <I>itemPos</I> contains the position of the selected item.  Otherwise, 
<I>itemPos</I> is undefined.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgOptionMenuGetSelectedItemString>mgOptionMenuGetSelectedItemString</A>, <A HREF=#mgOptionMenuSelectItemAtPos>mgOptionMenuSelectItemAtPos</A>, 
<A HREF=#mgOptionMenuSelectItem>mgOptionMenuSelectItem</A></DD></DL>
<HR>
<LEFT><A NAME=mgOptionMenuGetSelectedItemString><H1 CLASS="APISYMBOL">mgOptionMenuGetSelectedItemString</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgOptionMenuGetSelectedItemString</B> - retrieves text of selected item 
in an option menu control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgOptionMenuGetSelectedItemString</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>itemString</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maxLen</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgOptionMenuGetSelectedItemString</B> retrieves the text string of the selected 
item in the specified option menu <I>control</I>.</P></DD><DD><P>The string is truncated and 
null terminated if it is longer than <I>maxLen</I> characters.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the option menu control</DD><DT><I>itemString</I></DT><DD>character buffer to hold text of selected item retrieved</DD><DT><I>maxLen</I></DT><DD>the maximum number of characters to store in <I>itemString</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.  If function 
is successful, <I>itemString</I> is loaded with the text of the selected item.  Otherwise, 
<I>itemString</I> is undefined.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgOptionMenuGetSelectedItemPos>mgOptionMenuGetSelectedItemPos</A>, <A HREF=#mgOptionMenuSelectItemAtPos>mgOptionMenuSelectItemAtPos</A>, 
<A HREF=#mgOptionMenuSelectItem>mgOptionMenuSelectItem</A></DD></DL>
<HR>
<LEFT><A NAME=mgOptionMenuSelectItem><H1 CLASS="APISYMBOL">mgOptionMenuSelectItem</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgOptionMenuSelectItem</B> - selects an item in an option menu 
control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgOptionMenuSelectItem</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>itemString</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgOptionMenuSelectItem</B> selects the first item in the specified 
option menu <I>control</I> that matches the specified text string <I>itemString</I>.</P></DD><DD><P>The <A HREF=#MGCB_ACTIVATE>MGCB_ACTIVATE</A> control event is not sent when this function 
is called.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the option menu control</DD><DT><I>itemString</I></DT><DD>the text of the item to select</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgOptionMenuSelectItemAtPos>mgOptionMenuSelectItemAtPos</A></DD></DL>
<HR>
<LEFT><A NAME=mgOptionMenuSelectItemAtPos><H1 CLASS="APISYMBOL">mgOptionMenuSelectItemAtPos</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgOptionMenuSelectItemAtPos</B> - selects an item an option 
menu control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgOptionMenuSelectItemAtPos</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>itemPos</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgOptionMenuSelectItemAtPos</B> selects the item at the position 
specified by <I>itemPos</I> in the specified option menu <I>control</I>.</P></DD><DD><P>Position 1 specifies the first item in the control.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the option menu control</DD><DT><I>itemPos</I></DT><DD>the position of the item to select</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgOptionMenuGetSelectedItemString>mgOptionMenuGetSelectedItemString</A>, <A HREF=#mgOptionMenuGetSelectedItemPos>mgOptionMenuGetSelectedItemPos</A>, 
<A HREF=#mgOptionMenuSelectItem>mgOptionMenuSelectItem</A></DD></DL>
<HR>
<LEFT><A NAME=mgpalettenotifyfunc><H1 CLASS="APISYMBOL">mgpalettenotifyfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgpalettenotifyfunc</B> - Palette notifier callback function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void (*<B>mgpalettenotifyfunc</B>) ( <TD><A HREF=#mgnotifier>mgnotifier</A> <TD><I>notifier</I>, 
<TR><TD></TD><TD><A HREF=#mgnotifierevent>mgnotifierevent</A> <TD><I>event</I>, 
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A> <TD><I>db</I>, 
<TR><TD></TD><TD>int <TD><I>index</I>, 
<TR><TD></TD><TD>void* <TD><I>userData</I> );</TABLE></DD>
</DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>notifier</I></DT><DD>the notifier</DD><DT><I>event</I></DT><DD>the notification event that triggered the callback</DD><DT><I>db</I></DT><DD>the database to which or in which the event occurred</DD><DT><I>index</I></DT><DD>the index of the palette entry that is affected</DD><DT><I>userData</I></DT><DD>user defined data specified when notifier registered</DD></DL></DD></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterPaletteNotifier>mgRegisterPaletteNotifier</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamAddBool><H1 CLASS="APISYMBOL">mgParamAddBool</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamAddBool</B> - adds a boolean parameter to a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgparam <B>mgParamAddBool</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamAddBool</B> creates a new boolean 
parameter named <I>paramName</I> and adds it to the parameter block <I>paramBlock</I>. 
The parameter value is initialized with <I>defaultValue</I>.</P></DD><DD><P>After the parameter value is defined, use <A HREF=#mgParamGetBool>mgParamGetBool</A> 
and <A HREF=#mgParamSetBool>mgParamSetBool</A> to query and change its value, respectively.</P></DD><DD><P>Note: If the named parameter already exists in <I>paramBlock</I>, it 
is replaced.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>defaultValue</I></DT><DD>default value of the parameter</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the parameter if created successfully, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamAddInteger>mgParamAddInteger</A>, <A HREF=#mgParamAddDouble>mgParamAddDouble</A>, 
<A HREF=#mgParamAddFloat>mgParamAddFloat</A>, <A HREF=#mgParamAddString>mgParamAddString</A>, 
<A HREF=#mgParamAddDouble2>mgParamAddDouble2</A>, <A HREF=#mgParamAddDouble3>mgParamAddDouble3</A>, 
<A HREF=#mgParamGetBool>mgParamGetBool</A>, <A HREF=#mgParamSetBool>mgParamSetBool</A>, 
<A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamAddDouble><H1 CLASS="APISYMBOL">mgParamAddDouble</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamAddDouble</B> - adds a double precision floating point 
parameter to a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgparam <B>mgParamAddDouble</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamAddDouble</B> creates a new double precision floating point 
parameter named <I>paramName</I> and adds it to the parameter block <I>paramBlock</I>. 
The parameter value is initialized with <I>defaultValue</I>.</P></DD><DD><P>You can use <A HREF=#mgParamSetDoubleMinGT>mgParamSetDoubleMinGT</A>, 
<A HREF=#mgParamSetDoubleMinGE>mgParamSetDoubleMinGE</A>, <A HREF=#mgParamSetDoubleMaxLT>mgParamSetDoubleMaxLT</A> and <A HREF=#mgParamSetDoubleMaxLE>mgParamSetDoubleMaxLE</A> 
to define the valid range for your parameter value.</P></DD><DD><P>After the parameter value is defined, use <A HREF=#mgParamGetDouble>mgParamGetDouble</A> 
and <A HREF=#mgParamSetDouble>mgParamSetDouble</A> to query and change its value, respectively.</P></DD><DD><P>Note: If the named parameter already exists in <I>paramBlock</I>, it 
is replaced.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>defaultValue</I></DT><DD>default value of the parameter</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the parameter if created successfully, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamAddInteger>mgParamAddInteger</A>, <A HREF=#mgParamAddFloat>mgParamAddFloat</A>, 
<A HREF=#mgParamAddBool>mgParamAddBool</A>, <A HREF=#mgParamAddString>mgParamAddString</A>, <A HREF=#mgParamAddDouble2>mgParamAddDouble2</A>, <A HREF=#mgParamAddDouble3>mgParamAddDouble3</A>, 
<A HREF=#mgParamGetDouble>mgParamGetDouble</A>, <A HREF=#mgParamSetDouble>mgParamSetDouble</A>, 
<A HREF=#mgParamSetDoubleMinGT>mgParamSetDoubleMinGT</A>, <A HREF=#mgParamSetDoubleMinGE>mgParamSetDoubleMinGE</A>, 
<A HREF=#mgParamSetDoubleMaxLT>mgParamSetDoubleMaxLT</A>, <A HREF=#mgParamSetDoubleMaxLE>mgParamSetDoubleMaxLE</A>, 
<A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamAddDouble2><H1 CLASS="APISYMBOL">mgParamAddDouble2</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamAddDouble2</B> - adds a parameter to a parameter block 
composed of two double precision floating point numbers.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgparam <B>mgParamAddDouble2</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>defaultValue1</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>defaultValue2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamAddDouble2</B> creates a new parameter composed of two double 
precision floating point numbers named <I>paramName</I> and adds it to the 
parameter block <I>paramBlock</I>. 
The parameter value is initialized with <I>defaultValue1</I> and <I>defaultValue2</I>.</P></DD><DD><P>After the parameter value is defined, use <A HREF=#mgParamGetDouble2>mgParamGetDouble2</A> 
and <A HREF=#mgParamSetDouble2>mgParamSetDouble2</A> to query and change its value, respectively.</P></DD><DD><P>Note: If the named parameter already exists in <I>paramBlock</I>, it 
is replaced.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>defaultValue1</I></DT><DD>default value 1 of the parameter</DD><DT><I>defaultValue2</I></DT><DD>default value 2 of the parameter</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the parameter if created successfully, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamAddInteger>mgParamAddInteger</A>, <A HREF=#mgParamAddDouble>mgParamAddDouble</A>, <A HREF=#mgParamAddDouble3>mgParamAddDouble3</A>, 
<A HREF=#mgParamAddFloat>mgParamAddFloat</A>, <A HREF=#mgParamAddBool>mgParamAddBool</A>, <A HREF=#mgParamAddString>mgParamAddString</A>, 
<A HREF=#mgParamGetDouble3>mgParamGetDouble3</A>, <A HREF=#mgParamSetDouble3>mgParamSetDouble3</A>, 
<A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamAddDouble3><H1 CLASS="APISYMBOL">mgParamAddDouble3</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamAddDouble3</B> - adds a parameter to a parameter block 
composed of three double precision floating point numbers.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgparam <B>mgParamAddDouble3</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>defaultValue1</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>defaultValue2</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>defaultValue3</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamAddDouble3</B> creates a new parameter composed of three double 
precision floating point numbers named <I>paramName</I> and adds it to the 
parameter block <I>paramBlock</I>. 
The parameter value is initialized with <I>defaultValue1</I>, <I>defaultValue2</I> and 
<I>defaultValue3</I>.</P></DD><DD><P>After the parameter value is defined, use <A HREF=#mgParamGetDouble3>mgParamGetDouble3</A> 
and <A HREF=#mgParamSetDouble3>mgParamSetDouble3</A> to query and change its value, respectively.</P></DD><DD><P>Note: If the named parameter already exists in <I>paramBlock</I>, it 
is replaced.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>defaultValue1</I></DT><DD>default value 1 of the parameter</DD><DT><I>defaultValue2</I></DT><DD>default value 2 of the parameter</DD><DT><I>defaultValue3</I></DT><DD>default value 3 of the parameter</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the parameter if created successfully, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamAddInteger>mgParamAddInteger</A>, <A HREF=#mgParamAddDouble>mgParamAddDouble</A>, <A HREF=#mgParamAddDouble2>mgParamAddDouble2</A>, 
<A HREF=#mgParamAddFloat>mgParamAddFloat</A>, <A HREF=#mgParamAddBool>mgParamAddBool</A>, <A HREF=#mgParamAddString>mgParamAddString</A>, 
<A HREF=#mgParamGetDouble3>mgParamGetDouble3</A>, <A HREF=#mgParamSetDouble3>mgParamSetDouble3</A>, 
<A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamAddFloat><H1 CLASS="APISYMBOL">mgParamAddFloat</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamAddFloat</B> - adds a single precision floating point 
parameter to a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgparam <B>mgParamAddFloat</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamAddFloat</B> creates a new single precision floating point 
parameter named <I>paramName</I> and adds it to the parameter block <I>paramBlock</I>. 
The parameter value is initialized with <I>defaultValue</I>.</P></DD><DD><P>You can use <A HREF=#mgParamSetDoubleMinGT>mgParamSetDoubleMinGT</A>, 
<A HREF=#mgParamSetDoubleMinGE>mgParamSetDoubleMinGE</A>, <A HREF=#mgParamSetDoubleMaxLT>mgParamSetDoubleMaxLT</A> and <A HREF=#mgParamSetDoubleMaxLE>mgParamSetDoubleMaxLE</A> 
to define the valid range for your parameter value.</P></DD><DD><P>After the parameter value is defined, use <A HREF=#mgParamGetFloat>mgParamGetFloat</A> 
and <A HREF=#mgParamSetFloat>mgParamSetFloat</A> to query and change its value, respectively.</P></DD><DD><P>Note: If the named parameter already exists in <I>paramBlock</I>, it 
is replaced.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>defaultValue</I></DT><DD>default value of the parameter</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the parameter if created successfully, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamAddInteger>mgParamAddInteger</A>, <A HREF=#mgParamAddDouble>mgParamAddDouble</A>, 
<A HREF=#mgParamAddBool>mgParamAddBool</A>, <A HREF=#mgParamAddString>mgParamAddString</A>, <A HREF=#mgParamAddDouble2>mgParamAddDouble2</A>, 
<A HREF=#mgParamAddDouble3>mgParamAddDouble3</A>, <A HREF=#mgParamGetFloat>mgParamGetFloat</A>, <A HREF=#mgParamSetFloat>mgParamSetFloat</A>, 
<A HREF=#mgParamSetDoubleMinGT>mgParamSetDoubleMinGT</A>, <A HREF=#mgParamSetDoubleMinGE>mgParamSetDoubleMinGE</A>, 
<A HREF=#mgParamSetDoubleMaxLT>mgParamSetDoubleMaxLT</A>, <A HREF=#mgParamSetDoubleMaxLE>mgParamSetDoubleMaxLE</A>, 
<A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamAddInteger><H1 CLASS="APISYMBOL">mgParamAddInteger</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamAddInteger</B> - adds an integer parameter to a 
parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgparam <B>mgParamAddInteger</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamAddInteger</B> creates a new integer parameter named 
<I>paramName</I> and adds it to the parameter block <I>paramBlock</I>. 
The parameter value is initialized with <I>defaultValue</I>.</P></DD><DD><P>You can use an integer parameter to represent numeric (the default) or 
enumerated values.  Enumerated integer parameters represent a set (may be non-contiguous) 
of discrete values, while numeric integer parameters represent a range of whole numbers.</P></DD><DD><P>If your integer parameter is enumerated, use <A HREF=#mgParamSetEnumerant>mgParamSetEnumerant</A> to define each 
enumerant.</P></DD><DD><P>If your integer parameter is numeric, you can use <A HREF=#mgParamSetIntegerMinGT>mgParamSetIntegerMinGT</A>, 
<A HREF=#mgParamSetIntegerMinGE>mgParamSetIntegerMinGE</A>, <A HREF=#mgParamSetIntegerMaxLT>mgParamSetIntegerMaxLT</A> and <A HREF=#mgParamSetIntegerMaxLE>mgParamSetIntegerMaxLE</A> 
to define the valid range for your parameter value.</P></DD><DD><P>After the parameter value is defined, use <A HREF=#mgParamGetInteger>mgParamGetInteger</A> 
and <A HREF=#mgParamSetInteger>mgParamSetInteger</A> to query and change its value, respectively.</P></DD><DD><P>Note: If the named parameter already exists in <I>paramBlock</I>, it 
is replaced.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>defaultValue</I></DT><DD>default value of the parameter</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the parameter if created successfully, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamAddDouble>mgParamAddDouble</A>, <A HREF=#mgParamAddFloat>mgParamAddFloat</A>, 
<A HREF=#mgParamAddBool>mgParamAddBool</A>, 
<A HREF=#mgParamAddString>mgParamAddString</A>, <A HREF=#mgParamAddDouble2>mgParamAddDouble2</A>, <A HREF=#mgParamAddDouble3>mgParamAddDouble3</A>, 
<A HREF=#mgParamGetInteger>mgParamGetInteger</A>, <A HREF=#mgParamSetInteger>mgParamSetInteger</A>, <A HREF=#mgParamSetEnumerant>mgParamSetEnumerant</A>, 
<A HREF=#mgParamSetIntegerMinGT>mgParamSetIntegerMinGT</A>, <A HREF=#mgParamSetIntegerMinGE>mgParamSetIntegerMinGE</A>, 
<A HREF=#mgParamSetIntegerMaxLT>mgParamSetIntegerMaxLT</A>, <A HREF=#mgParamSetIntegerMaxLE>mgParamSetIntegerMaxLE</A>, 
<A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamAddString><H1 CLASS="APISYMBOL">mgParamAddString</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamAddString</B> - adds a string parameter to a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgparam <B>mgParamAddString</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamAddString</B> creates a new string 
parameter named <I>paramName</I> and adds it to the parameter block <I>paramBlock</I>. 
The parameter value is initialized with <I>defaultValue</I>.</P></DD><DD><P>After the parameter value is defined, use <A HREF=#mgParamGetString>mgParamGetString</A> 
and <A HREF=#mgParamSetString>mgParamSetString</A> to query and change its value, respectively.</P></DD><DD><P>Note: If the named parameter already exists in <I>paramBlock</I>, it 
is replaced.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>defaultValue</I></DT><DD>default value of the parameter</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the parameter if created successfully, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamAddInteger>mgParamAddInteger</A>, <A HREF=#mgParamAddDouble>mgParamAddDouble</A>, 
<A HREF=#mgParamAddFloat>mgParamAddFloat</A>, <A HREF=#mgParamAddBool>mgParamAddBool</A>, 
<A HREF=#mgParamAddDouble2>mgParamAddDouble2</A>, <A HREF=#mgParamAddDouble3>mgParamAddDouble3</A>, 
<A HREF=#mgParamGetString>mgParamGetString</A>, <A HREF=#mgParamSetString>mgParamSetString</A>, 
<A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamAppend><H1 CLASS="APISYMBOL">mgParamAppend</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamAppend</B> - appends a value to an array type parameter 
in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For C)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamAppend</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#variant>variant</A></TD><TD><I>paramValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamAppend</B> appends the value <I>paramValue</I> to the array type 
parameter named <I>paramName</I> in the parameter block <I>paramBlock</I>. 
If the parameter does not exist, no value is appended.</P></DD><DD><P>When setting up an array type parameter, use <A HREF=#mgParamSet>mgParamSet</A> 
to set the first item in the array.  When you call <A HREF=#mgParamSet>mgParamSet</A>, the 
parameter array is truncated to a single item.  To add the second and subsequent 
items to the array, use <B>mgParamAppend</B> as needed.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block. 
Also, if the parameter is not an array type parameter, this function will do nothing.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>Note that this function is for OpenFlight Scripts only and cannot 
be used by your C language plug-in. 
In your C language plug-in you must use either 
<A HREF=#mgParamAppendInteger>mgParamAppendInteger</A>, <A HREF=#mgParamAppendDouble>mgParamAppendDouble</A>, <A HREF=#mgParamAppendFloat>mgParamAppendFloat</A>, 
<A HREF=#mgParamAppendBool>mgParamAppendBool</A>, <A HREF=#mgParamAppendString>mgParamAppendString</A>, <A HREF=#mgParamAppendDouble2>mgParamAppendDouble2</A> 
or <A HREF=#mgParamAppendDouble3>mgParamAppendDouble3</A> depending on the data type of the parameter.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>paramValue</I></DT><DD>value to append for <I>paramName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>paramName</I> is not a parameter in <I>paramBlock</I>, 
if <I>paramValue</I> is not a valid value for the <I>paramName</I> parameter 
as defined by its constraints (if any), or if the maximum dimension of 
<I>paramName</I> would be exceeded by appending this item.
</DD></DL><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT>The following shows how you might use this function in your script 
to execute the Polygon tool, which accepts an array of 3D points as 
parameters representing the points on the polygon:</DT><DT><PRE CLASS="EXAMPLE"># set the parameters for and call the Creator Polygon tool.
paramBlock = mgGetParamBlock ("Polygon")

# note that the "Points" parameter of the Polygon tool is an
# array type parameter - each point in the array is a point
# on the polygon created

# use mgParamSet to set the first point
mgParamSet (paramBlock, "Points", [0, 0, 0])

# then use mgParamAppend to add more points
mgParamAppend (paramBlock, "Points", [10,  0, 0])
mgParamAppend (paramBlock, "Points", [10, 10, 0])
mgParamAppend (paramBlock, "Points", [ 0, 10, 0])

# finally, set the parameter to make a "solid" polygon...
mgParamSet (paramBlock, "Type", "Solid")

# ...and execute the tool
mgExecute ("Polygon", paramBlock)</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamAppendInteger>mgParamAppendInteger</A>, <A HREF=#mgParamAppendDouble>mgParamAppendDouble</A>, 
<A HREF=#mgParamAppendFloat>mgParamAppendFloat</A>, <A HREF=#mgParamAppendBool>mgParamAppendBool</A>, <A HREF=#mgParamAppendString>mgParamAppendString</A>, 
<A HREF=#mgParamAppendDouble2>mgParamAppendDouble2</A>, <A HREF=#mgParamAppendDouble3>mgParamAppendDouble3</A>, <A HREF=#mgParamSet>mgParamSet</A>, 
<A HREF=#mgGetParamBlock>mgGetParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamAppendBool><H1 CLASS="APISYMBOL">mgParamAppendBool</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamAppendBool</B> - appends a value to a boolean 
array type parameter in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamAppendBool</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>paramValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamAppendBool</B> appends the value <I>paramValue</I> to the boolean 
array type parameter named <I>paramName</I> in the parameter block <I>paramBlock</I>. 
If the parameter does not exist, no value is appended.</P></DD><DD><P>When setting up a boolean array type parameter, 
use <A HREF=#mgParamSetBool>mgParamSetBool</A> to set the first item in the array.  When you call 
<A HREF=#mgParamSetBool>mgParamSetBool</A>, the parameter array is truncated to a single item. 
To add the second and subsequent items to the array, use <B>mgParamAppendBool</B> 
as needed.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block. 
Also, if the parameter is not an array type parameter, this function will do nothing.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>paramValue</I></DT><DD>value to append for <I>paramName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>paramName</I> is not a parameter in <I>paramBlock</I>, 
if <I>paramValue</I> is not a valid value for the <I>paramName</I> parameter 
as defined by its constraints (if any), or if the maximum dimension of 
<I>paramName</I> would be exceeded by appending this item.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamGetBoolNth>mgParamGetBoolNth</A>, <A HREF=#mgParamSetBool>mgParamSetBool</A>, 
<A HREF=#mgParamAppendInteger>mgParamAppendInteger</A>, <A HREF=#mgParamAppendDouble>mgParamAppendDouble</A>, 
<A HREF=#mgParamAppendFloat>mgParamAppendFloat</A> 
<A HREF=#mgParamAppendString>mgParamAppendString</A>, <A HREF=#mgParamAppendDouble2>mgParamAppendDouble2</A>, <A HREF=#mgParamAppendDouble3>mgParamAppendDouble3</A>, 
<A HREF=#mgGetParamBlock>mgGetParamBlock</A>, <A HREF=#mgNewParamBlock>mgNewParamBlock</A>, <A HREF=#mgParamAppend>mgParamAppend</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamAppendDouble><H1 CLASS="APISYMBOL">mgParamAppendDouble</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamAppendDouble</B> - appends a value to a double precision 
floating point array type parameter in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamAppendDouble</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>paramValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamAppendDouble</B> appends the value <I>paramValue</I> to the 
double precision floating point array type parameter named <I>paramName</I> 
in the parameter block <I>paramBlock</I>. 
If the parameter does not exist, no value is appended.</P></DD><DD><P>When setting up a double precision floating point array type parameter, 
use <A HREF=#mgParamSetDouble>mgParamSetDouble</A> to set the first item in the array.  When you call 
<A HREF=#mgParamSetDouble>mgParamSetDouble</A>, the parameter array is truncated to a single item. 
To add the second and subsequent items to the array, use <B>mgParamAppendDouble</B> 
as needed.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block. 
Also, if the parameter is not an array type parameter, this function will do nothing.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>paramValue</I></DT><DD>value to append for <I>paramName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>paramName</I> is not a parameter in <I>paramBlock</I>, 
if <I>paramValue</I> is not a valid value for the <I>paramName</I> parameter 
as defined by its constraints (if any), or if the maximum dimension of 
<I>paramName</I> would be exceeded by appending this item.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamGetDoubleNth>mgParamGetDoubleNth</A>, <A HREF=#mgParamSetDouble>mgParamSetDouble</A>, 
<A HREF=#mgParamAppendInteger>mgParamAppendInteger</A>, 
<A HREF=#mgParamAppendFloat>mgParamAppendFloat</A>, <A HREF=#mgParamAppendBool>mgParamAppendBool</A>, 
<A HREF=#mgParamAppendString>mgParamAppendString</A>, <A HREF=#mgParamAppendDouble2>mgParamAppendDouble2</A>, <A HREF=#mgParamAppendDouble3>mgParamAppendDouble3</A>, 
<A HREF=#mgGetParamBlock>mgGetParamBlock</A>, <A HREF=#mgNewParamBlock>mgNewParamBlock</A>, <A HREF=#mgParamAppend>mgParamAppend</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamAppendDouble2><H1 CLASS="APISYMBOL">mgParamAppendDouble2</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamAppendDouble2</B> - appends a value to a double2 array 
type parameter in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamAppendDouble2</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>paramValue1</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>paramValue2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamAppendDouble2</B> appends the value (comprised of <I>paramValue1</I> 
and <I>paramValue2</I>) to the double2 array type parameter 
named <I>paramName</I> in the parameter block <I>paramBlock</I>. 
If the parameter does not exist, no value is appended.</P></DD><DD><P>When setting up a double2 array type parameter, use <A HREF=#mgParamSetDouble2>mgParamSetDouble2</A> 
to set the first item in the array.  When you call <A HREF=#mgParamSetDouble2>mgParamSetDouble2</A>, the 
parameter array is truncated to a single item.  To add the second and subsequent 
items to the array, use <B>mgParamAppendDouble2</B> as needed.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block. 
Also, if the parameter is not an array type parameter, this function will do nothing.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>paramValue1</I></DT><DD>value 1 to append for <I>paramName</I></DD><DT><I>paramValue2</I></DT><DD>value 2 to append for <I>paramName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>paramName</I> is not a parameter in <I>paramBlock</I>, 
if <I>paramValue1</I> or <I>paramValue2</I> is not a valid value for 
the <I>paramName</I> parameter as defined by its constraints (if any), or if the 
maximum dimension of <I>paramName</I> would be exceeded by appending this item.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamGetDouble2Nth>mgParamGetDouble2Nth</A>, <A HREF=#mgParamSetDouble2>mgParamSetDouble2</A>, 
<A HREF=#mgParamAppendInteger>mgParamAppendInteger</A>, <A HREF=#mgParamAppendDouble>mgParamAppendDouble</A>, 
<A HREF=#mgParamAppendDouble3>mgParamAppendDouble3</A>, <A HREF=#mgParamAppendFloat>mgParamAppendFloat</A>, <A HREF=#mgParamAppendBool>mgParamAppendBool</A>, 
<A HREF=#mgParamAppendString>mgParamAppendString</A>, 
<A HREF=#mgGetParamBlock>mgGetParamBlock</A>, <A HREF=#mgNewParamBlock>mgNewParamBlock</A>, <A HREF=#mgParamAppend>mgParamAppend</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamAppendDouble3><H1 CLASS="APISYMBOL">mgParamAppendDouble3</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamAppendDouble3</B> - appends a value to a double3 array 
type parameter in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamAppendDouble3</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>paramValue1</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>paramValue2</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>paramValue3</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamAppendDouble3</B> appends the value (comprised of <I>paramValue1</I>, 
<I>paramValue2</I> and <I>paramValue3</I>) to the double3 array type parameter 
named <I>paramName</I> in the parameter block <I>paramBlock</I>. 
If the parameter does not exist, no value is appended.</P></DD><DD><P>When setting up a double3 array type parameter, use <A HREF=#mgParamSetDouble3>mgParamSetDouble3</A> 
to set the first item in the array.  When you call <A HREF=#mgParamSetDouble3>mgParamSetDouble3</A>, the 
parameter array is truncated to a single item.  To add the second and subsequent 
items to the array, use <B>mgParamAppendDouble3</B> as needed.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block. 
Also, if the parameter is not an array type parameter, this function will do nothing.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>paramValue1</I></DT><DD>value 1 to append for <I>paramName</I></DD><DT><I>paramValue2</I></DT><DD>value 2 to append for <I>paramName</I></DD><DT><I>paramValue3</I></DT><DD>value 3 to append for <I>paramName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>paramName</I> is not a parameter in <I>paramBlock</I>, 
if <I>paramValue1</I>, <I>paramValue2</I> or <I>paramValue3</I> is not a valid value for 
the <I>paramName</I> parameter as defined by its constraints (if any), or if the 
maximum dimension of <I>paramName</I> would be exceeded by appending this item.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamGetDouble3Nth>mgParamGetDouble3Nth</A>, <A HREF=#mgParamSetDouble3>mgParamSetDouble3</A>, 
<A HREF=#mgParamAppendInteger>mgParamAppendInteger</A>, <A HREF=#mgParamAppendDouble>mgParamAppendDouble</A>, 
<A HREF=#mgParamAppendDouble2>mgParamAppendDouble2</A>, <A HREF=#mgParamAppendFloat>mgParamAppendFloat</A>, <A HREF=#mgParamAppendBool>mgParamAppendBool</A>, 
<A HREF=#mgParamAppendString>mgParamAppendString</A>, 
<A HREF=#mgGetParamBlock>mgGetParamBlock</A>, <A HREF=#mgNewParamBlock>mgNewParamBlock</A>, <A HREF=#mgParamAppend>mgParamAppend</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamAppendFloat><H1 CLASS="APISYMBOL">mgParamAppendFloat</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamAppendFloat</B> - appends a value to a single precision 
floating point array type parameter in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamAppendFloat</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>paramValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamAppendFloat</B> appends the value <I>paramValue</I> to the 
single precision floating point array type parameter named <I>paramName</I> 
in the parameter block <I>paramBlock</I>. 
If the parameter does not exist, no value is appended.</P></DD><DD><P>When setting up a single precision floating point array type parameter, 
use <A HREF=#mgParamSetFloat>mgParamSetFloat</A> to set the first item in the array.  When you call 
<A HREF=#mgParamSetFloat>mgParamSetFloat</A>, the parameter array is truncated to a single item. 
To add the second and subsequent items to the array, use <B>mgParamAppendFloat</B> 
as needed.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block. 
Also, if the parameter is not an array type parameter, this function will do nothing.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>paramValue</I></DT><DD>value to append for <I>paramName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>paramName</I> is not a parameter in <I>paramBlock</I>, 
if <I>paramValue</I> is not a valid value for the <I>paramName</I> parameter 
as defined by its constraints (if any), or if the maximum dimension of 
<I>paramName</I> would be exceeded by appending this item.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamGetFloatNth>mgParamGetFloatNth</A>, <A HREF=#mgParamSetFloat>mgParamSetFloat</A>, 
<A HREF=#mgParamAppendInteger>mgParamAppendInteger</A>, <A HREF=#mgParamAppendDouble>mgParamAppendDouble</A>, 
<A HREF=#mgParamAppendBool>mgParamAppendBool</A>, 
<A HREF=#mgParamAppendString>mgParamAppendString</A>, <A HREF=#mgParamAppendDouble2>mgParamAppendDouble2</A>, <A HREF=#mgParamAppendDouble3>mgParamAppendDouble3</A>, 
<A HREF=#mgGetParamBlock>mgGetParamBlock</A>, <A HREF=#mgNewParamBlock>mgNewParamBlock</A>, <A HREF=#mgParamAppend>mgParamAppend</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamAppendInteger><H1 CLASS="APISYMBOL">mgParamAppendInteger</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamAppendInteger</B> - appends a value to an integer 
array type parameter in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamAppendInteger</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>paramValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamAppendInteger</B> appends the value <I>paramValue</I> to the 
integer array type parameter named <I>paramName</I> in the parameter block 
<I>paramBlock</I>.  If the parameter does not exist, no value is appended.</P></DD><DD><P>When setting up an integer array type parameter, use <A HREF=#mgParamSetInteger>mgParamSetInteger</A> 
to set the first item in the array.  When you call <A HREF=#mgParamSetInteger>mgParamSetInteger</A>, the 
parameter array is truncated to a single item.  To add the second and subsequent 
items to the array, use <B>mgParamAppendInteger</B> as needed.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block. 
Also, if the parameter is not an array type parameter, this function will do  nothing.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>paramValue</I></DT><DD>value to append for <I>paramName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>paramName</I> is not a parameter in <I>paramBlock</I>, 
if <I>paramValue</I> is not a valid value for the <I>paramName</I> parameter 
as defined by its constraints (if any), or if the maximum dimension of 
<I>paramName</I> would be exceeded by appending this item.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamGetIntegerNth>mgParamGetIntegerNth</A>, <A HREF=#mgParamSetInteger>mgParamSetInteger</A>, 
<A HREF=#mgParamAppendDouble>mgParamAppendDouble</A>, 
<A HREF=#mgParamAppendFloat>mgParamAppendFloat</A>, <A HREF=#mgParamAppendBool>mgParamAppendBool</A>, 
<A HREF=#mgParamAppendString>mgParamAppendString</A>, <A HREF=#mgParamAppendDouble2>mgParamAppendDouble2</A>, <A HREF=#mgParamAppendDouble3>mgParamAppendDouble3</A>, 
<A HREF=#mgGetParamBlock>mgGetParamBlock</A>, <A HREF=#mgNewParamBlock>mgNewParamBlock</A>, <A HREF=#mgParamAppend>mgParamAppend</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamAppendString><H1 CLASS="APISYMBOL">mgParamAppendString</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamAppendString</B> - appends a value to a string 
array type parameter in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamAppendString</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamAppendString</B> appends the value <I>paramValue</I> to the string 
array type parameter named <I>paramName</I> in the parameter block <I>paramBlock</I>. 
If the parameter does not exist, no value is appended.</P></DD><DD><P>When setting up a string array type parameter, 
use <A HREF=#mgParamSetString>mgParamSetString</A> to set the first item in the array.  When you call 
<A HREF=#mgParamSetString>mgParamSetString</A>, the parameter array is truncated to a single item. 
To add the second and subsequent items to the array, use <B>mgParamAppendString</B> 
as needed.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>paramValue</I></DT><DD>value to append for <I>paramName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>paramName</I> is not a parameter in <I>paramBlock</I>, 
if <I>paramValue</I> is not a valid value for the <I>paramName</I> parameter 
as defined by its constraints (if any), or if the maximum dimension of 
<I>paramName</I> would be exceeded by appending this item.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamGetStringNth>mgParamGetStringNth</A>, <A HREF=#mgParamSetString>mgParamSetString</A>, 
<A HREF=#mgParamAppendInteger>mgParamAppendInteger</A>, <A HREF=#mgParamAppendDouble>mgParamAppendDouble</A>, 
<A HREF=#mgParamAppendFloat>mgParamAppendFloat</A>, <A HREF=#mgParamAppendBool>mgParamAppendBool</A>, 
<A HREF=#mgParamAppendDouble2>mgParamAppendDouble2</A>, <A HREF=#mgParamAppendDouble3>mgParamAppendDouble3</A>, 
<A HREF=#mgGetParamBlock>mgGetParamBlock</A>, <A HREF=#mgNewParamBlock>mgNewParamBlock</A>, <A HREF=#mgParamAppend>mgParamAppend</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamExists><H1 CLASS="APISYMBOL">mgParamExists</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamExists</B> - determines whether a parameter value exists 
in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamExists</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamExists</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamExists</B> checks if a parameter value named <I>paramName</I> exists 
in the parameter block <I>paramBlock</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the parameter exists, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewParamBlock>mgNewParamBlock</A>, <A HREF=#mgGetParamBlock>mgGetParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamGetBool><H1 CLASS="APISYMBOL">mgParamGetBool</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamGetBool</B> - gets a boolean parameter value from a 
parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamGetBool</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool*</A></TD><TD><I>paramValue</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, paramValue <B>mgParamGetBool</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamGetBool</B> retrieves a boolean 
parameter value named <I>paramName</I> from the parameter block <I>paramBlock</I>. 
If the parameter exists, its value is returned in <I>paramValue</I>. If the 
parameter does not exist, <I>paramValue</I> is set to <I>defaultValue</I>.</P></DD><DD><P>If the parameter is not an array type parameter, this is the 
standard way to retrieve its boolean value. 
If the parameter is an array type parameter, this function gets 
the first item in the array and is equivalent to calling 
<A HREF=#mgParamGetBoolNth>mgParamGetBoolNth</A> passing 1 as <I>nth</I>.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>paramValue</I></DT><DD>storage location for the parameter value returned</DD><DT><I>defaultValue</I></DT><DD>default value returned if parameter does not exist</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the parameter exists, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>paramValue</DT><DD>If successful, <I>paramValue</I> will be the parameter 
value, otherwise <I>paramValue</I> will be <I>defaultValue</I>.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamSetBool>mgParamSetBool</A>, 
<A HREF=#mgParamGetInteger>mgParamGetInteger</A>, <A HREF=#mgParamGetDouble>mgParamGetDouble</A>, 
<A HREF=#mgParamGetFloat>mgParamGetFloat</A>, <A HREF=#mgParamGetString>mgParamGetString</A>, 
<A HREF=#mgParamGetDouble2>mgParamGetDouble2</A>, <A HREF=#mgParamGetDouble3>mgParamGetDouble3</A>, 
<A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamGetBoolNth><H1 CLASS="APISYMBOL">mgParamGetBoolNth</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamGetBoolNth</B> - gets the nth item of a boolean 
parameter value in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamGetBoolNth</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>nth</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool*</A></TD><TD><I>paramValue</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, paramValue <B>mgParamGetBoolNth</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamGetBoolNth</B> retrieves the <I>nth</I> item of a 
boolean parameter value named <I>paramName</I> in the parameter block 
<I>paramBlock</I>.  If the parameter exists and contains an <I>nth</I> 
item, its value is returned in <I>paramValue</I>. If the parameter 
does not exist or does not contain an <I>nth</I> item, <I>paramValue</I> 
is set to <I>defaultValue</I>.</P></DD><DD><P>The first item of an array parameter is <I>nth</I> equal to 1.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>nth</I></DT><DD>which value to return from the array parameter</DD><DT><I>paramValue</I></DT><DD>storage location for the parameter value returned</DD><DT><I>defaultValue</I></DT><DD>default value returned if parameter does not exist</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>paramValue</DT><DD>If successful, <I>paramValue</I> will be the parameter 
value, otherwise <I>paramValue</I> will be <I>defaultValue</I>.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamSetBool>mgParamSetBool</A>, <A HREF=#mgParamAppendBool>mgParamAppendBool</A>, 
<A HREF=#mgParamGetIntegerNth>mgParamGetIntegerNth</A>, <A HREF=#mgParamGetDoubleNth>mgParamGetDoubleNth</A>, <A HREF=#mgParamGetFloatNth>mgParamGetFloatNth</A>, 
<A HREF=#mgParamGetStringNth>mgParamGetStringNth</A>, <A HREF=#mgParamGetDouble2Nth>mgParamGetDouble2Nth</A>, <A HREF=#mgParamGetDouble3Nth>mgParamGetDouble3Nth</A>, 
<A HREF=#mgGetParamBlock>mgGetParamBlock</A>, <A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamGetDimension><H1 CLASS="APISYMBOL">mgParamGetDimension</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamGetDimension</B> - gets the maximum dimension of a 
parameter in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>unsigned int <B>mgParamGetDimension</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamGetDimension</B> gets the maximum dimension allowed for the 
parameter named <I>paramValue</I> in the parameter block <I>paramBlock</I>.</P></DD><DD><P>When a parameter is defined, it is assigned a maximum dimension. 
For most parameters, this value is 1, meaning that the parameter is one 
single value.  For array type parameters, the maximum dimension is some 
number greater than 1 or is 0.  If the maximum dimension is greater 
than 1, the value defines the finite number of values the array type 
parameter can contain.  If the maximum dimension is 0, the parameter 
is an array type but does not define the maximum number of values it 
can contain.</P></DD><DD><P>Note that <B>mgParamGetDimension</B> returns the maximum number of 
values a parameter can contain and <A HREF=#mgParamGetSize>mgParamGetSize</A> returns the number 
of values a parameter currently does contain.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the maximum dimension of the parameter named <I>paramValue</I>. 
0 indicates that the array type parameter can accept an unlimited number 
of values.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<HR>
<LEFT><A NAME=mgParamGetDouble><H1 CLASS="APISYMBOL">mgParamGetDouble</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamGetDouble</B> - gets a double precision floating point 
parameter value from a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamGetDouble</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>paramValue</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, paramValue <B>mgParamGetDouble</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamGetDouble</B> retrieves a double precision floating point 
parameter value named <I>paramName</I> from the parameter block <I>paramBlock</I>. 
If the parameter exists, its value is returned in <I>paramValue</I>. If the 
parameter does not exist, <I>paramValue</I> is set to <I>defaultValue</I>.</P></DD><DD><P>If the parameter is not an array type parameter, this is the 
standard way to retrieve its double precision floating point value. 
If the parameter is an array type parameter, this function gets 
the first item in the array and is equivalent to calling 
<A HREF=#mgParamGetDoubleNth>mgParamGetDoubleNth</A> passing 1 as <I>nth</I>.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>paramValue</I></DT><DD>storage location for the parameter value returned</DD><DT><I>defaultValue</I></DT><DD>default value returned if parameter does not exist</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the parameter exists, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>paramValue</DT><DD>If successful, <I>paramValue</I> will be the parameter 
value, otherwise <I>paramValue</I> will be <I>defaultValue</I>.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamSetDouble>mgParamSetDouble</A>, 
<A HREF=#mgParamGetInteger>mgParamGetInteger</A>, <A HREF=#mgParamGetFloat>mgParamGetFloat</A>, 
<A HREF=#mgParamGetBool>mgParamGetBool</A>, <A HREF=#mgParamGetString>mgParamGetString</A>, 
<A HREF=#mgParamGetDouble2>mgParamGetDouble2</A>, <A HREF=#mgParamGetDouble3>mgParamGetDouble3</A>, 
<A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamGetDouble2><H1 CLASS="APISYMBOL">mgParamGetDouble2</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamGetDouble2</B> - gets the two double precision floating 
point values for a parameter from a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamGetDouble2</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>paramValue1</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>paramValue2</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>defaultValue1</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>defaultValue2</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, paramValue1, paramValue2 <B>mgParamGetDouble2</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamGetDouble2</B> retrieves the two double precision floating point 
values of a parameter named <I>paramName</I> from the parameter block <I>paramBlock</I>. 
If the parameter exists, its values are returned in <I>paramValue1</I> and <I>paramValue2</I>. 
If the parameter does not exist, the output parameter values 
are set to the default you provide in <I>defaultValue1</I> and <I>defaultValue2</I>.</P></DD><DD><P>If the parameter is not an array type parameter, this is the 
standard way to retrieve its double2 value. 
If the parameter is an array type parameter, this function gets 
the first item in the array and is equivalent to calling 
<A HREF=#mgParamGetDouble2Nth>mgParamGetDouble2Nth</A> passing 1 as <I>nth</I>.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>paramValue1</I></DT><DD>storage location for the parameter value 1 returned</DD><DT><I>paramValue2</I></DT><DD>storage location for the parameter value 2 returned</DD><DT><I>defaultValue1</I></DT><DD>default value 1 returned if parameter does not exist</DD><DT><I>defaultValue2</I></DT><DD>default value 2 returned if parameter does not exist</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the parameter exists, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>paramValue1</DT><DD>If successful, this will be the first component of the 
returned values, otherwise will be <I>defaultValue1</I>.</DD><DT>paramValue2</DT><DD>If successful, this will be the second component of the 
returned values, otherwise will be <I>defaultValue2</I>.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamSetDouble2>mgParamSetDouble2</A>, 
<A HREF=#mgParamGetInteger>mgParamGetInteger</A>, <A HREF=#mgParamGetDouble>mgParamGetDouble</A>, 
<A HREF=#mgParamGetDouble3>mgParamGetDouble3</A>, <A HREF=#mgParamGetFloat>mgParamGetFloat</A>, 
<A HREF=#mgParamGetBool>mgParamGetBool</A>, <A HREF=#mgParamGetString>mgParamGetString</A>, 
<A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamGetDouble2Nth><H1 CLASS="APISYMBOL">mgParamGetDouble2Nth</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamGetDouble2Nth</B> - gets the nth item of a double2 
parameter value in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamGetDouble2Nth</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>nth</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>paramValue1</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>paramValue2</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>defaultValue1</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>defaultValue2</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, paramValue1, paramValue2 <B>mgParamGetDouble2Nth</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamGetDouble2Nth</B> retrieves the <I>nth</I> item of a 
double2 parameter value named <I>paramName</I> in the parameter block 
<I>paramBlock</I>.  If the parameter exists and contains an <I>nth</I> 
item, its two values are returned in <I>paramValue1</I> and <I>paramValue2</I>, 
If the parameter does not exist or does not contain an <I>nth</I> item, 
the output parameter values are set to the default you provide 
in <I>defaultValue1</I> and <I>defaultValue2</I>.</P></DD><DD><P>The first item of an array parameter is <I>nth</I> equal to 1.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>nth</I></DT><DD>which value to return from the array parameter</DD><DT><I>paramValue1</I></DT><DD>storage location for the parameter value 1 returned</DD><DT><I>paramValue2</I></DT><DD>storage location for the parameter value 2 returned</DD><DT><I>defaultValue1</I></DT><DD>default value 1 returned if parameter does not exist</DD><DT><I>defaultValue2</I></DT><DD>default value 2 returned if parameter does not exist</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>paramValue1</DT><DD>If successful, this will be the first component of the 
returned values, otherwise will be <I>defaultValue1</I>.</DD><DT>paramValue2</DT><DD>If successful, this will be the second component of the 
returned values, otherwise will be <I>defaultValue2</I>.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamSetDouble2>mgParamSetDouble2</A>, <A HREF=#mgParamAppendDouble2>mgParamAppendDouble2</A>, 
<A HREF=#mgParamGetIntegerNth>mgParamGetIntegerNth</A>, <A HREF=#mgParamGetDoubleNth>mgParamGetDoubleNth</A>, 
<A HREF=#mgParamGetDouble3Nth>mgParamGetDouble3Nth</A>, <A HREF=#mgParamGetFloatNth>mgParamGetFloatNth</A>, 
<A HREF=#mgParamGetBoolNth>mgParamGetBoolNth</A>, <A HREF=#mgParamGetStringNth>mgParamGetStringNth</A>, 
<A HREF=#mgGetParamBlock>mgGetParamBlock</A>, <A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamGetDouble3><H1 CLASS="APISYMBOL">mgParamGetDouble3</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamGetDouble3</B> - gets the three double precision floating 
point values for a parameter from a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamGetDouble3</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>paramValue1</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>paramValue2</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>paramValue3</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>defaultValue1</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>defaultValue2</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>defaultValue3</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, paramValue1, paramValue2, paramValue3 <B>mgParamGetDouble3</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamGetDouble3</B> retrieves the three double precision floating point 
values of a parameter named <I>paramName</I> from the parameter block <I>paramBlock</I>. 
If the parameter exists, its values are returned in <I>paramValue1</I>, <I>paramValue2</I> 
and <I>paramValue3</I>. If the parameter does not exist, the output parameter values 
are set to the default you provide in <I>defaultValue1</I>, <I>defaultValue2</I> and 
<I>defaultValue3</I>.</P></DD><DD><P>If the parameter is not an array type parameter, this is the 
standard way to retrieve its double3 value. 
If the parameter is an array type parameter, this function gets 
the first item in the array and is equivalent to calling 
<A HREF=#mgParamGetDouble3Nth>mgParamGetDouble3Nth</A> passing 1 as <I>nth</I>.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>paramValue1</I></DT><DD>storage location for the parameter value 1 returned</DD><DT><I>paramValue2</I></DT><DD>storage location for the parameter value 2 returned</DD><DT><I>paramValue3</I></DT><DD>storage location for the parameter value 3 returned</DD><DT><I>defaultValue1</I></DT><DD>default value 1 returned if parameter does not exist</DD><DT><I>defaultValue2</I></DT><DD>default value 2 returned if parameter does not exist</DD><DT><I>defaultValue3</I></DT><DD>default value 3 returned if parameter does not exist</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the parameter exists, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>paramValue1</DT><DD>If successful, this will be the first component of the 
returned values, otherwise will be <I>defaultValue1</I>.</DD><DT>paramValue2</DT><DD>If successful, this will be the second component of the 
returned values, otherwise will be <I>defaultValue2</I>.</DD><DT>paramValue3</DT><DD>If successful, this will be the third component of the 
returned values, otherwise will be <I>defaultValue3</I>.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamSetDouble3>mgParamSetDouble3</A>, 
<A HREF=#mgParamGetInteger>mgParamGetInteger</A>, <A HREF=#mgParamGetDouble>mgParamGetDouble</A>, 
<A HREF=#mgParamGetDouble2>mgParamGetDouble2</A>, <A HREF=#mgParamGetFloat>mgParamGetFloat</A>, 
<A HREF=#mgParamGetBool>mgParamGetBool</A>, <A HREF=#mgParamGetString>mgParamGetString</A>, 
<A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamGetDouble3Nth><H1 CLASS="APISYMBOL">mgParamGetDouble3Nth</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamGetDouble3Nth</B> - gets the nth item of a double3 
parameter value in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamGetDouble3Nth</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>nth</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>paramValue1</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>paramValue2</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>paramValue3</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>defaultValue1</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>defaultValue2</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>defaultValue3</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, paramValue1, paramValue2, paramValue3 <B>mgParamGetDouble3Nth</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamGetDouble3Nth</B> retrieves the <I>nth</I> item of a 
double3 parameter value named <I>paramName</I> in the parameter block 
<I>paramBlock</I>.  If the parameter exists and contains an <I>nth</I> 
item, its three values are returned in <I>paramValue1</I>, <I>paramValue2</I> 
and <I>paramValue3</I>. 
If the parameter does not exist or does not contain an <I>nth</I> item, 
the output parameter values are set to the default you provide 
in <I>defaultValue1</I>, <I>defaultValue2</I> and <I>defaultValue3</I>.</P></DD><DD><P>The first item of an array parameter is <I>nth</I> equal to 1.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>nth</I></DT><DD>which value to return from the array parameter</DD><DT><I>paramValue1</I></DT><DD>storage location for the parameter value 1 returned</DD><DT><I>paramValue2</I></DT><DD>storage location for the parameter value 2 returned</DD><DT><I>paramValue3</I></DT><DD>storage location for the parameter value 3 returned</DD><DT><I>defaultValue1</I></DT><DD>default value 1 returned if parameter does not exist</DD><DT><I>defaultValue2</I></DT><DD>default value 2 returned if parameter does not exist</DD><DT><I>defaultValue3</I></DT><DD>default value 3 returned if parameter does not exist</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>paramValue1</DT><DD>If successful, this will be the first component of the 
returned values, otherwise will be <I>defaultValue1</I>.</DD><DT>paramValue2</DT><DD>If successful, this will be the second component of the 
returned values, otherwise will be <I>defaultValue2</I>.</DD><DT>paramValue3</DT><DD>If successful, this will be the third component of the 
returned values, otherwise will be <I>defaultValue3</I>.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamSetDouble3>mgParamSetDouble3</A>, <A HREF=#mgParamAppendDouble3>mgParamAppendDouble3</A>, 
<A HREF=#mgParamGetIntegerNth>mgParamGetIntegerNth</A>, <A HREF=#mgParamGetDoubleNth>mgParamGetDoubleNth</A>, 
<A HREF=#mgParamGetDouble2Nth>mgParamGetDouble2Nth</A>, <A HREF=#mgParamGetFloatNth>mgParamGetFloatNth</A>, 
<A HREF=#mgParamGetBoolNth>mgParamGetBoolNth</A>, <A HREF=#mgParamGetStringNth>mgParamGetStringNth</A>, 
<A HREF=#mgGetParamBlock>mgGetParamBlock</A>, <A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamGetDoubleNth><H1 CLASS="APISYMBOL">mgParamGetDoubleNth</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamGetDoubleNth</B> - gets the nth item of a 
double precision floating point parameter value in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamGetDoubleNth</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>nth</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>paramValue</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, paramValue <B>mgParamGetDoubleNth</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamGetDoubleNth</B> retrieves the <I>nth</I> item of a double 
precision floating point parameter value named <I>paramName</I> in the 
parameter block <I>paramBlock</I>.  If the parameter exists and contains 
an <I>nth</I> item, its value is returned in <I>paramValue</I>. If the parameter 
does not exist or does not contain an <I>nth</I> item, <I>paramValue</I> 
is set to <I>defaultValue</I>.</P></DD><DD><P>The first item of an array parameter is <I>nth</I> equal to 1.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>nth</I></DT><DD>which value to return from the array parameter</DD><DT><I>paramValue</I></DT><DD>storage location for the parameter value returned</DD><DT><I>defaultValue</I></DT><DD>default value returned if parameter does not exist</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>paramValue</DT><DD>If successful, <I>paramValue</I> will be the parameter 
value, otherwise <I>paramValue</I> will be <I>defaultValue</I>.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamSetDouble>mgParamSetDouble</A>, <A HREF=#mgParamAppendDouble>mgParamAppendDouble</A>, 
<A HREF=#mgParamGetIntegerNth>mgParamGetIntegerNth</A>, <A HREF=#mgParamGetFloatNth>mgParamGetFloatNth</A>, 
<A HREF=#mgParamGetBoolNth>mgParamGetBoolNth</A>, <A HREF=#mgParamGetStringNth>mgParamGetStringNth</A>, 
<A HREF=#mgParamGetDouble2Nth>mgParamGetDouble2Nth</A>, <A HREF=#mgParamGetDouble3Nth>mgParamGetDouble3Nth</A>, 
<A HREF=#mgGetParamBlock>mgGetParamBlock</A>, <A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamGetFloat><H1 CLASS="APISYMBOL">mgParamGetFloat</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamGetFloat</B> - gets a single precision floating point 
parameter value from a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamGetFloat</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>paramValue</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, paramValue <B>mgParamGetFloat</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamGetFloat</B> retrieves a single precision floating point 
parameter value named <I>paramName</I> from the parameter block <I>paramBlock</I>. 
If the parameter exists, its value is returned in <I>paramValue</I>. If the 
parameter does not exist, <I>paramValue</I> is set to <I>defaultValue</I>.</P></DD><DD><P>If the parameter is not an array type parameter, this is the 
standard way to retrieve its single precision floating point value. 
If the parameter is an array type parameter, this function gets 
the first item in the array and is equivalent to calling 
<A HREF=#mgParamGetFloatNth>mgParamGetFloatNth</A> passing 1 as <I>nth</I>.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>paramValue</I></DT><DD>storage location for the parameter value returned</DD><DT><I>defaultValue</I></DT><DD>default value returned if parameter does not exist</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the parameter exists, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>paramValue</DT><DD>If successful, <I>paramValue</I> will be the parameter 
value, otherwise <I>paramValue</I> will be <I>defaultValue</I>.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamSetFloat>mgParamSetFloat</A>, 
<A HREF=#mgParamGetInteger>mgParamGetInteger</A>, <A HREF=#mgParamGetDouble>mgParamGetDouble</A>, 
<A HREF=#mgParamGetBool>mgParamGetBool</A>, <A HREF=#mgParamGetString>mgParamGetString</A>, 
<A HREF=#mgParamGetDouble2>mgParamGetDouble2</A>, <A HREF=#mgParamGetDouble3>mgParamGetDouble3</A>, 
<A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamGetFloatNth><H1 CLASS="APISYMBOL">mgParamGetFloatNth</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamGetFloatNth</B> - gets the nth item of a single 
precision floating point parameter value in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamGetFloatNth</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>nth</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>paramValue</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, paramValue <B>mgParamGetFloatNth</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamGetFloatNth</B> retrieves the <I>nth</I> item of a single 
precision floating point parameter value named <I>paramName</I> in the 
parameter block <I>paramBlock</I>.  If the parameter exists and contains 
an <I>nth</I> item, its value is returned in <I>paramValue</I>. If the parameter 
does not exist or does not contain an <I>nth</I> item, <I>paramValue</I> 
is set to <I>defaultValue</I>.</P></DD><DD><P>The first item of an array parameter is <I>nth</I> equal to 1.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>nth</I></DT><DD>which value to return from the array parameter</DD><DT><I>paramValue</I></DT><DD>storage location for the parameter value returned</DD><DT><I>defaultValue</I></DT><DD>default value returned if parameter does not exist</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>paramValue</DT><DD>If successful, <I>paramValue</I> will be the parameter 
value, otherwise <I>paramValue</I> will be <I>defaultValue</I>.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamSetFloat>mgParamSetFloat</A>, <A HREF=#mgParamAppendFloat>mgParamAppendFloat</A>, 
<A HREF=#mgParamGetIntegerNth>mgParamGetIntegerNth</A>, <A HREF=#mgParamGetDoubleNth>mgParamGetDoubleNth</A>, 
<A HREF=#mgParamGetBoolNth>mgParamGetBoolNth</A>, <A HREF=#mgParamGetStringNth>mgParamGetStringNth</A>, 
<A HREF=#mgParamGetDouble2Nth>mgParamGetDouble2Nth</A>, <A HREF=#mgParamGetDouble3Nth>mgParamGetDouble3Nth</A>, 
<A HREF=#mgGetParamBlock>mgGetParamBlock</A>, <A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamGetInteger><H1 CLASS="APISYMBOL">mgParamGetInteger</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamGetInteger</B> - gets an integer parameter value from a 
parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamGetInteger</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>paramValue</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, paramValue <B>mgParamGetInteger</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamGetInteger</B> retrieves an integer parameter value named 
<I>paramName</I> from the parameter block <I>paramBlock</I>.  If the parameter 
exists, its value is returned in <I>paramValue</I>. If the parameter 
does not exist, <I>paramValue</I> is set to <I>defaultValue</I>.</P></DD><DD><P>If the parameter is not an array type parameter, this is the 
standard way to retrieve its integer value. 
If the parameter is an array type parameter, this function gets 
the first item in the array and is equivalent to calling 
<A HREF=#mgParamGetIntegerNth>mgParamGetIntegerNth</A> passing 1 as <I>nth</I>.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>paramValue</I></DT><DD>storage location for the parameter value returned</DD><DT><I>defaultValue</I></DT><DD>default value returned if parameter does not exist</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the parameter exists, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>paramValue</DT><DD>If successful, <I>paramValue</I> will be the parameter 
value, otherwise <I>paramValue</I> will be <I>defaultValue</I>.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamSetInteger>mgParamSetInteger</A>, 
<A HREF=#mgParamGetDouble>mgParamGetDouble</A>, <A HREF=#mgParamGetFloat>mgParamGetFloat</A>, 
<A HREF=#mgParamGetBool>mgParamGetBool</A>, <A HREF=#mgParamGetString>mgParamGetString</A>, 
<A HREF=#mgParamGetDouble2>mgParamGetDouble2</A>, <A HREF=#mgParamGetDouble3>mgParamGetDouble3</A>, 
<A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamGetIntegerNth><H1 CLASS="APISYMBOL">mgParamGetIntegerNth</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamGetIntegerNth</B> - gets the nth item of an 
integer parameter value in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamGetIntegerNth</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>nth</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>paramValue</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, paramValue <B>mgParamGetIntegerNth</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamGetIntegerNth</B> retrieves the <I>nth</I> item of an 
integer parameter value named <I>paramName</I> in the parameter block 
<I>paramBlock</I>.  If the parameter exists and contains an <I>nth</I> 
item, its value is returned in <I>paramValue</I>. If the parameter 
does not exist or does not contain an <I>nth</I> item, <I>paramValue</I> 
is set to <I>defaultValue</I>.</P></DD><DD><P>The first item of an array parameter is <I>nth</I> equal to 1.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>nth</I></DT><DD>which value to return from the array parameter</DD><DT><I>paramValue</I></DT><DD>storage location for the parameter value returned</DD><DT><I>defaultValue</I></DT><DD>default value returned if parameter does not exist</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>paramValue</DT><DD>If successful, <I>paramValue</I> will be the parameter 
value, otherwise <I>paramValue</I> will be <I>defaultValue</I>.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamSetInteger>mgParamSetInteger</A>, <A HREF=#mgParamAppendInteger>mgParamAppendInteger</A>, 
<A HREF=#mgParamGetDoubleNth>mgParamGetDoubleNth</A>, <A HREF=#mgParamGetFloatNth>mgParamGetFloatNth</A>, 
<A HREF=#mgParamGetBoolNth>mgParamGetBoolNth</A>, <A HREF=#mgParamGetStringNth>mgParamGetStringNth</A>, 
<A HREF=#mgParamGetDouble2Nth>mgParamGetDouble2Nth</A>, <A HREF=#mgParamGetDouble3Nth>mgParamGetDouble3Nth</A>, 
<A HREF=#mgGetParamBlock>mgGetParamBlock</A>, <A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamGetSize><H1 CLASS="APISYMBOL">mgParamGetSize</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamGetSize</B> - gets the current dimension of a 
parameter in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>unsigned int <B>mgParamGetSize</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamGetSize</B> gets the number of items currently contained in 
the parameter named <I>paramValue</I> in the parameter block <I>paramBlock</I>.</P></DD><DD><P>When a parameter is defined, it is assigned a maximum dimension 
which is the maximum number of items that the parameter can contain. 
When a parameter is in use, it contains a certain number of parameters 
at a specific time.  <B>mgParamGetSize</B> returns the number of values 
currently contained in the parameter.</P></DD><DD><P>Note that <A HREF=#mgParamGetDimension>mgParamGetDimension</A> returns the maximum number of 
values a parameter can contain and <B>mgParamGetSize</B> returns the number 
of values a parameter currently does contain.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the current dimension of the parameter named <I>paramValue</I>. 
This value is always 1 or greater for parameters that exist.  If the parameter 
does not exist, this function will return 0.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows how to get the values of an array 
type parameter in a parameter block.</DT><DT><PRE CLASS="EXAMPLE">unsigned int i, numCoords;
mgcoord3d coords;

// "Coords" parameter is an array type, each element is double3
// first, determine how many elements are in the parameter array
numCoords = mgParamGetSize (paramBlock, "Coords");

// then allocate space to receive the elements in the array
coords = mgMalloc (numCoords * sizeof(mgcoord3d));

// finally, loop through each element of the parameter array and
// load its value into our allocated array
for (i = 1; i &lt= numCoords; ++i) {
   mgParamGetDouble3Nth (paramBlock, "Coords", i,
      &coords[i].x, &coords[i].y, &coords[i].z,
      0.0, 0.0, 0.0);
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<HR>
<LEFT><A NAME=mgParamGetString><H1 CLASS="APISYMBOL">mgParamGetString</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamGetString</B> - gets a string parameter value from a 
parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamGetString</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>paramValue</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maxLen</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, paramValue <B>mgParamGetString</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>defaultValue</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamGetString</B> retrieves a string 
parameter value named <I>paramName</I> from the parameter block <I>paramBlock</I>. 
If the parameter exists, its value is returned in <I>paramValue</I>. If the 
parameter does not exist, <I>paramValue</I> is set to <I>defaultValue</I>.</P></DD><DD><P>If the parameter is not an array type parameter, this a standard 
ways to retrieve its string value. 
If the parameter is an array type parameter, this function gets 
the first item in the array and is equivalent to calling 
<A HREF=#mgParamGetStringNth>mgParamGetStringNth</A> passing 1 as <I>nth</I>.</P></DD><DD><P>This function is similar to <A HREF=#mgParamGetStringAlloc>mgParamGetStringAlloc</A>.  Use <B>mgParamGetString</B> 
if the value of the string parameter you want is a known or fixed length and you can guarantee 
the buffer you pass in <I>paramValue</I> is big enough.  If you do not know the length of the string 
parameter value or want to make sure the entire string is retrieved use <A HREF=#mgParamGetStringAlloc>mgParamGetStringAlloc</A>.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>paramValue</I></DT><DD>storage location for the parameter value returned</DD><DT><I>maxLen</I></DT><DD>maximum number of characters to store in <I>paramValue</I></DD><DT><I>defaultValue</I></DT><DD>default value returned if parameter does not exist</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the parameter exists, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>paramValue</DT><DD>If successful, <I>paramValue</I> will be the parameter 
value, otherwise <I>paramValue</I> will be <I>defaultValue</I>.</DD></DL></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>See <A HREF=#mgParamGetStringAlloc>mgParamGetStringAlloc</A> for an example of how to use this function.</DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamGetStringAlloc>mgParamGetStringAlloc</A>, <A HREF=#mgParamSetString>mgParamSetString</A>, 
<A HREF=#mgParamGetInteger>mgParamGetInteger</A>, <A HREF=#mgParamGetDouble>mgParamGetDouble</A>, 
<A HREF=#mgParamGetFloat>mgParamGetFloat</A>, <A HREF=#mgParamGetBool>mgParamGetBool</A>, 
<A HREF=#mgParamGetDouble2>mgParamGetDouble2</A>, <A HREF=#mgParamGetDouble3>mgParamGetDouble3</A>, 
<A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamGetStringAlloc><H1 CLASS="APISYMBOL">mgParamGetStringAlloc</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamGetStringAlloc</B> - allocates and gets a string parameter 
value from a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamGetStringAlloc</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>char**</TD><TD><I>paramValue</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamGetStringAlloc</B> allocates and retrieves a string 
parameter value named <I>paramName</I> from the parameter block <I>paramBlock</I>. 
If the parameter exists, a string is allocated, initialized to the parameter value 
and returned in <I>paramValue</I>. If the parameter does not exist, a string is allocated, 
initialized to <I>defaultValue</I> and returned in <I>paramValue</I>.</P></DD><DD><P>The string returned for <I>paramValue</I> 
is dynamically allocated and must be deallocated by the caller when it 
is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD><DD><P>If the parameter is not an array type parameter, this is a standard 
ways to retrieve its string value. 
If the parameter is an array type parameter, this function gets 
the first item in the array and is equivalent to calling 
<A HREF=#mgParamGetStringNthAlloc>mgParamGetStringNthAlloc</A> passing 1 as <I>nth</I>.</P></DD><DD><P>This function is similar to <A HREF=#mgParamGetString>mgParamGetString</A>.  Use <A HREF=#mgParamGetString>mgParamGetString</A> 
if the value of the string parameter you want is a known or fixed length and you can guarantee 
the buffer you pass in <I>paramValue</I> is big enough.  If you do not know the length of the string 
parameter value or want to make sure the entire string is retrieved use <B>mgParamGetStringAlloc</B>.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>paramValue</I></DT><DD>the address of value to receive parameter value returned</DD><DT><I>defaultValue</I></DT><DD>default value returned if parameter does not exist</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the parameter exists, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows how to use both <B>mgParamGetStringAlloc</B> and <A HREF=#mgParamGetString>mgParamGetString</A> 
to get the value of a string parameter from a parameter block.</DT><DT><PRE CLASS="EXAMPLE">mgparamblock paramBlock;
mgparam param;
char stringBuf[10];
char* allocatedBuf = NULL;

// create a parameter block
paramBlock = mgNewParamBlock();

// add a string parameter called "Text Parameter"
// default value is "Some text here"
param = mgParamAddString (paramBlock, "Text Parameter", "Some text here");

// first use mgParamGetString to get parameter string value
// if buffer passed is not long enough, the parameter value returned will
// be truncated, in this case it will return 9 characters of the parameter
// value and a terminating NULL character (10 characters total)
// stringBuf will be "Some text"
mgParamGetString (paramBlock, "Text Parameter", stringBuf, 10, "");
printf (stringBuf);

// next use mgParamGetStringAlloc to get parameter string value
// mgParamGetStringAlloc will always return entire string
// allocatedBuf will contain entire string "Some text here"
mgParamGetStringAlloc (paramBlock, "Text Parameter", &allocatedBuf, "");
printf (allocatedBuf);

// remember to free the allocated string buffer when you're done with it
mgFree (allocatedBuf);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamGetString>mgParamGetString</A>, <A HREF=#mgParamSetString>mgParamSetString</A>, 
<A HREF=#mgParamGetInteger>mgParamGetInteger</A>, <A HREF=#mgParamGetDouble>mgParamGetDouble</A>, 
<A HREF=#mgParamGetFloat>mgParamGetFloat</A>, <A HREF=#mgParamGetBool>mgParamGetBool</A>, 
<A HREF=#mgParamGetDouble2>mgParamGetDouble2</A>, <A HREF=#mgParamGetDouble3>mgParamGetDouble3</A>, 
<A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamGetStringNth><H1 CLASS="APISYMBOL">mgParamGetStringNth</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamGetStringNth</B> - gets the nth item of a string 
parameter value in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamGetStringNth</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>nth</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>paramValue</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maxLen</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, paramValue <B>mgParamGetStringNth</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamGetStringNth</B> retrieves the <I>nth</I> item of a 
string parameter value named <I>paramName</I> in the parameter block 
<I>paramBlock</I>.  If the parameter exists and contains an <I>nth</I> 
item, its value is returned in <I>paramValue</I>. If the parameter 
does not exist or does not contain an <I>nth</I> item, <I>paramValue</I> 
is set to <I>defaultValue</I>.</P></DD><DD><P>The first item of an array parameter is <I>nth</I> equal to 1.</P></DD><DD><P>This function is similar to <A HREF=#mgParamGetStringNthAlloc>mgParamGetStringNthAlloc</A>.  Use <B>mgParamGetStringNth</B> 
if the value of the string parameter you want is a known or fixed length and you can guarantee 
the buffer you pass in <I>paramValue</I> is big enough.  If you do not know the length of the string 
parameter value or want to make sure the entire string is retrieved use <A HREF=#mgParamGetStringNthAlloc>mgParamGetStringNthAlloc</A>.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>nth</I></DT><DD>which value to return from the array parameter</DD><DT><I>paramValue</I></DT><DD>storage location for the parameter value returned</DD><DT><I>maxLen</I></DT><DD>maximum number of characters to store in <I>paramValue</I></DD><DT><I>defaultValue</I></DT><DD>default value returned if parameter does not exist</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>paramValue</DT><DD>If successful, <I>paramValue</I> will be the parameter 
value, otherwise <I>paramValue</I> will be <I>defaultValue</I>.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamGetStringNthAlloc>mgParamGetStringNthAlloc</A>, <A HREF=#mgParamSetString>mgParamSetString</A>, <A HREF=#mgParamAppendString>mgParamAppendString</A>, 
<A HREF=#mgParamGetIntegerNth>mgParamGetIntegerNth</A>, <A HREF=#mgParamGetDoubleNth>mgParamGetDoubleNth</A>, <A HREF=#mgParamGetFloatNth>mgParamGetFloatNth</A>, 
<A HREF=#mgParamGetBoolNth>mgParamGetBoolNth</A>, <A HREF=#mgParamGetDouble2Nth>mgParamGetDouble2Nth</A>, <A HREF=#mgParamGetDouble3Nth>mgParamGetDouble3Nth</A>, 
<A HREF=#mgGetParamBlock>mgGetParamBlock</A>, <A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamGetStringNthAlloc><H1 CLASS="APISYMBOL">mgParamGetStringNthAlloc</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamGetStringNthAlloc</B> - allocates and gets the nth item of a string 
parameter value in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamGetStringNthAlloc</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>nth</I>,</TD></TR>
<TR><TD></TD><TD>char**</TD><TD><I>paramValue</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamGetStringNthAlloc</B> allocates and retrieves the <I>nth</I> item of a 
string parameter value named <I>paramName</I> in the parameter block 
<I>paramBlock</I>.  If the parameter exists and contains an <I>nth</I> 
item, a string is allocated, initialized to the <I>nth</I> parameter value 
and returned in <I>paramValue</I>.  If the parameter 
does not exist or does not contain an <I>nth</I> item, a string is allocated, 
initialized to <I>defaultValue</I> and returned in <I>paramValue</I>.</P></DD><DD><P>The string returned for <I>paramValue</I> 
is dynamically allocated and must be deallocated by the caller when it 
is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD><DD><P>The first item of an array parameter is <I>nth</I> equal to 1.</P></DD><DD><P>This function is similar to <A HREF=#mgParamGetStringNth>mgParamGetStringNth</A>.  Use <A HREF=#mgParamGetStringNth>mgParamGetStringNth</A> 
if the value of the string parameter you want is a known or fixed length and you can guarantee 
the buffer you pass in <I>paramValue</I> is big enough.  If you do not know the length of the string 
parameter value or want to make sure the entire string is retrieved use <B>mgParamGetStringNthAlloc</B>.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>nth</I></DT><DD>which value to return from the array parameter</DD><DT><I>paramValue</I></DT><DD>the address of value to receive parameter value returned</DD><DT><I>defaultValue</I></DT><DD>default value returned if parameter does not exist</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamGetStringNth>mgParamGetStringNth</A>, <A HREF=#mgParamSetString>mgParamSetString</A>, <A HREF=#mgParamAppendString>mgParamAppendString</A>, 
<A HREF=#mgParamGetIntegerNth>mgParamGetIntegerNth</A>, <A HREF=#mgParamGetDoubleNth>mgParamGetDoubleNth</A>, <A HREF=#mgParamGetFloatNth>mgParamGetFloatNth</A>, 
<A HREF=#mgParamGetBoolNth>mgParamGetBoolNth</A>, <A HREF=#mgParamGetDouble2Nth>mgParamGetDouble2Nth</A>, <A HREF=#mgParamGetDouble3Nth>mgParamGetDouble3Nth</A>, 
<A HREF=#mgGetParamBlock>mgGetParamBlock</A>, <A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamSet><H1 CLASS="APISYMBOL">mgParamSet</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamSet</B> - sets a parameter value in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For C)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamSet</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#variant>variant</A></TD><TD><I>paramValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamSet</B> sets the value of a parameter named 
<I>paramName</I> in the parameter block <I>paramBlock</I> to <I>paramValue</I>. 
If the parameter does not exist, no value is set.</P></DD><DD><P>If the parameter is an array type parameter, this function sets 
the first value in the array and clears all the other values in the 
parameter.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>Note that this function is for OpenFlight Scripts only and cannot 
be used by your C language plug-in. 
In your C language plug-in you must use either 
<A HREF=#mgParamSetInteger>mgParamSetInteger</A>, <A HREF=#mgParamSetDouble>mgParamSetDouble</A>, <A HREF=#mgParamSetFloat>mgParamSetFloat</A>, 
<A HREF=#mgParamSetBool>mgParamSetBool</A>, <A HREF=#mgParamSetString>mgParamSetString</A>, <A HREF=#mgParamSetDouble2>mgParamSetDouble2</A>, 
or <A HREF=#mgParamSetDouble3>mgParamSetDouble3</A> depending on the data type of the parameter.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>paramValue</I></DT><DD>value to set for <I>paramName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>paramName</I> is not a parameter in <I>paramBlock</I> 
or if <I>paramValue</I> is not a valid value for the <I>paramName</I> parameter 
as defined by its constraints (if any).
</DD></DL><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT>The following shows how you might use this function in your script 
to set different types of parameter values:</DT><DT><PRE CLASS="EXAMPLE"># set the parameters for and call a fictitious tool named "My Scale"
paramBlock = mgGetParamBlock ("My Scale")

# use tuple syntax (See Python Docs) to set double3 parameter type
mgParamSet (paramBlock, "Center Point", [0, 0, 0])

# use numeric (integer or float) to set integer or double parameter type
mgParamSet (paramBlock, "Scale X", 2.5)
mgParamSet (paramBlock, "Scale Y", 1)
mgParamSet (paramBlock, "Scale Z", 1)

# use string (quoted) to set string parameter type
mgParamSet (paramBlock, "Comment", "Scale by X")

# finally execute "My Scale" tool with parameters set
mgExecute ("My Scale", paramBlock)</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamSetInteger>mgParamSetInteger</A>, <A HREF=#mgParamSetDouble>mgParamSetDouble</A>, 
<A HREF=#mgParamSetFloat>mgParamSetFloat</A>, <A HREF=#mgParamSetBool>mgParamSetBool</A>, <A HREF=#mgParamSetString>mgParamSetString</A>, 
<A HREF=#mgParamSetDouble2>mgParamSetDouble2</A>, <A HREF=#mgParamSetDouble3>mgParamSetDouble3</A>, <A HREF=#mgParamAppend>mgParamAppend</A>, 
<A HREF=#mgGetParamBlock>mgGetParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamSetBool><H1 CLASS="APISYMBOL">mgParamSetBool</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamSetBool</B> - sets a boolean parameter value in a 
parameter block.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamSetBool</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>paramValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamSetBool</B> sets the value of a boolean parameter named 
<I>paramName</I> in the parameter block <I>paramBlock</I> to <I>paramValue</I>. 
If the parameter does not exist, no value is set.</P></DD><DD><P>If the parameter is an array type parameter, this function sets 
the first value in the array and clears all the other values in the 
parameter.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>paramValue</I></DT><DD>value to set for <I>paramName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>paramName</I> is not a parameter in <I>paramBlock</I> 
or if <I>paramValue</I> is not a valid value for the <I>paramName</I> parameter 
as defined by its constraints (if any).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamGetBool>mgParamGetBool</A>, <A HREF=#mgParamAppendBool>mgParamAppendBool</A>, 
<A HREF=#mgParamSetInteger>mgParamSetInteger</A>, <A HREF=#mgParamSetDouble>mgParamSetDouble</A>, 
<A HREF=#mgParamSetFloat>mgParamSetFloat</A>, <A HREF=#mgParamSetString>mgParamSetString</A>, <A HREF=#mgParamSetDouble2>mgParamSetDouble2</A>, <A HREF=#mgParamSetDouble3>mgParamSetDouble3</A>, 
<A HREF=#mgGetParamBlock>mgGetParamBlock</A>, <A HREF=#mgNewParamBlock>mgNewParamBlock</A>, <A HREF=#mgParamSet>mgParamSet</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamSetDimension><H1 CLASS="APISYMBOL">mgParamSetDimension</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamSetDimension</B> - defines a parameter in a parameter 
block to be an "array" type.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamSetDimension</B> (</TD><TD><A HREF=#mgparam>mgparam</A></TD><TD><I>param</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>maxArrayDimension</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>By default, a parameter in a parameter block contains a single value. 
<B>mgParamSetDimension</B> defines a parameter so it can contain multiple 
values (an array of values) and sets its maximum dimension.  If you want 
to define a parameter to contain multiple values, use this function to 
specify how many items the parameter can have using <I>maxArrayDimension</I>. 
If you specify 0 for <I>maxArrayDimension</I>, the parameter is an array that 
can contain an unlimited number of items.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>param</I></DT><DD>the parameter to set</DD><DT><I>maxArrayDimension</I></DT><DD>the maximum number of items 
this parameter can have, 0 for no maximum</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example creates a parameter that can contain at most 4 
3D coordinates:</DT><DT><PRE CLASS="EXAMPLE">mgparamblock paramBlock;
mgparam param;

// create a parameter block for our array parameter
paramBlock = mgNewParamBlock();

// add the double3 parameter to hold 3D coordinates
// by default it can contain exactly one item
param = mgParamAddDouble3 (paramBlock, "Coords", 0.0, 0.0, 0.0);

// set the parameter so it can contain up to 4 items (double3 items)
mgParamSetDimension (param, 4);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamGetDimension>mgParamGetDimension</A>, <A HREF=#mgParamGetSize>mgParamGetSize</A>, 
<A HREF=#mgParamAddInteger>mgParamAddInteger</A>, <A HREF=#mgParamAddFloat>mgParamAddFloat</A>, <A HREF=#mgParamAddDouble>mgParamAddDouble</A>, 
<A HREF=#mgParamAddBool>mgParamAddBool</A>, <A HREF=#mgParamAddString>mgParamAddString</A>, <A HREF=#mgParamAddDouble2>mgParamAddDouble2</A>, 
<A HREF=#mgParamAddDouble3>mgParamAddDouble3</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamSetDouble><H1 CLASS="APISYMBOL">mgParamSetDouble</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamSetDouble</B> - sets a double precision floating point 
parameter value in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamSetDouble</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>paramValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamSetDouble</B> sets the value of a double precision floating 
point parameter named <I>paramName</I> in the parameter block <I>paramBlock</I> 
to <I>paramValue</I>. 
If the parameter does not exist, no value is set.</P></DD><DD><P>If the parameter is an array type parameter, this function sets 
the first value in the array and clears all the other values in the 
parameter.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>paramValue</I></DT><DD>value to set for <I>paramName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>paramName</I> is not a parameter in <I>paramBlock</I> 
or if <I>paramValue</I> is not a valid value for the <I>paramName</I> parameter 
as defined by its constraints (if any).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamGetDouble>mgParamGetDouble</A>, <A HREF=#mgParamAppendDouble>mgParamAppendDouble</A>, 
<A HREF=#mgParamSetInteger>mgParamSetInteger</A>, <A HREF=#mgParamSetFloat>mgParamSetFloat</A>, 
<A HREF=#mgParamSetBool>mgParamSetBool</A>, <A HREF=#mgParamSetString>mgParamSetString</A>, <A HREF=#mgParamSetDouble2>mgParamSetDouble2</A>, <A HREF=#mgParamSetDouble3>mgParamSetDouble3</A>, 
<A HREF=#mgGetParamBlock>mgGetParamBlock</A>, <A HREF=#mgNewParamBlock>mgNewParamBlock</A>, <A HREF=#mgParamSet>mgParamSet</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamSetDouble2><H1 CLASS="APISYMBOL">mgParamSetDouble2</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamSetDouble2</B> - sets the two double precision floating 
point values of a parameter in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamSetDouble2</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>paramValue1</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>paramValue2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamSetDouble2</B> sets the two double precision floating point 
values of the parameter named <I>paramName</I> in the parameter block <I>paramBlock</I> 
to <I>paramValue1</I> and <I>paramValue2</I>. 
If the parameter does not exist, no values are set.</P></DD><DD><P>If the parameter is an array type parameter, this function sets 
the first value in the array and clears all the other values in the 
parameter.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>paramValue1</I></DT><DD>value 1 to set for <I>paramName</I></DD><DT><I>paramValue2</I></DT><DD>value 2 to set for <I>paramName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>paramName</I> is not a parameter in <I>paramBlock</I> 
or if <I>paramValue1</I> or <I>paramValue2</I> is not a valid value 
for the <I>paramName</I> parameter as defined by its constraints (if any).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamGetDouble2>mgParamGetDouble2</A>, <A HREF=#mgParamAppendDouble2>mgParamAppendDouble2</A>, 
<A HREF=#mgParamSetInteger>mgParamSetInteger</A>, <A HREF=#mgParamSetDouble>mgParamSetDouble</A>, <A HREF=#mgParamSetDouble3>mgParamSetDouble3</A>, <A HREF=#mgParamSetFloat>mgParamSetFloat</A>, 
<A HREF=#mgParamSetBool>mgParamSetBool</A>, <A HREF=#mgParamSetString>mgParamSetString</A>, 
<A HREF=#mgGetParamBlock>mgGetParamBlock</A>, <A HREF=#mgNewParamBlock>mgNewParamBlock</A>, <A HREF=#mgParamSet>mgParamSet</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamSetDouble3><H1 CLASS="APISYMBOL">mgParamSetDouble3</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamSetDouble3</B> - sets the three double precision floating 
point values of a parameter in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamSetDouble3</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>paramValue1</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>paramValue2</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>paramValue3</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamSetDouble3</B> sets the three double precision floating point 
values of the parameter named <I>paramName</I> in the parameter block <I>paramBlock</I> 
to <I>paramValue1</I>, <I>paramValue2</I> and <I>paramValue3</I>. 
If the parameter does not exist, no values are set.</P></DD><DD><P>If the parameter is an array type parameter, this function sets 
the first value in the array and clears all the other values in the 
parameter.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>paramValue1</I></DT><DD>value 1 to set for <I>paramName</I></DD><DT><I>paramValue2</I></DT><DD>value 2 to set for <I>paramName</I></DD><DT><I>paramValue3</I></DT><DD>value 3 to set for <I>paramName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>paramName</I> is not a parameter in <I>paramBlock</I> 
or if <I>paramValue1</I>, <I>paramValue2</I> or <I>paramValue3</I> is not a valid value 
for the <I>paramName</I> parameter as defined by its constraints (if any).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamGetDouble3>mgParamGetDouble3</A>, <A HREF=#mgParamAppendDouble3>mgParamAppendDouble3</A>, 
<A HREF=#mgParamSetInteger>mgParamSetInteger</A>, <A HREF=#mgParamSetDouble>mgParamSetDouble</A>, <A HREF=#mgParamSetDouble2>mgParamSetDouble2</A>, <A HREF=#mgParamSetFloat>mgParamSetFloat</A>, 
<A HREF=#mgParamSetBool>mgParamSetBool</A>, <A HREF=#mgParamSetString>mgParamSetString</A>, 
<A HREF=#mgGetParamBlock>mgGetParamBlock</A>, <A HREF=#mgNewParamBlock>mgNewParamBlock</A>, <A HREF=#mgParamSet>mgParamSet</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamSetDoubleMaxLE><H1 CLASS="APISYMBOL">mgParamSetDoubleMaxLE</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamSetDoubleMaxLE</B> - defines the maximum value (inclusive) 
for a double precision floating point parameter in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamSetDoubleMaxLE</B> (</TD><TD><A HREF=#mgparam>mgparam</A></TD><TD><I>param</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>maxValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamSetDoubleMaxLE</B> defines the maximum value <I>maxValue</I> for 
the double precision floating point parameter <I>param</I> such that the parameter 
must be less than or equal to <I>maxValue</I>.</P></DD><DD><P>See the example code in <A HREF=#mgParamSetDoubleMinGT>mgParamSetDoubleMinGT</A> to see how to set 
up valid ranges for double precision floating point parameters.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>param</I></DT><DD>the parameter to set max value for</DD><DT><I>maxValue</I></DT><DD>the maximum value for <I>paramName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamSetDoubleMinGT>mgParamSetDoubleMinGT</A>, <A HREF=#mgParamSetDoubleMinGE>mgParamSetDoubleMinGE</A>, 
<A HREF=#mgParamSetDoubleMaxLT>mgParamSetDoubleMaxLT</A>, 
<A HREF=#mgParamAddDouble>mgParamAddDouble</A>, 
<A HREF=#mgParamSetDouble>mgParamSetDouble</A>, <A HREF=#mgParamGetDouble>mgParamGetDouble</A>, 
<A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamSetDoubleMaxLT><H1 CLASS="APISYMBOL">mgParamSetDoubleMaxLT</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamSetDoubleMaxLT</B> - defines the maximum value (exclusive) 
for a double precision floating point parameter in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamSetDoubleMaxLT</B> (</TD><TD><A HREF=#mgparam>mgparam</A></TD><TD><I>param</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>maxValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamSetDoubleMaxLT</B> defines the maximum value <I>maxValue</I> for 
the double precision floating point parameter <I>param</I> such that the parameter 
must be less than <I>maxValue</I>.</P></DD><DD><P>See the example code in <A HREF=#mgParamSetDoubleMinGT>mgParamSetDoubleMinGT</A> to see how to set 
up valid ranges for double precision floating point parameters.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>param</I></DT><DD>the parameter to set max value for</DD><DT><I>maxValue</I></DT><DD>the maximum value for <I>paramName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamSetDoubleMinGT>mgParamSetDoubleMinGT</A>, <A HREF=#mgParamSetDoubleMinGE>mgParamSetDoubleMinGE</A>, 
<A HREF=#mgParamSetDoubleMaxLE>mgParamSetDoubleMaxLE</A>, 
<A HREF=#mgParamAddDouble>mgParamAddDouble</A>, 
<A HREF=#mgParamSetDouble>mgParamSetDouble</A>, <A HREF=#mgParamGetDouble>mgParamGetDouble</A>, 
<A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamSetDoubleMinGE><H1 CLASS="APISYMBOL">mgParamSetDoubleMinGE</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamSetDoubleMinGE</B> - defines the minimum value (inclusive) 
for a double precision floating point parameter in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamSetDoubleMinGE</B> (</TD><TD><A HREF=#mgparam>mgparam</A></TD><TD><I>param</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>minValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamSetDoubleMinGE</B> defines the minimum value <I>minValue</I> for 
the double precision floating point parameter <I>param</I> such that the parameter 
must be greater than or equal to <I>minValue</I>.</P></DD><DD><P>See the example code in <A HREF=#mgParamSetDoubleMinGT>mgParamSetDoubleMinGT</A> to see how to set 
up valid ranges for double precision floating point parameters.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>param</I></DT><DD>the parameter to set min value for</DD><DT><I>minValue</I></DT><DD>the minimum value for <I>paramName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamSetDoubleMinGT>mgParamSetDoubleMinGT</A>, 
<A HREF=#mgParamSetDoubleMaxLT>mgParamSetDoubleMaxLT</A>, <A HREF=#mgParamSetDoubleMaxLE>mgParamSetDoubleMaxLE</A>, 
<A HREF=#mgParamAddDouble>mgParamAddDouble</A>, 
<A HREF=#mgParamSetDouble>mgParamSetDouble</A>, <A HREF=#mgParamGetDouble>mgParamGetDouble</A>, 
<A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamSetDoubleMinGT><H1 CLASS="APISYMBOL">mgParamSetDoubleMinGT</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamSetDoubleMinGT</B> - defines the minimum value (exclusive) 
for a double precision floating point parameter in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamSetDoubleMinGT</B> (</TD><TD><A HREF=#mgparam>mgparam</A></TD><TD><I>param</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>minValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamSetDoubleMinGT</B> defines the minimum value <I>minValue</I> for 
the double precision floating point parameter <I>param</I> such that the parameter 
must be greater than <I>minValue</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>param</I></DT><DD>the parameter to set min value for</DD><DT><I>minValue</I></DT><DD>the minimum value for <I>paramName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example creates a default parameter block for an editor 
plug-in tool containing several double precision floating point parameters. 
It shows how to set up valid ranges for these parameters.</DT><DT><PRE CLASS="EXAMPLE">mgparamblock paramBlock;
mgparam param;

// create the default param block for our editor plug-in tool.
paramBlock = mgNewParamBlock();

// add several double precision floating point parameters

// "Double 1" must be less than or equal to 0
param = mgParamAddInteger (paramBlock, "Double 1", 0);
mgParamSetDoubleMinLE (param, 0.0);

// "Double 2" must be between 0 and 100 (exclusive)
param = mgParamAddDouble (paramBlock, "Double 2", 1.0);
mgParamSetDoubleMinGT (param, 0.0);
mgParamSetDoubleMaxLT (param, 100.0);

// "Double 3" must be between 1 and 10 (inclusive)
param = mgParamAddDouble (paramBlock, "Double 3", 1.0);
mgParamSetDoubleMinGE (param, 1.0);
mgParamSetDoubleMaxLE (param, 10.0);

// assign this param block as the default for our tool
mgPluginToolSetDefaultParamBlock (pluginTool, paramBlock);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamSetDoubleMinGE>mgParamSetDoubleMinGE</A>, 
<A HREF=#mgParamSetDoubleMaxLT>mgParamSetDoubleMaxLT</A>, <A HREF=#mgParamSetDoubleMaxLE>mgParamSetDoubleMaxLE</A>, 
<A HREF=#mgParamAddDouble>mgParamAddDouble</A>, 
<A HREF=#mgParamSetDouble>mgParamSetDouble</A>, <A HREF=#mgParamGetDouble>mgParamGetDouble</A>, 
<A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamSetEnumerant><H1 CLASS="APISYMBOL">mgParamSetEnumerant</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamSetEnumerant</B> - defines an enumerant for an integer 
parameter in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamSetEnumerant</B> (</TD><TD><A HREF=#mgparam>mgparam</A></TD><TD><I>param</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>value</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>string</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamSetEnumerant</B> defines an enumerant (value and string pair) 
for the integer parameter <I>param</I>.  An enumerant defines an integer value 
<I>value</I> and corresponding string value <I>string</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>param</I></DT><DD>the parameter to set</DD><DT><I>value</I></DT><DD>the integer value for this enumerant</DD><DT><I>string</I></DT><DD>the string value corresponding to <I>value</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example defines several enumerants for an integer parameter 
and shows how to get and set its value in different ways.</DT><DT><PRE CLASS="EXAMPLE">mgparamblock paramBlock;
mgparam param;

// create a parameter block
paramBlock = mgNewParamBlock();

// add an integer parameter called "User Choices"
// default value is 5
param = mgParamAddInteger (paramBlock, "User Choices", 5);

// define the enumerants for this parameter -
// note how the values do not have to be contiguous
mgParamSetEnumerant (param, -1, "Choice 1");
mgParamSetEnumerant (param,  0, "Choice 2");
mgParamSetEnumerant (param,  5, "Choice 3");
mgParamSetEnumerant (param, 10, "Choice 4");

// after an enumerated integer parameter is added,
// it can be "set" by integer or by string as shown below:

// the following two lines are equivalent:
mgParamSetInteger (paramBlock, "User Choices", 5);
mgParamSetString (paramBlock, "User Choices", "Choice 3");

// as are:
mgParamSetInteger (paramBlock, "User Choices", -1);
mgParamSetString (paramBlock, "User Choices", "Choice 1");

// similarly, when you "get" an enumerated integer parameter,
// you can get it by integer or string as shown below:

int intVal;
char stringVal[200];

// if the current value of "User Choices" parameter is -1...

// intVal will be -1
mgParamGetInteger (paramBlock, "User Choices", &intVal, 0);

// stringVal will be "Choice 1"
mgParamGetString (paramBlock, "User Choices", stringVal, 200, "");</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamAddInteger>mgParamAddInteger</A>, 
<A HREF=#mgParamSetInteger>mgParamSetInteger</A>, <A HREF=#mgParamGetInteger>mgParamGetInteger</A>, 
<A HREF=#mgParamSetString>mgParamSetString</A>, <A HREF=#mgParamGetString>mgParamGetString</A>, 
<A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamSetFloat><H1 CLASS="APISYMBOL">mgParamSetFloat</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamSetFloat</B> - sets a single precision floating point 
parameter value in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamSetFloat</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>paramValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamSetFloat</B> sets the value of a single precision floating 
point parameter named <I>paramName</I> in the parameter block <I>paramBlock</I> 
to <I>paramValue</I>. 
If the parameter does not exist, no value is set.</P></DD><DD><P>If the parameter is an array type parameter, this function sets 
the first value in the array and clears all the other values in the 
parameter.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>paramValue</I></DT><DD>value to set for <I>paramName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>paramName</I> is not a parameter in <I>paramBlock</I> 
or if <I>paramValue</I> is not a valid value for the <I>paramName</I> parameter 
as defined by its constraints (if any).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamGetFloat>mgParamGetFloat</A>, <A HREF=#mgParamAppendFloat>mgParamAppendFloat</A>, 
<A HREF=#mgParamSetInteger>mgParamSetInteger</A>, <A HREF=#mgParamSetDouble>mgParamSetDouble</A>, 
<A HREF=#mgParamSetBool>mgParamSetBool</A>, <A HREF=#mgParamSetString>mgParamSetString</A>, <A HREF=#mgParamSetDouble2>mgParamSetDouble2</A>, <A HREF=#mgParamSetDouble3>mgParamSetDouble3</A>, 
<A HREF=#mgGetParamBlock>mgGetParamBlock</A>, <A HREF=#mgNewParamBlock>mgNewParamBlock</A>, <A HREF=#mgParamSet>mgParamSet</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamSetInteger><H1 CLASS="APISYMBOL">mgParamSetInteger</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamSetInteger</B> - sets an integer parameter value in a 
parameter block.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamSetInteger</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>paramValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamSetInteger</B> sets the value of an integer parameter named 
<I>paramName</I> in the parameter block <I>paramBlock</I> to <I>paramValue</I>. 
If the parameter does not exist, no value is set.</P></DD><DD><P>If the parameter is an array type parameter, this function sets 
the first value in the array and clears all the other values in the 
parameter.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>paramValue</I></DT><DD>value to set for <I>paramName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>paramName</I> is not a parameter in <I>paramBlock</I> 
or if <I>paramValue</I> is not a valid value for the <I>paramName</I> parameter 
as defined by its constraints (if any).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamGetInteger>mgParamGetInteger</A>, <A HREF=#mgParamAppendInteger>mgParamAppendInteger</A>, 
<A HREF=#mgParamSetDouble>mgParamSetDouble</A>, <A HREF=#mgParamSetFloat>mgParamSetFloat</A>, 
<A HREF=#mgParamSetBool>mgParamSetBool</A>, <A HREF=#mgParamSetString>mgParamSetString</A>, <A HREF=#mgParamSetDouble2>mgParamSetDouble2</A>, <A HREF=#mgParamSetDouble3>mgParamSetDouble3</A>, 
<A HREF=#mgGetParamBlock>mgGetParamBlock</A>, <A HREF=#mgNewParamBlock>mgNewParamBlock</A>, <A HREF=#mgParamSet>mgParamSet</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamSetIntegerMaxLE><H1 CLASS="APISYMBOL">mgParamSetIntegerMaxLE</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamSetIntegerMaxLE</B> - defines the maximum value (inclusive) 
for an integer parameter in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamSetIntegerMaxLE</B> (</TD><TD><A HREF=#mgparam>mgparam</A></TD><TD><I>param</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maxValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamSetIntegerMaxLE</B> defines the maximum value <I>maxValue</I> for 
the integer parameter <I>param</I> such that the parameter must be less than 
or equal to <I>maxValue</I>.</P></DD><DD><P>See the example code in <A HREF=#mgParamSetIntegerMinGT>mgParamSetIntegerMinGT</A> to see how to set 
up valid ranges for integer parameters.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>param</I></DT><DD>the parameter to set max value for</DD><DT><I>maxValue</I></DT><DD>the maximum value for <I>paramName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamSetIntegerMinGT>mgParamSetIntegerMinGT</A>, <A HREF=#mgParamSetIntegerMinGE>mgParamSetIntegerMinGE</A>, 
<A HREF=#mgParamSetIntegerMaxLT>mgParamSetIntegerMaxLT</A>, 
<A HREF=#mgParamAddInteger>mgParamAddInteger</A>, 
<A HREF=#mgParamSetInteger>mgParamSetInteger</A>, <A HREF=#mgParamGetInteger>mgParamGetInteger</A>, 
<A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamSetIntegerMaxLT><H1 CLASS="APISYMBOL">mgParamSetIntegerMaxLT</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamSetIntegerMaxLT</B> - defines the maximum value (exclusive) 
for an integer parameter in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamSetIntegerMaxLT</B> (</TD><TD><A HREF=#mgparam>mgparam</A></TD><TD><I>param</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maxValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamSetIntegerMaxLT</B> defines the maximum value <I>maxValue</I> for 
the integer parameter <I>param</I> such that the parameter must be less than 
<I>maxValue</I>.</P></DD><DD><P>See the example code in <A HREF=#mgParamSetIntegerMinGT>mgParamSetIntegerMinGT</A> to see how to set 
up valid ranges for integer parameters.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>param</I></DT><DD>the parameter to set max value for</DD><DT><I>maxValue</I></DT><DD>the maximum value for <I>paramName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamSetIntegerMinGT>mgParamSetIntegerMinGT</A>, <A HREF=#mgParamSetIntegerMinGE>mgParamSetIntegerMinGE</A>, 
<A HREF=#mgParamSetIntegerMaxLE>mgParamSetIntegerMaxLE</A>, 
<A HREF=#mgParamAddInteger>mgParamAddInteger</A>, 
<A HREF=#mgParamSetInteger>mgParamSetInteger</A>, <A HREF=#mgParamGetInteger>mgParamGetInteger</A>, 
<A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamSetIntegerMinGE><H1 CLASS="APISYMBOL">mgParamSetIntegerMinGE</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamSetIntegerMinGE</B> - defines the minimum value (inclusive) 
for an integer parameter in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamSetIntegerMinGE</B> (</TD><TD><A HREF=#mgparam>mgparam</A></TD><TD><I>param</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>minValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamSetIntegerMinGE</B> defines the minimum value <I>minValue</I> for 
the integer parameter <I>param</I> such that the parameter must be greater than 
or equal to <I>minValue</I>.</P></DD><DD><P>See the example code in <A HREF=#mgParamSetIntegerMinGT>mgParamSetIntegerMinGT</A> to see how to set 
up valid ranges for integer parameters.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>param</I></DT><DD>the parameter to set min value for</DD><DT><I>minValue</I></DT><DD>the minimum value for <I>paramName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamSetIntegerMinGT>mgParamSetIntegerMinGT</A>, 
<A HREF=#mgParamSetIntegerMaxLT>mgParamSetIntegerMaxLT</A>, <A HREF=#mgParamSetIntegerMaxLE>mgParamSetIntegerMaxLE</A>, 
<A HREF=#mgParamAddInteger>mgParamAddInteger</A>, 
<A HREF=#mgParamSetInteger>mgParamSetInteger</A>, <A HREF=#mgParamGetInteger>mgParamGetInteger</A>, 
<A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamSetIntegerMinGT><H1 CLASS="APISYMBOL">mgParamSetIntegerMinGT</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamSetIntegerMinGT</B> - defines the minimum value (exclusive) 
for an integer parameter in a parameter block.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamSetIntegerMinGT</B> (</TD><TD><A HREF=#mgparam>mgparam</A></TD><TD><I>param</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>minValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamSetIntegerMinGT</B> defines the minimum value <I>minValue</I> for 
the integer parameter <I>param</I> such that the parameter must be greater than 
<I>minValue</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>param</I></DT><DD>the parameter to set min value for</DD><DT><I>minValue</I></DT><DD>the minimum value for <I>paramName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example creates a default parameter block for an editor 
plug-in tool containing several integer parameters.  It shows how to set 
up valid ranges for these parameters.</DT><DT><PRE CLASS="EXAMPLE">mgparamblock paramBlock;
mgparam param;

// create the default param block for our editor plug-in tool.
paramBlock = mgNewParamBlock();

// add several integer parameters

// "Integer 1" must be greater than or equal to 0
param = mgParamAddInteger (paramBlock, "Integer 1", 0);
mgParamSetIntegerMinGE (param, 0);

// "Integer 2" must be between 0 and 100 (exclusive)
param = mgParamAddInteger (paramBlock, "Integer 2", 1);
mgParamSetIntegerMinGT (param, 0);
mgParamSetIntegerMaxLT (param, 100);

// "Integer 3" must be between 1 and 10 (inclusive)
param = mgParamAddInteger (paramBlock, "Integer 3", 1);
mgParamSetIntegerMinGE (param, 1);
mgParamSetIntegerMaxLE (param, 10);

// assign this param block as the default for our tool
mgPluginToolSetDefaultParamBlock (pluginTool, paramBlock);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamSetIntegerMinGE>mgParamSetIntegerMinGE</A>, 
<A HREF=#mgParamSetIntegerMaxLT>mgParamSetIntegerMaxLT</A>, <A HREF=#mgParamSetIntegerMaxLE>mgParamSetIntegerMaxLE</A>, 
<A HREF=#mgParamAddInteger>mgParamAddInteger</A>, 
<A HREF=#mgParamSetInteger>mgParamSetInteger</A>, <A HREF=#mgParamGetInteger>mgParamGetInteger</A>, 
<A HREF=#mgNewParamBlock>mgNewParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgParamSetString><H1 CLASS="APISYMBOL">mgParamSetString</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgParamSetString</B> - sets a string parameter value in a 
parameter block.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgParamSetString</B> (</TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramName</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>paramValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgParamSetString</B> sets the value of a string parameter named 
<I>paramName</I> in the parameter block <I>paramBlock</I> to <I>paramValue</I>. 
If the parameter does not exist, no value is set.</P></DD><DD><P>If the parameter is an array type parameter, this function sets 
the first value in the array and clears all the other values in the 
parameter.</P></DD><DD><P>Note that if the parameter does not exist, it is NOT created in the parameter block.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paramBlock</I></DT><DD>the parameter block</DD><DT><I>paramName</I></DT><DD>the parameter name</DD><DT><I>paramValue</I></DT><DD>value to set for <I>paramName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>paramName</I> is not a parameter in <I>paramBlock</I> 
or if <I>paramValue</I> is not a valid value for the <I>paramName</I> parameter 
as defined by its constraints (if any).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgParamGetString>mgParamGetString</A>, <A HREF=#mgParamAppendString>mgParamAppendString</A>, 
<A HREF=#mgParamSetInteger>mgParamSetInteger</A>, <A HREF=#mgParamSetDouble>mgParamSetDouble</A>, 
<A HREF=#mgParamSetFloat>mgParamSetFloat</A>, <A HREF=#mgParamSetBool>mgParamSetBool</A>, <A HREF=#mgParamSetDouble2>mgParamSetDouble2</A>, <A HREF=#mgParamSetDouble3>mgParamSetDouble3</A>, 
<A HREF=#mgGetParamBlock>mgGetParamBlock</A>, <A HREF=#mgNewParamBlock>mgNewParamBlock</A>, <A HREF=#mgParamSet>mgParamSet</A></DD></DL>
<HR>
<LEFT><A NAME=mgpExit><H1 CLASS="APISYMBOL">mgpExit</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgpExit</B> - plug-in termination function.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>MGPIDECLARE(void) <B>mgpExit</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the plug-in termination function required for all plug-in 
modules.  You must supply this function so that your plug-in is 
properly recognized.</P></DD><DD><P>You must declare 
this function exactly as shown here, using the <A HREF=#MGPIDECLARE>MGPIDECLARE</A> macro, so 
that it is properly exported from your plug-in module library.</P></DD><DD><P>This function will be called by the plug-in runtime environment at 
termination.  In this function, a plug-in module will perform any termination 
processing required.  Typically a plug-in module will unregister any 
registered plug-in tools and/or data extensions and unload any loaded resources.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in module being exited</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Declared by Plug-in Module</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgpInit>mgpInit</A>, <A HREF=#mgDeclarePlugin>mgDeclarePlugin</A>, <A HREF=#mgUnregisterAllTools>mgUnregisterAllTools</A>, 
<A HREF=#mgUnloadResource>mgUnloadResource</A></DD></DL>
<HR>
<LEFT><A NAME=mgpexitfunc><H1 CLASS="APISYMBOL">mgpexitfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgpexitfunc</B> - Plug-in exit function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void (*<B>mgpexitfunc</B>) ( <TD><A HREF=#mgplugin>mgplugin</A> <TD><I>plugin</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for the plug-in exit function you 
must declare in your source code so that your plug-in is properly 
recognized.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in module being exited</DD></DL></DD></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgpExit>mgpExit</A></DD></DL>
<HR>
<LEFT><A NAME=MGPIDECLARE><H1 CLASS="APISYMBOL">MGPIDECLARE</H1></A></LEFT>
<DL>
<DT><H3>MACRO NAME</H3></DT>
<DD><B>MGPIDECLARE</B> - exports a symbol from a plug-in module.<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD> <B>MGPIDECLARE</B> ( <TD><A HREF=#></A> <TD><I>type</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>type</I></DT><DD>the return type (for function symbols) or object type 
(for variables) you are exporting.</DD></DL></DD></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When you declare symbols (functions or variables) in the source 
code for your plug-in module that need to be exported from 
your plug-in module library, you should use this macro to do so. 
Using this macro ensures that your code is portable between the 
different platforms supported by the OpenFlight API.</P></DD></DT></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following shows how you would use this macro to export 
your plug-in initialization function, <A HREF=#mgpInit>mgpInit</A> in a portable fashion.</DT><DT><PRE CLASS="EXAMPLE">MGPIDECLARE(mgbool) mgpInit (mgplugin plugin, int* argc, char* argv [])
{
   // your plug-in initialization processing goes here
}</PRE></DT></DL></DD></DL>

<HR>
<LEFT><A NAME=mgpInit><H1 CLASS="APISYMBOL">mgpInit</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgpInit</B> - plug-in initialization function.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>MGPIDECLARE(mgbool) <B>mgpInit</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>argc</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>argv []</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the plug-in initialization function required for all plug-in 
modules.  You must supply this function so that your plug-in is 
properly recognized.</P></DD><DD><P>You must declare 
this function exactly as shown here, using the <A HREF=#MGPIDECLARE>MGPIDECLARE</A> macro, so 
that it is properly exported from your plug-in module library.</P></DD><DD><P>This function is called by the plug-in runtime environment at 
startup.  In this function a plug-in module performs any initialization 
processing required.  Typically, a plug-in module registers plug-in tools 
and/or data extensions for the runtime environment as well as load a 
resource containing GUI definitions required by the plug-in.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in module being initialized</DD><DT><I>argc</I></DT><DD>a pointer to the number of arguments contained in argv</DD><DT><I>argv []</I></DT><DD>array of arguments passed to the program when it 
was started</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Return <A HREF=#mgbool>MG_TRUE</A> if the plug-in was successfully initialized, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Declared by Plug-in Module</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgpExit>mgpExit</A>, <A HREF=#mgDeclarePlugin>mgDeclarePlugin</A>, <A HREF=#mgRegisterImporter>mgRegisterImporter</A>, 
<A HREF=#mgRegisterExporter>mgRegisterExporter</A>, <A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A>, 
<A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgRegisterSite>mgRegisterSite</A>, <A HREF=#mgRegisterInputDevice>mgRegisterInputDevice</A>, 
<A HREF=#mgLoadResource>mgLoadResource</A></DD></DL>
<HR>
<LEFT><A NAME=mgpinitfunc><H1 CLASS="APISYMBOL">mgpinitfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgpinitfunc</B> - Plug-in initialization function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool (*<B>mgpinitfunc</B>) ( <TD><A HREF=#mgplugin>mgplugin</A> <TD><I>plugin</I>, 
<TR><TD></TD><TD>int* <TD><I>argc</I>, 
<TR><TD></TD><TD>char* <TD><I>argv []</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for the plug-in initialization function you 
must declare in your source code so that your plug-in is properly 
recognized.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in module being initialized</DD><DT><I>argc</I></DT><DD>reserved for future enhancement</DD><DT><I>argv []</I></DT><DD>reserved for future enhancement</DD></DL></DD></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgpInit>mgpInit</A></DD></DL>
<HR>
<LEFT><A NAME=mgPixmapIdsMatch><H1 CLASS="APISYMBOL">mgPixmapIdsMatch</H1></A></LEFT>
<DL>
<DT><H3>MACRO NAME</H3></DT>
<DD><B>mgPixmapIdsMatch</B> - Checks if two pixmap identifiers match.<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgPixmapIdsMatch</B> (</TD><TD><A HREF=#></A></TD><TD><I>id1</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>id2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns 1 if identifiers match, 0 otherwise.
</DD></DL><DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>id1</I></DT><DD>A pixmap identifier</DD><DT><I>id2</I></DT><DD>Another pixmap identifier</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgStringIdsMatch>mgStringIdsMatch</A>, <A HREF=#mgControlIdsMatch>mgControlIdsMatch</A>, 
<A HREF=#mgCursorIdsMatch>mgCursorIdsMatch</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginDeleteProperty><H1 CLASS="APISYMBOL">mgPluginDeleteProperty</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginDeleteProperty</B> - deletes user defined data 
associated with a plug-in module.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgPluginDeleteProperty</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgpropertyname>mgpropertyname</A></TD><TD><I>propName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Use <B>mgPluginDeleteProperty</B> to delete the data named <I>propName</I> 
that was associated with the plug-in module <I>plugin</I> using <A HREF=#mgPluginPutProperty>mgPluginPutProperty</A>.</P></DD><DD><P>Note that this function does not free or otherwise affect the actual data 
that was associated.  If this data was dynamically allocated, it is the 
callers responsibility to deallocate it.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in module</DD><DT><I>propName</I></DT><DD>the name of the property to delete</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginPutProperty>mgPluginPutProperty</A>, <A HREF=#mgPluginGetProperty>mgPluginGetProperty</A>, 
<A HREF=#mgPluginToolPutProperty>mgPluginToolPutProperty</A>, <A HREF=#mgPluginToolGetProperty>mgPluginToolGetProperty</A>, 
<A HREF=#mgPluginToolDeleteProperty>mgPluginToolDeleteProperty</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginGetProperty><H1 CLASS="APISYMBOL">mgPluginGetProperty</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginGetProperty</B> - retrieves user defined data 
associated with a plug-in module.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgpropertyvalue <B>mgPluginGetProperty</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgpropertyname>mgpropertyname</A></TD><TD><I>propName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Use <B>mgPluginGetProperty</B> to retrieve the data named <I>propName</I> 
that was associated with the plug-in module <I>plugin</I> using 
<A HREF=#mgPluginPutProperty>mgPluginPutProperty</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in module</DD><DT><I>propName</I></DT><DD>the name of the property to get</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the user-defined data if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginPutProperty>mgPluginPutProperty</A>, <A HREF=#mgPluginDeleteProperty>mgPluginDeleteProperty</A>, 
<A HREF=#mgPluginToolPutProperty>mgPluginToolPutProperty</A>, <A HREF=#mgPluginToolGetProperty>mgPluginToolGetProperty</A>, 
<A HREF=#mgPluginToolDeleteProperty>mgPluginToolDeleteProperty</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginPrefDelete><H1 CLASS="APISYMBOL">mgPluginPrefDelete</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginPrefDelete</B> - deletes a preference value 
from the plug-in preferences.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgPluginPrefDelete</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>prefName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginPrefDelete</B> deletes a named preference key, 
<I>prefName</I> from <I>plugin</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in handle</DD><DT><I>prefName</I></DT><DD>the preference key name to delete</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginPrefSetInteger>mgPluginPrefSetInteger</A>, <A HREF=#mgPluginPrefSetFloat>mgPluginPrefSetFloat</A>, 
<A HREF=#mgPluginPrefSetDouble>mgPluginPrefSetDouble</A>, <A HREF=#mgPluginPrefSetString>mgPluginPrefSetString</A>, 
<A HREF=#mgPluginPrefSetBool>mgPluginPrefSetBool</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginPrefGetBool><H1 CLASS="APISYMBOL">mgPluginPrefGetBool</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginPrefGetBool</B> - gets an mgbool preference value 
from the plug-in preferences.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgPluginPrefGetBool</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>prefName</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool*</A></TD><TD><I>prefValue</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginPrefGetBool</B> retrieves an mgbool value from a 
named preference key, <I>prefName</I> for <I>plugin</I>, and store it in <I>prefValue</I>. 
If the key <I>prefName</I> does not exist for the  <I>plugin</I>, it 
is created with a value of <I>defaultValue</I>.</P></DD><DD><P>Preference keys accessed using this function are stored relative 
to the entire plug-in library, and are separate from the keys used for 
individual plug-in tools within the plug-in library.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in handle</DD><DT><I>prefName</I></DT><DD>the preference key name</DD><DT><I>prefValue</I></DT><DD>storage location for the preference value</DD><DT><I>defaultValue</I></DT><DD>default value for creating preference if 
it does not yet exist</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginPrefSetBool>mgPluginPrefSetBool</A>, <A HREF=#mgPluginToolPrefGetBool>mgPluginToolPrefGetBool</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginPrefGetDouble><H1 CLASS="APISYMBOL">mgPluginPrefGetDouble</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginPrefGetDouble</B> - get a double preference value 
from the plug-in preferences.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgPluginPrefGetDouble</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>prefName</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>prefValue</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginPrefGetDouble</B> retrieves a double value from a 
named preference key, <I>prefName</I> for <I>plugin</I>, and stores it in <I>prefValue</I>. 
If the key <I>prefName</I> does not exist for the <I>plugin</I>, it 
is created with a value of <I>defaultValue</I>.</P></DD><DD><P>Preference keys accessed using this function are stored relative 
to the entire plug-in library, and are separate from the keys used for 
individual plug-in tools within the plug-in library.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in handle</DD><DT><I>prefName</I></DT><DD>the preference key name</DD><DT><I>prefValue</I></DT><DD>storage location for the preference value</DD><DT><I>defaultValue</I></DT><DD>default value for creating preference if 
it does not yet exist</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginPrefSetDouble>mgPluginPrefSetDouble</A>, <A HREF=#mgPluginToolPrefGetDouble>mgPluginToolPrefGetDouble</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginPrefGetFloat><H1 CLASS="APISYMBOL">mgPluginPrefGetFloat</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginPrefGetFloat</B> - gets a float preference value 
from the plug-in preferences.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgPluginPrefGetFloat</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>prefName</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>prefValue</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginPrefGetFloat</B> retrieves a float value from a 
named preference key, <I>prefName</I> for <I>plugin</I>, and stores it in <I>prefValue</I>. 
If the key <I>prefName</I> does not exist for the <I>plugin</I>, it is 
created with a value of <I>defaultValue</I>.</P></DD><DD><P>Preference keys accessed using this function are stored relative 
to the entire plug-in library, and are separate from the keys used for 
individual plug-in tools within the plug-in library.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in handle</DD><DT><I>prefName</I></DT><DD>the preference key name</DD><DT><I>prefValue</I></DT><DD>storage location for the preference value</DD><DT><I>defaultValue</I></DT><DD>default value for creating preference if 
it does not yet exist</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginPrefSetFloat>mgPluginPrefSetFloat</A>, <A HREF=#mgPluginToolPrefGetFloat>mgPluginToolPrefGetFloat</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginPrefGetInteger><H1 CLASS="APISYMBOL">mgPluginPrefGetInteger</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginPrefGetInteger</B> - gets an integer preference value 
from the plug-in preferences.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgPluginPrefGetInteger</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>prefName</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>prefValue</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginPrefGetInteger</B> retrieves an integer value from a 
named preference key, <I>prefName</I> for <I>plugin</I>, and store it in <I>prefValue</I>. 
If the key <I>prefName</I> does not exist for the <I>plugin</I>, it 
is created with a value of <I>defaultValue</I>.</P></DD><DD><P>Preference keys accessed using this function are stored relative 
to the entire plug-in library, and are separate from the keys used for 
individual plug-in tools within the plug-in library.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in handle</DD><DT><I>prefName</I></DT><DD>the preference key name</DD><DT><I>prefValue</I></DT><DD>storage location for the preference value</DD><DT><I>defaultValue</I></DT><DD>default value for creating preference if 
it does not yet exist</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginPrefSetInteger>mgPluginPrefSetInteger</A>, <A HREF=#mgPluginToolPrefGetInteger>mgPluginToolPrefGetInteger</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginPrefGetString><H1 CLASS="APISYMBOL">mgPluginPrefGetString</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginPrefGetString</B> - gets a string preference value 
from the plug-in preferences.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgPluginPrefGetString</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>prefName</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>prefValue</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maxLen</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginPrefGetString</B> retrieves a string value from a 
named preference key, <I>prefName</I> for <I>plugin</I>, and stores it in <I>prefValue</I>. 
If the key <I>prefName</I> does not exist for the <I>plugin</I>, it is 
created with a value of <I>defaultValue</I>.</P></DD><DD><P>Preference keys accessed using this function are stored relative 
to the entire plug-in library, and are separate from the keys used for 
individual plug-in tools within the plug-in library.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in handle</DD><DT><I>prefName</I></DT><DD>the preference key name</DD><DT><I>prefValue</I></DT><DD>storage location for the preference value</DD><DT><I>maxLen</I></DT><DD>maximum number of characters to store in <I>prefValue</I></DD><DT><I>defaultValue</I></DT><DD>default value for creating preference if 
it does not yet exist</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginPrefSetString>mgPluginPrefSetString</A>, <A HREF=#mgPluginToolPrefGetString>mgPluginToolPrefGetString</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginPrefSetBool><H1 CLASS="APISYMBOL">mgPluginPrefSetBool</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginPrefSetBool</B> - sets an mgbool preference value 
in the plug-in preferences.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgPluginPrefSetBool</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>prefName</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>prefValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginPrefSetBool</B> stores an mgbool value for a 
named preference key, <I>prefName</I> for <I>plugin</I>. 
If the key <I>prefName</I> does not exist for the <I>plugin</I>, it 
is created with a value of <I>prefValue</I>.</P></DD><DD><P>Preference keys created using this function are stored relative 
to the entire plug-in library, and are separate from the keys used for 
individual plug-in tools within the plug-in library.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in handle</DD><DT><I>prefName</I></DT><DD>the preference key name</DD><DT><I>prefValue</I></DT><DD>value to store for <I>prefName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginPrefGetBool>mgPluginPrefGetBool</A>, <A HREF=#mgPluginToolPrefSetBool>mgPluginToolPrefSetBool</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginPrefSetDouble><H1 CLASS="APISYMBOL">mgPluginPrefSetDouble</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginPrefSetDouble</B> - sets a double preference value 
in the plug-in preferences.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgPluginPrefSetDouble</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>prefName</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>prefValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginPrefSetDouble</B> stores a double value for a 
named preference key, <I>prefName</I> for <I>plugin</I>. 
If the key <I>prefName</I> does not exist for the <I>plugin</I>, it 
is created with a value of <I>prefValue</I>.</P></DD><DD><P>Preference keys created using this function are stored relative 
to the entire plug-in library, and are separate from the keys used for 
individual plug-in tools within the plug-in library.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in handle</DD><DT><I>prefName</I></DT><DD>the preference key name</DD><DT><I>prefValue</I></DT><DD>value to store for <I>prefName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginPrefGetDouble>mgPluginPrefGetDouble</A>, <A HREF=#mgPluginToolPrefSetDouble>mgPluginToolPrefSetDouble</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginPrefSetFloat><H1 CLASS="APISYMBOL">mgPluginPrefSetFloat</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginPrefSetFloat</B> - sets a float preference value 
in the plug-in preferences.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgPluginPrefSetFloat</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>prefName</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>prefValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginPrefSetFloat</B> stores a float value for a 
named preference key, <I>prefName</I> for <I>plugin</I>. 
If the key <I>prefName</I> does not exist for the <I>plugin</I>, it 
is created with a value of <I>prefValue</I>.</P></DD><DD><P>Preference keys created using this function are stored relative 
to the entire plug-in library, and are separate from the keys used for 
individual plug-in tools within the plug-in library.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in handle</DD><DT><I>prefName</I></DT><DD>the preference key name</DD><DT><I>prefValue</I></DT><DD>value to store for <I>prefName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginPrefGetFloat>mgPluginPrefGetFloat</A>, <A HREF=#mgPluginToolPrefSetFloat>mgPluginToolPrefSetFloat</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginPrefSetInteger><H1 CLASS="APISYMBOL">mgPluginPrefSetInteger</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginPrefSetInteger</B> - sets an integer preference value 
in the plug-in preferences.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgPluginPrefSetInteger</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>prefName</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>prefValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginPrefSetInteger</B> stores an integer value for a 
named preference key, <I>prefName</I> for <I>plugin</I>. 
If the key <I>prefName</I> does not exist for the <I>plugin</I>, it 
is created with a value of <I>prefValue</I>.</P></DD><DD><P>Preference keys created using this function are stored relative 
to the entire plug-in library, and are separate from the keys used for 
individual plug-in tools within the plug-in library.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in handle</DD><DT><I>prefName</I></DT><DD>the preference key name</DD><DT><I>prefValue</I></DT><DD>value to store for <I>prefName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginPrefGetInteger>mgPluginPrefGetInteger</A>, <A HREF=#mgPluginToolPrefSetInteger>mgPluginToolPrefSetInteger</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginPrefSetString><H1 CLASS="APISYMBOL">mgPluginPrefSetString</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginPrefSetString</B> - sets a string preference value 
in the plug-in preferences.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgPluginPrefSetString</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>prefName</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>prefValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginPrefSetString</B> stores a string value for a 
named preference key, <I>prefName</I> for <I>plugin</I>. 
If the key <I>prefName</I> does not exist for the <I>plugin</I>, it 
is created with a value of <I>prefValue</I>.</P></DD><DD><P>Preference keys created using this function are stored relative 
to the entire plug-in library, and are separate from the keys used for 
individual plug-in tools within the plug-in library.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in handle</DD><DT><I>prefName</I></DT><DD>the preference key name</DD><DT><I>prefValue</I></DT><DD>value to store for <I>prefName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginPrefGetString>mgPluginPrefGetString</A>, <A HREF=#mgPluginToolPrefSetString>mgPluginToolPrefSetString</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginPutProperty><H1 CLASS="APISYMBOL">mgPluginPutProperty</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginPutProperty</B> - associates user defined data with a 
plug-in.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgPluginPutProperty</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgpropertyname>mgpropertyname</A></TD><TD><I>propName</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgpropertyvalue>mgpropertyvalue</A></TD><TD><I>propValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginPutProperty</B> allows you to associate data of 
any type, <I>propValue</I>, with a plug-in module.  The user-defined data 
is associated with the plug-in module, <I>plugin</I>, and identified by a 
property name string, <I>propName</I>, allowing any number of data records 
to be associated with the plug-in module, as long as all property names 
are unique.</P></DD><DD><P>After using this function to associate user data to a plug-in, use 
the function <A HREF=#mgPluginGetProperty>mgPluginGetProperty</A> to retrieve the data.  Then when you 
no longer need the data associated to the plug-in, use 
<A HREF=#mgPluginDeleteProperty>mgPluginDeleteProperty</A> to disassociate the data from the plug-in. 
Note that <A HREF=#mgPluginDeleteProperty>mgPluginDeleteProperty</A> does not free or otherwise affect 
the actual data that was associated.  If this data was dynamically 
allocated, it is the callers responsibility to deallocate it.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in module to which the data 
is to be associated</DD><DT><I>propName</I></DT><DD>the name of the property to assign</DD><DT><I>propValue</I></DT><DD>the value of the property to assign</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Return <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example associates a string property to a plug-in, 
retrieves the string and prints it out.  Finally, it deletes the 
property from the plug-in.</DT><DT><PRE CLASS="EXAMPLE">#define PROPERTY_NAME   "My String Property"
#define USER_STRING     "This String is associated to my plug-in"

char* string;

// allocate the string to be associated to the plug-in
string = mgMalloc (strlen (USER_STRING) + 1);
strcpy (string, USER_STRING);

// associate the string as a property of the plug-in
mgPluginPutProperty (plugin, PROPERTY_NAME, string);

// Then later, retrieve the string property, print it out

char* string;

// Retrieve the string property from the plug-in
string = (char*) mgPluginGetProperty (plugin, PROPERTY_NAME);
printf ("%s: %s", PROPERTY_NAME, string);

// Output is:
// My String Property: This String is associated to my plug-in

// Then finally, when you no longer need the string to be
// associated to the plug-in

char* string;

// Retrieve the string property from the plug-in (need to free it)
string = (char*) mgPluginGetProperty (plugin, PROPERTY_NAME);
mgFree (string);
mgPluginDeleteProperty (plugin, PROPERTY_NAME);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginGetProperty>mgPluginGetProperty</A>, <A HREF=#mgPluginDeleteProperty>mgPluginDeleteProperty</A>, 
<A HREF=#mgPluginToolPutProperty>mgPluginToolPutProperty</A>, <A HREF=#mgPluginToolGetProperty>mgPluginToolGetProperty</A>, 
<A HREF=#mgPluginToolDeleteProperty>mgPluginToolDeleteProperty</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginSetHelpContext><H1 CLASS="APISYMBOL">mgPluginSetHelpContext</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginSetHelpContext</B> - sets a help context for a plug-in 
module.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgPluginSetHelpContext</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mghelpcontext>mghelpcontext</A></TD><TD><I>helpContext</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginSetHelpContext</B> associates the named help context, 
<I>helpContext</I>, to the specified plug-in module, <I>plugin</I>.</P></DD><DD><P>If a help file is registered for a plug-in module and a valid help 
context exists in that help file, you can associate that help context to 
it using this function.  If you do so, Creator will 
automatically display the help context in the Creator Online Help system 
when the user requests context sensitive help for the plug-in module.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in module to associate the help 
context with</DD><DT><I>helpContext</I></DT><DD>the help context</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterHelpFile>mgRegisterHelpFile</A>, <A HREF=#mgGuiSetHelpContext>mgGuiSetHelpContext</A>, 
<A HREF=#mgShowHelpContext>mgShowHelpContext</A>, <A HREF=#MTA_HELPCONTEXT>MTA_HELPCONTEXT</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginToolDeleteProperty><H1 CLASS="APISYMBOL">mgPluginToolDeleteProperty</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginToolDeleteProperty</B> - deletes user defined data 
associated with a plug-in tool.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgPluginToolDeleteProperty</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>pluginTool</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgpropertyname>mgpropertyname</A></TD><TD><I>propName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Use <B>mgPluginToolDeleteProperty</B> to delete the data named 
<I>propName</I> that was associated with the plug-in tool <I>pluginTool</I> 
using <A HREF=#mgPluginToolPutProperty>mgPluginToolPutProperty</A>.</P></DD><DD><P>Note that this function does not free or otherwise affect the actual data 
that was associated.  If this data was dynamically allocated, it is the 
callers responsibility to deallocate it.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginTool</I></DT><DD>the plug-in tool</DD><DT><I>propName</I></DT><DD>the name of the property to delete</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginToolPutProperty>mgPluginToolPutProperty</A>, <A HREF=#mgPluginToolGetProperty>mgPluginToolGetProperty</A>, 
<A HREF=#mgPluginPutProperty>mgPluginPutProperty</A>, <A HREF=#mgPluginGetProperty>mgPluginGetProperty</A>, <A HREF=#mgPluginDeleteProperty>mgPluginDeleteProperty</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginToolFreeAction><H1 CLASS="APISYMBOL">mgPluginToolFreeAction</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginToolFreeAction</B> - deallocates a plug-in tool action.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgPluginToolFreeAction</B> (</TD><TD><A HREF=#mgtoolaction>mgtoolaction</A></TD><TD><I>toolAction</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginToolFreeAction</B> deallocates a plug-in tool action 
created by <A HREF=#mgPluginToolNewAction>mgPluginToolNewAction</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>toolAction</I></DT><DD>the tool action to free</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginToolNewAction>mgPluginToolNewAction</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginToolGetAction><H1 CLASS="APISYMBOL">mgPluginToolGetAction</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginToolGetAction</B> - gets a plug-in tool action 
associated with a plug-in tool.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgtoolaction <B>mgPluginToolGetAction</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>pluginTool</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>actionName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginToolGetAction</B> gets the plug-in tool action identified 
by <I>actionName</I> associated with plug-in tool <I>pluginTool</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginTool</I></DT><DD>the plug-in tool for which the action applies</DD><DT><I>actionName</I></DT><DD>the name of the tool action to lookup</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the plug-in action if successful, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginToolNewAction>mgPluginToolNewAction</A>, <A HREF=#mgPluginToolFreeAction>mgPluginToolFreeAction</A>, <A HREF=#mgToolActionGetName>mgToolActionGetName</A>, 
<A HREF=#mgToolActionSetShortCut>mgToolActionSetShortCut</A>, <A HREF=#mgToolActionGetShortCut>mgToolActionGetShortCut</A>, 
<A HREF=#mgToolActionGetShortCutString>mgToolActionGetShortCutString</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginToolGetPlugin><H1 CLASS="APISYMBOL">mgPluginToolGetPlugin</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginToolGetPlugin</B> - gets the plug-in associated with 
a plug-in tool.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgplugin <B>mgPluginToolGetPlugin</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>pluginTool</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginToolGetPlugin</B> gets the plug-in that contains the 
plug-in tool <I>pluginTool</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginTool</I></DT><DD>the plug-in tool</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the plug-in that contains <I>pluginTool</I> if successful, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImporter>mgRegisterImporter</A>, <A HREF=#mgRegisterExporter>mgRegisterExporter</A>, 
<A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgRegisterViewer>mgRegisterViewer</A>, 
<A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgRegisterInputDevice>mgRegisterInputDevice</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginToolGetProperty><H1 CLASS="APISYMBOL">mgPluginToolGetProperty</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginToolGetProperty</B> - retrieves user defined data 
associated with a plug-in tool.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgpropertyvalue <B>mgPluginToolGetProperty</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>pluginTool</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgpropertyname>mgpropertyname</A></TD><TD><I>propName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Use <B>mgPluginToolGetProperty</B> to retrieve the data named <I>propName</I> 
that was associated with the plug-in tool <I>pluginTool</I> using 
<A HREF=#mgPluginToolPutProperty>mgPluginToolPutProperty</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginTool</I></DT><DD>the plug-in tool</DD><DT><I>propName</I></DT><DD>the name of the property to get</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the user-defined data if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginToolPutProperty>mgPluginToolPutProperty</A>, <A HREF=#mgPluginToolDeleteProperty>mgPluginToolDeleteProperty</A>, 
<A HREF=#mgPluginToolGetUserData>mgPluginToolGetUserData</A>, 
<A HREF=#mgPluginPutProperty>mgPluginPutProperty</A>, <A HREF=#mgPluginGetProperty>mgPluginGetProperty</A>, <A HREF=#mgPluginDeleteProperty>mgPluginDeleteProperty</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginToolGetUserData><H1 CLASS="APISYMBOL">mgPluginToolGetUserData</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginToolGetUserData</B> - gets the user data associated 
with a plug-in tool.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void* <B>mgPluginToolGetUserData</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>pluginTool</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginToolGetUserData</B> gets the user data that was associated to 
the plug-in tool <I>pluginTool</I> when it was registered via <A HREF=#mgRegisterImporter>mgRegisterImporter</A>, 
<A HREF=#mgRegisterExporter>mgRegisterExporter</A>, <A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgRegisterViewer>mgRegisterViewer</A>, 
<A HREF=#mgRegisterEditor>mgRegisterEditor</A> or <A HREF=#mgRegisterInputDevice>mgRegisterInputDevice</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginTool</I></DT><DD>the plug-in tool</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the user data associated to <I>pluginTool</I> if found, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImporter>mgRegisterImporter</A>, <A HREF=#mgRegisterExporter>mgRegisterExporter</A>, 
<A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgRegisterViewer>mgRegisterViewer</A>, 
<A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgRegisterInputDevice>mgRegisterInputDevice</A>, <A HREF=#mgPluginToolGetProperty>mgPluginToolGetProperty</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginToolNewAction><H1 CLASS="APISYMBOL">mgPluginToolNewAction</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginToolNewAction</B> - creates a plug-in tool action.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgtoolaction <B>mgPluginToolNewAction</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>pluginTool</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>actionName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginToolNewAction</B> creates a plug-in tool action identified by 
<I>actionName</I>.  If your plug-in tool uses keyboard shortcuts in its dialog, 
it must create a plug-in tool action using this function in the plug-in 
initialization function. It can then assign a default keyboard shortcut 
to the action and bind the action to a user interface control in the 
dialog.</P></DD><DD><P>Note: You must create all plug-in tool actions within your plug-in 
initialization function.  If you create plug-in tool actions at any other 
time during the modeling session, the results are not defined.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginTool</I></DT><DD>the plug-in tool for which the action applies</DD><DT><I>actionName</I></DT><DD>the name of the new tool action</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Pointer to plug-in tool action if created successfully, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows how a plug-in might create a set 
of actions for a tool, assign default shortcuts for the actions, and 
bind the actions to specific controls in the plug-in tool dialog.</DT><DT><PRE CLASS="EXAMPLE">// Plug-in tool actions
static mgtoolaction Action1 = MG_NULL;
static mgtoolaction Action2 = MG_NULL;

// Tool instance data
typedef struct toolrec_t {
   mgresource        resource;
   mgplugintool      pluginTool;
   mgrec*            db;
} toolrec;

// Control callback function for Action buttons in dialog
static mgstatus ActionCallback (mggui gui, mgcontrolid controlId,
&#32&#32&#32&#32 mgguicallbackreason callbackReason,
&#32&#32&#32&#32 void* userData, void* callData)
{
   toolrec* toolRec = (toolrec*) userData;
   switch (callbackReason) {
   case MGCB_ACTIVATE:
      // Will get here if:
      // User pressed either action button
      // --OR--
      // User pressed shortcut key sequence for either action
      // while tool dialog is active
      //
      if (mgControlIdsMatch (controlId, ACTION1_BUTTON)) {
      // ACTION1_BUTTON button pressed or key sequence CTRL+A
      }
      else if (mgControlIdsMatch (controlId, ACTION2_BUTTON)) {
      // ACTION2_BUTTON button pressed or key sequence SHIFT+CTRL+A
      }
      break;
   case MGCB_REFRESH:
      break;
   }
   return (MSTAT_OK);
}

// Tool dialog function
static mgstatus DialogProc (mggui dialog, mgdialogid dialogId,
&#32&#32&#32     mgguicallbackreason callbackReason,
&#32&#32&#32     void* userData, void* callData)
{
   toolrec* toolRec = (toolrec*) userData;
   mgeditorcontext editorContext = mgEditorGetContext (dialog);
   mggui gui;

   switch (callbackReason)
   {
   case MGCB_INIT:
      // Bind Action1 to ACTION1_BUTTON
      gui = mgFindGuiById (dialog, ACTION1_BUTTON );
      mgSetGuiCallback (gui, MGCB_ACTIVATE|MGCB_REFRESH, ActionCallback, toolRec);
      mgSetGuiToolAction (gui, Action1);

      // Bind Action2 to ACTION2_BUTTON
      gui = mgFindGuiById (dialog, ACTION2_BUTTON );
      mgSetGuiCallback (gui, MGCB_ACTIVATE|MGCB_REFRESH, ActionCallback, toolRec);
      mgSetGuiToolAction (gui, Action2);
      break;

   case MGCB_DESTROY:
      mgFree (toolRec);
      break;
   }
   return (MSTAT_OK);
}

// Tool create dialog function
static mggui CreateDialogFunc (mgplugintool pluginTool, void* userData)
{
   toolrec* toolRec = (toolrec*) userData;
   mggui dialog = mgResourceGetDialog (MG_NULL, toolRec-&gtresource, MYTOOLDIALOG,
&#32&#32&#32       MGCB_INIT|MGCB_DESTROY, DialogProc, toolRec);
   return (dialog);
}

// Tool start function
static mgstatus StartTool (mgplugintool pluginTool, void* userData, void* callData)
{
   mgresource resource = (mgresource) userData;
   mgeditorcallbackrec* cbData = (mgeditorcallbackrec*) callData;
   mgrec* db = mgGetActivationDb (cbData-&gttoolActivation);
   toolrec* toolRec;

   // Allocate and initialize tool instance data
   toolRec = (toolrec*) mgMalloc (sizeof(toolrec));
   toolRec-&gtresource = resource;
   toolRec-&gtdb = db;
   toolRec-&gtpluginTool = pluginTool;

   // Tell caller that tool can continue and to create its dialog
   cbData-&gtdialogRequired = MG_TRUE;
   cbData-&gttoolData = toolRec;
   return (MSTAT_OK);
}

// Plug-in initialization function
MGPIDECLARE(mgbool) mgpInit (mgplugin plugin, int* argc, char* argv [])
{
   mgmodulehandle moduleHandle;
   mgplugintool pluginTool;
   mgkeysequence keySequence;
   mgresource resource;

   moduleHandle = mgGetModuleHandle (plugin);
   resource = mgLoadResource (moduleHandle);

   // Register "My Tool" editor tool in the "Edit" menu
   pluginTool = mgRegisterEditor (
      plugin, "My Tool",
      StartTool, resource,
      MTA_VERSION, "1.0",
      MTA_MENULOCATION, MMENU_EDIT,
      MG_NULL);

   if (pluginTool) {
      // Assign create dialog function for editor tool instance
      mgEditorSetCreateDialogFunc (pluginTool, CreateDialogFunc);

      // Create Action1, shortcut CTRL+A
      Action1 = mgPluginToolNewAction (pluginTool, "Action 1");
      keySequence.keyboardFlags = MKB_CTRLKEY;
      keySequence.key = MKEY_A;
      mgToolActionSetShortCut (Action1, &keySequence);

      // Create Action2, shortcut SHIFT+CTRL+A
      Action2 = mgPluginToolNewAction (pluginTool, "Action 2");
      keySequence.keyboardFlags = MKB_SHIFT|MKB_CTRL;
      keySequence.key = MKEY_A;
      mgToolActionSetShortCut (Action2, &keySequence);
   }
   return (pluginTool ? MG_TRUE : MG_FALSE);
}

// Plug-in termination function
MGPIDECLARE(void) mgpExit (mgplugin plugin)
{
   mgUnregisterAllTools (plugin);
   mgPluginToolFreeAction (Action1);
   Action1 = MG_NULL;
   mgPluginToolFreeAction (Action2);
   Action2 = MG_NULL;
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginToolFreeAction>mgPluginToolFreeAction</A>, <A HREF=#mgPluginToolGetAction>mgPluginToolGetAction</A>, <A HREF=#mgToolActionGetName>mgToolActionGetName</A>, 
<A HREF=#mgToolActionSetShortCut>mgToolActionSetShortCut</A>, <A HREF=#mgToolActionGetShortCut>mgToolActionGetShortCut</A>, 
<A HREF=#mgToolActionGetShortCutString>mgToolActionGetShortCutString</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginToolPrefDelete><H1 CLASS="APISYMBOL">mgPluginToolPrefDelete</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginToolPrefDelete</B> - deletes a preference value 
from the plug-in tool preferences.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgPluginToolPrefDelete</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>plugintool</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>prefName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginToolPrefDelete</B> deletes a named preference key, 
<I>prefName</I> from <I>plugintool</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugintool</I></DT><DD>the plug-in tool handle</DD><DT><I>prefName</I></DT><DD>the preference key name to delete</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginToolPrefSetInteger>mgPluginToolPrefSetInteger</A>, <A HREF=#mgPluginToolPrefSetFloat>mgPluginToolPrefSetFloat</A>, 
<A HREF=#mgPluginToolPrefSetDouble>mgPluginToolPrefSetDouble</A>, <A HREF=#mgPluginToolPrefSetString>mgPluginToolPrefSetString</A>, 
<A HREF=#mgPluginToolPrefSetBool>mgPluginToolPrefSetBool</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginToolPrefGetBool><H1 CLASS="APISYMBOL">mgPluginToolPrefGetBool</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginToolPrefGetBool</B> - gets an mgbool preference value 
from the plug-in tool preferences.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgPluginToolPrefGetBool</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>plugintool</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>prefName</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool*</A></TD><TD><I>prefValue</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginToolPrefGetBool</B> retrieves an mgbool value from a 
named preference key, <I>prefName</I> for <I>pluginTool</I>, and stores it in <I>prefValue</I>. 
If the key <I>prefName</I> does not exist for the <I>pluginTool</I>, it 
is created with a value of <I>defaultValue</I>.</P></DD><DD><P>Preference keys accessed using this function are stored relative 
to the individual plug-in tools within the plug-in library, and are 
separate from the keys used for entire plug-in library.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugintool</I></DT><DD>the plug-in tool handle</DD><DT><I>prefName</I></DT><DD>the preference key name</DD><DT><I>prefValue</I></DT><DD>storage location for the preference value</DD><DT><I>defaultValue</I></DT><DD>default value for creating preference if 
it does not yet exist</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginToolPrefSetBool>mgPluginToolPrefSetBool</A>, <A HREF=#mgPluginPrefGetBool>mgPluginPrefGetBool</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginToolPrefGetDouble><H1 CLASS="APISYMBOL">mgPluginToolPrefGetDouble</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginToolPrefGetDouble</B> - gets a double preference value 
from the plug-in tool preferences.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgPluginToolPrefGetDouble</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>plugintool</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>prefName</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>prefValue</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginToolPrefGetDouble</B> retrieves a double value from a 
named preference key, <I>prefName</I> for <I>pluginTool</I>, and stores it in <I>prefValue</I>. 
If the key <I>prefName</I> does not exist for the <I>pluginTool</I>, it 
is created with a value of <I>defaultValue</I>.</P></DD><DD><P>Preference keys accessed using this function are stored relative 
to the individual plug-in tools within the plug-in library, and are 
separate from the keys used for entire plug-in library.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugintool</I></DT><DD>the plug-in tool handle</DD><DT><I>prefName</I></DT><DD>the preference key name</DD><DT><I>prefValue</I></DT><DD>storage location for the preference value</DD><DT><I>defaultValue</I></DT><DD>default value for creating a new key if 
the requested key does not already exist</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginToolPrefSetDouble>mgPluginToolPrefSetDouble</A>, <A HREF=#mgPluginPrefGetDouble>mgPluginPrefGetDouble</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginToolPrefGetFloat><H1 CLASS="APISYMBOL">mgPluginToolPrefGetFloat</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginToolPrefGetFloat</B> - gets a float preference value 
from the plug-in tool preferences.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgPluginToolPrefGetFloat</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>plugintool</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>prefName</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>prefValue</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginToolPrefGetFloat</B> retrieves a float value from a 
named preference key, <I>prefName</I> for <I>pluginTool</I>, and store it in <I>prefValue</I>. 
If the key <I>prefName</I> does not exist for the <I>pluginTool</I>, it 
is created with a value of <I>defaultValue</I>.</P></DD><DD><P>Preference keys accessed using this function are stored relative 
to the individual plug-in tools within the plug-in library, and are 
separate from the keys used for entire plug-in library.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugintool</I></DT><DD>the plug-in tool handle</DD><DT><I>prefName</I></DT><DD>the preference key name</DD><DT><I>prefValue</I></DT><DD>storage location for the preference value</DD><DT><I>defaultValue</I></DT><DD>default value for creating preference if 
it does not yet exist</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginToolPrefSetFloat>mgPluginToolPrefSetFloat</A>, <A HREF=#mgPluginPrefGetFloat>mgPluginPrefGetFloat</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginToolPrefGetInteger><H1 CLASS="APISYMBOL">mgPluginToolPrefGetInteger</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginToolPrefGetInteger</B> - gets an integer preference value 
from the plug-in tool preferences.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgPluginToolPrefGetInteger</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>plugintool</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>prefName</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>prefValue</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginToolPrefGetInteger</B> retrieves an integer value from a 
named preference key, <I>prefName</I> for <I>pluginTool</I>, and stores it in <I>prefValue</I>. 
If the key <I>prefName</I> does not exist for the <I>pluginTool</I>, it 
is created with a value of <I>defaultValue</I>.</P></DD><DD><P>Preference keys accessed using this function are stored relative 
to the individual plug-in tools within the plug-in library, and are 
separate from the keys used for entire plug-in library.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugintool</I></DT><DD>the plug-in tool handle</DD><DT><I>prefName</I></DT><DD>the preference key name</DD><DT><I>prefValue</I></DT><DD>storage location for the preference value</DD><DT><I>defaultValue</I></DT><DD>default value for creating preference if 
it does not yet exist</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginToolPrefSetInteger>mgPluginToolPrefSetInteger</A>, <A HREF=#mgPluginPrefGetInteger>mgPluginPrefGetInteger</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginToolPrefGetString><H1 CLASS="APISYMBOL">mgPluginToolPrefGetString</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginToolPrefGetString</B> - gets a string preference value 
from the plug-in tool preferences.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgPluginToolPrefGetString</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>plugintool</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>prefName</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>prefValue</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maxLen</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>defaultValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginToolPrefGetString</B> retrieves a string value from a 
named preference key, <I>prefName</I> for <I>pluginTool</I>, and store it in <I>prefValue</I>. 
If the key <I>prefName</I> does not exist for the <I>pluginTool</I>, it 
is created with a value of <I>defaultValue</I>.</P></DD><DD><P>Preference keys accessed using this function are stored relative 
to the individual plug-in tools within the plug-in library, and are 
separate from the keys used for entire plug-in library.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugintool</I></DT><DD>the plug-in tool handle</DD><DT><I>prefName</I></DT><DD>the preference key name</DD><DT><I>prefValue</I></DT><DD>storage location for the preference value</DD><DT><I>maxLen</I></DT><DD>maximum number of characters to store in <I>prefValue</I></DD><DT><I>defaultValue</I></DT><DD>default value for creating preference if 
it does not yet exist</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginToolPrefSetString>mgPluginToolPrefSetString</A>, <A HREF=#mgPluginPrefGetString>mgPluginPrefGetString</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginToolPrefSetBool><H1 CLASS="APISYMBOL">mgPluginToolPrefSetBool</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginToolPrefSetBool</B> - sets an mgbool preference value 
in the plug-in tool preferences.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgPluginToolPrefSetBool</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>plugintool</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>prefName</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>prefValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginToolPrefSetBool</B> stores an mgbool value for a 
named preference key, <I>prefName</I> for <I>pluginTool</I>. 
If the key <I>prefName</I> does not exist for the <I>pluginTool</I>, it 
is created with a value of <I>prefValue</I>.</P></DD><DD><P>Preference keys created using this function are stored relative 
to the individual plug-in tools within the plug-in library, and are 
separate from the keys used for entire plug-in library.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugintool</I></DT><DD>the plug-in tool handle</DD><DT><I>prefName</I></DT><DD>the preference key name</DD><DT><I>prefValue</I></DT><DD>value to store for <I>prefName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginToolPrefGetBool>mgPluginToolPrefGetBool</A>, <A HREF=#mgPluginPrefSetBool>mgPluginPrefSetBool</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginToolPrefSetDouble><H1 CLASS="APISYMBOL">mgPluginToolPrefSetDouble</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginToolPrefSetDouble</B> - sets a double preference value 
in the plug-in tool preferences.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgPluginToolPrefSetDouble</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>plugintool</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>prefName</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>prefValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginToolPrefSetDouble</B> stores a double value for a 
named preference key, <I>prefName</I> for <I>pluginTool</I>. 
If the key <I>prefName</I> does not exist for the <I>pluginTool</I>, it 
is created with a value of <I>prefValue</I>.</P></DD><DD><P>Preference keys created using this function are stored relative 
to the individual plug-in tools within the plug-in library, and are 
separate from the keys used for entire plug-in library.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugintool</I></DT><DD>the plug-in tool handle</DD><DT><I>prefName</I></DT><DD>the preference key name</DD><DT><I>prefValue</I></DT><DD>value to store for <I>prefName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginToolPrefGetDouble>mgPluginToolPrefGetDouble</A>, <A HREF=#mgPluginPrefSetDouble>mgPluginPrefSetDouble</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginToolPrefSetFloat><H1 CLASS="APISYMBOL">mgPluginToolPrefSetFloat</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginToolPrefSetFloat</B> - sets a float preference value 
in the plug-in tool preferences.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgPluginToolPrefSetFloat</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>plugintool</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>prefName</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>prefValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginToolPrefSetFloat</B> stores a float value for a 
named preference key, <I>prefName</I> for <I>pluginTool</I>. 
If the key <I>prefName</I> does not exist for the <I>pluginTool</I>, it 
is created with a value of <I>prefValue</I>.</P></DD><DD><P>Preference keys created using this function are stored relative 
to the individual plug-in tools within the plug-in library, and are 
separate from the keys used for entire plug-in library.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugintool</I></DT><DD>the plug-in tool handle</DD><DT><I>prefName</I></DT><DD>the preference key name</DD><DT><I>prefValue</I></DT><DD>value to store for <I>prefName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginToolPrefGetFloat>mgPluginToolPrefGetFloat</A>, <A HREF=#mgPluginPrefSetFloat>mgPluginPrefSetFloat</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginToolPrefSetInteger><H1 CLASS="APISYMBOL">mgPluginToolPrefSetInteger</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginToolPrefSetInteger</B> - sets an integer preference value 
in the plug-in tool preferences.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgPluginToolPrefSetInteger</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>plugintool</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>prefName</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>prefValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginToolPrefSetInteger</B> stores an integer value for a 
named preference key, <I>prefName</I> for <I>pluginTool</I>. 
If the key <I>prefName</I> does not exist for the <I>pluginTool</I>, it 
is created with a value of <I>prefValue</I>.</P></DD><DD><P>Preference keys created using this function are stored relative 
to the individual plug-in tools within the plug-in library, and are 
separate from the keys used for entire plug-in library.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugintool</I></DT><DD>the plug-in tool handle</DD><DT><I>prefName</I></DT><DD>the preference key name</DD><DT><I>prefValue</I></DT><DD>value to store for <I>prefName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginToolPrefGetInteger>mgPluginToolPrefGetInteger</A>, <A HREF=#mgPluginPrefSetInteger>mgPluginPrefSetInteger</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginToolPrefSetString><H1 CLASS="APISYMBOL">mgPluginToolPrefSetString</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginToolPrefSetString</B> - sets a string preference value 
in the plug-in tool preferences.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgPluginToolPrefSetString</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>plugintool</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>prefName</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>prefValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginToolPrefSetString</B> stores a string value for a 
named preference key, <I>prefName</I> for <I>pluginTool</I>. 
If the key <I>prefName</I> does not exist for the <I>pluginTool</I>, it 
is created with a value of <I>prefValue</I>.</P></DD><DD><P>Preference keys created using this function are stored relative 
to the individual plug-in tools within the plug-in library, and are 
separate from the keys used for entire plug-in library.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugintool</I></DT><DD>the plug-in tool handle</DD><DT><I>prefName</I></DT><DD>the preference key name</DD><DT><I>prefValue</I></DT><DD>value to store for <I>prefName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginToolPrefGetString>mgPluginToolPrefGetString</A>, <A HREF=#mgPluginPrefSetString>mgPluginPrefSetString</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginToolPutProperty><H1 CLASS="APISYMBOL">mgPluginToolPutProperty</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginToolPutProperty</B> - associates user defined data with 
a plug-in tool.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgPluginToolPutProperty</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>pluginTool</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgpropertyname>mgpropertyname</A></TD><TD><I>propName</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgpropertyvalue>mgpropertyvalue</A></TD><TD><I>propValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginToolPutProperty</B> allows you to associate data of 
any type, <I>propValue</I>, with a plug-in tool.  The user-defined data 
is associated with the plug-in tool, <I>pluginTool</I>, and identified by a 
property name string, <I>propName</I>, allowing any number of data records to 
be associated with the plug-in tool, as long as all property names are 
unique.</P></DD><DD><P>After using this function to associate user data to a plug-in tool, 
use the function <A HREF=#mgPluginToolGetProperty>mgPluginToolGetProperty</A> to retrieve the data.  Then 
when you no longer need the data associated to the plug-in tool, use 
<A HREF=#mgPluginToolDeleteProperty>mgPluginToolDeleteProperty</A> to disassociate the data from the plug-in 
tool. Note that <A HREF=#mgPluginToolDeleteProperty>mgPluginToolDeleteProperty</A> does not free or otherwise 
affect the actual data that was associated.  If this data was dynamically 
allocated, it is the callers responsibility to deallocate it.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginTool</I></DT><DD>the plug-in tool to which the data 
is to be associated</DD><DT><I>propName</I></DT><DD>the name of the property to assign</DD><DT><I>propValue</I></DT><DD>the value of the property to assign</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example associates a string property to a plug-in 
tool, retrieves the string and prints it out.  Finally, it deletes the 
property from the plug-in tool.</DT><DT><PRE CLASS="EXAMPLE">#define PROPERTY_NAME   "My String Property"
#define USER_STRING     "This String is associated to my plug-in tool"

char* string;

// allocate the string to be associated to the plug-in tool
string = mgMalloc (strlen (USER_STRING) + 1);
strcpy (string, USER_STRING);

// associate the string as a property of the plug-in
mgPluginToolPutProperty (pluginTool, PROPERTY_NAME, string);

// Then later, retrieve the string property, print it out

char* string;

// Retrieve the string property from the plug-in
string = (char*) mgPluginToolGetProperty (pluginTool, PROPERTY_NAME);
printf ("%s: %s", PROPERTY_NAME, string);

// Output is:
// My String Property: This String is associated to my plug-in tool

// Then finally, when you no longer need the string to be
// associated to the plug-in tool

char* string;

// Retrieve the string property from the plug-in tool (need to free it)
string = (char*) mgPluginToolGetProperty (pluginTool, PROPERTY_NAME);
mgFree (string);
mgPluginToolDeleteProperty (pluginTool, PROPERTY_NAME);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginToolGetProperty>mgPluginToolGetProperty</A>, <A HREF=#mgPluginToolDeleteProperty>mgPluginToolDeleteProperty</A>, 
<A HREF=#mgPluginPutProperty>mgPluginPutProperty</A>, <A HREF=#mgPluginGetProperty>mgPluginGetProperty</A>, <A HREF=#mgPluginDeleteProperty>mgPluginDeleteProperty</A></DD></DL>
<HR>
<LEFT><A NAME=mgPluginToolSetDefaultParamBlock><H1 CLASS="APISYMBOL">mgPluginToolSetDefaultParamBlock</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPluginToolSetDefaultParamBlock</B> - sets the default tool 
parameter block for an editor plug-in tool.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgPluginToolSetDefaultParamBlock</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>pluginTool</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgparamblock>mgparamblock</A></TD><TD><I>paramBlock</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPluginToolSetDefaultParamBlock</B> sets the default parameter 
block for the editor plug-in tool <I>pluginTool</I>.</P></DD><DD><P>A scriptable editor plug-in tool that normally displays a dialog to 
gather additional data from the user to continue its work must create and 
assign a default parameter block for itself.  This parameter block defines 
the data that the user will set and pass to the plug-in tool when invoking 
the tool via the Creator Script interface, using <A HREF=#mgExecute>mgExecute</A>.</P></DD><DD><P>Note: By passing a parameter block to this function, you transfer 
ownership of that parameter block to the OpenFlight API and you should 
NOT deallocate the block.  The OpenFlight API will automatically dispose 
of the memory when it is appropriate to do so.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginTool</I></DT><DD>the plug-in tool</DD><DT><I>paramBlock</I></DT><DD>the parameter block</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Return <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example creates the default parameter block for the 
Calculate Shading plug-in tool <B>calculateShadingTool</B>.</DT><DT><PRE CLASS="EXAMPLE">mgparamblock paramBlock;
mgparam param;

// create the default param block for the Calculate Shading command
paramBlock = mgNewParamBlock();

// add the "Shading Model" parameter
param = mgParamAddInteger (paramBlock, "Shading Model", 2);

// its possible values are these enumerants:
mgParamSetEnumerant (param, 0, "Flat");
mgParamSetEnumerant (param, 1, "Gouraud");
mgParamSetEnumerant (param, 2, "Lit");
mgParamSetEnumerant (param, 3, "Lit Gouraud");

// add several boolean (checkbox) parameters
param = mgParamAddBool (paramBlock, "Update Vertex Normals", MG_TRUE);
param = mgParamAddBool (paramBlock, "Update Vertex Colors", MG_TRUE);
param = mgParamAddBool (paramBlock, "Triangle Area Weighting", MG_FALSE);
param = mgParamAddBool (paramBlock, "Use Face Color Intensities", MG_TRUE);
param = mgParamAddBool (paramBlock, "Use Face Color Intensities", MG_TRUE);

// add the "Angular Tolerance" parameter...
param = mgParamAddDouble (paramBlock, "Angular Tolerance", 89.0);

// ... its value must be greater than or equal to 0.0 ...
mgParamSetDoubleMinGE (param, 0.0);
// ... and less than 360.0
mgParamSetDoubleMaxLT (param, 360.0);

// add the "Sampling Tolerance" parameter...
param = mgParamAddDouble (paramBlock, "Sampling Tolerance", 0.01);

// ... its value must be greater than or equal to 0.0
mgParamSetDoubleMinGE (param, 0.0);

// assign this param block as the default for this tool
mgPluginToolSetDefaultParamBlock (calculateShadingTool, paramBlock);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgNewParamBlock>mgNewParamBlock</A>, 
<A HREF=#mgParamAddInteger>mgParamAddInteger</A>, <A HREF=#mgParamAddDouble>mgParamAddDouble</A>, <A HREF=#mgParamAddFloat>mgParamAddFloat</A>, 
<A HREF=#mgParamAddString>mgParamAddString</A>, <A HREF=#mgParamAddBool>mgParamAddBool</A></DD></DL>
<HR>
<LEFT><A NAME=mgposteditfunc><H1 CLASS="APISYMBOL">mgposteditfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgposteditfunc</B> - Data Field Post-Edit function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool (*<B>mgposteditfunc</B>) ( <TD><A HREF=#mgrec>mgrec*</A> <TD><I>rec</I>, 
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A> <TD><I>code</I>, 
<TR><TD></TD><TD>void* <TD><I>val</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for data field post-edit action functions. 
You can define a post-edit action function for the data fields you 
define in your data extension of this form.  Data field post-edit 
functions are called after a modification to a field value is 
committed.  Data fields can be modified interactively by the modeler 
in the attribute pages and/or programmatically by calling 
<A HREF=#mgSetAttList>mgSetAttList</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record that was modified</DD><DT><I>code</I></DT><DD>the code of the field modified</DD><DT><I>val</I></DT><DD>the address of the value that was 
committed - depending on the type of the data field, 
this is the address of an object of the appropriate 
type</DD></DL></DD></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterSite>mgRegisterSite</A>, <A HREF=#mgpreeditfunc>mgpreeditfunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgpreeditfunc><H1 CLASS="APISYMBOL">mgpreeditfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgpreeditfunc</B> - Data Field Pre-Edit function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool (*<B>mgpreeditfunc</B>) ( <TD><A HREF=#mgrec>mgrec*</A> <TD><I>rec</I>, 
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A> <TD><I>code</I>, 
<TR><TD></TD><TD>void* <TD><I>val</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for data field pre-edit action functions. 
You can define a pre-edit action function for the data fields you 
define in your data extension of this form.  Data field pre-edit 
functions are called before a modification to a field value is 
committed.  Data fields can be modified interactively by the modeler 
in the attribute pages and/or programmatically by calling 
<A HREF=#mgSetAttList>mgSetAttList</A>.</P></DD><DD><P>You can disallow the edit by returning <A HREF=#mgbool>MG_FALSE</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record that is being modified</DD><DT><I>code</I></DT><DD>the code of the field being modified</DD><DT><I>val</I></DT><DD>the address of the value that is about to 
be committed - depending on the type of the data field, 
this is the address of an object of the appropriate 
type</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Return <A HREF=#mgbool>MG_TRUE</A> to allow edit, <A HREF=#mgbool>MG_FALSE</A> to 
disallow edit.
</DD></DL><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterSite>mgRegisterSite</A>, <A HREF=#mgposteditfunc>mgposteditfunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgPrintRec><H1 CLASS="APISYMBOL">mgPrintRec</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPrintRec</B> - prints the contents of a record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgPrintRec</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPrintRec</B> prints all the information associated with a 
record <I>rec</I>.  If invoked from within the stand-alone program 
environment, output is directed to <I>stdout</I>.  If invoked from the 
modeler environment, output is directed to the Status Log Window.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record to print</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPrintField>mgPrintField</A></DD></DL>
<HR>
<LEFT><A NAME=mgProgressGetMinMax><H1 CLASS="APISYMBOL">mgProgressGetMinMax</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgProgressGetMinMax</B> - retrieves the minimum and maximum 
logical values for a progress control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgProgressGetMinMax</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>min</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>max</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgProgressGetMinMax</B> returns the range of values valid for the 
specified progress <I>control</I>.  The minimum value is returned in 
<I>min</I>, the maximum in <I>max</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the progress control</DD><DT><I>min</I></DT><DD>address of double value to receive 
minimum value from control</DD><DT><I>max</I></DT><DD>address of double value to receive 
maximum value from control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.  If 
function is successful, <I>min</I> and <I>max</I> contain the corresponding minimum 
and maximum values, otherwise their contents are undefined.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgProgressSetMinMax>mgProgressSetMinMax</A>, <A HREF=#mgProgressSetValue>mgProgressSetValue</A>, <A HREF=#mgProgressGetValue>mgProgressGetValue</A>, 
<A HREF=#mgProgressStepValue>mgProgressStepValue</A>, <A HREF=#mgProgressSetStepIncrement>mgProgressSetStepIncrement</A></DD></DL>
<HR>
<LEFT><A NAME=mgProgressGetValue><H1 CLASS="APISYMBOL">mgProgressGetValue</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgProgressGetValue</B> - retrieves the current value of a progress 
control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgProgressGetValue</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>value</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgProgressGetValue</B> returns the current value of the specified progress 
<I>control</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the progress control</DD><DT><I>value</I></DT><DD>address of double value to receive 
current value from control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.  If 
function is successful, <I>value</I> contains the current value of the 
control, otherwise <I>value</I> is undefined.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgProgressSetValue>mgProgressSetValue</A>, <A HREF=#mgProgressStepValue>mgProgressStepValue</A>, <A HREF=#mgProgressSetMinMax>mgProgressSetMinMax</A>, 
<A HREF=#mgProgressGetMinMax>mgProgressGetMinMax</A>, <A HREF=#mgProgressSetStepIncrement>mgProgressSetStepIncrement</A></DD></DL>
<HR>
<LEFT><A NAME=mgProgressSetMinMax><H1 CLASS="APISYMBOL">mgProgressSetMinMax</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgProgressSetMinMax</B> - sets the minimum and maximum logical 
values for a progress control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgProgressSetMinMax</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>min</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>max</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgProgressSetMinMax</B> sets the range of logical values valid for the 
specified progress <I>control</I>.  The minimum value is specified 
by <I>min</I>, the maximum by <I>max</I>.</P></DD><DD><P>The default minimum and maximum values for a progress control are 0 
and 100 respectively.</P></DD><DD><P>If the current progress value is outside the new range, the progress value 
will be clamped to the new maximum or minimum value.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the progress control</DD><DT><I>min</I></DT><DD>the minimum value for the control</DD><DT><I>max</I></DT><DD>the maximum value for the control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgProgressGetMinMax>mgProgressGetMinMax</A>, <A HREF=#mgProgressSetValue>mgProgressSetValue</A>, <A HREF=#mgProgressGetValue>mgProgressGetValue</A>, 
<A HREF=#mgProgressStepValue>mgProgressStepValue</A>, <A HREF=#mgProgressSetStepIncrement>mgProgressSetStepIncrement</A></DD></DL>
<HR>
<LEFT><A NAME=mgProgressSetStepIncrement><H1 CLASS="APISYMBOL">mgProgressSetStepIncrement</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgProgressSetStepIncrement</B> - sets the step increment for 
a progress control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgProgressSetStepIncrement</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>increment</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgProgressSetStepIncrement</B> sets the step increment value for the 
specified progress <I>control</I> to the specified value, <I>increment</I>.</P></DD><DD><P>The step increment value is the value that a progress control is 
incremented when <A HREF=#mgProgressStepValue>mgProgressStepValue</A> is called.</P></DD><DD><P>The step increment value specified must be positive.  The value 
will be ignored if it is not.  The default step increment value for a 
progress control is 10.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the progress control</DD><DT><I>increment</I></DT><DD>the step increment value for the control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgProgressSetValue>mgProgressSetValue</A>, <A HREF=#mgProgressGetValue>mgProgressGetValue</A>, <A HREF=#mgProgressSetMinMax>mgProgressSetMinMax</A>, 
<A HREF=#mgProgressGetMinMax>mgProgressGetMinMax</A>, <A HREF=#mgProgressStepValue>mgProgressStepValue</A></DD></DL>
<HR>
<LEFT><A NAME=mgProgressSetValue><H1 CLASS="APISYMBOL">mgProgressSetValue</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgProgressSetValue</B> - sets the value of a progress control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgProgressSetValue</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>value</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgProgressSetValue</B> sets the value of a progress <I>control</I>, 
to the specified <I>value</I>.</P></DD><DD><P>If the value you specify is greater than the maximum value allowed for 
the progress control, the progress value will be set to the maximum progress value. 
Similarly, if value is less than the minimum progress value, the progress value will 
be set to the minimum progress value.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the progress control</DD><DT><I>value</I></DT><DD>the value for the control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgProgressStepValue>mgProgressStepValue</A>, <A HREF=#mgProgressGetValue>mgProgressGetValue</A>, <A HREF=#mgProgressSetMinMax>mgProgressSetMinMax</A>, 
<A HREF=#mgProgressGetMinMax>mgProgressGetMinMax</A>, <A HREF=#mgProgressSetStepIncrement>mgProgressSetStepIncrement</A></DD></DL>
<HR>
<LEFT><A NAME=mgProgressStepValue><H1 CLASS="APISYMBOL">mgProgressStepValue</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgProgressStepValue</B> - steps the value of a progress control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgProgressStepValue</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgProgressStepValue</B> steps the value of a progress&#32<I>control</I>, 
by the current step increment value of the control.</P></DD><DD><P>You can specify the step increment value for a progress control using 
the function <A HREF=#mgProgressSetStepIncrement>mgProgressSetStepIncrement</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the progress control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgProgressSetValue>mgProgressSetValue</A>, <A HREF=#mgProgressGetValue>mgProgressGetValue</A>, <A HREF=#mgProgressSetMinMax>mgProgressSetMinMax</A>, 
<A HREF=#mgProgressGetMinMax>mgProgressGetMinMax</A>, <A HREF=#mgProgressSetStepIncrement>mgProgressSetStepIncrement</A></DD></DL>
<HR>
<LEFT><A NAME=mgProject><H1 CLASS="APISYMBOL">mgProject</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgProject</B> - projects projection coordinates to database coordinates.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgProject</B> (</TD><TD>const <A HREF=#mgprojcoord>mgprojcoord*</A></TD><TD><I>coord</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgProject</B> projects projection coordinates to database coordinates. This 
function performs the same function as <A HREF=#mgProjectionConvertLLEtoXYZ>mgProjectionConvertLLEtoXYZ</A>.  If 
you need to convert multiple coordinates consecutively, it is more efficient to 
use <A HREF=#mgProjectionConvertLLEtoXYZ>mgProjectionConvertLLEtoXYZ</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>projection coordinates to project</DD><DT><I>db</I></DT><DD>database containing the projection to use</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the database coordinates represented by <I>coord</I>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgprojcoord>mgprojcoord</A>, <A HREF=#mgcoord3d>mgcoord3d</A>, 
<A HREF=#mgUnproject>mgUnproject</A>, <A HREF=#mgProjectionConvertLLEtoXYZ>mgProjectionConvertLLEtoXYZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgProjectionConvertLLEtoXYZ><H1 CLASS="APISYMBOL">mgProjectionConvertLLEtoXYZ</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgProjectionConvertLLEtoXYZ</B> - converts projection 
(lat/lon/elevation) coordinates to database XYZ coordinates.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgProjectionConvertLLEtoXYZ</B> (</TD><TD><A HREF=#mgprojection>mgprojection</A></TD><TD><I>projection</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgprojcoord>mgprojcoord*</A></TD><TD><I>lleCoord</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>xyzCoord</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, xyzCoord <B>mgProjectionConvertLLEtoXYZ</B> (</TD><TD><A HREF=#mgprojection>mgprojection</A></TD><TD><I>projection</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgprojcoord>mgprojcoord*</A></TD><TD><I>lleCoord</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgProjectionConvertLLEtoXYZ</B> converts projection (lat/lon/elevation) 
coordinates to database XYZ coordinates using the specified <I>projection</I>. 
This function performs the same function as <A HREF=#mgProject>mgProject</A>. 
If you need to convert multiple coordinates consecutively, it is 
more efficient to use <B>mgProjectionConvertLLEtoXYZ</B>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>projection</I></DT><DD>the projection object to use</DD><DT><I>lleCoord</I></DT><DD>projection (lat/lon/elevation) 
coordinates to convert</DD><DT><I>xyzCoord</I></DT><DD>the result database XYZ coordinates</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>xyzCoord</DT><DD>If function is successful, this is the database XYZ 
coordinate of <I>lleCoord</I>.</DD></DL></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show you how to convert 
from projection coordinates to database XYZ coordinates in database <I>db</I>.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgbool ok;
mgprojcoord lle;
mgcoord3d xyz;
mgprojection proj = mgNewProjection (db);

lle.lat = 37.0;
lle.lon = -122.0;
lle.height = 0.0;

ok = mgProjectionConvertLLEtoXYZ (proj, lle, &xyz);
printf ("XYZ Coordinates: %lf %lf %lf&#92;n", xyz.x, xyz.y, xyz.z);
mgFreeProjection (proj);</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">proj = mgNewProjection (db)
lle = mgprojcoord()
lle.lat = 37.0
lle.lon = -122.0
lle.height = 0.0
ok, xyz = mgProjectionConvertLLEtoXYZ (proj, lle)
print "XYZ Coordinates:", xyz.x, xyz.y, xyz.z</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgprojcoord>mgprojcoord</A>, <A HREF=#mgcoord3d>mgcoord3d</A>, 
<A HREF=#mgProjectionConvertXYZtoLLE>mgProjectionConvertXYZtoLLE</A>, <A HREF=#mgNewProjection>mgNewProjection</A>, <A HREF=#mgFreeProjection>mgFreeProjection</A>, 
<A HREF=#mgProject>mgProject</A></DD></DL>
<HR>
<LEFT><A NAME=mgProjectionConvertXYZtoLLE><H1 CLASS="APISYMBOL">mgProjectionConvertXYZtoLLE</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgProjectionConvertXYZtoLLE</B> - converts database XYZ coordinates 
into projection (lat/lon/elevation) coordinates.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgProjectionConvertXYZtoLLE</B> (</TD><TD><A HREF=#mgprojection>mgprojection</A></TD><TD><I>projection</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>xyzCoord</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgprojcoord>mgprojcoord*</A></TD><TD><I>lleCoord</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, lleCoord <B>mgProjectionConvertXYZtoLLE</B> (</TD><TD><A HREF=#mgprojection>mgprojection</A></TD><TD><I>projection</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>xyzCoord</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgProjectionConvertXYZtoLLE</B> converts database XYZ coordinates into 
projection (lat/lon/elevation) coordinates using the specified <I>projection</I>. 
This function performs the same function as <A HREF=#mgUnproject>mgUnproject</A>. 
If you need to convert multiple coordinates consecutively, it is 
more efficient to use <B>mgProjectionConvertXYZtoLLE</B>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>projection</I></DT><DD>the projection object to use</DD><DT><I>xyzCoord</I></DT><DD>database XYZ coordinates to convert</DD><DT><I>lleCoord</I></DT><DD>the result projection (lat/lon/elevation) 
coordinates</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>lleCoord</DT><DD>If function is successful, this is the 
projection (lat/lon/elevation) coordinate of <I>xyzCoord</I>.</DD></DL></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show you how to convert 
from database XYZ coordinates to projection coordinates in database <I>db</I>.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgbool ok;
mgprojcoord lle;
mgprojection proj = mgNewProjection (db);
mgcoord3d xyz = mgMakeCoord3d (0.0, 0.0, 20.0);

ok = mgProjectionConvertXYZtoLLE (proj, xyz, &lle);
printf ("Projection Coordinates: %lf %lf %lf&#92;n", lle.lat, lle.lon, lle.height);
mgFreeProjection (proj);</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">proj = mgNewProjection (db)
xyz = mgMakeCoord3d (0.0, 0.0, 20.0)
ok, lle = mgProjectionConvertXYZtoLLE (proj, xyz)
print "Projection Coordinates:", lle.lat, lle.lon, lle.height</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgprojcoord>mgprojcoord</A>, <A HREF=#mgcoord3d>mgcoord3d</A>, 
<A HREF=#mgProjectionConvertLLEtoXYZ>mgProjectionConvertLLEtoXYZ</A>, <A HREF=#mgNewProjection>mgNewProjection</A>, <A HREF=#mgFreeProjection>mgFreeProjection</A>, 
<A HREF=#mgUnproject>mgUnproject</A></DD></DL>
<HR>
<LEFT><A NAME=mgPromptDialogColor><H1 CLASS="APISYMBOL">mgPromptDialogColor</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPromptDialogColor</B> - prompts the user to select a color 
using a standard color chooser.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgPromptDialogColor</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>parent</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>inR</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>inG</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>inB</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>outR</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>outG</I>,</TD></TR>
<TR><TD></TD><TD>short*</TD><TD><I>outB</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus, outR, outG, outB <B>mgPromptDialogColor</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>parent</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>inR</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>inG</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>inB</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPromptDialogColor</B> displays a modal color chooser dialog in 
which the user is prompted to select a color.</P></DD><DD><P>When the dialog is initially displayed, it will present the color 
specified by the input parameters <I>inR</I>, <I>inG</I>, and <I>inB</I>. 
The input and output color values are in the range 0 to 255.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The dialog is created as a child of the specified dialog <I>parent</I>. 
If you specify <I>parent</I> as <A HREF=#MG_NULL>MG_NULL</A>, the dialog is created as a 
child of the Creator main window.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>Currently the <I>parent</I> parameter is reserved for future enhancement 
and should be specified as <B>None</B>.  For now the dialog is created as a child 
of the main Creator main window.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>parent</I></DT><DD>the dialog parent to attach the color dialog</DD><DT><I>inR</I></DT><DD>the red component of the initial color</DD><DT><I>inG</I></DT><DD>the green component of the initial color</DD><DT><I>inB</I></DT><DD>the blue component of the initial color</DD><DT><I>outR</I></DT><DD>the red component of the selected color</DD><DT><I>outG</I></DT><DD>the green component of the selected color</DD><DT><I>outB</I></DT><DD>the blue component of the selected color</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgstatus</DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success. 
Success indicates that the user selected and accepted a color.</DD><DT>outR</DT><DD>If function 
is successful, outR contains the corresponding color value, otherwise 
outR is undefined.</DD><DT>outG</DT><DD>If function 
is successful, outG contains the corresponding color value, otherwise 
outG is undefined.</DD><DT>outB</DT><DD>If function 
is successful, outB contains the corresponding color value, otherwise 
outB is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPromptDialogFile>mgPromptDialogFile</A>, <A HREF=#mgPromptDialogFolder>mgPromptDialogFolder</A>, <A HREF=#mgPromptDialogTexture>mgPromptDialogTexture</A></DD></DL>
<HR>
<LEFT><A NAME=mgPromptDialogDouble><H1 CLASS="APISYMBOL">mgPromptDialogDouble</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPromptDialogDouble</B> - prompts the user to enter double 
precision floating point value.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgPromptDialogDouble</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>parent</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>messageText</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>value</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus, number <B>mgPromptDialogDouble</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>parent</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#string>string</A></TD><TD><I>messageText</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>value</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPromptDialogDouble</B> displays a modal dialog in which the 
user is asked to enter a double precision floating point value.</P></DD><DD><P>The dialog displays a text message and contain a text control as well 
as two push button controls - OK and Cancel. The text control is used 
to enter the numeric value.  The initial value displayed in the text control 
is the numeric value contained in the parameter <I>value</I>. 
The OK and Cancel push button controls are 
used to dismiss the dialog.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The dialog is created as a child of the specified dialog <I>parent</I>. 
If you specify <I>parent</I> as <A HREF=#MG_NULL>MG_NULL</A>, the dialog is created as a 
child of the Creator main window.  If the user enters a valid numeric 
value and chooses the OK button to dismiss the dialog, the value is returned 
in the parameter <I>value</I>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>Currently the <I>parent</I> parameter is reserved for future enhancement 
and should be specified as <B>None</B>.  For now the dialog is created as a child 
of the main Creator main window.  If the user enters a valid numeric 
value and chooses the OK button to dismiss the dialog, the value is returned.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>parent</I></DT><DD>the dialog parent to attach the prompt dialog</DD><DT><I>messageText</I></DT><DD>a text string that is displayed in the dialog 
as a message to the user</DD><DT><I>value</I></DT><DD>on input, the address of the initial double 
value to display in the text control, on output 
receives the double value entered</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgstatus</DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success. 
Success indicates that the value entered was a valid double value 
and the user dismissed the dialog using the OK push button.</DD><DT>number</DT><DD>If function is successful, contains the number entered by the user.</DD></DL></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) prompt the user to enter 
a double precision floating point number (default value 4.0).</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">double number = 4.0;
mgstatus status = mgPromptDialogDouble (MG_NULL, "Enter Number", &number);
if (MSTAT_ISOK (status)) {
   printf ("Number: %f", number);
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">status,number = mgPromptDialogDouble (None, "Enter Number", 4.0)
if (MSTAT_ISOK (status)):
   print "Number:", number</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPromptDialogString>mgPromptDialogString</A>, <A HREF=#mgPromptDialogInteger>mgPromptDialogInteger</A>, <A HREF=#mgPromptDialogFloat>mgPromptDialogFloat</A></DD></DL>
<HR>
<LEFT><A NAME=mgPromptDialogFile><H1 CLASS="APISYMBOL">mgPromptDialogFile</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPromptDialogFile</B> - prompts the user to select one or 
more files using a standard file browser.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgPromptDialogFile</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>parent</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>mode</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>numFiles</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgstringlist>mgstringlist*</A></TD><TD><I>fileList</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>...</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus, numFiles, name1, name2, ... <B>mgPromptDialogFile</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>parent</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>mode</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>< paramKey ></I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>< paramValue ></I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>...</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPromptDialogFile</B> displays a modal dialog in which the 
user is prompted to select one or more files.</P></DD><DD><P>The dialog displays the directory structure using a file browser with 
two push buttons Open/Save and Cancel.&#32The file browser control is used to 
select the file. The user can specify the mode of the file browser as either 
Open or Save by specifying either <A HREF=#MPFM_OPEN>MPFM_OPEN</A> or <A HREF=#MPFM_SAVE>MPFM_SAVE</A> in <I>mode</I>.</P></DD><DD><P>The optional parameters are specified as key/value pairs in variable argument style. 
Following is a list of parameter keys and their associated values:</P></DD><DD><P><A HREF=#MPFA_FLAGS>MPFA_FLAGS</A> - argument value is a bitwise combination of<BR> 
<A HREF=#MPFF_OVERWRITEPROMPT>MPFF_OVERWRITEPROMPT</A>,<BR> 
<A HREF=#MPFF_FILEMUSTEXIST>MPFF_FILEMUSTEXIST</A>, and<BR> 
<A HREF=#MPFF_MULTISELECT>MPFF_MULTISELECT</A>.</P></DD><DD><P><A HREF=#MPFA_TITLE>MPFA_TITLE</A> - argument value is a string specifying the title of the dialog.</P></DD><DD><P><A HREF=#MPFA_PATTERN>MPFA_PATTERN</A> - argument value is a string containing a list of 
description-extension pairs that describe the file browser filters 
to use.  See <A HREF=#MPFA_PATTERN>MPFA_PATTERN</A> for a description of the required 
format of this string.</P></DD><DD><P><A HREF=#MPFA_DIRECTORY>MPFA_DIRECTORY</A> - argument value is a string specifying the 
initial directory name.</P></DD><DD><P><A HREF=#MPFA_FILENAME>MPFA_FILENAME</A> - argument value is a string specifying the initial 
file name (does not include directory path).</P></DD><DD><P><A HREF=#MPFA_FULLFILENAME>MPFA_FULLFILENAME</A> - argument value is a string specifying 
the full file name including the path.</P></DD><DD><P><A HREF=#MPFA_DIALOGID>MPFA_DIALOGID</A> - argument value is the identifier of a custom dialog 
to use for the file browser.<BR> 
This argument is not supported in Python OpenFlight Script.</P></DD><DD><P><A HREF=#MPFA_RESOURCE>MPFA_RESOURCE</A> - argument value is an object of type <A HREF=#mgresource>mgresource</A> 
to identify the resource where your custom dialog template is located.<BR> 
This argument is not supported in Python OpenFlight Script.</P></DD><DD><P><A HREF=#MPFA_DIALOGFUNC>MPFA_DIALOGFUNC</A> - argument value is a dialog function for the file 
browser dialog.<BR> 
This argument is not supported in Python OpenFlight Script.</P></DD><DD><P><A HREF=#MPFA_USERDATA>MPFA_USERDATA</A> - argument value is the user data to pass to 
the dialog function.<BR> 
This argument is not supported in Python OpenFlight Script.</P></DD><DD><P><A HREF=#MPFA_CALLBACKMASK>MPFA_CALLBACKMASK</A> - argument value is an unsigned integer value specifying 
the dialog events selected for the dialog function of the file browser.<BR> 
This argument is not supported in Python OpenFlight Script.</P></DD><DD><P><A HREF=#MPFA_PATTERNINDEX>MPFA_PATTERNINDEX</A> - argument value is the address of an integer object 
to receive the index of the selected pattern when the file chooses a file 
in the browser.<BR> 
This argument is not supported in Python OpenFlight Script.</P></DD><DD><P><A HREF=#MPFA_EXITDIRECTORY>MPFA_EXITDIRECTORY</A> - argument value is the address of a char* value to receive 
the name of the "exit" directory at the time the user closes the file browser 
dialog.  If the user cancels the selection in the file browser, this directory 
is not defined.  In C, the string returned is dynamically allocated. When you 
are done accessing this string, you should dispose of it using <A HREF=#mgFree>mgFree</A>.<BR> 
This argument is not supported in Python OpenFlight Script.</P></DD><DD><P>All optional parameter pairs are passed using variable argument style.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>Terminate the argument list with <A HREF=#MG_NULL>MG_NULL</A>.</P></DD><DD><P>The dialog is created as a child of the specified dialog <I>parent</I>. 
If you specify <I>parent</I> as <A HREF=#MG_NULL>MG_NULL</A>, the dialog is created as a 
child of the Creator main window.</P></DD><DD><P>The string list returned for <I>fileList</I> is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFreeStringList>mgFreeStringList</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>Currently the <I>parent</I> parameter is reserved for future enhancement 
and should be specified as <B>None</B>.  For now the dialog is created as a child 
of the main Creator main window. It is not necessary to terminate the argument 
list with <A HREF=#MG_NULL>MG_NULL</A> in Python. It is not necessary to free the string list 
returned for <I>fileList</I> in Python.</P></DD><DD><P>If function is successful, the selected files are returned.</P></DD><DD><P>The following optional input parameters are not supported in 
Python OpenFlight Script:<BR> 
<A HREF=#MPFA_DIALOGFUNC>MPFA_DIALOGFUNC</A><BR> 
<A HREF=#MPFA_DIALOGID>MPFA_DIALOGID</A><BR> 
<A HREF=#MPFA_RESOURCE>MPFA_RESOURCE</A><BR> 
<A HREF=#MPFA_USERDATA>MPFA_USERDATA</A><BR> 
<A HREF=#MPFA_CALLBACKMASK>MPFA_CALLBACKMASK</A><BR> 
<A HREF=#MPFA_PATTERNINDEX>MPFA_PATTERNINDEX</A><BR> 
<A HREF=#MPFA_EXITDIRECTORY>MPFA_EXITDIRECTORY</A></P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>parent</I></DT><DD>the dialog parent to attach the prompt dialog</DD><DT><I>mode</I></DT><DD>an integer value that is either MPFM_OPEN or 
MPFM_SAVE that specifies the mode for the file dialog</DD><DT><I>numFiles</I></DT><DD>a pointer to an integer that holds the number of 
files that have been selected - 
if the user had selected the MPFF_MULTISELECT option, 
then this value can be more than one else it will be 
at most one</DD><DT><I>fileList</I></DT><DD>a pointer to an <A HREF=#mgstringlist>mgstringlist</A> object 
that will be allocated and filled with the names 
of the selected files, <A HREF=#MG_NULL>MG_NULL</A> if no files selected - 
caller should free this list when no longer needed using 
<A HREF=#mgFreeStringList>mgFreeStringList</A></DD><DT><I>...</I></DT><DD>optional input parameter pairs 
(<I>paramKey</I>, <I>paramValue</I>) in variable 
argument style</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgstatus</DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success. 
Success indicates that the file selected was a valid file and the user 
dismissed the dialog using the Open/Save push button.  If function call is 
successful, <I>numFiles</I> contains the number of files that have been selected, 
and <I>fileList</I> contains the selected file name(s), otherwise both are undefined.</DD><DT>numFiles</DT><DD>The number of file names returned.</DD><DT>name1</DT><DD>The first file name returned.</DD><DT>name2</DT><DD>The second file name returned.</DD><DT>...</DT><DD>etc.</DD></DL></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) create a file broswer with 
*.flt and *.txt as filters starting at the initial directory 'C:/gallery/models' 
and with the initial file from that directory 'church.flt'. The title for the dialog 
is 'Open Flight Files or Text Files'. The user is allowed to select multiple files 
and success is returned only if a valid file is selected.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgstatus status;
int numFiles;
mgstringlist fileNames = MG_NULL;

status = mgPromptDialogFile (
   parent, MPFM_OPEN,
   &numFiles,
   &fileNames,
   MPFA_FLAGS, MPFF_FILEMUSTEXIST|MPFF_MULTISELECT,
   MPFA_PATTERN, "OpenFlight Files|*.flt || Text Files|*.txt",
   MPFA_TITLE, "Open Flight Files or Text Files",
   MPFA_DIRECTORY, "C:/gallery/models",
   MPFA_FILENAME, "church.flt",
   MG_NULL);

if (MSTAT_ISOK (status)) {
   mgstringlist fileNameH = fileNames;
   // print the name of each file selected
   while (fileNameH && *fileNameH) {
      char* fileName = *fileNameH;
      printf (fileName);
      fileNameH++;
   }
   // free allocated memory when done with file names
   mgFreeStringList (fileNames);
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">outs = mgPromptDialogFile (
   None, MPFM_OPEN,
   MPFA_FLAGS, MPFF_FILEMUSTEXIST|MPFF_MULTISELECT,
   MPFA_PATTERN, "OpenFlight Files|*.flt || Text Files|*.txt",
   MPFA_TITLE, "Open Flight Files or Text Files",
   MPFA_DIRECTORY, "C:/gallery/models",
   MPFA_FILENAME, "church.flt")

status = outs[0]

if (MSTAT_ISOK (status)):
   numFiles = outs[1]
   fileNames = outs[2:len(outs)]
   for fileName in fileNames:
      print fileName</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPromptDialogFolder>mgPromptDialogFolder</A>, <A HREF=#mgPromptDialogTexture>mgPromptDialogTexture</A></DD></DL>
<HR>
<LEFT><A NAME=mgPromptDialogFloat><H1 CLASS="APISYMBOL">mgPromptDialogFloat</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPromptDialogFloat</B> - prompts the user to enter single 
precision floating point value.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgPromptDialogFloat</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>parent</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>messageText</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>value</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus, number <B>mgPromptDialogFloat</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>parent</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#string>string</A></TD><TD><I>messageText</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>value</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPromptDialogFloat</B> displays a modal dialog in which the 
user is asked to enter a single precision floating point value.</P></DD><DD><P>The dialog displays a text message and contain a text control as well 
as two push button controls - OK and Cancel.  The text control is used 
to enter the numeric value.  The initial value displayed in the text control 
is the numeric value contained in the parameter <I>value</I>. 
The OK and Cancel push button controls are used to dismiss the dialog.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The dialog is created as a child of the specified dialog <I>parent</I>. 
If you specify <I>parent</I> as <A HREF=#MG_NULL>MG_NULL</A>, the dialog is created as a 
child of the Creator main window.  If the user enters a valid numeric 
value and chooses the OK button to dismiss the dialog, the value is returned 
in the parameter <I>value</I>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>Currently the <I>parent</I> parameter is reserved for future enhancement 
and should be specified as <B>None</B>.  For now the dialog is created as a child 
of the main Creator main window.  If the user enters a valid numeric 
value and chooses the OK button to dismiss the dialog, the value is returned.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>parent</I></DT><DD>the dialog parent to attach the prompt dialog</DD><DT><I>messageText</I></DT><DD>a text string that is displayed in the dialog 
as a message to the user</DD><DT><I>value</I></DT><DD>on input, the address of the initial float 
value to display in the text control, on output 
receives the float value entered</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgstatus</DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success. 
Success indicates that the value entered was a valid floating point value 
and the user dismissed the dialog using the OK push button.</DD><DT>number</DT><DD>If function is successful, contains the number entered by the user.</DD></DL></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) prompt the user to enter 
a single precision floating point number (default value 3.0).</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">float number = 3.0f;
mgstatus status = mgPromptDialogFloat (MG_NULL, "Enter Number", &number);
if (MSTAT_ISOK (status)) {
   printf ("Number: %f", number);
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">status,number = mgPromptDialogFloat (None, "Enter Number", 3.0)
if (MSTAT_ISOK (status)):
   print "Number:", number</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPromptDialogString>mgPromptDialogString</A>, <A HREF=#mgPromptDialogInteger>mgPromptDialogInteger</A>, <A HREF=#mgPromptDialogDouble>mgPromptDialogDouble</A></DD></DL>
<HR>
<LEFT><A NAME=mgPromptDialogFolder><H1 CLASS="APISYMBOL">mgPromptDialogFolder</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPromptDialogFolder</B> - prompts the user to select a 
folder using a standard folder browser.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgPromptDialogFolder</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>parent</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>title</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>initialFolderName</I>,</TD></TR>
<TR><TD></TD><TD>char**</TD><TD><I>selectedFolderName</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus, selectedFolderName <B>mgPromptDialogFolder</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>parent</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#string>string</A></TD><TD><I>title</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#string>string</A></TD><TD><I>initialFolderName</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPromptDialogFolder</B> displays a modal dialog in which the 
user is prompted to select a folder.</P></DD><DD><P>The dialog displays the directory structure using a tree control and 
three push button controls - OK, Cancel and New Folder.  The tree control is 
used to select the directory.  The initial folder selected in the tree control 
is specified through the parameter <I>initialFolderName</I>.  The OK and Cancel 
buttons are used to accept and cancel the selected folder, respectively, and 
dismiss the dialog.  The New Folder button is used to create a new folder 
below the currently selected folder in the dialog.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The dialog is created as a child of the specified dialog <I>parent</I>. 
If you specify <I>parent</I> as <A HREF=#MG_NULL>MG_NULL</A>, the dialog is created as a 
child of the Creator main window.  If function is successful, the 
output parameter <I>selectedFolderName</I> contains the corresponding 
folder name, otherwise <I>selectedFolderName</I> is undefined. 
The string returned for <I>selectedFolderName</I> 
is dynamically allocated and must be deallocated by the caller when it 
is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>Currently the <I>parent</I> parameter is reserved for future enhancement 
and should be specified as <B>None</B>.  For now the dialog is created as a child 
of the main Creator main window. It is not necessary to free the string 
returned for <I>selectedFolderName</I> in Python.</P></DD><DD><P>If function is successful, the selected folder is returned. Otherwise 
<I>selectedFolderName</I> will be <B>None</B>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>parent</I></DT><DD>the dialog parent to attach the prompt dialog</DD><DT><I>title</I></DT><DD>the title string for the dialog</DD><DT><I>initialFolderName</I></DT><DD>the initial folder that the user wants to go to</DD><DT><I>selectedFolderName</I></DT><DD>on selection and choosing OK button, this parameter 
contains the selected folder name</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgstatus</DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.  Success 
indicates that the folder selected was a valid folder&#32and the user dismissed 
the dialog using the OK push button.</DD><DT>selectedFolderName</DT><DD>If function is successful, 
contains the folder selected by the user.</DD></DL></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) illustrate the 
use of <B>mgPromptDialogFolder</B> with the initial folder 'C:/gallery/models'.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">char* selectedFolder;
mgstatus status;

status = mgPromptDialogFolder (
   parent, "Choose Folder",
   "C:/gallery/models" &selectedFolder);

if (MSTAT_ISOK (status)) {
   printf ("Selected Folder: %s", selectedFolder);
   // free allocated memory when done with folder
   mgFree (selectedFolder);
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">outs = mgPromptDialogFolder (None,
&#32 "Choose Folder",
&#32 "C:/gallery/models")

status = outs[0]
if (MSTAT_ISOK (status)):
   selectedFolder = outs[1]
   print "Selected Folder:",selectedFolder</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPromptDialogFile>mgPromptDialogFile</A>, <A HREF=#mgPromptDialogTexture>mgPromptDialogTexture</A></DD></DL>
<HR>
<LEFT><A NAME=mgPromptDialogInteger><H1 CLASS="APISYMBOL">mgPromptDialogInteger</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPromptDialogInteger</B> - prompts the user to enter integer value.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgPromptDialogInteger</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>parent</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>messageText</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>value</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus, number <B>mgPromptDialogInteger</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>parent</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#string>string</A></TD><TD><I>messageText</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>value</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPromptDialogInteger</B> displays a modal dialog in which the 
user is asked to enter an integer value.</P></DD><DD><P>The dialog displays a text message and contains a text control and 
two push button controls - OK and Cancel.  The text control is used to control 
the numeric value contained in the parameter <I>value</I>.  The OK and Cancel 
push button controls will be used to dismiss the dialog.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The dialog is created as a child of the specified dialog <I>parent</I>. 
If you specify <I>parent</I> as <A HREF=#MG_NULL>MG_NULL</A>, the dialog is created as a 
child of the Creator main window.  If the user enters a valid numeric 
value and chooses the OK button to dismiss the dialog, the value is returned 
in the parameter <I>value</I>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>Currently the <I>parent</I> parameter is reserved for future enhancement 
and should be specified as <B>None</B>.  For now the dialog is created as a child 
of the main Creator main window.  If the user enters a valid numeric 
value and chooses the OK button to dismiss the dialog, the value is returned.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>parent</I></DT><DD>the dialog parent to attach the prompt dialog</DD><DT><I>messageText</I></DT><DD>a text string that is displayed in the dialog 
as a message to the user</DD><DT><I>value</I></DT><DD>C - on input, the address of the initial integer 
value to display in the text control, on output will receive 
the integer value entered 
<BR>Python - the initial integer value to display in the text control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgstatus</DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success. 
Success indicates that the value entered was a valid integer value 
and the user dismissed the dialog using the OK push button.</DD><DT>number</DT><DD>If function is successful, contains the number entered by the user.</DD></DL></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) prompt the user to enter 
an integer number (default value 2).</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">int number = 2;
mgstatus status = mgPromptDialogInteger (MG_NULL, "Enter Number", &number);
if (MSTAT_ISOK (status)) {
   printf ("Number: %d", number);
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">status,number = mgPromptDialogInteger (None, "Enter Number", 2)
if (MSTAT_ISOK (status)):
   print "Number:", number</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPromptDialogString>mgPromptDialogString</A>, <A HREF=#mgPromptDialogFloat>mgPromptDialogFloat</A>, <A HREF=#mgPromptDialogDouble>mgPromptDialogDouble</A></DD></DL>
<HR>
<LEFT><A NAME=mgPromptDialogString><H1 CLASS="APISYMBOL">mgPromptDialogString</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPromptDialogString</B> - prompts the user to enter string value.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgPromptDialogString</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>parent</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>numColumns</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>messageText</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>value</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maxLen</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus, string <B>mgPromptDialogString</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>parent</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>numColumns</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#string>string</A></TD><TD><I>messageText</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#string>string</A></TD><TD><I>value</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPromptDialogString</B> displays a modal dialog in which the 
user is asked to enter a text string value.</P></DD><DD><P>The dialog displays a text message and contains a text control and 
two push button controls - OK and Cancel.  The text control is wide 
enough to display <I>numColumns</I> characters and initially displays the 
text string contained in the parameter <I>value</I>.  The user enters the 
string value into this text control. The OK and Cancel push button controls 
are used to dismiss the dialog.</P></DD><DD><P>If the user enters a valid string value and chooses the OK button 
to dismiss the dialog, the value is returned in the parameter 
<I>value</I>.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The dialog is created as a child of the specified dialog <I>parent</I>. 
If you specify <I>parent</I> as <A HREF=#MG_NULL>MG_NULL</A>, the dialog is created as a 
child of the Creator main window.  If the user enters a valid string 
value and chooses the OK button to dismiss the dialog, the value is returned 
in the parameter <I>value</I>.  The returned string is truncated and 
null terminated if it is longer than <I>maxLen</I> characters.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>Currently the <I>parent</I> parameter is reserved for future enhancement 
and should be specified as <B>None</B>.  For now the dialog is created as a child 
of the main Creator main window.  If the user enters a valid string 
value and chooses the OK button to dismiss the dialog, the value is returned. 
The return string is limited to 256 characters.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>parent</I></DT><DD>the dialog parent to attach the prompt dialog</DD><DT><I>numColumns</I></DT><DD>number of columns that will be visible in the 
text control</DD><DT><I>messageText</I></DT><DD>a text string that is displayed in the dialog 
as a message to the user</DD><DT><I>value</I></DT><DD>C - on input, the initial text string to display in 
the text control, on output will receive the text entered. 
<BR>Python - the initial string value to display in the text control</DD><DT><I>maxLen</I></DT><DD>the maximum number of characters to store in <I>value</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgstatus</DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success. 
Success indicates that the value entered was a valid string value 
and the user dismissed the dialog using the OK push button.</DD><DT>string</DT><DD>If function 
is successful, <I>value</I> contains the corresponding string, otherwise 
<I>value</I> is undefined.</DD></DL></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) prompt the user to enter 
a string (default value "Default").</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgstatus status;
char outString[100];
strcpy (outString, "Default");
status = mgPromptDialogString (MG_NULL, 20, "Enter String", outString, 100)
if (MSTAT_ISOK (status)) {
   printf ("String: %s", outString);
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">status,outString = mgPromptDialogString (None, 20, "Enter String", "Default")
if (MSTAT_ISOK (status)):
   print "String:", outString</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPromptDialogInteger>mgPromptDialogInteger</A>, <A HREF=#mgPromptDialogFloat>mgPromptDialogFloat</A>, <A HREF=#mgPromptDialogDouble>mgPromptDialogDouble</A></DD></DL>
<HR>
<LEFT><A NAME=mgPromptDialogTexture><H1 CLASS="APISYMBOL">mgPromptDialogTexture</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPromptDialogTexture</B> - prompts the user to select one or 
more texture files using a standard file browser.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgPromptDialogTexture</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>parent</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>mode</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>numFiles</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgstringlist>mgstringlist*</A></TD><TD><I>fileList</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>...</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus, numFiles, name1, name2, ... <B>mgPromptDialogTexture</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>parent</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>mode</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>< paramKey ></I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>< paramValue ></I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>...</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPromptDialogTexture</B> displays a modal dialog in which the 
user is prompted to select one or more texture files.</P></DD><DD><P>The dialog displays the directory structure using a file browser with 
two push buttons Open/Save and Cancel and a texture preview area.  When the 
user selects a texture file in the file browser, the texture preview area 
displays a thumbnail view of the texture and lists some useful information 
(dimensions) about the texture selected.</P></DD><DD><P><B>mgPromptDialogTexture</B> functions very similar to <A HREF=#mgPromptDialogFile>mgPromptDialogFile</A>. 
The main difference is the file browser that is displayed.  As described above, 
the file browser displayed by <B>mgPromptDialogTexture</B> includes a texture preview 
area that is not displayed by <A HREF=#mgPromptDialogFile>mgPromptDialogFile</A>. 
For more information on <B>mgPromptDialogTexture</B>, see <A HREF=#mgPromptDialogFile>mgPromptDialogFile</A>.</P></DD><DD><P>All optional parameters are passed using variable argument style 
and must be terminated with <A HREF=#MG_NULL>MG_NULL</A>.</P></DD><DD><P>Unlike <A HREF=#mgPromptDialogFile>mgPromptDialogFile</A>, <B>mgPromptDialogTexture</B> does not allow 
you to supply a custom dialog.  For that reason, the following optional 
input parameters are not supported for <B>mgPromptDialogTexture</B>:<P>
<A HREF=#MPFA_RESOURCE>MPFA_RESOURCE</A><BR> 
<A HREF=#MPFA_DIALOGID>MPFA_DIALOGID</A><BR> 
<A HREF=#MPFA_DIALOGFUNC>MPFA_DIALOGFUNC</A><BR> 
<A HREF=#MPFA_USERDATA>MPFA_USERDATA</A><BR> 
<A HREF=#MPFA_CALLBACKMASK>MPFA_CALLBACKMASK</A></P></DD><DD><P>If you do not specify the optional parameter <A HREF=#MPFA_PATTERN>MPFA_PATTERN</A>, 
<B>mgPromptDialogTexture</B> will automatically add the standard list of texture 
pattern description-extension pairs supported by Creator.  If you do specify 
<A HREF=#MPFA_PATTERN>MPFA_PATTERN</A>, you can override this default list of extensions with your 
own.  In this case, the list you specify will be the only description-extension 
pairs displayed in the file browser.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string list returned for <I>fileList</I> is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFreeStringList>mgFreeStringList</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>Currently the <I>parent</I> parameter is reserved for future enhancement 
and should be specified as <B>None</B>.  For now the dialog is created as a child 
of the main Creator main window.  It is not necessary to free the string list 
returned for <I>fileList</I> in Python.</P></DD><DD><P>In addition to the custom dialog optional parameters listed above, the 
following optional input parameters are not supported in 
Python OpenFlight Script:<BR> 
<A HREF=#MPFA_PATTERNINDEX>MPFA_PATTERNINDEX</A><BR> 
<A HREF=#MPFA_EXITDIRECTORY>MPFA_EXITDIRECTORY</A></P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>parent</I></DT><DD>the dialog parent to attach the prompt dialog</DD><DT><I>mode</I></DT><DD>an integer value that is either MPFM_OPEN or 
MPFM_SAVE that specifies the mode for the file dialog</DD><DT><I>numFiles</I></DT><DD>a pointer to an integer that holds the number of 
files that have been selected - 
if the user had selected the MPFF_MULTISELECT option, 
then this value can be more than one else it will be 
at most one</DD><DT><I>fileList</I></DT><DD>a pointer to an <A HREF=#mgstringlist>mgstringlist</A> object 
that will be allocated and filled with the names 
of the selected files, <A HREF=#MG_NULL>MG_NULL</A> if no files selected - 
caller should free this list when no longer needed using 
<A HREF=#mgFreeStringList>mgFreeStringList</A></DD><DT><I>...</I></DT><DD>optional input parameters in variable 
argument style</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgstatus</DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success. 
Success indicates that the file selected was a valid file and the user 
dismissed the dialog using the Open/Save push button.  If function call is 
successful, <I>numFiles</I> contains the number of files that have been selected, 
and <I>fileList</I> contains the selected file name(s), otherwise both are undefined.</DD><DT>numFiles</DT><DD>The number of file names returned.</DD><DT>name1</DT><DD>The first file name returned.</DD><DT>name2</DT><DD>The second file name returned.</DD><DT>...</DT><DD>etc.</DD></DL></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>As noted above, this function is similar to <A HREF=#mgPromptDialogFile>mgPromptDialogFile</A>.  See 
<A HREF=#mgPromptDialogFile>mgPromptDialogFile</A> for an example similar to that for using <B>mgPromptDialogTexture</B>.</DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPromptDialogFile>mgPromptDialogFile</A>, <A HREF=#mgPromptDialogFolder>mgPromptDialogFolder</A>, <A HREF=#mgPromptDialogColor>mgPromptDialogColor</A></DD></DL>
<HR>
<LEFT><A NAME=mgPtrArrayAppend><H1 CLASS="APISYMBOL">mgPtrArrayAppend</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPtrArrayAppend</B> - append an item onto a pointer array.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgPtrArrayAppend</B> (</TD><TD><A HREF=#mgptrarray>mgptrarray</A></TD><TD><I>ptrArray</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>item</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPtrArrayAppend</B> appends the specified <I>item</I> to the 
end of the pointer array <I>ptrArray</I>.</P></DD><DD><P>The pointer array is automatically "grown" to accommodate the 
new item.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>ptrArray</I></DT><DD>the pointer array</DD><DT><I>item</I></DT><DD>the item to be appended to the pointer array</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>The length of the array after the item is appended.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewPtrArray>mgNewPtrArray</A>, <A HREF=#mgFreePtrArray>mgFreePtrArray</A>, <A HREF=#mgPtrArrayInsert>mgPtrArrayInsert</A>, 
<A HREF=#mgPtrArrayReplace>mgPtrArrayReplace</A>, <A HREF=#mgPtrArrayGet>mgPtrArrayGet</A>, <A HREF=#mgPtrArrayRemove>mgPtrArrayRemove</A>, 
<A HREF=#mgPtrArrayClear>mgPtrArrayClear</A>, <A HREF=#mgPtrArrayLength>mgPtrArrayLength</A>, <A HREF=#mgPtrArraySort>mgPtrArraySort</A>, 
<A HREF=#mgPtrArraySearch>mgPtrArraySearch</A>, <A HREF=#mgPtrArrayBSearch>mgPtrArrayBSearch</A></DD></DL>
<HR>
<LEFT><A NAME=mgPtrArrayBSearch><H1 CLASS="APISYMBOL">mgPtrArrayBSearch</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPtrArrayBSearch</B> - searches a pointer array for a specific 
item using a binary search.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgPtrArrayBSearch</B> (</TD><TD><A HREF=#mgptrarray>mgptrarray</A></TD><TD><I>ptrArray</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>key</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgptrarraycomparefunc>mgptrarraycomparefunc</A></TD><TD><I>compareFunc</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>pos</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPtrArrayBSearch</B> uses a binary search to locate a specific item 
<I>key</I> in a pointer array <I>ptrArray</I>.</P></DD><DD><P>This function assumes that the pointer array <I>ptrArray</I> is sorted 
according to the comparison function <I>compareFunc</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>ptrArray</I></DT><DD>the pointer array</DD><DT><I>key</I></DT><DD>the item to search for</DD><DT><I>compareFunc</I></DT><DD>the comparison function for 
the items in <I>ptrArray</I></DD><DT><I>pos</I></DT><DD>if function successful, contains 
the index of the item, if function fails, 
contains the index where the item should 
be inserted</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the item was found, otherwise 
<A HREF=#mgbool>MG_FALSE</A>.  If successful, the index where the item was found 
is returned in the output parameter, <I>pos</I>.  If not successful, 
the index where the item should be inserted is returned in <I>pos</I>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewPtrArray>mgNewPtrArray</A>, <A HREF=#mgFreePtrArray>mgFreePtrArray</A>, <A HREF=#mgPtrArrayAppend>mgPtrArrayAppend</A>, 
<A HREF=#mgPtrArrayInsert>mgPtrArrayInsert</A>, <A HREF=#mgPtrArrayReplace>mgPtrArrayReplace</A>, <A HREF=#mgPtrArrayGet>mgPtrArrayGet</A>, 
<A HREF=#mgPtrArrayRemove>mgPtrArrayRemove</A>, <A HREF=#mgPtrArrayLength>mgPtrArrayLength</A>, <A HREF=#mgPtrArraySort>mgPtrArraySort</A>, 
<A HREF=#mgPtrArraySearch>mgPtrArraySearch</A></DD></DL>
<HR>
<LEFT><A NAME=mgPtrArrayClear><H1 CLASS="APISYMBOL">mgPtrArrayClear</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPtrArrayClear</B> - remove all items from a pointer array.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgPtrArrayClear</B> (</TD><TD><A HREF=#mgptrarray>mgptrarray</A></TD><TD><I>ptrArray</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPtrArrayClear</B> removes all items from pointer array <I>ptrArray</I>.</P></DD><DD><P>Note that this function does not free or otherwise affect 
the actual items that were in the array.  If the items were dynamically 
allocated, it is the callers responsibility to deallocate them.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>ptrArray</I></DT><DD>the pointer array</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewPtrArray>mgNewPtrArray</A>, <A HREF=#mgFreePtrArray>mgFreePtrArray</A>, <A HREF=#mgPtrArrayAppend>mgPtrArrayAppend</A>, 
<A HREF=#mgPtrArrayInsert>mgPtrArrayInsert</A>, <A HREF=#mgPtrArrayReplace>mgPtrArrayReplace</A>, <A HREF=#mgPtrArrayRemove>mgPtrArrayRemove</A>, 
<A HREF=#mgPtrArrayGet>mgPtrArrayGet</A>, <A HREF=#mgPtrArrayLength>mgPtrArrayLength</A>, <A HREF=#mgPtrArraySort>mgPtrArraySort</A>, 
<A HREF=#mgPtrArraySearch>mgPtrArraySearch</A>, <A HREF=#mgPtrArrayBSearch>mgPtrArrayBSearch</A></DD></DL>
<HR>
<LEFT><A NAME=mgptrarraycomparefunc><H1 CLASS="APISYMBOL">mgptrarraycomparefunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgptrarraycomparefunc</B> - Pointer Array compare function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int (*<B>mgptrarraycomparefunc</B>) ( <TD>const void* <TD><I>item1Addr</I>, 
<TR><TD></TD><TD>const void* <TD><I>item2Addr</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for pointer array compare functions. 
When you call <A HREF=#mgPtrArraySort>mgPtrArraySort</A>, you provide a function of this 
type to perform the comparisons on the items in your array.</P></DD><DD><P>This function compares two array elements and returns a 
value specifying their relationship.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>item1Addr</I></DT><DD>the address of the first element to compare</DD><DT><I>item2Addr</I></DT><DD>the address of the second element to compare</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Return<BR> 
< 0 - if item pointed to by <I>item1Addrr</I> is less than item pointed to by <I>item2Addr</I><BR> 
0 - if item pointed to by <I>item1Addrr</I> is equal to item pointed to by <I>item2Addr</I><BR> 
> 0 - if item pointed to by <I>item1Addrr</I> is greater than item pointed to by <I>item2Addr</I>
</DD></DL><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPtrArraySort>mgPtrArraySort</A></DD></DL>
<HR>
<LEFT><A NAME=mgPtrArrayGet><H1 CLASS="APISYMBOL">mgPtrArrayGet</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPtrArrayGet</B> - get an item from a pointer array.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void* <B>mgPtrArrayGet</B> (</TD><TD><A HREF=#mgptrarray>mgptrarray</A></TD><TD><I>ptrArray</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>pos</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPtrArrayGet</B> returns the item in pointer array <I>ptrArray</I> 
at position <I>pos</I>.</P></DD><DD><P>The first item in a pointer array is at index 1.  Therefore, 
to get the first item of the array, specify <I>pos</I> as 1. 
To get the item at the end of the array, specify <I>pos</I> as 
the length of the pointer array.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>ptrArray</I></DT><DD>the pointer array</DD><DT><I>pos</I></DT><DD>the position of the item in 
the array to get (in range 1..length)</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>The item at the specified position if successful, <A HREF=#MG_NULL>MG_NULL</A> 
otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewPtrArray>mgNewPtrArray</A>, <A HREF=#mgFreePtrArray>mgFreePtrArray</A>, <A HREF=#mgPtrArrayAppend>mgPtrArrayAppend</A>, 
<A HREF=#mgPtrArrayInsert>mgPtrArrayInsert</A>, <A HREF=#mgPtrArrayReplace>mgPtrArrayReplace</A>, <A HREF=#mgPtrArrayRemove>mgPtrArrayRemove</A>, 
<A HREF=#mgPtrArrayClear>mgPtrArrayClear</A>, <A HREF=#mgPtrArrayLength>mgPtrArrayLength</A>, <A HREF=#mgPtrArraySort>mgPtrArraySort</A>, 
<A HREF=#mgPtrArraySearch>mgPtrArraySearch</A>, <A HREF=#mgPtrArrayBSearch>mgPtrArrayBSearch</A></DD></DL>
<HR>
<LEFT><A NAME=mgPtrArrayInsert><H1 CLASS="APISYMBOL">mgPtrArrayInsert</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPtrArrayInsert</B> - insert an item into a pointer array.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgPtrArrayInsert</B> (</TD><TD><A HREF=#mgptrarray>mgptrarray</A></TD><TD><I>ptrArray</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>pos</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>item</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPtrArrayInsert</B> inserts the specified <I>item</I> into the 
pointer array <I>ptrArray</I> at the position <I>pos</I>.</P></DD><DD><P>This function inserts a new item into the pointer array such 
that the new item, after it is inserted, is at position <I>pos</I>. 
This causes the item that was previously at this position (and all 
items after it) to get shifted up one index.</P></DD><DD><P>The first item in a pointer array is at index 1.  Therefore, 
to insert an item at the beginning of the array, specify <I>pos</I> 
as 1.  To insert an item at the end of the array, specify <I>pos</I> 
as the length of the pointer array plus one (or use 
<A HREF=#mgPtrArrayAppend>mgPtrArrayAppend</A>).</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>ptrArray</I></DT><DD>the pointer array</DD><DT><I>pos</I></DT><DD>the position in array to insert 
the item (in range 1..length+1)</DD><DT><I>item</I></DT><DD>the item to be inserted into the 
pointer array</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewPtrArray>mgNewPtrArray</A>, <A HREF=#mgFreePtrArray>mgFreePtrArray</A>, <A HREF=#mgPtrArrayAppend>mgPtrArrayAppend</A>, 
<A HREF=#mgPtrArrayReplace>mgPtrArrayReplace</A>, <A HREF=#mgPtrArrayGet>mgPtrArrayGet</A>, <A HREF=#mgPtrArrayRemove>mgPtrArrayRemove</A>, 
<A HREF=#mgPtrArrayClear>mgPtrArrayClear</A>, <A HREF=#mgPtrArrayLength>mgPtrArrayLength</A>, <A HREF=#mgPtrArraySort>mgPtrArraySort</A>, 
<A HREF=#mgPtrArraySearch>mgPtrArraySearch</A>, <A HREF=#mgPtrArrayBSearch>mgPtrArrayBSearch</A></DD></DL>
<HR>
<LEFT><A NAME=mgPtrArrayLength><H1 CLASS="APISYMBOL">mgPtrArrayLength</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPtrArrayLength</B> - get the length of a pointer array.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgPtrArrayLength</B> (</TD><TD><A HREF=#mgptrarray>mgptrarray</A></TD><TD><I>ptrArray</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPtrArrayLength</B> returns the number of elements contained in 
the pointer array <I>ptrArray</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>ptrArray</I></DT><DD>the pointer array</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>The length of the pointer array.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewPtrArray>mgNewPtrArray</A>, <A HREF=#mgFreePtrArray>mgFreePtrArray</A>, <A HREF=#mgPtrArrayAppend>mgPtrArrayAppend</A>, 
<A HREF=#mgPtrArrayInsert>mgPtrArrayInsert</A>, <A HREF=#mgPtrArrayReplace>mgPtrArrayReplace</A>, <A HREF=#mgPtrArrayGet>mgPtrArrayGet</A>, 
<A HREF=#mgPtrArrayRemove>mgPtrArrayRemove</A>, <A HREF=#mgPtrArrayClear>mgPtrArrayClear</A>, <A HREF=#mgPtrArraySort>mgPtrArraySort</A>, 
<A HREF=#mgPtrArraySearch>mgPtrArraySearch</A>, <A HREF=#mgPtrArrayBSearch>mgPtrArrayBSearch</A></DD></DL>
<HR>
<LEFT><A NAME=mgPtrArrayRemove><H1 CLASS="APISYMBOL">mgPtrArrayRemove</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPtrArrayRemove</B> - remove an item from a pointer array.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void* <B>mgPtrArrayRemove</B> (</TD><TD><A HREF=#mgptrarray>mgptrarray</A></TD><TD><I>ptrArray</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>pos</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPtrArrayRemove</B> removes the item in pointer array <I>ptrArray</I> 
at position <I>pos</I>.</P></DD><DD><P>Note that this function does not free or otherwise affect the actual 
item that was removed from the array.  If this item was dynamically 
allocated, it is the callers responsibility to deallocate it.</P></DD><DD><P>The first item in a pointer array is at index 1.  Therefore, 
to remove the first item of the array, specify <I>pos</I> as 1. 
To remove the item at the end of the array, specify <I>pos</I> as 
the length of the pointer array.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>ptrArray</I></DT><DD>the pointer array</DD><DT><I>pos</I></DT><DD>the position of the item in 
the array to remove (in range 1..length)</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the item removed from the pointer array, <A HREF=#MG_NULL>MG_NULL</A> if 
item not found.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows how to remove all items from a pointer 
array and deallocate the memory allocated for each.  The items in this 
pointer array are dynamically allocated strings.</DT><DT><PRE CLASS="EXAMPLE">char* thisString;
while (thisString = (char*) mgPtrArrayRemove (ptrArray, 1))
   mgFree (thisString);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewPtrArray>mgNewPtrArray</A>, <A HREF=#mgFreePtrArray>mgFreePtrArray</A>, <A HREF=#mgPtrArrayAppend>mgPtrArrayAppend</A>, 
<A HREF=#mgPtrArrayInsert>mgPtrArrayInsert</A>, <A HREF=#mgPtrArrayReplace>mgPtrArrayReplace</A>, <A HREF=#mgPtrArrayClear>mgPtrArrayClear</A>, 
<A HREF=#mgPtrArrayGet>mgPtrArrayGet</A>, <A HREF=#mgPtrArrayLength>mgPtrArrayLength</A>, <A HREF=#mgPtrArraySort>mgPtrArraySort</A>, 
<A HREF=#mgPtrArraySearch>mgPtrArraySearch</A>, <A HREF=#mgPtrArrayBSearch>mgPtrArrayBSearch</A></DD></DL>
<HR>
<LEFT><A NAME=mgPtrArrayReplace><H1 CLASS="APISYMBOL">mgPtrArrayReplace</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPtrArrayReplace</B> - replace an item in a pointer array.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgPtrArrayReplace</B> (</TD><TD><A HREF=#mgptrarray>mgptrarray</A></TD><TD><I>ptrArray</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>pos</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>item</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPtrArrayReplace</B> replaces the item at position <I>pos</I> in 
the pointer array <I>ptrArray</I> with the specified <I>item</I>.</P></DD><DD><P>The first item in a pointer array is at index 1.  Therefore, 
to replace the first item of the array, specify <I>pos</I> as 1. 
To replace the item at the end of the array, specify <I>pos</I> as 
the length of the pointer array.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>ptrArray</I></DT><DD>the pointer array</DD><DT><I>pos</I></DT><DD>the position of the item in 
the array to replace (in range 
1..length)</DD><DT><I>item</I></DT><DD>the item that is to replace the 
item at <I>pos</I> in the pointer array</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewPtrArray>mgNewPtrArray</A>, <A HREF=#mgFreePtrArray>mgFreePtrArray</A>, <A HREF=#mgPtrArrayAppend>mgPtrArrayAppend</A>, 
<A HREF=#mgPtrArrayInsert>mgPtrArrayInsert</A>, <A HREF=#mgPtrArrayGet>mgPtrArrayGet</A>, <A HREF=#mgPtrArrayRemove>mgPtrArrayRemove</A>, 
<A HREF=#mgPtrArrayClear>mgPtrArrayClear</A>, <A HREF=#mgPtrArrayLength>mgPtrArrayLength</A>, <A HREF=#mgPtrArraySort>mgPtrArraySort</A>, 
<A HREF=#mgPtrArraySearch>mgPtrArraySearch</A>, <A HREF=#mgPtrArrayBSearch>mgPtrArrayBSearch</A></DD></DL>
<HR>
<LEFT><A NAME=mgPtrArraySearch><H1 CLASS="APISYMBOL">mgPtrArraySearch</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPtrArraySearch</B> - searches a pointer array for a specific 
item using a linear search.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgPtrArraySearch</B> (</TD><TD><A HREF=#mgptrarray>mgptrarray</A></TD><TD><I>ptrArray</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>key</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><A HREF=#mgPtrArrayBSearch>mgPtrArrayBSearch</A> uses a linear search to locate a specific item 
<I>key</I> in a pointer array <I>ptrArray</I>.  The linear search starts at the 
item at index 1 and searches the list until the <I>key</I> is found.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>ptrArray</I></DT><DD>the pointer array</DD><DT><I>key</I></DT><DD>the item to search for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>If the <I>key</I> is found, returns the index of the item (which will 
be in the range 1..length of array).  If the <I>key</I> is not found, returns 0.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewPtrArray>mgNewPtrArray</A>, <A HREF=#mgFreePtrArray>mgFreePtrArray</A>, <A HREF=#mgPtrArrayAppend>mgPtrArrayAppend</A>, 
<A HREF=#mgPtrArrayInsert>mgPtrArrayInsert</A>, <A HREF=#mgPtrArrayReplace>mgPtrArrayReplace</A>, <A HREF=#mgPtrArrayGet>mgPtrArrayGet</A>, 
<A HREF=#mgPtrArrayRemove>mgPtrArrayRemove</A>, <A HREF=#mgPtrArrayLength>mgPtrArrayLength</A>, <A HREF=#mgPtrArraySort>mgPtrArraySort</A>, 
<A HREF=#mgPtrArrayBSearch>mgPtrArrayBSearch</A></DD></DL>
<HR>
<LEFT><A NAME=mgPtrArraySort><H1 CLASS="APISYMBOL">mgPtrArraySort</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPtrArraySort</B> - sort the contents of a pointer array.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgPtrArraySort</B> (</TD><TD><A HREF=#mgptrarray>mgptrarray</A></TD><TD><I>ptrArray</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgptrarraycomparefunc>mgptrarraycomparefunc</A></TD><TD><I>compareFunc</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPtrArraySort</B> reorders the elements of a pointer array <I>ptrArray</I> 
according to the specified compare function <I>compareFunc</I>.</P></DD><DD><P>The <I>compareFunc</I> is a function that compares two array elements and 
returns a value specifying their relationship.  <B>mgPtrArraySort</B> calls the 
compare function one or more times during the sort, passing pointers to two 
array elements on each call: 
<PRE CLASS="EXAMPLE">*(compareFunc) (const void* item1Addr, const void* item1Addr)</PRE></P></DD><DD><P>The compare function compares the elements and returns:<BR> 
< 0 - if item pointed to by <I>item1Addrr</I> is less than item pointed to by <I>item2Addr</I><BR> 
0 - if item pointed to by <I>item1Addrr</I> is equal to item pointed to by <I>item2Addr</I><BR> 
> 0 - if item pointed to by <I>item1Addrr</I> is greater than item pointed to by <I>item2Addr</I></P></DD><DD><P>This describes a sort in ascending order.  To sort an array in descending 
order, reverse the sense of "greater than" and "less than" in the comparison 
function.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>ptrArray</I></DT><DD>the pointer array</DD><DT><I>compareFunc</I></DT><DD>the comparison function for 
the items in <I>ptrArray</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>The length of the pointer array.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">static int CompareNames (const void* item1Addr, const void* item2Addr)
{
   // Note the indirection required to get to the actual items in the
   // array.  The parameters item1Addr and item2Addr are pointers to
   // the items you loaded into the array, in this case, they are
   // pointers to char*

   char* name1 = *((char**) item1Addr);
   char* name2 = *((char**) item2Addr);
   return strcmp (name1, name2);
}

char name1[20] = "Yet Another Name";
char name2[20] = "Another Name";
char name3[20] = "A Name";

mgptrarray array = mgNewPtrArray ();
mgPtrArrayAppend (array, name1);
mgPtrArrayAppend (array, name2);
mgPtrArrayAppend (array, name3);

// before... order of items in array:
// "Yet Another Name"
// "Another Name"
// "A Name"

mgPtrArraySort (array, CompareNames);

// after... order of items in array:
// "A Name"
// "Another Name"
// "Yet Another Name"</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewPtrArray>mgNewPtrArray</A>, <A HREF=#mgFreePtrArray>mgFreePtrArray</A>, <A HREF=#mgPtrArrayAppend>mgPtrArrayAppend</A>, 
<A HREF=#mgPtrArrayInsert>mgPtrArrayInsert</A>, <A HREF=#mgPtrArrayReplace>mgPtrArrayReplace</A>, <A HREF=#mgPtrArrayGet>mgPtrArrayGet</A>, 
<A HREF=#mgPtrArrayRemove>mgPtrArrayRemove</A>, <A HREF=#mgPtrArrayLength>mgPtrArrayLength</A>, <A HREF=#mgPtrArraySearch>mgPtrArraySearch</A>, 
<A HREF=#mgPtrArrayBSearch>mgPtrArrayBSearch</A></DD></DL>
<HR>
<LEFT><A NAME=mgPtrStackClear><H1 CLASS="APISYMBOL">mgPtrStackClear</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPtrStackClear</B> - pops all items off a pointer stack.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgPtrStackClear</B> (</TD><TD><A HREF=#mgptrstack>mgptrstack</A></TD><TD><I>ptrStack</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPtrStackClear</B> pops all items off the pointer stack 
<I>ptrStack</I>.</P></DD><DD><P>Note that this function does not free or otherwise affect 
the actual items that were in the stack.  If the items were dynamically 
allocated, it is the callers responsibility to deallocate them.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>ptrStack</I></DT><DD>the pointer stack</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewPtrStack>mgNewPtrStack</A>, <A HREF=#mgFreePtrStack>mgFreePtrStack</A>, 
<A HREF=#mgPtrStackPush>mgPtrStackPush</A>, <A HREF=#mgPtrStackPop>mgPtrStackPop</A>, 
<A HREF=#mgPtrStackTop>mgPtrStackTop</A>, <A HREF=#mgPtrStackLength>mgPtrStackLength</A></DD></DL>
<HR>
<LEFT><A NAME=mgPtrStackLength><H1 CLASS="APISYMBOL">mgPtrStackLength</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPtrStackLength</B> - get the length of a pointer length.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgPtrStackLength</B> (</TD><TD><A HREF=#mgptrstack>mgptrstack</A></TD><TD><I>ptrStack</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPtrStackLength</B> returns the number of items contained in 
the pointer stack <I>ptrStack</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>ptrStack</I></DT><DD>the pointer stack</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the length (or size) of the pointer stack.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewPtrStack>mgNewPtrStack</A>, <A HREF=#mgFreePtrStack>mgFreePtrStack</A>, 
<A HREF=#mgPtrStackPush>mgPtrStackPush</A>, <A HREF=#mgPtrStackPop>mgPtrStackPop</A>, <A HREF=#mgPtrStackClear>mgPtrStackClear</A>, 
<A HREF=#mgPtrStackTop>mgPtrStackTop</A>,</DD></DL>
<HR>
<LEFT><A NAME=mgPtrStackPop><H1 CLASS="APISYMBOL">mgPtrStackPop</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPtrStackPop</B> - pops an item off the top of a pointer stack.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void* <B>mgPtrStackPop</B> (</TD><TD><A HREF=#mgptrstack>mgptrstack</A></TD><TD><I>ptrStack</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPtrStackPop</B> pops an item off the top of the pointer stack 
<I>ptrStack</I> and returns that item.</P></DD><DD><P>Note that this function does not free or otherwise affect the actual 
item that was popped from the stack.  If this item was dynamically 
allocated, it is the callers responsibility to deallocate it.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>ptrStack</I></DT><DD>the pointer stack</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the item that was at the top of the stack before it was popped off, 
<A HREF=#MG_NULL>MG_NULL</A> if stack is empty.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows how to pop all items from a pointer 
stack and deallocate the memory allocated for each.  The items in this 
pointer stack are dynamically allocated strings.</DT><DT><PRE CLASS="EXAMPLE">char* thisString;
while (thisString = (char*) mgPtrStackPop (ptrStack))
   mgFree (thisString);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewPtrStack>mgNewPtrStack</A>, <A HREF=#mgFreePtrStack>mgFreePtrStack</A>, 
<A HREF=#mgPtrStackPush>mgPtrStackPush</A>, <A HREF=#mgPtrStackClear>mgPtrStackClear</A>, 
<A HREF=#mgPtrStackTop>mgPtrStackTop</A>, <A HREF=#mgPtrStackLength>mgPtrStackLength</A></DD></DL>
<HR>
<LEFT><A NAME=mgPtrStackPush><H1 CLASS="APISYMBOL">mgPtrStackPush</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPtrStackPush</B> - push an item onto a pointer stack.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgPtrStackPush</B> (</TD><TD><A HREF=#mgptrstack>mgptrstack</A></TD><TD><I>ptrStack</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>item</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPtrStackAppend</B> pushes the specified <I>item</I> onto the 
stack <I>ptrStack</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>ptrStack</I></DT><DD>the pointer stack</DD><DT><I>item</I></DT><DD>the item to be pushed onto the pointer stack</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of items in the stack after the item is pushed.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewPtrStack>mgNewPtrStack</A>, <A HREF=#mgFreePtrStack>mgFreePtrStack</A>, 
<A HREF=#mgPtrStackPop>mgPtrStackPop</A>, <A HREF=#mgPtrStackClear>mgPtrStackClear</A>, 
<A HREF=#mgPtrStackTop>mgPtrStackTop</A>, <A HREF=#mgPtrStackLength>mgPtrStackLength</A></DD></DL>
<HR>
<LEFT><A NAME=mgPtrStackTop><H1 CLASS="APISYMBOL">mgPtrStackTop</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPtrStackTop</B> - returns the item on top of a pointer stack.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void* <B>mgPtrStackTop</B> (</TD><TD><A HREF=#mgptrstack>mgptrstack</A></TD><TD><I>ptrStack</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPtrStackTop</B> gets the item on top of the pointer stack 
<I>ptrStack</I> and returns that item.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>ptrStack</I></DT><DD>the pointer stack</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the item that is currently at the top of the stack, 
<A HREF=#MG_NULL>MG_NULL</A> if stack is empty.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewPtrStack>mgNewPtrStack</A>, <A HREF=#mgFreePtrStack>mgFreePtrStack</A>, 
<A HREF=#mgPtrStackPush>mgPtrStackPush</A>, <A HREF=#mgPtrStackPop>mgPtrStackPop</A>, <A HREF=#mgPtrStackClear>mgPtrStackClear</A>, 
<A HREF=#mgPtrStackLength>mgPtrStackLength</A></DD></DL>
<HR>
<LEFT><A NAME=mgPurgeTextures><H1 CLASS="APISYMBOL">mgPurgeTextures</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgPurgeTextures</B> - purges the OpenFlight API texture cache.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> void <B>mgPurgeTextures</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgPurgeTextures</B> purges the texture cache used by the OpenFlight API 
to store information about recently open texture files.</P></DD><DD><P>The OpenFlight API maintains a texture cache containing information 
about all the textures referenced by any database that has ever been open. 
It does this during the Creator modeling session as well as during the lifetime 
of your stand-alone application.  If you open multiple databases that each 
reference the same "texture set", this cache can reduce the time it takes 
a database to open as textures referenced (that are already in the cache) 
will not have to be re-loaded when the database is loaded.</P></DD><DD><P>While this cache can help reduce database "load time", as the cache 
gets larger and larger, it takes up more and more memory.  This can eventually 
degrade performance and may cause Creator or your stand-alone application 
to run out of memory.</P></DD><DD><P>To address this problem, your stand-alone application can call 
<B>mgPurgeTextures</B> periodically to clear the texture cache and effectively 
reclaim the memory associated with it.</P></DD><DD><P>Note: You can only call this from your stand-alone application and not 
from a plug-in.  The user has control of the texture cache in Creator and decides 
if and when it is cleared during the modeling session.  Furthermore, when used 
in your stand-alone application, you can only call <B>mgPurgeTextures</B> when no 
databases are currently open.  If you call this function when one or more 
databases are open, it will do nothing.</P></DD></DT></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example processes several databases.  It purges the texture 
cache as it is done processing each database.</DT><DT><PRE CLASS="EXAMPLE">mgrec* db;
mgbool moreFiles = MG_TRUE;
while (moreFiles == MG_TRUE)
{
   const char* nextFile = GetNextFileToProcess ();
   if (nextFile == NULL) {
      moreFiles = MG_FALSE;
   }
   else {
      db = mgOpenDb (nextFile);

      // do something with this database, then write and close it

      mgWriteDb (db);
      mgCloseDb (db);

      // purge the texture cache
      mgPurgeTextures ();
   }
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=mgReadColorPalette><H1 CLASS="APISYMBOL">mgReadColorPalette</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgReadColorPalette</B> - loads a database&#146s color palette 
from a file.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgReadColorPalette</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fileName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgReadColorPalette</B> loads the color palette for database <I>db</I> 
from a file named <I>fileName</I>.  The palette entries 
for <I>db</I> are replaced by those read from <I>fileName</I>.</P></DD><DD><P>The file <I>fileName</I> was created by <A HREF=#mgWriteColorPalette>mgWriteColorPalette</A>, 
<A HREF=#mgWriteDefaultColorPalette>mgWriteDefaultColorPalette</A> or via the Save Palette command in the 
color palette in Creator.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>fileName</I></DT><DD>the color file name</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadDefaultColorPalette>mgReadDefaultColorPalette</A>, <A HREF=#mgWriteDefaultColorPalette>mgWriteDefaultColorPalette</A></DD></DL>
<HR>
<LEFT><A NAME=mgReadDefaultColorPalette><H1 CLASS="APISYMBOL">mgReadDefaultColorPalette</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgReadDefaultColorPalette</B> - loads the default color palette 
from a file.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgReadDefaultColorPalette</B> (</TD><TD>const char*</TD><TD><I>fileName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgReadDefaultColorPalette</B> loads the default color palette 
from a file named <I>fileName</I>.</P></DD><DD><P>The file <I>fileName</I> was created by <A HREF=#mgWriteColorPalette>mgWriteColorPalette</A>, 
<A HREF=#mgWriteDefaultColorPalette>mgWriteDefaultColorPalette</A> or via the Save Palette command in the 
color palette in Creator.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>fileName</I></DT><DD>the color file name</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadColorPalette>mgReadColorPalette</A>, <A HREF=#mgWriteDefaultColorPalette>mgWriteDefaultColorPalette</A></DD></DL>
<HR>
<LEFT><A NAME=mgReadImage><H1 CLASS="APISYMBOL">mgReadImage</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgReadImage</B> - reads an image from disk.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgReadImage</B> (</TD><TD>const char*</TD><TD><I>textureName</I>,</TD></TR>
<TR><TD></TD><TD>unsigned char**</TD><TD><I>pixels</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>type</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>width</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>height</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>status, pixels, type, width, height <B>mgReadImage</B> (</TD><TD><A HREF=#string>string</A></TD><TD><I>textureName</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given an image file name, <B>mgReadImage</B> allocates a pixel array 
to hold the texels of the image, reads the image from disk into the pixel 
array allocated and returns information about the image read.</P></DD><DD><P>It is the responsibility of the caller to deallocate 
the <I>pixels</I> returned when they are no longer needed using 
the function <A HREF=#mgFree>mgFree</A>.</P></DD><DD><P>The image <I>pixels</I>, <I>type</I>, <I>width</I> and <I>height</I> are 
returned through arguments.</P></DD><DD><P>The memory layout for <I>pixels</I> is described here: 
<TABLE CLASS="SIMPLE">
 
<TR CLASS="HEADER">
 
<TD CLASS="BORDER">
 Image Type </TD>
 
<TD CLASS="BORDER">
 Memory Layout </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#MIMG_INT>MIMG_INT</A> </TD>
 
<TD CLASS="BORDER">
 These are single band grayscale images. A texel value of 0 is 
black and a value of 255 is white. The texels are stored in a 
contiguous array with the origin (texel 0, 0) in the lower-left 
corner of the image. </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#MIMG_INTA>MIMG_INTA</A> </TD>
 
<TD CLASS="BORDER">
 These are two-band grayscale images with an alpha 
(transparency) channel. In the intensity channel, a texel value of 
0 is black and a value of 255 is white. In the alpha channel, a 
texel value of 0 is transparent and a value of 255 is opaque. 
Texels are stored in a contiguous array with the origin (texel 0, 
0) in the lower-left corner of the image. All the intensity values 
are stored contiguously, followed by all the alpha values. </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#MIMG_RGB>MIMG_RGB</A> </TD>
 
<TD CLASS="BORDER">
 These are three-band color (Red, Green, Blue) images. The 
intensity of each color component for a texel value of 0 is 
black; a value of 255 is full intensity. Texels are stored in a 
contiguous array with the origin (texel 0, 0) in the lower-left 
corner of the image. All the red values are stored contiguously, 
followed by all the green values, followed by all the blue 
values. </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#MIMG_RGBA>MIMG_RGBA</A> </TD>
 
<TD CLASS="BORDER">
 These are three-band color (Red, Green, Blue) images with an 
alpha (transparency) channel. The intensity of each color 
component for a texel value of 0 is black; 255 is full intensity. 
In the alpha channel, a texel value of 0 is transparent and a 
value of 255 is opaque. The texels are stored in a contiguous 
array with the origin (texel 0, 0) in the lower-left corner of the 
image. For this image type the components are interleaved (all 
four components of each texel are stored contiguously in 
RGBA order). For example, the first four texels in an image 
would be stored as RGBARGBARGBARGBA. </TD>
 
</TR>
 
</TABLE>
</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>textureName</I></DT><DD>the name of the image file on disk</DD><DT><I>pixels</I></DT><DD>address of pixels read from disk</DD><DT><I>type</I></DT><DD>address of value to receive image type, 
possible values returned are <A HREF=#MIMG_INT>MIMG_INT</A>, 
<A HREF=#MIMG_INTA>MIMG_INTA</A>, <A HREF=#MIMG_RGB>MIMG_RGB</A>, and <A HREF=#MIMG_RGBA>MIMG_RGBA</A></DD><DT><I>width</I></DT><DD>address of value to receive image width</DD><DT><I>height</I></DT><DD>address of value to receive image height</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>status</DT><DD>Returns <A HREF=#MIMG_NO_ERROR>MIMG_NO_ERROR</A> if successful, otherwise applicable 
texture error code.</DD><DT>pixels</DT><DD>pixels read from disk.</DD><DT>type</DT><DD>image type - possible values returned are <A HREF=#MIMG_INT>MIMG_INT</A>, 
<A HREF=#MIMG_INTA>MIMG_INTA</A>, <A HREF=#MIMG_RGB>MIMG_RGB</A>, and <A HREF=#MIMG_RGBA>MIMG_RGBA</A></DD><DT>width</DT><DD>image width.</DD><DT>height</DT><DD>image height.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWriteImage>mgWriteImage</A>, <A HREF=#mgReadImageHeader>mgReadImageHeader</A>, <A HREF=#mgReadTexture>mgReadTexture</A>, 
<A HREF=#mgInsertTexture>mgInsertTexture</A>, <A HREF=#mgFree>mgFree</A></DD></DL>
<HR>
<LEFT><A NAME=mgReadImageAttributes><H1 CLASS="APISYMBOL">mgReadImageAttributes</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgReadImageAttributes</B> - reads an image's attribute file from disk.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgReadImageAttributes</B> (</TD><TD>const char*</TD><TD><I>textureName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgReadImageAttributes</B> reads an image's attribute file from disk and returns 
the data in an attributes record.  The <I>textureName</I> passed to this function 
is the name of the image file.  The attributes file name is <I>textureName</I> 
appended with ".attr".</P></DD><DD><P>The record returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgDelete>mgDelete</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>textureName</I></DT><DD>the name of the image on disk</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the image attributes record if successful, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadImage>mgReadImage</A>, <A HREF=#mgWriteImageAttributes>mgWriteImageAttributes</A>, <A HREF=#mgGetTextureAttributes>mgGetTextureAttributes</A>, 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltImage>fltImage</A>
</DD></DL>
<HR>
<LEFT><A NAME=mgReadImageGeoInfo><H1 CLASS="APISYMBOL">mgReadImageGeoInfo</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgReadImageGeoInfo</B> - reads the georeference information 
from an image file.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgReadImageGeoInfo</B> (</TD><TD>const char*</TD><TD><I>textureName</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgimagegeoinfo>mgimagegeoinfo*</A></TD><TD><I>geoInfo</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus, geoInfo <B>mgReadImageGeoInfo</B> (</TD><TD><A HREF=#string>string</A></TD><TD><I>textureName</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgReadImageGeoInfo</B> reads the georeference information of an 
image on disk and returns a georeference info object containing the 
information read.  The parameter <I>textureName</I> is the name of the image file.</P></DD><DD><P>This function reads georeference information from the image 
file itself, not the image attribute file.  This implies that the 
file must contain georeference information for this function to 
succeed.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>When you are through with the returned georeference info object, 
you must free it by calling <A HREF=#mgFreeImageGeoInfo>mgFreeImageGeoInfo</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned georeference info object in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>textureName</I></DT><DD>the name of the image file</DD><DT><I>geoInfo</I></DT><DD>address of object to receive 
georeference info object allocated 
and filled</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgstatus</DT><DD><A HREF=#MIMG_NO_ERROR>MIMG_NO_ERROR</A> if successful, otherwise applicable 
texture error code.</DD><DT>geoInfo</DT><DD>If function is successful, geoInfo contains the georeference 
info object, otherwise geoInfo is undefined.</DD></DL></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) illustrate the 
use of <B>mgReadImageGeoInfo</B> to read and examine a georeference info object 
for a georeferenced texture.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">int imgError;
mgimagegeoinfo info = MG_NULL;
imgError = mgReadImageGeoInfo ("c:/MyTextures/TrueMarble.16km.2700x1350.tif", &info);
if (imgError == MIMG_NO_ERROR)
{
   mgbool ok;
   int type, projection, earthModel;
   ok = mgGetTextureGeoType (info, &type);
   if (ok == MG_TRUE)
      printf ("Type: %d&#92;n", type);
   ok = mgGetTextureGeoProjection (info, &projection);
   if (ok == MG_TRUE)
      printf ("Projection: %d&#92;n", projection);
   ok = mgGetTextureGeoEarthModel (info, &earthModel);
   if (ok == MG_TRUE)
      printf ("Earth Model: %d&#92;n", earthModel);
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">imgError, info = mgReadImageGeoInfo ("c:/MyTextures/TrueMarble.16km.2700x1350.tif")
if (imgError == MIMG_NO_ERROR):
   ok, type = mgGetTextureGeoType (info)
   if (ok == MG_TRUE):
      print "Type:", type
   ok, projection = mgGetTextureGeoProjection (info)
   if (ok == MG_TRUE):
      print "Projection:", projection
   b, earthModel = mgGetTextureGeoEarthModel (info)
   if (ok == MG_TRUE):
      print "Earth Model:", earthModel</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetTextureGeoType>mgGetTextureGeoType</A>, <A HREF=#mgGetTextureGeoProjection>mgGetTextureGeoProjection</A>, 
<A HREF=#mgGetTextureGeoEarthModel>mgGetTextureGeoEarthModel</A>, <A HREF=#mgGetTextureGeoUTMZone>mgGetTextureGeoUTMZone</A>, 
<A HREF=#mgGetTextureGeoUTMHemisphere>mgGetTextureGeoUTMHemisphere</A>, <A HREF=#mgGetTextureGeoImageOrigin>mgGetTextureGeoImageOrigin</A>, 
<A HREF=#mgGetTextureGeoNumCtlPts>mgGetTextureGeoNumCtlPts</A>, <A HREF=#mgGetTextureGeoCtlPt>mgGetTextureGeoCtlPt</A>, 
<A HREF=#mgFreeImageGeoInfo>mgFreeImageGeoInfo</A>, <A HREF=#mgReadImageInfo>mgReadImageInfo</A></DD></DL>
<HR>
<LEFT><A NAME=mgReadImageHeader><H1 CLASS="APISYMBOL">mgReadImageHeader</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgReadImageHeader</B> - reads the header information from an image file.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgReadImageHeader</B> (</TD><TD>const char*</TD><TD><I>textureName</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>type</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>width</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>height</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>status, type, width, height <B>mgReadImageHeader</B> (</TD><TD><A HREF=#string>string</A></TD><TD><I>textureName</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgReadImageHeader</B> reads the header information of an image from the 
specified file <I>textureName</I>.  The header information is returned in 
<I>type</I>, <I>width</I> and <I>height</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>textureName</I></DT><DD>the name of the image file on disk</DD><DT><I>type</I></DT><DD>address of value to receive image type 
Possible values returned are <A HREF=#MIMG_INT>MIMG_INT</A>, 
<A HREF=#MIMG_INTA>MIMG_INTA</A>, <A HREF=#MIMG_RGB>MIMG_RGB</A>, and <A HREF=#MIMG_RGBA>MIMG_RGBA</A></DD><DT><I>width</I></DT><DD>address of value to receive image width</DD><DT><I>height</I></DT><DD>address of value to receive image height</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>status</DT><DD>Returns <A HREF=#MIMG_NO_ERROR>MIMG_NO_ERROR</A> if successful, otherwise applicable 
texture error code.</DD><DT>type</DT><DD>image type - possible values returned are <A HREF=#MIMG_INT>MIMG_INT</A>, 
<A HREF=#MIMG_INTA>MIMG_INTA</A>, <A HREF=#MIMG_RGB>MIMG_RGB</A>, and <A HREF=#MIMG_RGBA>MIMG_RGBA</A>.</DD><DT>width</DT><DD>image width.</DD><DT>height</DT><DD>image height.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadImage>mgReadImage</A>, <A HREF=#mgWriteImage>mgWriteImage</A></DD></DL>
<HR>
<LEFT><A NAME=mgReadImageInfo><H1 CLASS="APISYMBOL">mgReadImageInfo</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgReadImageInfo</B> - reads the header information from 
an image file.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgReadImageInfo</B> (</TD><TD>const char*</TD><TD><I>textureName</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgimageinfo>mgimageinfo*</A></TD><TD><I>textureInfo</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus, textureInfo <B>mgReadImageInfo</B> (</TD><TD><A HREF=#string>string</A></TD><TD><I>textureName</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgReadImageInfo</B> reads the header of an image on disk and 
returns an image info object containing the information read. 
The parameter <I>textureName</I> is the name of the image file.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>When you are through with the returned image info object, you 
must free it by calling <A HREF=#mgFreeImageInfo>mgFreeImageInfo</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned image info object in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>textureName</I></DT><DD>the name of the image file</DD><DT><I>textureInfo</I></DT><DD>address of object to receive image 
info object allocated and filled</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgstatus</DT><DD><A HREF=#MIMG_NO_ERROR>MIMG_NO_ERROR</A> if successful, otherwise applicable 
texture error code.</DD><DT>textureInfo</DT><DD>If function is successful, textureInfo contains the image 
info object, otherwise textureInfo is undefined.</DD></DL></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) illustrate the 
use of <B>mgReadImageInfo</B> to read and examine an image info object 
for a texture.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">int imgError;
mgimageinfo info = MG_NULL;
imgError = mgReadImageInfo ("c:/MyTextures/ah6.rgb", &info);
if (imgError == MIMG_NO_ERROR)
{
   mgbool ok;
   int width, height, type;
   ok = mgGetTextureWidth (info, &width);
   if (ok == MG_TRUE)
      printf ("Width: %d&#92;n", width);
   ok = mgGetTextureHeight (info, &height);
   if (ok == MG_TRUE)
      printf ("Height: %d&#92;n", height);
   ok = mgGetTextureType (info, &type);
   if (ok == MG_TRUE)
      printf ("Type: %d&#92;n", type);
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">imgError, info = mgReadImageInfo ("c:/MyTextures/ah6.rgb")
if (imgError == MIMG_NO_ERROR):
   ok, width = mgGetTextureWidth (info)
   if (ok == MG_TRUE):
      print "Width:", width
   ok, height = mgGetTextureHeight (info)
   if (ok == MG_TRUE):
      print "Height:", height
   ok, type = mgGetTextureType (info)
   if (ok == MG_TRUE):
      print "Type:", type</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewImageInfo>mgNewImageInfo</A>, <A HREF=#mgGetTextureWidth>mgGetTextureWidth</A>, <A HREF=#mgGetTextureHeight>mgGetTextureHeight</A>, 
<A HREF=#mgGetTextureType>mgGetTextureType</A>, <A HREF=#mgGetTextureSampleSize>mgGetTextureSampleSize</A>, <A HREF=#mgGetTextureTiledFlag>mgGetTextureTiledFlag</A>, 
<A HREF=#mgGetTextureMinMax>mgGetTextureMinMax</A>, <A HREF=#mgHasTextureTransparentValue>mgHasTextureTransparentValue</A>, 
<A HREF=#mgGetTextureTransparentValue>mgGetTextureTransparentValue</A>, <A HREF=#mgGetTextureSignedFlag>mgGetTextureSignedFlag</A>, 
<A HREF=#mgFreeImageInfo>mgFreeImageInfo</A>, <A HREF=#mgReadImageGeoInfo>mgReadImageGeoInfo</A></DD></DL>
<HR>
<LEFT><A NAME=mgReadLightPointFile><H1 CLASS="APISYMBOL">mgReadLightPointFile</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgReadLightPointFile</B> - loads a database's light point 
appearance and animation palettes from a file.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgReadLightPointFile</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fileName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgReadLightPointFile</B> loads the light point appearance and 
animation palettes for database <I>db</I> from a file named <I>fileName</I>. 
The palette entries for <I>db</I> are replaced by those read from <I>fileName</I>.</P></DD><DD><P>The file <I>fileName</I> was created by <A HREF=#mgWriteLightPointFile>mgWriteLightPointFile</A>, 
or via the Save Palette command in the light point palette in Creator.</P></DD><DD><P>Existing light point palette records become invalid.</P></DD><DD><P>Note that even though the light point appearance and animation palettes 
are really separate, this function, as well as <A HREF=#mgWriteLightPointFile>mgWriteLightPointFile</A> groups 
the entries in both into one single file.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>fileName</I></DT><DD>the light point file name</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWriteLightPointFile>mgWriteLightPointFile</A></DD></DL>
<HR>
<LEFT><A NAME=mgReadLightSourceFile><H1 CLASS="APISYMBOL">mgReadLightSourceFile</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgReadLightSourceFile</B> - loads a database's light source 
palette from a file.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgReadLightSourceFile</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fileName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgReadLightSourceFile</B> loads the light source palette for 
database <I>db</I> from a file named <I>fileName</I>.  The palette entries 
for <I>db</I> are replaced by those read from <I>fileName</I>.</P></DD><DD><P>The file <I>fileName</I> was created by <A HREF=#mgWriteLightSourceFile>mgWriteLightSourceFile</A>, 
or via the Save Palette command in the light source palette in Creator.</P></DD><DD><P>Existing light source palette records become invalid.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>fileName</I></DT><DD>the light source file name</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWriteLightSourceFile>mgWriteLightSourceFile</A></DD></DL>
<HR>
<LEFT><A NAME=mgReadMaterialFile><H1 CLASS="APISYMBOL">mgReadMaterialFile</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgReadMaterialFile</B> - loads a database's material 
palette from a file.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgReadMaterialFile</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fileName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgReadMaterialFile</B> loads the material palette for 
database <I>db</I> from a file named <I>fileName</I>.  The palette entries 
for <I>db</I> are replaced by those read from <I>fileName</I>.</P></DD><DD><P>The file <I>fileName</I> was created by <A HREF=#mgWriteMaterialFile>mgWriteMaterialFile</A>, 
or via the Save Palette command in the material palette in Creator. 
This function can read material files that contain extended material palette 
entries (OpenFlight version 16.3 and beyond) or standard material palette 
entries (OpenFlight 16.2 and earlier).</P></DD><DD><P>Existing material palette records become invalid.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>fileName</I></DT><DD>the material file name</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWriteMaterialFile>mgWriteMaterialFile</A></DD></DL>
<HR>
<LEFT><A NAME=mgReadTexture><H1 CLASS="APISYMBOL">mgReadTexture</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgReadTexture</B> - loads a texture and creates a new entry 
in a database's texture palette at a specified location and index.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgReadTexture</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>textureName</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>y</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgReadTexture</B> loads a texture (image and attributes) into the 
palette of the specified database <I>db</I>.  The palette entry is loaded 
at the specified <I>index</I> and lower left hand location <I>x</I>, <I>y</I>.</P></DD><DD><P>The attributes are read from the file specified by the texture 
file name appended with ".attr".  If there is no attributes file, default 
attributes are assigned.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>textureName</I></DT><DD>the name of the texture file on disk</DD><DT><I>index</I></DT><DD>the index to assign to the texture 
palette entry created</DD><DT><I>x</I></DT><DD>the x position of the texture in the 
palette (in pixels)</DD><DT><I>y</I></DT><DD>the y position of the texture in the 
palette (in pixels)</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the image is read successfully, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadTextureAndAlpha>mgReadTextureAndAlpha</A>, <A HREF=#mgInsertTexture>mgInsertTexture</A>, <A HREF=#mgInsertTextureAndAlpha>mgInsertTextureAndAlpha</A>, 
<A HREF=#mgWriteTexture>mgWriteTexture</A>, <A HREF=#mgReadImage>mgReadImage</A>, <A HREF=#mgGetTexturePosition>mgGetTexturePosition</A>, <A HREF=#mgSetTexturePosition>mgSetTexturePosition</A></DD></DL>
<HR>
<LEFT><A NAME=mgReadTextureAndAlpha><H1 CLASS="APISYMBOL">mgReadTextureAndAlpha</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgReadTextureAndAlpha</B> - loads a texture and alpha mask as a 
single texture palette entry at a specified location and index.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgReadTextureAndAlpha</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>textureName</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>alphaName</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>mergeName</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>y</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgReadTextureAndAlpha</B> loads a texture and alpha mask from files 
<I>textureName</I> and <I>alphaName</I>, respectively, into the texture 
palette for database <I>db</I>.  The palette entry is loaded 
at the specified <I>index</I> and lower left hand location <I>x</I>, <I>y</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>textureName</I></DT><DD>the name of the texture file on disk</DD><DT><I>alphaName</I></DT><DD>the name of the alpha mask file on disk</DD><DT><I>mergeName</I></DT><DD>the name to associate with the merged 
texture in the palette</DD><DT><I>index</I></DT><DD>the index to assign to the texture 
palette entry created</DD><DT><I>x</I></DT><DD>the x position of the texture in the 
palette (in pixels)</DD><DT><I>y</I></DT><DD>the y position of the texture in the 
palette (in pixels)</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the image is read successfully, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadTexture>mgReadTexture</A>, <A HREF=#mgInsertTexture>mgInsertTexture</A>, <A HREF=#mgInsertTextureAndAlpha>mgInsertTextureAndAlpha</A>, 
<A HREF=#mgWriteTexture>mgWriteTexture</A></DD></DL>
<HR>
<LEFT><A NAME=mgReadTextureMappingFile><H1 CLASS="APISYMBOL">mgReadTextureMappingFile</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgReadTextureMappingFile</B> - loads a database's texture mapping 
palette from a file.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgReadTextureMappingFile</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fileName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgReadTextureMappingFile</B> loads the texture mapping palette for 
database <I>db</I> from a file named <I>fileName</I>.  The palette entries 
for <I>db</I> are replaced by those read from <I>fileName</I>.</P></DD><DD><P>The file <I>fileName</I> was created by <A HREF=#mgWriteTextureMappingFile>mgWriteTextureMappingFile</A>, 
or via the Save Palette command in the texture mapping palette in Creator.</P></DD><DD><P>Existing texture mapping palette records become invalid.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>fileName</I></DT><DD>the texture mapping file name</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWriteTextureMappingFile>mgWriteTextureMappingFile</A></DD></DL>
<HR>
<LEFT><A NAME=mgReadTexturePalette><H1 CLASS="APISYMBOL">mgReadTexturePalette</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgReadTexturePalette</B> - loads a database's texture 
palette from a file.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgReadTexturePalette</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fileName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgReadTexturePalette</B> loads the texture palette for 
database <I>db</I> from a file named <I>fileName</I>.  The palette entries 
for <I>db</I> are replaced by those read from <I>fileName</I>.</P></DD><DD><P>The file <I>fileName</I> was created by <A HREF=#mgWriteTexturePalette>mgWriteTexturePalette</A>, 
or via the Save Palette command in the texture palette in Creator.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>fileName</I></DT><DD>the name of the texture 
palette file to read</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of textures loaded if successful, -1 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWriteTexturePalette>mgWriteTexturePalette</A></DD></DL>
<HR>
<LEFT><A NAME=mgRec2Db><H1 CLASS="APISYMBOL">mgRec2Db</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRec2Db</B> - gets the database node from any node of a database.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgRec2Db</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgRec2db</B> returns the database node corresponding to the specified 
node <I>rec</I>.  If the node is not associated with any database, the database 
node of the current database is returned.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to check</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the database node of the database that contains the node.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example prints a message if a polygon node, <I>poly</I> 
belongs to the current database.</DT><DT><PRE CLASS="EXAMPLE">mgrec* curDb;
mgrec* polyDb;
curDb = mgGetCurrentDb ();
polyDb = mgRec2Db (poly);
if (polyDb == curDb)
   printf ("poly belongs to current database");</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCurrentDb>mgGetCurrentDb</A>, <A HREF=#mgRec2Filename>mgRec2Filename</A></DD></DL>
<HR>
<LEFT><A NAME=mgRec2Filename><H1 CLASS="APISYMBOL">mgRec2Filename</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRec2Filename</B> - gets the database name from any node of a database.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char* <B>mgRec2Filename</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given any node in a database, <I>rec</I>, <B>mgRec2Filename</B> returns the 
database file name.  If a node is not associated with any database, a null string is 
returned.  The file name returned has a path if it was opened or created in a remote 
directory.</P></DD><DD><P>Note: Forward slashes "/" are used as directory delimiters in the path 
of the file returned.  Also, if the database being queried has not yet been 
saved to disk, the name returned will be a "temporary" name.  You can use the 
function <A HREF=#mgIsDbUntitled>mgIsDbUntitled</A> to check this.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned string in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node in a database</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the file name if successful, or <A HREF=#MG_NULL>MG_NULL</A> if no node is found.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* db;
mgbool isUntitled;
char* fileName;
db = mgGetCurrentDb ();
fileName = mgRec2Filename (db);
isUntitled = mgIsDbUntitled (db);
if (fileName != MG_NULL) {
   if (isUntitled == MG_TRUE) {
      printf ("%s is a temporary filename for the database", fileName);
   }
   else {
      printf ("%s is the actual filename for the database", fileName);
   }

   // free the fileName string when you are done with it !
   mgFree (fileName);
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCurrentDb>mgGetCurrentDb</A>, <A HREF=#mgRec2Db>mgRec2Db</A>, <A HREF=#mgIsDbUntitled>mgIsDbUntitled</A></DD></DL>
<HR>
<LEFT><A NAME=mgRecDeleteProperty><H1 CLASS="APISYMBOL">mgRecDeleteProperty</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRecDeleteProperty</B> - deletes user defined data 
associated with a record.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgRecDeleteProperty</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>pluginTool</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgpropertyname>mgpropertyname</A></TD><TD><I>propName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Use <B>mgRecDeleteProperty</B> to delete the data named <I>propName</I> 
that was associated with the record <I>rec</I> using <A HREF=#mgRecPutProperty>mgRecPutProperty</A>.</P></DD><DD><P>Note that this function does not free or otherwise affect the actual data 
that was associated.  If this data was dynamically allocated, it is the 
callers responsibility to deallocate it.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginTool</I></DT><DD>the plug-in tool handle</DD><DT><I>rec</I></DT><DD>the record</DD><DT><I>propName</I></DT><DD>the name of the property to delete</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRecPutProperty>mgRecPutProperty</A>, <A HREF=#mgRecGetProperty>mgRecGetProperty</A></DD></DL>
<HR>
<LEFT><A NAME=mgRecGetProperty><H1 CLASS="APISYMBOL">mgRecGetProperty</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRecGetProperty</B> - retrieves user defined data 
associated with a record.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgpropertyvalue <B>mgRecGetProperty</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>pluginTool</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgpropertyname>mgpropertyname</A></TD><TD><I>propName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Use <B>mgRecGetProperty</B> to retrieve the data named <I>propName</I> 
that was associated with the record <I>rec</I> using <A HREF=#mgRecPutProperty>mgRecPutProperty</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginTool</I></DT><DD>the plug-in tool handle</DD><DT><I>rec</I></DT><DD>the record to get property for</DD><DT><I>propName</I></DT><DD>the name of the property to get</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the user-defined data if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRecPutProperty>mgRecPutProperty</A>, <A HREF=#mgRecDeleteProperty>mgRecDeleteProperty</A>, <A HREF=#mgGetUserData>mgGetUserData</A></DD></DL>
<HR>
<LEFT><A NAME=mgRecPutProperty><H1 CLASS="APISYMBOL">mgRecPutProperty</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRecPutProperty</B> - associates user defined data with a record.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgRecPutProperty</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>pluginTool</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgpropertyname>mgpropertyname</A></TD><TD><I>propName</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgpropertyvalue>mgpropertyvalue</A></TD><TD><I>propValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgRecPutProperty</B> allows you to associate data of any 
type, <I>propValue</I>, with \\ node record.  The user-defined data is associated 
with a record, <I>rec</I>, and identified by a property name string, <I>propName</I>, 
allowing any number of data records to be associated with the node record, 
as long as all property names are unique.</P></DD><DD><P>Since there may be multiple plug-in tools associating data to node records 
in the scene simultaneously, a plug-in tool <I>pluginTool</I> is required to ensure 
the actual property names are unique.  In this way, multiple plug-in tools can all 
use the same property name with no risk of name space collisions. However, if the 
same plug-in tool uses a property name more than once, the last use overwrites 
any previous uses.</P></DD><DD><P>After using this function to associate user data to a node record, 
use the function <A HREF=#mgRecGetProperty>mgRecGetProperty</A> to retrieve the data.  Then when 
you no longer need the data associated to the node record, use 
<A HREF=#mgRecDeleteProperty>mgRecDeleteProperty</A> to disassociate the data from the node. 
Note that <A HREF=#mgRecDeleteProperty>mgRecDeleteProperty</A> does not free or otherwise affect 
the actual data that was associated.  If this data was dynamically 
allocated, it is the callers responsibility to deallocate it.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginTool</I></DT><DD>the plug-in tool handle</DD><DT><I>rec</I></DT><DD>the record to put property on</DD><DT><I>propName</I></DT><DD>the name of the property to assign</DD><DT><I>propValue</I></DT><DD>the value of the property to assign</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example associates a string property to a node, 
retrieves the string and prints it out.  Finally, it deletes the 
property from the node.</DT><DT><PRE CLASS="EXAMPLE">#define PROPERTY_NAME   "My String Property"
#define USER_STRING     "This String is associated to my node"

char* string;

// allocate the string to be associated to the node
string = mgMalloc (strlen (USER_STRING) + 1);
strcpy  string, USER_STRING);

// associate the string as a property of the node
mgRecPutProperty (pluginTool, rec, PROPERTY_NAME, string);

// Then later, retrieve the string property, print it out

char* string;

// Retrieve the string property from the node
string = (char*) mgRecGetProperty (pluginTool, rec, PROPERTY_NAME);
printf ("%s: %s", PROPERTY_NAME, string);

// Output is:
// My String Property: This String is associated to my node

// Then finally, when you no longer need the string to be
// associated to the node

char* string;

// Retrieve the string property from the node (need to free it)
string = (char*) mgRecGetProperty (pluginTool, rec, PROPERTY_NAME);
mgFree (string);
mgRecDeleteProperty (pluginTool, rec, PROPERTY_NAME);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRecGetProperty>mgRecGetProperty</A>, <A HREF=#mgRecDeleteProperty>mgRecDeleteProperty</A>, <A HREF=#mgSetUserData>mgSetUserData</A></DD></DL>
<HR>
<LEFT><A NAME=mgReference><H1 CLASS="APISYMBOL">mgReference</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgReference</B> - changes an existing node record into an instance node record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgReference</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>refRec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given an existing node record <I>rec</I>, <B>mgReference</B> causes <I>rec</I> to become an instance 
of the reference node record <I>refRec</I>.</P></DD><DD><P>Alternatively, you can use <A HREF=#mgAttach>mgAttach</A> to attach a child as the first child of a parent or 
<A HREF=#mgAppend>mgAppend</A> to attach a child as the last child of a parent.</P></DD><DD><P>The node <I>refRec</I> must not be a child node of any node in the database.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>a node record, which will be an instance of the reference node</DD><DT><I>refRec</I></DT><DD>a reference node record.</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgDeReference>mgDeReference</A>, <A HREF=#mgAttach>mgAttach</A>, <A HREF=#mgAppend>mgAppend</A>, <A HREF=#mgInsert>mgInsert</A></DD></DL>
<HR>
<LEFT><A NAME=mgRefreshControl><H1 CLASS="APISYMBOL">mgRefreshControl</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRefreshControl</B> - refreshes a control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgRefreshControl</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgRefreshControl</B> refreshes the specified <I>control</I>.</P></DD><DD><P>If the refresh control event has been selected for the callback 
function of the specified control, the refresh event is sent to the 
control.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the control to refresh</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetGuiCallback>mgSetGuiCallback</A>, <A HREF=#mgRefreshDialog>mgRefreshDialog</A></DD></DL>
<HR>
<LEFT><A NAME=mgRefreshDialog><H1 CLASS="APISYMBOL">mgRefreshDialog</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRefreshDialog</B> - refreshes a dialog.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgRefreshDialog</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>gui</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgRefreshDialog</B> refreshes the dialog associated to the specified 
<I>gui</I>.  The parameter <I>gui</I> may be any control contained in the dialog 
or may be the dialog itself.</P></DD><DD><P>If the refresh dialog event has been selected for the dialog function 
of the intended dialog, the refresh event is first sent to the dialog. 
Then, for all controls contained in the dialog that have selected the 
refresh control event, the event is sent.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>gui</I></DT><DD>any control in the dialog (or the dialog itself)</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRefreshDialogCallback>mgRefreshDialogCallback</A>, <A HREF=#mgShowDialog>mgShowDialog</A>, 
<A HREF=#mgHideDialog>mgHideDialog</A>, <A HREF=#mgDestroyDialog>mgDestroyDialog</A>, <A HREF=#mgRefreshControl>mgRefreshControl</A></DD></DL>
<HR>
<LEFT><A NAME=mgRefreshDialogCallback><H1 CLASS="APISYMBOL">mgRefreshDialogCallback</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRefreshDialogCallback</B> - built-in callback function to 
refresh a dialog when a control is activated.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgRefreshDialogCallback</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>gui</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcontrolid>mgcontrolid</A></TD><TD><I>controlId</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgguicallbackreason>mgguicallbackreason</A></TD><TD><I>callbackReason</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>callData</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgRefreshDialogCallback</B> can be passed to <A HREF=#mgSetGuiCallback>mgSetGuiCallback</A> 
for a control whose <A HREF=#MGCB_ACTIVATE>MGCB_ACTIVATE</A> event causes the dialog containing 
the control to be refreshed.</P></DD><DD><P>This function is not meant to be called directly, only passed to 
<A HREF=#mgSetGuiCallback>mgSetGuiCallback</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>gui</I></DT><DD>control in the dialog to refresh</DD><DT><I>controlId</I></DT><DD>the identifier of gui</DD><DT><I>callbackReason</I></DT><DD>the control event that 
triggered the callback</DD><DT><I>userData</I></DT><DD>user data passed through</DD><DT><I>callData</I></DT><DD>call data passed through</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>In both of the following examples, a dialog contains a list control. 
When the user selects an item in the list control, no action is required 
by the plug-in other than to refresh the dialog.  Both examples show 
alternate implementations for setting up this behavior.  Both are 
functionally equivalent.<BR><BR> 
In this first example, the plug-in defines and assigns an explicit control 
callback function to the list control.  This callback function refreshes the 
dialog containing the control when the <A HREF=#MGCB_ACTIVATE>MGCB_ACTIVATE</A> event is sent to 
the list control.</DT><DT><PRE CLASS="EXAMPLE">static mgstatus ListCallback (mggui gui, mgcontrolid controlId,
&#32&#32&#32&#32mgguicallbackreason callbackReason,
&#32&#32&#32&#32void* userData, void* callData)
{
   if (callbackReason == MGCB_ACTIVATE)
      mgRefreshDialog (gui);
   return (MSTAT_OK);
}

static void InitializeControls (mggui dialog)
{
   mggui gui = mgFindGuiById (dialog, IDC_LIST);
   mgSetGuiCallback (gui, MGCB_ACTIVATE, ListCallback, MG_NULL);
}</PRE></DT><DT>In this next example, the plug-in assigns the built-in control callback 
function <B>mgRefreshDialogCallback</B> to the list control.  This built-in callback 
refreshes the dialog when the <A HREF=#MGCB_ACTIVATE>MGCB_ACTIVATE</A> event is sent to the list control. 
In this way, defining an explicit callback function is not required.</DT><DT><PRE CLASS="EXAMPLE">static void InitializeControls ( mggui dialog )
{
   mggui gui = mgFindGuiById (dialog, IDC_LIST);
   // Note: You must select the MGCB_ACTIVATE event.
   //       If you select any other events, they are ignored.
   //       You must pass MG_NULL as the user data.
   mgSetGuiCallback (gui, MGCB_ACTIVATE, mgRefreshDialogCallback, MG_NULL);
}</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetGuiCallback>mgSetGuiCallback</A>, <A HREF=#mgRefreshDialog>mgRefreshDialog</A>, 
<A HREF=#mgHideDialogCallback>mgHideDialogCallback</A>, <A HREF=#mgDestroyDialogCallback>mgDestroyDialogCallback</A></DD></DL>
<HR>
<LEFT><A NAME=mgRefreshScene><H1 CLASS="APISYMBOL">mgRefreshScene</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRefreshScene</B> - forces a database to be redrawn.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgRefreshScene</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgRefreshScene</B> forces the database associated with the 
specified editor context, <I>editorContext</I> to be redrawn in Creator.</P></DD><DD><P>While an editor tool instance is active, it may perform actions 
within a database node that change the appearance of the database contents 
in the graphics or hierarchy view or both.  For example, the tool may 
create new geometry or modify a visual attribute of an existing geometry 
node.  When such an action is performed, <B>mgRefreshScene</B> can be called 
to make sure the graphic and hierarchy views of the corresponsing 
database are redrawn.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context used to identify 
the database that is to be redrawn</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<HR>
<LEFT><A NAME=mgRegisterCreate><H1 CLASS="APISYMBOL">mgRegisterCreate</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRegisterCreate</B> - sets the create action 
function for an extension node type.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgRegisterCreate</B> (</TD><TD><A HREF=#mgpluginsite>mgpluginsite</A></TD><TD><I>pluginSite</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>rCode</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcreatefunc>mgcreatefunc</A></TD><TD><I>createFunc</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgRegisterCreate</B> registers a create function for 
the specified extension node type <I>rCode</I>.  The function you register, 
<I>createFunc</I> will be called after a user creates a node of type 
<I>rCode</I> using either the Extensions Menu or the Create Tool.  In this 
way extension developers can be notified after their extension nodes 
are created and can perform actions on the new node.</P></DD><DD><P>Note: You can only assign create functions to node types 
that your extension has defined.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginSite</I></DT><DD>the data extension site</DD><DT><I>rCode</I></DT><DD>the record code</DD><DT><I>createFunc</I></DT><DD>the create action function</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterSite>mgRegisterSite</A></DD></DL>
<HR>
<LEFT><A NAME=mgRegisterEditor><H1 CLASS="APISYMBOL">mgRegisterEditor</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRegisterEditor</B> - registers an editor tool.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgplugintool <B>mgRegisterEditor</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>toolName</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgtoolstartfunc>mgtoolstartfunc</A></TD><TD><I>startFunc</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>...</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgRegisterEditor</B> registers an editor tool for 
the specified plug-in module <I>plugin</I> with the specified tool attributes.</P></DD><DD><P>The required tool attributes include the name of the tool <I>toolName</I>, 
a start function for the tool, <I>startFunc</I> and user defined callback data, 
<I>userData</I> (may be <A HREF=#MG_NULL>MG_NULL</A>) that is passed to the start function 
when it is called.</P></DD><DD><P>Additional required tool attributes include launch location attributes. 
Your tool can be launched from either a tool palette or menu. If your tool 
is to be launched from a tool palette, you must specify 
<A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A> and <A HREF=#MTA_PALETTEICON>MTA_PALETTEICON</A>.  If your tool is to be 
launched from a menu, you must specify <A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A> and 
<A HREF=#MTA_MENULABEL>MTA_MENULABEL</A>.  Additional optional tool attributes for tools launched 
from a menu include <A HREF=#MTA_MENUPOSITION>MTA_MENUPOSITION</A> and <A HREF=#MTA_MENUSUBMENU>MTA_MENUSUBMENU</A>.</P></DD><DD><P>Additional optional tool attributes for all editor tools 
include <A HREF=#MTA_VERSION>MTA_VERSION</A>, <A HREF=#MTA_HELPCONTEXT>MTA_HELPCONTEXT</A>, <A HREF=#MTA_TOOLTIP>MTA_TOOLTIP</A>, 
<A HREF=#MTA_REPEATABLE>MTA_REPEATABLE</A> and <A HREF=#MTA_NOHIDESELECTOUTLINE>MTA_NOHIDESELECTOUTLINE</A>. 
If you specify that your tool be launched from a tool palette and 
do not specify <A HREF=#MTA_TOOLTIP>MTA_TOOLTIP</A>, the default 
tool tip text displayed is the name of your tool as specified in the 
parameter <I>toolName</I>.</P></DD><DD><P>All additional (required and optional) tool attributes are passed 
using variable argument style and must be terminated with 
<A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in module registering the tool</DD><DT><I>toolName</I></DT><DD>the name of the tool</DD><DT><I>startFunc</I></DT><DD>the tool start function that is called 
when the tool is launched</DD><DT><I>userData</I></DT><DD>user defined data that will be passed to 
<I>startFunc</I> when it is called</DD><DT><I>...</I></DT><DD>additional editor tool 
specific attributes in variable argument style</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Pointer to plug-in tool registered if successful, <A HREF=#MG_NULL>MG_NULL</A> 
otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, 
<A HREF=#mgEditorSetVertexFunc>mgEditorSetVertexFunc</A>, 
<A HREF=#mgEditorSetPointFunc>mgEditorSetPointFunc</A>, <A HREF=#mgEditorSetPickFunc>mgEditorSetPickFunc</A>, 
<A HREF=#mgEditorSetTerminateFunc>mgEditorSetTerminateFunc</A>, <A HREF=#mgEditorSetCreateDialogFunc>mgEditorSetCreateDialogFunc</A>, 
<A HREF=#mgEditorSetButtonFunc>mgEditorSetButtonFunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgRegisterExporter><H1 CLASS="APISYMBOL">mgRegisterExporter</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRegisterExporter</B> - registers a database exporter tool.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgplugintool <B>mgRegisterExporter</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>toolName</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgtoolstartfunc>mgtoolstartfunc</A></TD><TD><I>startFunc</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>...</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgRegisterExporter</B> registers a database exporter tool for 
the specified plug-in module <I>plugin</I> with the specified tool attributes.</P></DD><DD><P>The required tool attributes include the name of the tool <I>toolName</I>, 
a start function for the tool, <I>startFunc</I> and user defined callback data, 
<I>userData</I> (may be <A HREF=#MG_NULL>MG_NULL</A>) that is passed to the start function 
when it is called.</P></DD><DD><P>Additional required database exporter tool attributes include 
<A HREF=#MTA_FILTER>MTA_FILTER</A> and <A HREF=#MTA_FILETYPE>MTA_FILETYPE</A>.  Additional optional tool attributes 
include <A HREF=#MTA_VERSION>MTA_VERSION</A> and <A HREF=#MTA_HELPCONTEXT>MTA_HELPCONTEXT</A>.  These additional tool attributes 
are passed using variable argument style and must be terminated with 
<A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in module registering the tool</DD><DT><I>toolName</I></DT><DD>the name of the tool</DD><DT><I>startFunc</I></DT><DD>the tool start function that is called 
when the tool is launched</DD><DT><I>userData</I></DT><DD>user defined data that will be passed to 
<I>startFunc</I> when it is called</DD><DT><I>...</I></DT><DD>additional database exporter 
tool specific attributes in variable argument 
style</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Pointer to plug-in tool registered if successful, <A HREF=#MG_NULL>MG_NULL</A> 
otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImporter>mgRegisterImporter</A></DD></DL>
<HR>
<LEFT><A NAME=mgRegisterGetHeaderCode><H1 CLASS="APISYMBOL">mgRegisterGetHeaderCode</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRegisterGetHeaderCode</B> - sets the Get Header Code 
(extension node helper) function for a database extension.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgRegisterGetHeaderCode</B> (</TD><TD><A HREF=#mgpluginsite>mgpluginsite</A></TD><TD><I>pluginSite</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mggetheadercodefunc>mggetheadercodefunc</A></TD><TD><I>getHeaderCodeFunc</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgRegisterGetHeaderCode</B> assigns the specified Get Header Code 
function <I>getHeaderCodeFunc</I> to the specified data extension site 
<I>pluginSite</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginSite</I></DT><DD>the data extension site</DD><DT><I>getHeaderCodeFunc</I></DT><DD>the Get Header Code function</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterSite>mgRegisterSite</A>, <A HREF=#mgRegisterGetMaxId>mgRegisterGetMaxId</A>, <A HREF=#mgRegisterSetMaxId>mgRegisterSetMaxId</A>, 
<A HREF=#mggetheadercodefunc>mggetheadercodefunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgRegisterGetMaxId><H1 CLASS="APISYMBOL">mgRegisterGetMaxId</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRegisterGetMaxId</B> - sets the Get Max Id (extension node 
helper) function for a database extension.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgRegisterGetMaxId</B> (</TD><TD><A HREF=#mgpluginsite>mgpluginsite</A></TD><TD><I>pluginSite</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mggetmaxidfunc>mggetmaxidfunc</A></TD><TD><I>getMaxIdfunc</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><A HREF=#mgRegisterSetMaxId>mgRegisterSetMaxId</A> assigns the specified Get Max Id function 
<I>getMaxIdFunc</I> to the specified data extension site <I>pluginSite</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginSite</I></DT><DD>the data extension site</DD><DT><I>getMaxIdfunc</I></DT><DD>the Get Max Id function</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterSite>mgRegisterSite</A>, <A HREF=#mgRegisterSetMaxId>mgRegisterSetMaxId</A>, <A HREF=#mgRegisterGetHeaderCode>mgRegisterGetHeaderCode</A>, 
<A HREF=#mggetmaxidfunc>mggetmaxidfunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgRegisterGraphicDraw><H1 CLASS="APISYMBOL">mgRegisterGraphicDraw</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRegisterGraphicDraw</B> - registers a graphic draw 
function for an extension node type.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgRegisterGraphicDraw</B> (</TD><TD><A HREF=#mgpluginsite>mgpluginsite</A></TD><TD><I>pluginSite</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>rCode</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mggraphicdrawfunc>mggraphicdrawfunc</A></TD><TD><I>drawFunc</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgRegisterGraphicDraw</B> registers a graphic draw function for 
the specified extension node type <I>rCode</I>.  The function you register, 
<I>drawFunc</I> will be called when nodes of type <I>rCode</I> are drawn in 
the graphics view of Creator.  In this way extension 
developers can modify how a node they develop appears in the graphic 
view.</P></DD><DD><P>Note: You can only assign graphic draw functions to node types 
that your extension has defined.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginSite</I></DT><DD>the data extension site</DD><DT><I>rCode</I></DT><DD>the record code</DD><DT><I>drawFunc</I></DT><DD>the graphic draw function</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterSite>mgRegisterSite</A>, <A HREF=#mgRegisterHierarchyDraw>mgRegisterHierarchyDraw</A></DD></DL>
<HR>
<LEFT><A NAME=mgRegisterHelpFile><H1 CLASS="APISYMBOL">mgRegisterHelpFile</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRegisterHelpFile</B> - register a help file for a plug-in 
module.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgRegisterHelpFile</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>helpFile</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgRegisterHelpFile</B> associates the named help file, <I>helpFile</I>, 
to the specified plug-in module, <I>plugin</I>.  Currently, Windows Help and 
HTML file formats are supported.</P></DD><DD><P>If <I>helpFile</I> is <A HREF=#MG_NULL>MG_NULL</A>, this function will assume the help 
file is located in the same directory as the plug-in module and has the 
same name as the plug-in module but with one of the accepted help file 
extensions.  If you do specify <A HREF=#MG_NULL>MG_NULL</A> for <I>helpFile</I> you must 
use one of the "known" file extensions, ".hlp" for Windows Help Files 
and ".htm" for HTML files.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in module to associate the help 
file with</DD><DT><I>helpFile</I></DT><DD>the help file to associate</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginSetHelpContext>mgPluginSetHelpContext</A>, <A HREF=#mgGuiSetHelpContext>mgGuiSetHelpContext</A>, 
<A HREF=#mgShowHelpContext>mgShowHelpContext</A>, <A HREF=#MTA_HELPCONTEXT>MTA_HELPCONTEXT</A></DD></DL>
<HR>
<LEFT><A NAME=mgRegisterHierarchyDraw><H1 CLASS="APISYMBOL">mgRegisterHierarchyDraw</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRegisterHierarchyDraw</B> - registers a hierarchy draw 
function for an extension node type.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgRegisterHierarchyDraw</B> (</TD><TD><A HREF=#mgpluginsite>mgpluginsite</A></TD><TD><I>pluginSite</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>rCode</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mghierarchydrawfunc>mghierarchydrawfunc</A></TD><TD><I>drawFunc</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgRegisterHierarchyDraw</B> registers a hierarchy draw function 
for the specified extension node type <I>rCode</I>.  The function you 
register, <I>drawFunc</I> will be called when any node of type <I>rCode</I> 
is drawn in the hierarchy view of Creator.  In this way extension 
developers can modify how a node they develop appears in the hierarchy 
view.</P></DD><DD><P>Note: You can only assign hierarchy draw functions to node types 
that your extension has defined.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginSite</I></DT><DD>the data extension site</DD><DT><I>rCode</I></DT><DD>the record code</DD><DT><I>drawFunc</I></DT><DD>the hierarchy draw function</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterSite>mgRegisterSite</A>, <A HREF=#mgRegisterGraphicDraw>mgRegisterGraphicDraw</A></DD></DL>
<HR>
<LEFT><A NAME=mgRegisterImageImporter><H1 CLASS="APISYMBOL">mgRegisterImageImporter</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRegisterImageImporter</B> - registers an image importer tool.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgplugintool <B>mgRegisterImageImporter</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>toolName</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>importFlags</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgimageopenfunc>mgimageopenfunc</A></TD><TD><I>openFunc</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgimageclosefunc>mgimageclosefunc</A></TD><TD><I>closeFunc</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgimagegetinfofunc>mgimagegetinfofunc</A></TD><TD><I>getInfoFunc</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgimagegettexelsfunc>mgimagegettexelsfunc</A></TD><TD><I>getTexelsFunc</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>...</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgRegisterImageImporter</B> registers an image importer tool for 
the specified plug-in module <I>plugin</I> with the specified tool attributes.</P></DD><DD><P>The required tool attributes include the name of the tool <I>toolName</I>, 
a start function for the tool, <I>startFunc</I> and user defined callback data, 
<I>userData</I> (may be <A HREF=#MG_NULL>MG_NULL</A>) that is passed to the start function 
when it is called.</P></DD><DD><P>Additional required tool attributes include 
<A HREF=#MTA_FILTER>MTA_FILTER</A> and <A HREF=#MTA_FILETYPE>MTA_FILETYPE</A>.  Additional optional tool attributes 
include <A HREF=#MTA_VERSION>MTA_VERSION</A> and <A HREF=#MTA_HELPCONTEXT>MTA_HELPCONTEXT</A>.  These additional tool attributes 
are passed using variable argument style and must be terminated with 
<A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in module registering the tool</DD><DT><I>toolName</I></DT><DD>the name of the tool</DD><DT><I>importFlags</I></DT><DD>image importer capability flags (reserved 
for future enhancement)</DD><DT><I>openFunc</I></DT><DD>open callback function for image importer</DD><DT><I>closeFunc</I></DT><DD>close callback function for image importer</DD><DT><I>getInfoFunc</I></DT><DD>get info callback function for image importer</DD><DT><I>getTexelsFunc</I></DT><DD>get texels callback function for image importer</DD><DT><I>userData</I></DT><DD>user defined data that will be passed to 
your import action functions <I>openFunc</I>, 
<I>closeFunc</I>, <I>getInfoFunc</I> and 
<I>getTexelsFunc</I> when they are called</DD><DT><I>...</I></DT><DD>additional viewer tool 
specific attributes in variable argument style</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Pointer to plug-in tool registered if successful, <A HREF=#MG_NULL>MG_NULL</A> 
otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetReadImageGeoInfoFunc>mgSetReadImageGeoInfoFunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgRegisterImporter><H1 CLASS="APISYMBOL">mgRegisterImporter</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRegisterImporter</B> - registers a database importer tool.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgplugintool <B>mgRegisterImporter</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>toolName</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgtoolstartfunc>mgtoolstartfunc</A></TD><TD><I>startFunc</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>...</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgRegisterImporter</B> registers a database importer tool for 
the specified plug-in module <I>plugin</I> with the specified tool attributes.</P></DD><DD><P>The required tool attributes include the name of the tool <I>toolName</I>, 
a start function for the tool, <I>startFunc</I> and user defined callback data, 
<I>userData</I> (may be <A HREF=#MG_NULL>MG_NULL</A>) that is passed to the start function 
when it is called.</P></DD><DD><P>Additional required tool attributes include 
<A HREF=#MTA_FILTER>MTA_FILTER</A> and <A HREF=#MTA_FILETYPE>MTA_FILETYPE</A>.  Additional optional tool attributes 
include <A HREF=#MTA_VERSION>MTA_VERSION</A> and <A HREF=#MTA_HELPCONTEXT>MTA_HELPCONTEXT</A>.  These additional tool attributes 
are passed using variable argument style and must be terminated with 
<A HREF=#MG_NULL>MG_NULL</A>.</P></DD><DD><P>The <A HREF=#mgstatus>mgstatus</A> value returned by the start function should indicate 
whether or not the import succeeded or failed.  The start function, <I>startFunc</I>, 
should therefore return <A HREF=#MSTAT_OK>MSTAT_OK</A> if the file was imported successfully.  If 
the file did not import successfully, the start function should return any non-zero 
value.  It is also recommended that the start function report an error message 
indicating the nature of the failure.</P></DD><DD><P>When a database importer is launched from within the modeler environment, 
the modeler can specify whether the file is to imported into a new database window 
or into the current database window.  If the file is imported into a new database 
window and the start function fails (returns any value other than <A HREF=#MSTAT_OK>MSTAT_OK</A>), 
the new database window will not be created on the desktop.  If the file is 
imported into the current database window and the start function fails, 
no such adverse action is taken.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in module registering the tool</DD><DT><I>toolName</I></DT><DD>the name of the tool</DD><DT><I>startFunc</I></DT><DD>the tool start function that is called 
when the tool is launched</DD><DT><I>userData</I></DT><DD>user defined data that will be passed to 
<I>startFunc</I> when it is called</DD><DT><I>...</I></DT><DD>additional database importer 
tool specific attributes in variable argument 
style</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Pointer to plug-in tool registered if successful, <A HREF=#MG_NULL>MG_NULL</A> 
otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterExporter>mgRegisterExporter</A></DD></DL>
<HR>
<LEFT><A NAME=mgRegisterInputDevice><H1 CLASS="APISYMBOL">mgRegisterInputDevice</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRegisterInputDevice</B> - registers an input device tool.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgplugintool <B>mgRegisterInputDevice</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>toolName</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>inputFlags</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mginputdevicestartfunc>mginputdevicestartfunc</A></TD><TD><I>startFunc</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mginputdevicestopfunc>mginputdevicestopfunc</A></TD><TD><I>stopFunc</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mginputdevicesetinputtypefunc>mginputdevicesetinputtypefunc</A></TD><TD><I>setInputTypeFunc</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>...</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgRegisterInputDevice</B> registers an input device tool for the 
specified plug-in module <I>plugin</I> with the specified tool attributes.</P></DD><DD><P>The required tool attributes include the name of the tool <I>toolName</I>, 
start and stop functions for collecting events from the input device, 
a set input type function for notifying the device which input type is 
desired, and user defined callback data <I>userData</I> (may be <A HREF=#MG_NULL>MG_NULL</A>) 
that is passed to the callback functions when they are called.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in module registering the tool</DD><DT><I>toolName</I></DT><DD>the name of the tool</DD><DT><I>inputFlags</I></DT><DD>input device capability flags, bitwise combination 
of <A HREF=#mgmouseinputtype>MMSI_VERTEXINPUT</A>, 
<A HREF=#mgmouseinputtype>MMSI_POINTINPUT</A>, and 
<A HREF=#mgmouseinputtype>MMSI_DEVICEINPUT</A></DD><DT><I>startFunc</I></DT><DD>start function called when input desired 
from your device</DD><DT><I>stopFunc</I></DT><DD>stop function called when input is no 
longer desired from your device</DD><DT><I>setInputTypeFunc</I></DT><DD>set input type function called 
to notify your device which kind of 
device input is desired</DD><DT><I>userData</I></DT><DD>user defined data that will be passed to 
<I>startFunc</I>, <I>stopFunc</I>, and <I>setInputTypeFunc</I></DD><DT><I>...</I></DT><DD>additional input device 
tool specific attributes in variable argument style</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the plug-in tool registered if successful, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<HR>
<LEFT><A NAME=mgRegisterNotifier><H1 CLASS="APISYMBOL">mgRegisterNotifier</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRegisterNotifier</B> - registers a notifier.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgnotifier <B>mgRegisterNotifier</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>pluginTool</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgnotifierevent>mgnotifierevent</A></TD><TD><I>event</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgnotifyfunc>mgnotifyfunc</A></TD><TD><I>notifyFunc</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgRegisterNotifier</B> registers a model-time notifier on behalf 
of the specified editor or viewer plug-in tool, <I>pluginTool</I>.  When the 
specified model time <I>event</I> occurs for the specified database <I>db</I> 
and/or node <I>rec</I>, the notification callback function, <I>notifyFunc</I> 
is called. The affected database and node (if any) are passed to the 
notification callback function with the specified user defined data, 
<I>userData</I>.</P></DD><DD><P>Typically, you register a model-time notifier for a particular 
database node <I>db</I> or specific node <I>rec</I> in the scene.  If you do this, 
your notification callback function will be called only when the specified <I>event</I> 
occurs to that specific <I>db</I> or <I>rec</I> node.  If you want your notification callback 
function to be called whenever the event occurs to any database node, set <I>db</I> to 
<A HREF=#MG_NULL>MG_NULL</A>.</P></DD><DD><P>After you register a model-time notifier, it is immediately enabled. You can 
disable and re-enable the notifier during the lifetime of your plug-in tool 
using <A HREF=#mgSetNotifierEnabled>mgSetNotifierEnabled</A>.</P></DD><DD><P>Note that the parameters <I>db</I> and <I>rec</I> are not applicable to all notifier 
events. For example, the notifier <A HREF=#mgnotifierevent>MNOTIFY_SELECTLISTCHANGED</A> that is 
sent whenever the select list changes, can accept a non-null <I>db</I> but ignores <I>rec</I>. 
Similarly, the notifier <A HREF=#mgnotifierevent>MNOTIFY_DESKTOPINIT</A> that is sent when the 
Creator desktop starts after all plug-ins are initialized, ignores both <I>db</I> and <I>rec</I> 
as they are not applicable for this event. The notifier <A HREF=#mgnotifierevent>MNOTIFY_NODEDELETED</A> 
that is sent whenever a node is deleted in Creator, accepts both <I>db</I> and <I>rec</I>.</P></DD><DD><P>Certain notifier events are valid only for certain plug-in tool types. 
For example, viewer tools can receive any notifier event while editor tools and 
other plug-in tool types can only receive a subset of the notifier events.</P></DD><DD><P>Other restrictions are imposed on editor tools when registering certain 
notifier events. Because an editor tool instance is bound to a specific database 
when it runs, an editor tool is required to specify that database as the <I>db</I> 
parameter when it registers certain notifier events.</P></DD><DD><P>The following lists the 
notifiers that are valid for this function. It also lists which types of plug-in 
tools can receive each notifier event and any restrictions imposed.<P>
<TABLE CLASS="SIMPLE">
<P>
<TR CLASS="HEADER">
 
<TD CLASS="BORDER">
 Notifier Event </TD>
 
<TD CLASS="BORDER">
 Plug-in tool types </TD>
 
<TD CLASS="BORDER">
 Notes </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_SELECTLISTCHANGED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_NEWTOPDATABASE</A> </TD>
 
<TD CLASS="BORDER">
 Viewer, Editor </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_DATABASECLOSED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer, Editor </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_CURRENTPRIMARYCOLORCHANGED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer, Editor </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored, <I>db</I> cannot be <A HREF=#MG_NULL>MG_NULL</A> for Editor </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_CURRENTALTCOLORCHANGED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer, Editor </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored, <I>db</I> cannot be <A HREF=#MG_NULL>MG_NULL</A> for Editor </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_CURRENTTEXTURECHANGED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer, Editor </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored, <I>db</I> cannot be <A HREF=#MG_NULL>MG_NULL</A> for Editor </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_CURRENTMATERIALCHANGED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer, Editor </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored, <I>db</I> cannot be <A HREF=#MG_NULL>MG_NULL</A> for Editor </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_CURRENTTEXTUREMAPPINGCHANGED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer, Editor </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored, <I>db</I> cannot be <A HREF=#MG_NULL>MG_NULL</A> for Editor </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_CURRENTLIGHTPOINTAPPEARANCECHANGED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer, Editor </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored, <I>db</I> cannot be <A HREF=#MG_NULL>MG_NULL</A> for Editor </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_CURRENTLIGHTPOINTANIMATIONCHANGED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer, Editor </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored, <I>db</I> cannot be <A HREF=#MG_NULL>MG_NULL</A> for Editor </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_CURRENTSHADERCHANGED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer, Editor </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored, <I>db</I> cannot be <A HREF=#MG_NULL>MG_NULL</A> for Editor </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_CURRENTSOUNDCHANGED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer, Editor </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored, <I>db</I> cannot be <A HREF=#MG_NULL>MG_NULL</A> for Editor </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_CURRENTLIGHTSOURCECHANGED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer, Editor </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored, <I>db</I> cannot be <A HREF=#MG_NULL>MG_NULL</A> for Editor </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_COLORPALETTECHANGED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer, Editor </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_TEXTUREPALETTECHANGED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer, Editor </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_MATERIALPALETTECHANGED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer, Editor </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_TEXTUREMAPPINGPALETTECHANGED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer, Editor </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_LIGHTPOINTAPPEARANCEPALETTECHANGED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer, Editor </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_LIGHTPOINTANIMATIONPALETTECHANGED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer, Editor </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_SHADERPALETTECHANGED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer, Editor </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_SOUNDPALETTECHANGED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer, Editor </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_LIGHTSOURCEPALETTECHANGED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer, Editor </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_LIGHTPOINTPALETTEIZED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_DESKTOPINIT</A> </TD>
 
<TD CLASS="BORDER">
 All </TD>
 
<TD CLASS="BORDER">
 <I>db</I> and <I>rec</I> ignored </TD>
 
</TR>
<P>
 
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_DESKTOPEXIT</A> </TD>
 
<TD CLASS="BORDER">
 All </TD>
 
<TD CLASS="BORDER">
 <I>db</I> and <I>rec</I> ignored </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_DATABASEOPENED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer, Editor </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored, <I>db</I> must be <A HREF=#MG_NULL>MG_NULL</A> </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_DATABASESAVED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer, Editor </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_NODECHANGED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer </TD>
 
<TD CLASS="BORDER">
 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_NODEDELETED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer </TD>
 
<TD CLASS="BORDER">
 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_NODECREATED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> must be <A HREF=#MG_NULL>MG_NULL</A> </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_NODEREPARENTED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer </TD>
 
<TD CLASS="BORDER">
 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_SWITCHDISTANCECHANGED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer, Editor </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_TIMEOFDAYCHANGED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer, Editor </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_TEXTURESELECTCHANGED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer, Editor </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_EXTENSIONCHANGED</A> </TD>
 
<TD CLASS="BORDER">
 All </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_DATABASEPRESAVE</A> </TD>
 
<TD CLASS="BORDER">
 Viewer, Editor </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A HREF=#mgnotifierevent>MNOTIFY_EYEPOINTCHANGED</A> </TD>
 
<TD CLASS="BORDER">
 Viewer, Editor </TD>
 
<TD CLASS="BORDER">
 <I>rec</I> ignored </TD>
 
</TR>
<P>
</TABLE>
</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginTool</I></DT><DD>the plug-in tool that is registering the notifier</DD><DT><I>event</I></DT><DD>notification event you are interested in</DD><DT><I>db</I></DT><DD>the database for which you are registering the event</DD><DT><I>rec</I></DT><DD>the specific node for which the event applies</DD><DT><I>notifyFunc</I></DT><DD>the notification callback function</DD><DT><I>userData</I></DT><DD>user data to be passed to notification callback 
function when it is called</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a notifier object if successful, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example shows how a plug-in tool might set up model-time notifiers 
to be notified when either the select list changes or the user brings a different 
database to the top (focus) in Creator:</DT><DT><PRE CLASS="EXAMPLE">static void MyNotifier (mgnotifier notifier, mgnotifierevent event,
&#32&#32&#32      mgrec* db, mgrec* rec, void* userData)
{
   switch (event)
   {
   case MNOTIFY_SELECTLISTCHANGED:
      // the select list has changed for db
      break;

   case MNOTIFY_NEWTOPDATABASE:
      // the current database is now db
      // db may be MG_NULL if Creator desktop has no more files
      break;

   case MNOTIFY_NODECREATED:
      // rec has been created in db
      break;
   }
}

// register interest in select list changing for any database
mgRegisterNotifier (pluginTool, MNOTIFY_SELECTLISTCHANGED,
     MG_NULL, MG_NULL, MyNotifier, MG_NULL);

// register interest in any database becoming the current (focus) database
mgRegisterNotifier (pluginTool, MNOTIFY_NEWTOPDATABASE,
     MG_NULL, MG_NULL, MyNotifier, MG_NULL);

// register interest in any node being created
mgRegisterNotifier (pluginTool, MNOTIFY_NODECREATED,
     MG_NULL, MG_NULL, MyNotifier, MG_NULL);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterPaletteNotifier>mgRegisterPaletteNotifier</A>, <A HREF=#mgUnregisterNotifier>mgUnregisterNotifier</A>, 
<A HREF=#mgSetNotifierEnabled>mgSetNotifierEnabled</A>, <A HREF=#mgnotifierevent>mgnotifierevent</A></DD></DL>
<HR>
<LEFT><A NAME=mgRegisterPaletteNotifier><H1 CLASS="APISYMBOL">mgRegisterPaletteNotifier</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRegisterPaletteNotifier</B> - registers a palette notifier.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgnotifier <B>mgRegisterPaletteNotifier</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>pluginTool</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgnotifierevent>mgnotifierevent</A></TD><TD><I>event</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgpalettenotifyfunc>mgpalettenotifyfunc</A></TD><TD><I>notifyFunc</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgRegisterPaletteNotifier</B> registers a model-time palette notifier 
on behalf of the specified editor or viewer plug-in tool, <I>pluginTool</I>. 
When the specified model time palette <I>event</I> occurs for the specified 
database <I>db</I>, the palette notification callback function, <I>notifyFunc</I> 
is called. The affected database and palette entry index are passed to the 
notification callback function with the specified user defined data, 
<I>userData</I>.</P></DD><DD><P>Typically, you register a model-time palette notifier for a particular 
database node <I>db</I> in the scene. If you do this, your notification callback 
function will be called only when the specified <I>event</I> occurs within the palette 
of that specific <I>db</I> node. If you want your notification callback function to 
be called whenever the event occurs within the palette of any database node, 
set <I>db</I> to <A HREF=#MG_NULL>MG_NULL</A>.</P></DD><DD><P>Note: Model-time palette notifier events only apply to viewer and editor tools. 
Database importers and exporters, image importers and input device plug-in 
cannot receive model-time palette notification in this way.</P></DD><DD><P>The following palette notifiers are valid for this function:<BR> 
<A HREF=#mgnotifierevent>MNOTIFY_COLORPALETTECHANGED</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_TEXTUREPALETTECHANGED</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_MATERIALPALETTECHANGED</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_TEXTUREMAPPINGPALETTECHANGED</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_LIGHTPOINTAPPEARANCEPALETTECHANGED</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_LIGHTPOINTANIMATIONPALETTECHANGED</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_SHADERPALETTECHANGED</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_SOUNDPALETTECHANGED</A><BR> 
<A HREF=#mgnotifierevent>MNOTIFY_LIGHTSOURCEPALETTECHANGED</A></P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginTool</I></DT><DD>the plug-in tool that is registering the notifier</DD><DT><I>event</I></DT><DD>notification event you are interested in</DD><DT><I>db</I></DT><DD>the database for which you are registering the event</DD><DT><I>notifyFunc</I></DT><DD>the palette notification callback function</DD><DT><I>userData</I></DT><DD>user data to be passed to notification callback 
function when it is called</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a notifier object if successful, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterNotifier>mgRegisterNotifier</A>, <A HREF=#mgUnregisterNotifier>mgUnregisterNotifier</A>, 
<A HREF=#mgSetNotifierEnabled>mgSetNotifierEnabled</A>, <A HREF=#mgnotifierevent>mgnotifierevent</A></DD></DL>
<HR>
<LEFT><A NAME=mgRegisterPostEdit><H1 CLASS="APISYMBOL">mgRegisterPostEdit</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRegisterPostEdit</B> - sets the Post-Edit action 
function for a data extension field.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgRegisterPostEdit</B> (</TD><TD><A HREF=#mgpluginsite>mgpluginsite</A></TD><TD><I>pluginSite</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgposteditfunc>mgposteditfunc</A></TD><TD><I>postEditFunc</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgRegisterPostEdit</B> assigns the Post-Edit action 
function, <I>postEditFunc</I> to the data field, <I>code</I> for 
the data extension site <I>pluginSite</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginSite</I></DT><DD>the data extension site</DD><DT><I>code</I></DT><DD>the field code</DD><DT><I>postEditFunc</I></DT><DD>the Post-Edit action function</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterSite>mgRegisterSite</A>, <A HREF=#mgRegisterPreEdit>mgRegisterPreEdit</A>, 
<A HREF=#mgposteditfunc>mgposteditfunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgRegisterPreEdit><H1 CLASS="APISYMBOL">mgRegisterPreEdit</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRegisterPreEdit</B> - sets the Pre-Edit action 
function for a data extension field.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgRegisterPreEdit</B> (</TD><TD><A HREF=#mgpluginsite>mgpluginsite</A></TD><TD><I>pluginSite</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgpreeditfunc>mgpreeditfunc</A></TD><TD><I>preEditFunc</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgRegisterPreEdit</B> assign the Pre-Edit action 
function, <I>preEditFunc</I> to the data field, <I>code</I> for 
the data extension site <I>pluginSite</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginSite</I></DT><DD>the data extension site</DD><DT><I>code</I></DT><DD>the field code</DD><DT><I>preEditFunc</I></DT><DD>the Pre-Edit action function</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterSite>mgRegisterSite</A>, <A HREF=#mgRegisterPostEdit>mgRegisterPostEdit</A>, 
<A HREF=#mgpreeditfunc>mgpreeditfunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgRegisterRenderer><H1 CLASS="APISYMBOL">mgRegisterRenderer</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRegisterRenderer</B> - registers a renderer.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgplugintool <B>mgRegisterRenderer</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>toolName</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgtoolstartfunc>mgtoolstartfunc</A></TD><TD><I>startFunc</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>...</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgRegisterRenderer</B> registers a renderer for 
the specified plug-in module <I>plugin</I> with the specified tool attributes.</P></DD><DD><P>The required tool attributes include the name of the renderer <I>toolName</I>, 
a start function for the renderer, <I>startFunc</I> and user defined callback data, 
<I>userData</I> (may be <A HREF=#MG_NULL>MG_NULL</A>) that is passed to the start function 
when it is called.</P></DD><DD><P>Additional required tool attributes include launch location attributes. 
Your renderer can be launched from either a tool palette or menu. If your renderer 
is to be launched from a tool palette, you must specify 
<A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A> and <A HREF=#MTA_PALETTEICON>MTA_PALETTEICON</A>.  If your renderer is to be 
launched from a menu, you must specify <A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A> and 
<A HREF=#MTA_MENULABEL>MTA_MENULABEL</A>.  Additional optional tool attributes for renderer launched 
from a menu include <A HREF=#MTA_MENUPOSITION>MTA_MENUPOSITION</A> and <A HREF=#MTA_MENUSUBMENU>MTA_MENUSUBMENU</A>.</P></DD><DD><P>Additional optional tool attributes for all renderers 
include <A HREF=#MTA_VERSION>MTA_VERSION</A>, <A HREF=#MTA_HELPCONTEXT>MTA_HELPCONTEXT</A> and <A HREF=#MTA_TOOLTIP>MTA_TOOLTIP</A>. 
If you specify that your renderer be launched from a tool palette and 
do not specify <A HREF=#MTA_TOOLTIP>MTA_TOOLTIP</A>, the default 
tool tip text displayed is the name of your renderer as specified in the 
parameter <I>toolName</I>.</P></DD><DD><P>All additional (required and optional) tool attributes are passed 
using variable argument style and must be terminated with 
<A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in module registering the tool</DD><DT><I>toolName</I></DT><DD>the name of the tool</DD><DT><I>startFunc</I></DT><DD>the tool start function that is called 
when the tool is launched</DD><DT><I>userData</I></DT><DD>user defined data that will be passed to 
<I>startFunc</I> when it is called</DD><DT><I>...</I></DT><DD>additional renderer 
specific attributes in variable argument style</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Pointer to plug-in tool registered if successful, <A HREF=#MG_NULL>MG_NULL</A> 
otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=mgRegisterSetMaxId><H1 CLASS="APISYMBOL">mgRegisterSetMaxId</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRegisterSetMaxId</B> - sets the Set Max Id (extension node 
helper) function for a database extension.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgRegisterSetMaxId</B> (</TD><TD><A HREF=#mgpluginsite>mgpluginsite</A></TD><TD><I>pluginSite</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgsetmaxidfunc>mgsetmaxidfunc</A></TD><TD><I>setMaxIdFunc</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgRegisterSetMaxId</B> assigns the specified Set Max Id function 
<I>setMaxIdFunc</I> to the specified data extension site <I>pluginSite</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginSite</I></DT><DD>the data extension site</DD><DT><I>setMaxIdFunc</I></DT><DD>the Set Max Id function</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterSite>mgRegisterSite</A>, <A HREF=#mgRegisterGetMaxId>mgRegisterGetMaxId</A>, <A HREF=#mgRegisterGetHeaderCode>mgRegisterGetHeaderCode</A>, 
<A HREF=#mgsetmaxidfunc>mgsetmaxidfunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgRegisterSite><H1 CLASS="APISYMBOL">mgRegisterSite</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRegisterSite</B> - registers a data extension site.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgpluginsite <B>mgRegisterSite</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>siteId</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#record_def*>record_def*</A></TD><TD><I>recordDefTbl</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode*</A></TD><TD><I>recordCodeMap</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>recordOffset</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>recordMax</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#data_def*>data_def*</A></TD><TD><I>dataDefTbl</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode*</A></TD><TD><I>dataCodeMap</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>dataOffset</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>dataMax</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>...</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgRegisterSite</B> registers a data extension site for 
the specified plug-in module <I>plugin</I> with the specified extension 
site attributes.</P></DD><DD><P>The required extension site attributes include the name of the 
site <I>siteId</I> and several attributes that describe the contents of 
the data extension.  The values provides for these attributes 
are contained in the auto-generated header files for your data extension.</P></DD><DD><P><I>recordDefTbl</I> - &RecordDefTable[0] <BR> 
<I>recordCodeMap</I> - [<I>Prefix</I>]RecordCodeMap <BR> 
<I>recordOffset</I> - [<I>PREFIX</I>]OP_RECORD_OFFSET <BR> 
<I>recordMax</I> - [<I>PREFIX</I>]_RECORD_MAX <BR> 
<I>dataDefTbl</I> - &DataDefTable[0] <BR> 
<I>dataCodeMap</I> - [<I>Prefix</I>]DataCodeMap <BR> 
<I>dataOffset</I> - [<I>PREFIX</I>]OP_DATA_OFFSET <BR> 
<I>dataMax</I> - [<I>PREFIX</I>]_DATA_MAX <BR></P></DD><DD><P>[<I>Prefix</I>] is your site's prefix with the first letter capitalized, 
and [<I>PREFIX</I>] is your site's prefix with all letters capitalized.</P></DD><DD><P>Additional optional extension site attributes include <A HREF=#MTA_VERSION>MTA_VERSION</A> 
and <A HREF=#MTA_HELPCONTEXT>MTA_HELPCONTEXT</A>.</P></DD><DD><P>All additional (required and optional) extension site attributes 
are passed using variable argument style and must be terminated with 
<A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in module registering the data 
extension</DD><DT><I>siteId</I></DT><DD>the name of the extension site</DD><DT><I>recordDefTbl</I></DT><DD>the address of the record definition table for the site</DD><DT><I>recordCodeMap</I></DT><DD>the address of the record code map for the site</DD><DT><I>recordOffset</I></DT><DD>the index of the first record defined by the site</DD><DT><I>recordMax</I></DT><DD>the number of records defined by the site</DD><DT><I>dataDefTbl</I></DT><DD>the address of the data definition table for the site</DD><DT><I>dataCodeMap</I></DT><DD>the address of the data code map for the site</DD><DT><I>dataOffset</I></DT><DD>the index of the first data field defined by the site</DD><DT><I>dataMax</I></DT><DD>the number of data fields defined by the site</DD><DT><I>...</I></DT><DD>additional extension site 
attributes in variable argument style</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the data extension site registered if successful, <A HREF=#MG_NULL>MG_NULL</A> 
otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterGetMaxId>mgRegisterGetMaxId</A>, <A HREF=#mgRegisterSetMaxId>mgRegisterSetMaxId</A>, 
<A HREF=#mgRegisterGetHeaderCode>mgRegisterGetHeaderCode</A>, 
<A HREF=#mgRegisterPreEdit>mgRegisterPreEdit</A>, <A HREF=#mgRegisterPostEdit>mgRegisterPostEdit</A></DD></DL>
<HR>
<LEFT><A NAME=mgRegisterTimer><H1 CLASS="APISYMBOL">mgRegisterTimer</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRegisterTimer</B> - submit a timer request.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgtimer <B>mgRegisterTimer</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>gui</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>timeout</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgtimerfunc>mgtimerfunc</A></TD><TD><I>timerFunc</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgRegisterTimer</B> submits a timer request for a specified time-out 
value <I>timeout</I>.  When the time-out expires, the specified timer function 
<I>timerFunc</I> will be called.</P></DD><DD><P>If the timer request was accepted, a timer object will be created 
and returned by this function.  If you need to cancel the timer before it 
expires, you can call <A HREF=#mgUnregisterTimer>mgUnregisterTimer</A> passing to it the timer object.</P></DD><DD><P>Note: The timer object is destroyed if either your timer function returns 
<A HREF=#mgbool>MG_FALSE</A> or you call <A HREF=#mgUnregisterTimer>mgUnregisterTimer</A> to remove the timer 
request before it expires.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>gui</I></DT><DD>dialog or control to associate timer to</DD><DT><I>timeout</I></DT><DD>time-out value in milliseconds</DD><DT><I>timerFunc</I></DT><DD>timer function to call when time-out expires</DD><DT><I>userData</I></DT><DD>user data to be passed to timer function when it is called</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the timer object if successful, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgUnregisterTimer>mgUnregisterTimer</A>, <A HREF=#mgtimerfunc>mgtimerfunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgRegisterViewer><H1 CLASS="APISYMBOL">mgRegisterViewer</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRegisterViewer</B> - registers a viewer tool.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgplugintool <B>mgRegisterViewer</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>toolName</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgtoolstartfunc>mgtoolstartfunc</A></TD><TD><I>startFunc</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>...</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgRegisterViewer</B> registers a viewer tool for 
the specified plug-in module <I>plugin</I> with the specified tool attributes.</P></DD><DD><P>The required tool attributes include the name of the tool <I>toolName</I>, 
a start function for the tool, <I>startFunc</I> and user defined callback data, 
<I>userData</I> (may be <A HREF=#MG_NULL>MG_NULL</A>) that is passed to the start function 
when it is called.</P></DD><DD><P>Additional required tool attributes include launch location attributes. 
Your tool can be launched from either a tool palette or menu. 
If your tool is to be launched from a tool palette, you must specify 
<A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A> and <A HREF=#MTA_PALETTEICON>MTA_PALETTEICON</A>. 
If your tool is to be launched from a menu, you must specify 
<A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A> and <A HREF=#MTA_MENULABEL>MTA_MENULABEL</A>.  Additional optional tool 
attributes for tools launched from a menu include <A HREF=#MTA_MENUPOSITION>MTA_MENUPOSITION</A> 
and <A HREF=#MTA_MENUSUBMENU>MTA_MENUSUBMENU</A>.</P></DD><DD><P>Additional optional tool attributes for all viewer tools include 
<A HREF=#MTA_VERSION>MTA_VERSION</A>, <A HREF=#MTA_HELPCONTEXT>MTA_HELPCONTEXT</A> and <A HREF=#MTA_TOOLTIP>MTA_TOOLTIP</A>.  If you specify that 
your tool be launched from a tool&#32palette and do not specify <A HREF=#MTA_TOOLTIP>MTA_TOOLTIP</A>, 
the default tool tip text displayed is the name of your tool as specified in 
the parameter <I>toolName</I>.</P></DD><DD><P>All additional (required and optional) tool attributes are passed 
using variable argument style and must be terminated with 
<A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in module registering the tool</DD><DT><I>toolName</I></DT><DD>the name of the tool</DD><DT><I>startFunc</I></DT><DD>the tool start function that is called 
when the tool is launched</DD><DT><I>userData</I></DT><DD>user defined data that will be passed to 
<I>startFunc</I> when it is called</DD><DT><I>...</I></DT><DD>additional viewer tool 
specific attributes in variable argument style</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Pointer to plug-in tool registered if successful, <A HREF=#MG_NULL>MG_NULL</A> 
otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=mgRemove><H1 CLASS="APISYMBOL">mgRemove</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRemove</B> - temporarily deletes a node record from a database.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgRemove</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgRemove</B> temporarily deletes the specified node record 
<I>rec</I>.  Node records that have been temporarily deleted in this 
way may be un-deleted later using the function <A HREF=#mgUnRemove>mgUnRemove</A>. 
This is useful for editor class plug-in tools to implement undo.</P></DD><DD><P>Records that have been temporarily deleted using this function 
is detached and appears to be completely deleted from the database. 
After <I>rec</I> has been removed in this way, the only OpenFlight API 
functions that accept <I>rec</I> are <A HREF=#mgUnRemove>mgUnRemove</A> which 
un-removes it and <A HREF=#mgDelete>mgDelete</A> which permanently deletes it.</P></DD><DD><P>This function is only applicable for node records in 
the Creator modeler environment.  Calling this function in the 
stand-alone application environment does nothing.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record to remove</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgDelete>mgDelete</A>, <A HREF=#mgDetach>mgDetach</A>, <A HREF=#mgUnRemove>mgUnRemove</A></DD></DL>
<HR>
<LEFT><A NAME=mgRemoveVtxNormal><H1 CLASS="APISYMBOL">mgRemoveVtxNormal</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRemoveVtxNormal</B> - removes the normal vector from a 
vertex record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgRemoveVtxNormal</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgRemoveVtxNormal</B> removes the normal vector from the 
specified vertex record <I>rec</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>a vertex record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the vertex normal was removed, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetVtxNormal>mgSetVtxNormal</A>, <A HREF=#mgGetVtxNormal>mgGetVtxNormal</A></DD></DL>
<HR>
<LEFT><A NAME=mgrendererfunc><H1 CLASS="APISYMBOL">mgrendererfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgrendererfunc</B> - Renderer function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void (*<B>mgrendererfunc</B>) ( <TD><A HREF=#mgrenderercontext>mgrenderercontext</A> <TD><I>rendererContext</I>, 
<TR><TD></TD><TD><A HREF=#mgrenderercallbackreason>mgrenderercallbackreason</A> <TD><I>callbackReason</I>, 
<TR><TD></TD><TD>void* <TD><I>rendererToolData</I>, 
<TR><TD></TD><TD>void* <TD><I>callData</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for renderer functions.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rendererContext</I></DT><DD>the renderer context that identifies the 
renderer instance</DD><DT><I>callbackReason</I></DT><DD>the renderer event that triggered the callback</DD><DT><I>rendererToolData</I></DT><DD>user defined tool instance data 
set in <I>toolData</I> field of <I>callData</I> 
parameter (<A HREF=#mgrenderercallbackrec>mgrenderercallbackrec</A>) during 
renderer tool start function <A HREF=#mgtoolstartfunc>mgtoolstartfunc</A></DD><DT><I>callData</I></DT><DD>callback specific data</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Currently, the value returned by <A HREF=#mgrendererfunc>mgrendererfunc</A> is ignored and 
reserved for future enhancement.  For now always return <A HREF=#MSTAT_OK>MSTAT_OK</A>.
</DD></DL><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRendererSetRendererFunc>mgRendererSetRendererFunc</A>, <A HREF=#mgRegisterRenderer>mgRegisterRenderer</A></DD></DL>
<HR>
<LEFT><A NAME=mgRendererGetViewHandle><H1 CLASS="APISYMBOL">mgRendererGetViewHandle</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRendererGetViewHandle</B> - return a view control handle for 
a renderer.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mggui <B>mgRendererGetViewHandle</B> (</TD><TD><A HREF=#mgrenderercontext>mgrenderercontext</A></TD><TD><I>rendererContext</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgRendererGetViewHandle</B> returns a platform specific handle 
to the view control in Creator associated to a renderer instance 
<I>rendererContext</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rendererContext</I></DT><DD>the renderer context to get 
associated view handle</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>On Windows, this function returns an object of type HWND 
corresponding to the view control in Creator associated with the 
<I>rendererContext</I>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterRenderer>mgRegisterRenderer</A></DD></DL>
<HR>
<LEFT><A NAME=mgRendererSetRendererFunc><H1 CLASS="APISYMBOL">mgRendererSetRendererFunc</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRendererSetRendererFunc</B> - registers a renderer function 
for a renderer.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgRendererSetRendererFunc</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>rendererPluginTool</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrendererfunc>mgrendererfunc</A></TD><TD><I>rendererFunc</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrenderercontext>mgrenderercontext</A></TD><TD><I>rendererContext</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>eyex</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>eyey</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>eyez</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>centerx</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>centery</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>centerz</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>upx</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>upy</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>upz</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>eyex</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>eyey</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>eyez</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>centerx</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>centery</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>centerz</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>upx</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>upy</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>upz</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgRendererSetRendererFunc</B> registers the renderer function for 
a renderer.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rendererPluginTool</I></DT><DD>the renderer plug-in tool to 
which this renderer function is to 
be applied</DD><DT><I>rendererFunc</I></DT><DD>the renderer function</DD><DT><I>rendererContext</I></DT><DD>the renderer context to get 
associated view handle</DD><DT><I>db</I></DT><DD>the database</DD><DT><I>eyex</I></DT><DD>the x component of the eyepoint position</DD><DT><I>eyey</I></DT><DD>the y component of the eyepoint position</DD><DT><I>eyez</I></DT><DD>the z component of the eyepoint position</DD><DT><I>centerx</I></DT><DD>the x component of the reference point</DD><DT><I>centery</I></DT><DD>the y component of the reference point</DD><DT><I>centerz</I></DT><DD>the z component of the reference point</DD><DT><I>upx</I></DT><DD>the i component of the up vector</DD><DT><I>upy</I></DT><DD>the j component of the up vector</DD><DT><I>upz</I></DT><DD>the k component of the up vector</DD><DT><I>db</I></DT><DD>the database</DD><DT><I>eyex</I></DT><DD>the x component of the eyepoint position</DD><DT><I>eyey</I></DT><DD>the y component of the eyepoint position</DD><DT><I>eyez</I></DT><DD>the z component of the eyepoint position</DD><DT><I>centerx</I></DT><DD>the x component of the reference point</DD><DT><I>centery</I></DT><DD>the y component of the reference point</DD><DT><I>centerz</I></DT><DD>the z component of the reference point</DD><DT><I>upx</I></DT><DD>the i component of the up vector</DD><DT><I>upy</I></DT><DD>the j component of the up vector</DD><DT><I>upz</I></DT><DD>the k component of the up vector</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterRenderer>mgRegisterRenderer</A></DD></DL>
<HR>
<LEFT><A NAME=mgReplaceTexture><H1 CLASS="APISYMBOL">mgReplaceTexture</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgReplaceTexture</B> - replaces a texture palette entry 
with a texture from a given file.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgReplaceTexture</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>textureName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgReplaceTexture</B> replaces the texture palette entry specified 
by <I>index</I> with an image and attributes from files specified by 
<I>textureName</I> (the attributes file is <I>textureName</I> appended 
with ".attr").  If there is no attributes file, default attributes 
are created and used.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the texture palette entry</DD><DT><I>textureName</I></DT><DD>the name of the texture file to replace 
<I>index</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if <I>index</I> is valid for this <I>db</I> 
and the new texture assigned to the  palette has a different name than the 
original texture at <I>index</I>, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadTextureAndAlpha>mgReadTextureAndAlpha</A>, <A HREF=#mgReadTexture>mgReadTexture</A>, <A HREF=#mgInsertTexture>mgInsertTexture</A>, <A HREF=#mgReadTexture>mgReadTexture</A></DD></DL>
<HR>
<LEFT><A NAME=mgResetRecList><H1 CLASS="APISYMBOL">mgResetRecList</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgResetRecList</B> - resets the traversal pointer of a record 
list to the first item in the list.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgResetRecList</B> (</TD><TD><A HREF=#mgreclist>mgreclist</A></TD><TD><I>recList</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgResetRecList</B> resets the internal traversal pointer of the 
specified record list <I>recList</I> to the first item in the list.</P></DD><DD><P>The traversal pointer of a record list keeps track of the item 
in the list that is returned by the next call to <A HREF=#mgGetNextRecInList>mgGetNextRecInList</A>. 
Calling this function insures that the next call to <A HREF=#mgGetNextRecInList>mgGetNextRecInList</A> 
returns the first item in the record list.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>recList</I></DT><DD>the record list to reset</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetNextRecInList>mgGetNextRecInList</A>, <A HREF=#mgGetNthRecInList>mgGetNthRecInList</A>, <A HREF=#mgIsRecInList>mgIsRecInList</A></DD></DL>
<HR>
<LEFT><A NAME=mgResetView><H1 CLASS="APISYMBOL">mgResetView</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgResetView</B> - resets the current view.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgResetView</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgResetView</B> resets the current view in <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the graphics view was set 
in Creator, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgFitOnNode>mgFitOnNode</A>, 
<A HREF=#mgFitOnGrid>mgFitOnGrid</A>, 
<A HREF=#mgFitOnRecList>mgFitOnRecList</A>, 
<A HREF=#mgFitOnSelect>mgFitOnSelect</A></DD></DL>
<HR>
<LEFT><A NAME=mgResourceGetCursor><H1 CLASS="APISYMBOL">mgResourceGetCursor</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgResourceGetCursor</B> - retrieves a cursor from 
a resource.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcursor <B>mgResourceGetCursor</B> (</TD><TD><A HREF=#mgresource>mgresource</A></TD><TD><I>resource</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcursorid>mgcursorid</A></TD><TD><I>cursorId</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgResourceGetCursor</B> retrieves a cursor corresponding to 
a specified cursor identifier <I>cursorId</I> from the <I>resource</I>.</P></DD><DD><P>The OpenFlight API provides several predefined cursors.  To use 
one of these predefined cursors, set <I>resource</I> to <A HREF=#MG_NULL>MG_NULL</A> and 
set <I>cursorId</I> to one of the following values:</P></DD><DD><P><A HREF=#MCURS_ARROW>MCURS_ARROW</A><BR> 
<A HREF=#MCURS_WAIT>MCURS_WAIT</A><BR> 
<A HREF=#MCURS_CROSS>MCURS_CROSS</A><BR> 
<A HREF=#MCURS_NO>MCURS_NO</A><BR> 
<A HREF=#MCURS_SIZEALL>MCURS_SIZEALL</A><BR> 
<A HREF=#MCURS_SIZENESW>MCURS_SIZENESW</A><BR> 
<A HREF=#MCURS_SIZENS>MCURS_SIZENS</A><BR> 
<A HREF=#MCURS_SIZENWSE>MCURS_SIZENWSE</A><BR> 
<A HREF=#MCURS_SIZEWE>MCURS_SIZEWE</A><BR> 
<A HREF=#MCURS_UPARROW>MCURS_UPARROW</A><BR> 
<A HREF=#MCURS_ZOOMIN>MCURS_ZOOMIN</A><BR> 
<A HREF=#MCURS_ZOOMOUT>MCURS_ZOOMOUT</A><BR> 
<A HREF=#MCURS_SPIN>MCURS_SPIN</A><BR> 
<A HREF=#MCURS_PEN>MCURS_PEN</A><BR> 
<A HREF=#MCURS_BUCKET>MCURS_BUCKET</A><BR> 
<A HREF=#MCURS_EYEDROPPER>MCURS_EYEDROPPER</A><BR> 
<A HREF=#MCURS_SPLITH>MCURS_SPLITH</A><BR> 
<A HREF=#MCURS_SPLITV>MCURS_SPLITV</A><BR></P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>resource</I></DT><DD>the resource containing the cursor</DD><DT><I>cursorId</I></DT><DD>the cursor identifier</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>If the cursor is found in the resource, the abstract representation 
of the cursor is returned, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCursor>mgSetCursor</A>, <A HREF=#mgLoadResource>mgLoadResource</A>, <A HREF=#mgResourceGetString>mgResourceGetString</A>, 
<A HREF=#mgResourceGetPixmap>mgResourceGetPixmap</A>, <A HREF=#mgResourceGetDialog>mgResourceGetDialog</A>, <A HREF=#mgGetCursorHandle>mgGetCursorHandle</A></DD></DL>
<HR>
<LEFT><A NAME=mgResourceGetDialog><H1 CLASS="APISYMBOL">mgResourceGetDialog</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgResourceGetDialog</B> - creates a dialog instance derived 
from a dialog template contained in a resource.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mggui <B>mgResourceGetDialog</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>gui</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgresource>mgresource</A></TD><TD><I>resource</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgdialogid>mgdialogid</A></TD><TD><I>dialogId</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>callbackMask</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgdialogfunc>mgdialogfunc</A></TD><TD><I>dialogFunc</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgResourceGetDialog</B> builds a dialog instance using a dialog 
template extracted from the specified <I>resource</I>.  The dialog template 
is identified in the <I>resource</I> by <I>dialogId</I>.</P></DD><DD><P>Specify a dialog function <I>dialogFunc</I> for the created 
dialog and select the dialog events you are interested in for your 
<I>dialogFunc</I> using the parameter <I>callbackMask</I>.</P></DD><DD><P>The dialog is created as a child of the dialog specified by <I>gui</I>. 
Note that <I>gui</I> can be a control, a dialog or <A HREF=#MG_NULL>MG_NULL</A>.  If <I>gui</I> 
is a control, it is assumed to be contained in the dialog that is to be 
the parent.  If <I>gui</I> is a dialog, it is the dialog to be the parent. 
If <I>gui</I> is <A HREF=#MG_NULL>MG_NULL</A>, the dialog is created as a 
child of the MultiGen modeling system main window.</P></DD><DD><P>The dialog created is not displayed until you explicitly do so by 
calling <A HREF=#mgShowDialog>mgShowDialog</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>gui</I></DT><DD>the dialog parent or a control in the dialog 
that is to be the parent</DD><DT><I>resource</I></DT><DD>the resource containing the dialog template</DD><DT><I>dialogId</I></DT><DD>the dialog template identifier</DD><DT><I>callbackMask</I></DT><DD>bitwise combination of dialog events selected 
for dialog function <I>dialogfunc</I> - choose any bitwise 
combination of <A HREF=#MGCB_INIT>MGCB_INIT</A>, <A HREF=#MGCB_SHOW>MGCB_SHOW</A>, 
<A HREF=#MGCB_REFRESH>MGCB_REFRESH</A>, <A HREF=#MGCB_HIDE>MGCB_HIDE</A> and <A HREF=#MGCB_DESTROY>MGCB_DESTROY</A></DD><DT><I>dialogFunc</I></DT><DD>dialog function to assign to dialog</DD><DT><I>userData</I></DT><DD>user defined data to pass to <I>dialogfunc</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>If the dialog template is found in the resource and the dialog 
instance is successfully created, the dialog instance is returned, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgLoadResource>mgLoadResource</A>, <A HREF=#mgResourceModalDialog>mgResourceModalDialog</A>, <A HREF=#mgShowDialog>mgShowDialog</A></DD></DL>
<HR>
<LEFT><A NAME=mgResourceGetPixmap><H1 CLASS="APISYMBOL">mgResourceGetPixmap</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgResourceGetPixmap</B> - retrieves a pixmap from 
a resource.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgpixmap <B>mgResourceGetPixmap</B> (</TD><TD><A HREF=#mgresource>mgresource</A></TD><TD><I>resource</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgpixmapid>mgpixmapid</A></TD><TD><I>pixmapId</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgResourceGetPixmap</B> retrieves a pixmap corresponding to 
a specified pixmap identifier <I>pixmapId</I> from the <I>resource</I>.</P></DD><DD><P>On Windows, both bitmaps and icons can be extracted as pixmaps. 
This function provides an abstraction layer for both types of images and 
will behave accordingly based on the contents of the resource file from 
which the image is being extracted.</P></DD><DD><P>The OpenFlight API provides several predefined pixmaps.  To use 
one of these predefined pixmaps, set <I>resource</I> to <A HREF=#MG_NULL>MG_NULL</A> and 
set <I>pixmapId</I> to one of the following values:</P></DD><DD><P><A HREF=#MPIXMAP_NEWFILE>MPIXMAP_NEWFILE</A><BR> 
<A HREF=#MPIXMAP_OPENFILE>MPIXMAP_OPENFILE</A><BR> 
<A HREF=#MPIXMAP_SAVEFILE>MPIXMAP_SAVEFILE</A><BR> 
<A HREF=#MPIXMAP_CUT>MPIXMAP_CUT</A><BR> 
<A HREF=#MPIXMAP_COPY>MPIXMAP_COPY</A><BR> 
<A HREF=#MPIXMAP_PASTE>MPIXMAP_PASTE</A><BR> 
<A HREF=#MPIXMAP_DELETE>MPIXMAP_DELETE</A><BR> 
<A HREF=#MPIXMAP_EDIT>MPIXMAP_EDIT</A><BR> 
<A HREF=#MPIXMAP_TEST>MPIXMAP_TEST</A><BR> 
<A HREF=#MPIXMAP_UNDO>MPIXMAP_UNDO</A><BR> 
<A HREF=#MPIXMAP_REDO>MPIXMAP_REDO</A><BR> 
<A HREF=#MPIXMAP_ROTATEVIEW>MPIXMAP_ROTATEVIEW</A><BR> 
<A HREF=#MPIXMAP_PANVIEW>MPIXMAP_PANVIEW</A><BR> 
<A HREF=#MPIXMAP_ZOOMVIEW>MPIXMAP_ZOOMVIEW</A><BR> 
<A HREF=#MPIXMAP_ARROW>MPIXMAP_ARROW</A><BR> 
<A HREF=#MPIXMAP_FENCE>MPIXMAP_FENCE</A><BR> 
<A HREF=#MPIXMAP_LASSO>MPIXMAP_LASSO</A><BR> 
<A HREF=#MPIXMAP_FITONFENCE>MPIXMAP_FITONFENCE</A><BR></P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>resource</I></DT><DD>the resource containing the pixmap</DD><DT><I>pixmapId</I></DT><DD>the pixmap identifier</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>If the pixmap is found in the resource, the abstract representation 
of the pixmap is returned, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgLoadResource>mgLoadResource</A>, <A HREF=#mgResourceGetString>mgResourceGetString</A>, <A HREF=#mgGetPixmapHandle>mgGetPixmapHandle</A>, 
<A HREF=#mgResourceGetDialog>mgResourceGetDialog</A></DD></DL>
<HR>
<LEFT><A NAME=mgResourceGetString><H1 CLASS="APISYMBOL">mgResourceGetString</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgResourceGetString</B> - retrieves a string definition from 
a resource.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgResourceGetString</B> (</TD><TD><A HREF=#mgresource>mgresource</A></TD><TD><I>resource</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgstringid>mgstringid</A></TD><TD><I>stringId</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>buf</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maxLen</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgResourceGetString</B> retrieves a text string corresponding to 
a specified string definition identifier <I>stringId</I> from the <I>resource</I>.</P></DD><DD><P>If the string definition is found in the resource, the text is 
copied into <I>buf</I>.  The string is truncated and  null terminated 
if it is longer than <I>maxLen</I> characters.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>resource</I></DT><DD>the resource containing the string definition</DD><DT><I>stringId</I></DT><DD>the string definition identifier</DD><DT><I>buf</I></DT><DD>character buffer to hold text string retrieved</DD><DT><I>maxLen</I></DT><DD>the maximum number of characters to store in <I>buf</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgLoadResource>mgLoadResource</A>, <A HREF=#mgResourceGetPixmap>mgResourceGetPixmap</A>, <A HREF=#mgResourceGetDialog>mgResourceGetDialog</A></DD></DL>
<HR>
<LEFT><A NAME=mgResourceModalDialog><H1 CLASS="APISYMBOL">mgResourceModalDialog</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgResourceModalDialog</B> - displays a modal dialog instance 
derived from a dialog template contained in a resource.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgResourceModalDialog</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>gui</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgresource>mgresource</A></TD><TD><I>resource</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgdialogid>mgdialogid</A></TD><TD><I>dialogId</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>callbackMask</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgdialogfunc>mgdialogfunc</A></TD><TD><I>dialogFunc</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgResourceModalDialog</B> creates and displays a modal dialog instance 
using a dialog template extracted from the specified <I>resource</I>.  The dialog 
template is identified in the <I>resource</I> by <I>dialogId</I>.</P></DD><DD><P>Specify a dialog function <I>dialogFunc</I> for the created 
dialog and select the dialog events you are interested in for your 
<I>dialogFunc</I> using the parameter <I>callbackMask</I>.</P></DD><DD><P>The dialog is created as a child of the dialog specified by <I>gui</I>. 
Note that <I>gui</I> can be a control, a dialog or <A HREF=#MG_NULL>MG_NULL</A>.  If <I>gui</I> 
is a control, it is assumed to be contained in the dialog that is to be 
the parent.  If <I>gui</I> is a dialog, it is the dialog to be the parent. 
If <I>gui</I> is <A HREF=#MG_NULL>MG_NULL</A>, the dialog is created as a 
child of the MultiGen modeling system main window.</P></DD><DD><P>The dialog is displayed automatically and this function 
is returned until the user explicitly dismisses it.  When the user dismisses 
the dialog, the dialog is destroyed.</P></DD><DD><P>The user can dismiss the dialog by pressing one of two predefined 
push buttons or clicking the close icon on the title bar of the dialog. 
The dialog must include at least one of these controls so that the 
user can dismiss the dialog.  The two predefined push buttons 
are expected to have the indentifiers <A HREF=#MGID_OK>MGID_OK</A> and <A HREF=#MGID_CANCEL>MGID_CANCEL</A>, 
corresponding to "OK" and "Cancel", respectively.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>gui</I></DT><DD>the dialog parent or a control in the dialog 
that is to be the parent</DD><DT><I>resource</I></DT><DD>the resource containing the dialog template</DD><DT><I>dialogId</I></DT><DD>the dialog template identifier</DD><DT><I>callbackMask</I></DT><DD>bitwise combination of dialog events selected 
for dialog function <I>dialogfunc</I> - choose any bitwise 
combination of <A HREF=#MGCB_INIT>MGCB_INIT</A>, <A HREF=#MGCB_SHOW>MGCB_SHOW</A>, 
<A HREF=#MGCB_REFRESH>MGCB_REFRESH</A>, <A HREF=#MGCB_HIDE>MGCB_HIDE</A> and <A HREF=#MGCB_DESTROY>MGCB_DESTROY</A></DD><DT><I>dialogFunc</I></DT><DD>dialog function to assign to dialog</DD><DT><I>userData</I></DT><DD>user defined data to pass to <I>dialogfunc</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns 1 if the user dismisses the dialog by pressing the button with the 
identifier <A HREF=#MGID_OK>MGID_OK</A>.
Returns 2 if the user dismisses the dialog by pressing the button with the 
identifier <A HREF=#MGID_CANCEL>MGID_CANCEL</A> or if the user clicked the close icon on 
the title bar of the dialog.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMessageDialog>mgMessageDialog</A>, <A HREF=#mgPromptDialogInteger>mgPromptDialogInteger</A>, <A HREF=#mgPromptDialogFloat>mgPromptDialogFloat</A>, 
<A HREF=#mgPromptDialogDouble>mgPromptDialogDouble</A>, <A HREF=#mgPromptDialogString>mgPromptDialogString</A></DD></DL>
<HR>
<LEFT><A NAME=mgReversePoly><H1 CLASS="APISYMBOL">mgReversePoly</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgReversePoly</B> - Reverses the order of the vertices in a polygon.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgReversePoly</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>poly</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgReversePoly</B> reverses the order of the vertices in the specified 
polygon <I>poly</I>.  This has the effect of reversing which side of the polygon 
is considered the "front".</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>poly</I></DT><DD>polygon whose vertices are to be reversed</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.  If successful, the vertices of <I>poly</I> 
will be in the reverse order after the function completes, otherwise 
the vertex order will be unchanged.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<HR>
<LEFT><A NAME=mgRGB2Index><H1 CLASS="APISYMBOL">mgRGB2Index</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgRGB2Index</B> - finds the color palette entry and intensity 
which most closely matches RGB values.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgRGB2Index</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>red</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>green</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>blue</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int*</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>intensity</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, index, intensity <B>mgRGB2Index</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>red</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>green</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>blue</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a database node <I>db</I>, and red, green, and blue values 
<I>red</I>, <I>green</I>, and <I>blue</I>, <B>mgRGB2Index</B> returns the index, <I>index</I>, 
and intensity, <I>intensity</I>, of the closest match in the database&#146s color 
palette. The best match is determined by the least sum of squares method.</P></DD><DD><P>The color components supplied must range from 0 to 255.  The intensity 
value returned will range from 0.0-1.0.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>red</I></DT><DD>the red value, which ranges from 0 to 255</DD><DT><I>green</I></DT><DD>the green value, which ranges from 0 to 255</DD><DT><I>blue</I></DT><DD>the blue value, which ranges from 0 to 255</DD><DT><I>index</I></DT><DD>address of value to receive palette index</DD><DT><I>intensity</I></DT><DD>address of value to receive intensity value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the index could be converted successfully, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>index</DT><DD>If function is successful, index contains the retrieved index, otherwise 
index is undefined.</DD><DT>intensity</DT><DD>If function is successful, intensity contains the retrieved intensity, otherwise 
intensity is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgIndex2RGB>mgIndex2RGB</A></DD></DL>
<HR>
<LEFT><A NAME=mgSaveAsDb><H1 CLASS="APISYMBOL">mgSaveAsDb</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSaveAsDb</B> - writes an OpenFlight database to disk with a 
specified name.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSaveAsDb</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fileName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given the database, <I>db</I>, and a file name, <I>fileName</I>, 
<B>mgSaveAsDb</B> writes this database to disk using the file name.</P></DD><DD><P>The in-memory representation of <I>db</I> is modified by this 
function.  In particular, the database <I>db</I> takes on the file name 
passed to <B>mgSaveAsDb</B> and the original name is no longer used. 
Because of this, subsequent calls to <A HREF=#mgWriteDb>mgWriteDb</A> will write out 
the new file name, not the original.</P></DD><DD><P>Note: If you call this function in Creator, it will fail if 
either <I>db</I> or the named file is open on the Creator desktop.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database to write</DD><DT><I>fileName</I></DT><DD>the new file name</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* db;
db = mgOpenDb ("file.flt");
mgSaveAsDb (db, "newname.flt");

// make some more changes to db...

mgWriteDb (db); // will write out "newname.flt"
mgClose (db);</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgOpenDb>mgOpenDb</A>, <A HREF=#mgNewDb>mgNewDb</A>, <A HREF=#mgCloseDb>mgCloseDb</A>, <A HREF=#mgWriteDb>mgWriteDb</A>, 
<A HREF=#mgExportDb>mgExportDb</A>, <A HREF=#mgSetNewOverwriteFlag>mgSetNewOverwriteFlag</A></DD></DL>
<HR>
<LEFT><A NAME=mgScaleGetMinMax><H1 CLASS="APISYMBOL">mgScaleGetMinMax</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgScaleGetMinMax</B> - retrieves the minimum and maximum 
logical values for a scale control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgScaleGetMinMax</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>min</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>max</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgScaleGetMinMax</B> returns the range of values valid for the 
specified scale <I>control</I>.  The minimum value is returned in 
<I>min</I>, the maximum in <I>max</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the scale control</DD><DT><I>min</I></DT><DD>address of double value to receive 
minimum value from control</DD><DT><I>max</I></DT><DD>address of double value to receive 
maximum value from control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.  If 
function is successful, <I>min</I> and <I>max</I> contain the corresponding minimum 
and maximum values, otherwise their contents are undefined.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgScaleSetMinMax>mgScaleSetMinMax</A>, <A HREF=#mgScaleSetValue>mgScaleSetValue</A>, <A HREF=#mgScaleGetValue>mgScaleGetValue</A></DD></DL>
<HR>
<LEFT><A NAME=mgScaleGetValue><H1 CLASS="APISYMBOL">mgScaleGetValue</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgScaleGetValue</B> - retrieves the current value of a scale 
control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgScaleGetValue</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>value</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgScaleGetValue</B> returns the current value of the specified scale 
<I>control</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the scale control</DD><DT><I>value</I></DT><DD>address of double value to receive 
current value from control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.  If 
function is successful, <I>value</I> contains the current value of the 
control, otherwise <I>value</I> is undefined.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgScaleSetValue>mgScaleSetValue</A>, <A HREF=#mgScaleSetMinMax>mgScaleSetMinMax</A>, <A HREF=#mgScaleGetMinMax>mgScaleGetMinMax</A></DD></DL>
<HR>
<LEFT><A NAME=mgScaleSetMinMax><H1 CLASS="APISYMBOL">mgScaleSetMinMax</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgScaleSetMinMax</B> - sets the minimum and maximum logical 
values for a scale control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgScaleSetMinMax</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>min</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>max</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgScaleSetMinMax</B> sets the range of logical values valid for the 
specified scale <I>control</I>.  The minimum value is specified 
by <I>min</I>, the maximum by <I>max</I>.</P></DD><DD><P>The default minimum and maximum values for a scale control are 0 
and 100 respectively.</P></DD><DD><P>If the current scale value is outside the new range, the scale value 
will be clamped to the new maximum or minimum value.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the scale control</DD><DT><I>min</I></DT><DD>the minimum value for the control</DD><DT><I>max</I></DT><DD>the maximum value for the control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgScaleGetMinMax>mgScaleGetMinMax</A>, <A HREF=#mgScaleSetValue>mgScaleSetValue</A>, <A HREF=#mgScaleGetValue>mgScaleGetValue</A></DD></DL>
<HR>
<LEFT><A NAME=mgScaleSetSpinBuddy><H1 CLASS="APISYMBOL">mgScaleSetSpinBuddy</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgScaleSetSpinBuddy</B> - associates a spin buddy control 
to a scale control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgScaleSetSpinBuddy</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>spinControl</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgScaleSetSpinBuddy</B> associates the specified spin buddy control, 
<I>spinControl</I>, to the specified scale <I>control</I>.</P></DD><DD><P>A spin buddy control will direct user input from itself to the 
associated scale control.  As the user clicks the up or down arrows of 
the spin control, the value of the scale control will increase or decrease 
accordingly.</P></DD><DD><P>The amount that the scale control value will increase/decrease when 
either arrow of the spin buddy control is pressed can be set by calling 
<A HREF=#mgScaleSetSpinIncrement>mgScaleSetSpinIncrement</A>.  The default spin increment is 1.0.</P></DD><DD><P>A scale control can have at most one spin buddy control.  Furthermore, 
once you associate a spin buddy control to a given scale control using this 
function, you cannot change which spin buddy is associated to that scale 
control by calling this function again.</P></DD><DD><P>After associating a buddy control to a scale control, the two controls 
will behave as one.  In particular, when calling <A HREF=#mgSetEnabled>mgSetEnabled</A> or 
<A HREF=#mgSetVisible>mgSetVisible</A> for the scale control, both the scale and the buddy 
control will be affected simultaneously and automatically.  Furthermore, 
when accessing the resulting composite control, you must use the scale 
control object, not the buddy control object.  Performing operations on the 
buddy control explicitly is not supported and the results are undefined.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the scale control</DD><DT><I>spinControl</I></DT><DD>the spin control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgScaleSetSpinIncrement>mgScaleSetSpinIncrement</A>, <A HREF=#mgScaleSetTextBuddy>mgScaleSetTextBuddy</A>, <A HREF=#mgSetGuiCallback>mgSetGuiCallback</A></DD></DL>
<HR>
<LEFT><A NAME=mgScaleSetSpinIncrement><H1 CLASS="APISYMBOL">mgScaleSetSpinIncrement</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgScaleSetSpinIncrement</B> - sets the spin increment for 
a scale control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgScaleSetSpinIncrement</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>increment</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgScaleSetSpinIncrement</B> sets the spin increment value for the 
specified scale <I>control</I> to the specified value, <I>increment</I>.</P></DD><DD><P>The spin increment value is the value that a scale control is 
incremented or decremented when the user clicks the up/down arrow buttons 
of the spin buddy control associated to the scale control.  The default 
value for this spin increment is 1.0.</P></DD><DD><P>If <I>increment</I> is positive, the up arrow of the spin control will 
increase the value of the scale control and the down arrow will decrease it. 
If <I>increment</I> is negative, the up arrow will decrease the scale's value 
and the down arrow will increase it.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the scale control</DD><DT><I>increment</I></DT><DD>the increment value for the control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgScaleSetSpinBuddy>mgScaleSetSpinBuddy</A>, <A HREF=#mgScaleSetTextBuddy>mgScaleSetTextBuddy</A></DD></DL>
<HR>
<LEFT><A NAME=mgScaleSetTextBuddy><H1 CLASS="APISYMBOL">mgScaleSetTextBuddy</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgScaleSetTextBuddy</B> - associates a text buddy control 
to a scale control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgScaleSetTextBuddy</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>textControl</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgScaleSetTextBuddy</B> associates the specified text buddy control, 
<I>textControl</I>, to the specified scale <I>control</I>.</P></DD><DD><P>A text buddy control will accept input from the user and automatically 
apply it to the associated scale control.  The text buddy control will also 
automatically display the current value of the scale control when the scale 
value changes.</P></DD><DD><P>A scale control can have at most one text buddy control.  Furthermore, 
once you associate a text buddy control to a given scale control using this 
function, you cannot change which text buddy is associated to that scale 
control by calling this function again.</P></DD><DD><P>After associating a buddy control to a scale control, the two controls 
will behave as one.  In particular, when calling <A HREF=#mgSetEnabled>mgSetEnabled</A> or 
<A HREF=#mgSetVisible>mgSetVisible</A> for the scale control, both the scale and the buddy 
control will be affected simultaneously and automatically.  Furthermore, 
when accessing the resulting composite control, you must use the scale 
control object, not the buddy control object.  Performing operations on the 
buddy control explicitly is not supported and the results are undefined.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the scale control</DD><DT><I>textControl</I></DT><DD>the text control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgScaleSetTextFormat>mgScaleSetTextFormat</A>, <A HREF=#mgScaleSetSpinBuddy>mgScaleSetSpinBuddy</A>, <A HREF=#mgSetGuiCallback>mgSetGuiCallback</A></DD></DL>
<HR>
<LEFT><A NAME=mgScaleSetTextFormat><H1 CLASS="APISYMBOL">mgScaleSetTextFormat</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgScaleSetTextFormat</B> - sets the text format string for 
a scale control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgScaleSetTextFormat</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fmtString</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgScaleSetTextFormat</B> sets the format string for the text buddy of 
a scale control.  The format string, <I>fmtString</I>, is assumed to be a 
<B>printf</B> style format string and is used to automatically format the 
numeric value that is displayed in the text buddy control associated 
to the scale control.</P></DD><DD><P>Since the value represented by a scale control is of type double, you 
may, for example, use this format string to effectively display integer values 
in the scale control by using a format string similar to "%.0lf".  See <B>printf</B> 
for more details on allowable format strings.</P></DD><DD><P>The default format string for a text buddy control is "%lf".</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the scale control</DD><DT><I>fmtString</I></DT><DD>the format string for the text buddy</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgScaleSetTextBuddy>mgScaleSetTextBuddy</A>, <A HREF=#mgScaleSetSpinBuddy>mgScaleSetSpinBuddy</A></DD></DL>
<HR>
<LEFT><A NAME=mgScaleSetValue><H1 CLASS="APISYMBOL">mgScaleSetValue</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgScaleSetValue</B> - sets the value of a scale control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgScaleSetValue</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>value</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgScaleSetValue</B> sets the value of a scale <I>control</I>, 
to the specified <I>value</I>.</P></DD><DD><P>If the value you specify is greater than the maximum value allowed for 
the scale control, the scale value will be set to the maximum scale value. 
Similarly, if value is less than the minimum scale value, the scale value will 
be set to the minimum scale value.</P></DD><DD><P>If the scale control has a text buddy control, the text control will 
be updated automatically.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the scale control</DD><DT><I>value</I></DT><DD>the value for the control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgScaleGetValue>mgScaleGetValue</A>, <A HREF=#mgScaleSetMinMax>mgScaleSetMinMax</A>, <A HREF=#mgScaleGetMinMax>mgScaleGetMinMax</A></DD></DL>
<HR>
<LEFT><A NAME=mgSelectList><H1 CLASS="APISYMBOL">mgSelectList</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSelectList</B> - selects all node in a record list.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgSelectList</B> (</TD><TD><A HREF=#mgreclist>mgreclist</A></TD><TD><I>list</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSelectList</B> selects all nodes in <I>list</I>.  Any node that was 
currently selected remains selected.  If you want only the nodes in <I>list</I> 
to be selected, call <A HREF=#mgDeselectAll>mgDeselectAll</A> before calling <B>mgSelectList</B>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>list</I></DT><DD>the record list containg the nodes to select</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSelectOne>mgSelectOne</A>, <A HREF=#mgSelectOneEx>mgSelectOneEx</A>, <A HREF=#mgSelectOneEdge>mgSelectOneEdge</A>, <A HREF=#mgDeselectOne>mgDeselectOne</A>, 
<A HREF=#mgIsSelected>mgIsSelected</A>, <A HREF=#mgIsSelectedEdge>mgIsSelectedEdge</A>, <A HREF=#mgDeselectAll>mgDeselectAll</A></DD></DL>
<HR>
<LEFT><A NAME=mgSelectOne><H1 CLASS="APISYMBOL">mgSelectOne</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSelectOne</B> - select a node record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgSelectOne</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSelectOne</B> selects the specified node record <I>rec</I>.</P></DD><DD><P>If selecting the specified node would result in a recursive 
select list (that is either an ancestor or descendant of <I>rec</I> is 
already selected), the selection is not allowed.</P></DD><DD><P>If any nodes are already selected, they remain selected and the 
specified <I>rec</I> is added to the select list. To make a node the only node 
selected, call <A HREF=#mgDeselectAll>mgDeselectAll</A> before <B>mgSelectOne</B>.</P></DD><DD><P>To select an "edge" in the scene, use <A HREF=#mgSelectOneEdge>mgSelectOneEdge</A> passing the 
first <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record of the edge.  Calling <B>mgSelectOne</B> with the 
same <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record will select only the vertex.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to select</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSelectOneEx>mgSelectOneEx</A>, <A HREF=#mgDeselectOne>mgDeselectOne</A>, <A HREF=#mgSelectOneEdge>mgSelectOneEdge</A>, <A HREF=#mgIsSelected>mgIsSelected</A>, 
<A HREF=#mgIsSelectedEdge>mgIsSelectedEdge</A>, <A HREF=#mgDeselectAll>mgDeselectAll</A>, <A HREF=#mgSelectList>mgSelectList</A></DD></DL>
<HR>
<LEFT><A NAME=mgSelectOneEdge><H1 CLASS="APISYMBOL">mgSelectOneEdge</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSelectOneEdge</B> - select a vertex node record as an edge.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgSelectOneEdge</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSelectOneEdge</B> selects the specified vertex node record <I>rec</I> 
as an edge.</P></DD><DD><P>When a vertex node is selected, it may be selected as a vertex or 
as an edge.  Use this function to select a vertex node as an edge. 
Use <A HREF=#mgSelectOne>mgSelectOne</A> to select a vertex node as a vertex.</P></DD><DD><P>If any nodes are already selected, they remain selected and the 
specified <I>rec</I> is added to the select list. To make a node the only node 
selected, call <A HREF=#mgDeselectAll>mgDeselectAll</A> before <B>mgSelectOneEdge</B>.</P></DD><DD><P>If selecting the specified node would result in a recursive 
select list (that is either an ancestor or descendant of <I>rec</I> is 
already selected), the selection is not allowed.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the vertex node to select as an edge</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSelectOne>mgSelectOne</A>, <A HREF=#mgSelectOneEx>mgSelectOneEx</A>, 
<A HREF=#mgDeselectOne>mgDeselectOne</A>, <A HREF=#mgIsSelected>mgIsSelected</A>, <A HREF=#mgIsSelectedEdge>mgIsSelectedEdge</A>, 
<A HREF=#mgDeselectAll>mgDeselectAll</A>, <A HREF=#mgSelectList>mgSelectList</A></DD></DL>
<HR>
<LEFT><A NAME=mgSelectOneEx><H1 CLASS="APISYMBOL">mgSelectOneEx</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSelectOneEx</B> - select a node record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgSelectOneEx</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>flags</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSelectOneEx</B> performs the same function as <A HREF=#mgSelectOne>mgSelectOne</A>, but 
in addition, it allows you to control certain capabilities of the selection 
using <I>flags</I>.  This parameter is a bitwise combination of the following:</P></DD><DD><P><A HREF=#MSEL_ALLOWRECURSIVE>MSEL_ALLOWRECURSIVE</A> - If you set this mask, recursive selection 
will be allowed. In other words, nodes whose ancestors or descendants are 
already selected will be allowed to be selected themselves. 
By default, recursive selection is not allowed.</P></DD><DD><P>For a complete description of <B>mgSelectOneEx</B>, see <A HREF=#mgSelectOne>mgSelectOne</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node to select</DD><DT><I>flags</I></DT><DD>selection modifiers that allow you to control 
how the selection is performed - 
this parameter is the bitwise combination of the following masks:<BR> 
<A HREF=#MSEL_ALLOWRECURSIVE>MSEL_ALLOWRECURSIVE</A></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSelectOne>mgSelectOne</A>, <A HREF=#mgDeselectOne>mgDeselectOne</A>, <A HREF=#mgSelectOneEdge>mgSelectOneEdge</A>, <A HREF=#mgIsSelected>mgIsSelected</A>, 
<A HREF=#mgIsSelectedEdge>mgIsSelectedEdge</A>, <A HREF=#mgDeselectAll>mgDeselectAll</A>, <A HREF=#mgSelectList>mgSelectList</A></DD></DL>
<HR>
<LEFT><A NAME=mgSelectTextureIndex><H1 CLASS="APISYMBOL">mgSelectTextureIndex</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSelectTextureIndex</B> - selects a texture in the palette.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgSelectTextureIndex</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSelectTextureIndex</B> selects the texture with the specified <I>index</I> 
in the texture palette of the database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the texture palette entry 
to select</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgDeselectTextureIndex>mgDeselectTextureIndex</A>, 
<A HREF=#mgDeselectAllTextures>mgDeselectAllTextures</A>, 
<A HREF=#mgGetFirstSelectedTexture>mgGetFirstSelectedTexture</A>, 
<A HREF=#mgGetNextSelectedTexture>mgGetNextSelectedTexture</A>, 
<A HREF=#mgGetSelectedTextureCount>mgGetSelectedTextureCount</A>, 
<A HREF=#mgIsTextureIndexSelected>mgIsTextureIndexSelected</A></DD></DL>
<HR>
<LEFT><A NAME=mgSendError><H1 CLASS="APISYMBOL">mgSendError</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSendError</B> - reports an error message.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSendError</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>pluginTool</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>message</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>...</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSendError</B> reports an error message containing the text <I>message</I>. 
This corresponds to message severity level <A HREF=#mgmessageseverityenum>MMSG_ERROR</A>. 
The error message is identified with the name of the plug-in tool 
that sent the message.</P></DD><DD><P>If invoked from within the stand-alone program environment, the reported 
message is directed to <I>stdout</I>.  If invoked from the modeler environment, 
the reported message is directed to the Status Bar/Status Log Window.</P></DD><DD><P>The message string can contain <B>printf</B> style formatting, in which 
case the appropriate number of additional parameters must be passed.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginTool</I></DT><DD>the plug-in tool sending the message</DD><DT><I>message</I></DT><DD>message string, which may contain formatting, 
and should be followed with the appropriate parameters, if any</DD><DT><I>...</I></DT><DD>optional additional parameters to support 
formatted output</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSendStatus>mgSendStatus</A>, <A HREF=#mgSendWarning>mgSendWarning</A>, <A HREF=#mgSendMessage>mgSendMessage</A></DD></DL>
<HR>
<LEFT><A NAME=mgSendMessage><H1 CLASS="APISYMBOL">mgSendMessage</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSendMessage</B> - reports a system message.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSendMessage</B> (</TD><TD><A HREF=#mgmessageseverityenum>mgmessageseverityenum</A></TD><TD><I>severity</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>message</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>...</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSendMessage</B> reports a system message containing the text <I>message</I> 
tagged with the specified severity level <I>severity</I>.</P></DD><DD><P>If invoked from within the stand-alone program environment, the reported 
message is directed to <I>stdout</I>.  If invoked from the modeler environment, 
the reported message is directed to the Status Bar/Status Log Window.</P></DD><DD><P>The message string can contain <B>printf</B> style formatting, in which 
case the appropriate number of additional parameters must be passed using 
variable argument style.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>severity</I></DT><DD>severity level of the message</DD><DT><I>message</I></DT><DD>message string, which may contain formatting, 
and should be followed with the appropriate parameters, 
if any</DD><DT><I>...</I></DT><DD>optional additional parameters to 
support formatted output</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if messages are not enabled.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSendStatus>mgSendStatus</A>, <A HREF=#mgSendWarning>mgSendWarning</A>, <A HREF=#mgSendError>mgSendError</A>, <A HREF=#mgSetMessagesEnabled>mgSetMessagesEnabled</A></DD></DL>
<HR>
<LEFT><A NAME=mgSendStatus><H1 CLASS="APISYMBOL">mgSendStatus</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSendStatus</B> - reports a status (informational) message.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSendStatus</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>pluginTool</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>message</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>...</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSendStatus</B> reports a status message containing the text <I>message</I>. 
This corresponds to message severity level <A HREF=#mgmessageseverityenum>MMSG_STATUS</A>.</P></DD><DD><P>If invoked from within the stand-alone program environment, the reported 
message is directed to <I>stdout</I>.  If invoked from the modeler environment, 
the reported message is directed to the Status Bar/Status Log Window.</P></DD><DD><P>The message string can contain <B>printf</B> style formatting, in which 
case the appropriate number of additional parameters must be passed.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginTool</I></DT><DD>the plug-in tool sending the message</DD><DT><I>message</I></DT><DD>message string, which may contain formatting, 
and should be followed with the appropriate parameters, if any</DD><DT><I>...</I></DT><DD>optional additional parameters to support 
formatted output</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSendWarning>mgSendWarning</A>, <A HREF=#mgSendError>mgSendError</A>, <A HREF=#mgSendMessage>mgSendMessage</A></DD></DL>
<HR>
<LEFT><A NAME=mgSendWarning><H1 CLASS="APISYMBOL">mgSendWarning</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSendWarning</B> - reports an error message.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSendWarning</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>pluginTool</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>message</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>...</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSendWarning</B> reports a warning message containing the text <I>message</I>. 
This corresponds to message severity level <A HREF=#mgmessageseverityenum>MMSG_WARNING</A>. 
The warning message is identified with the name of the plug-in tool 
that sent the message.</P></DD><DD><P>If invoked from within the stand-alone program environment, the reported 
message is directed to <I>stdout</I>.  If invoked from the modeler environment, 
the reported message is directed to the Status Bar/Status Log Window.</P></DD><DD><P>The message string can contain <B>printf</B> style formatting, in which 
case the appropriate number of additional parameters must be passed.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginTool</I></DT><DD>the plug-in tool sending the message</DD><DT><I>message</I></DT><DD>message string, which may contain formatting, 
and should be followed with the appropriate parameters, if any</DD><DT><I>...</I></DT><DD>optional additional parameters to support 
formatted output</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSendStatus>mgSendStatus</A>, <A HREF=#mgSendError>mgSendError</A>, <A HREF=#mgSendMessage>mgSendMessage</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetAllNotifiersEnabled><H1 CLASS="APISYMBOL">mgSetAllNotifiersEnabled</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetAllNotifiersEnabled</B> - enables or disables all notifiers for 
a plug-in tool.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgSetAllNotifiersEnabled</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>pluginTool</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>enabled</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Depending on the value of the parameter <I>enabled</I>, 
<B>mgSetAllNotifiersEnabled</B> either enables (<A HREF=#mgbool>MG_TRUE</A>) or 
disables (<A HREF=#mgbool>MG_FALSE</A>).</P></DD><DD><P>A notifier that is enabled reports events; one that is disabled 
does not.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginTool</I></DT><DD>the plug-in tool for which all notifiers 
are being enabled/disabled</DD><DT><I>enabled</I></DT><DD>enum mgbool <A HREF=#mgbool>MG_TRUE</A> to enable all 
notifiers, <A HREF=#mgbool>MG_FALSE</A> to disable them</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterNotifier>mgRegisterNotifier</A>, <A HREF=#mgUnregisterNotifier>mgUnregisterNotifier</A>, <A HREF=#mgSetNotifierEnabled>mgSetNotifierEnabled</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetAttBuf><H1 CLASS="APISYMBOL">mgSetAttBuf</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetAttBuf</B> - sets the values of consecutive attributes using a data buffer.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetAttBuf</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>fcode</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>buf</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a record, <I>rec</I>, <B>mgSetAttBuf</B> sets the values of the attribute <I>fcode</I> from 
from the data buffer <I>buf</I>.</P></DD><DD><P>This routine is used for setting all the attribute values of a record, with the condition 
that the attributes are consecutive as defined by the data dictionary. Note: Simple records 
such as <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3d</A>
 and <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMatrix>fltMatrix</A>
 are guaranteed to be stored consecutively; more complex 
records are not. Exercise caution when using this routine.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record in which to set values</DD><DT><I>fcode</I></DT><DD>the attribute code to be set from <I>buf</I></DD><DT><I>buf</I></DT><DD>the data buffer from which to assign attributes</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the attribute values are assigned, 
<A HREF=#mgbool>MG_FALSE</A> otherwise
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example sets the attribute record <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3d</A>
 in 
<I>vtx</I>.</DT><DT><PRE CLASS="EXAMPLE">mgrec* vtx;
double icoord1 = {1.0, 0.0, 0.0};

mgSetAttBuf (vtx, fltCoord3d, icoord1);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetAttBuf>mgGetAttBuf</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetAttList><H1 CLASS="APISYMBOL">mgSetAttList</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetAttList</B> - sets the values of record attributes using <B>varargs</B> argument style.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgSetAttList</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>< attrCode ></I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>< attrVal ></I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>...</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetAttList</B> sets one or more values of <I>rec</I>'s attributes named by the 
attribute codes <I>attrCode</I>.  Values are specified by the corresponding <I>attrVal</I>. 
Note that <I>rec</I> must be a proper record and cannot be a value record.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>Variable-length argument lists cannot be type-checked by the compiler, so using 
varargs functions can be a source of bugs. Be sure to terminate the argument list 
with <A HREF=#MG_NULL>MG_NULL</A> and be sure that the type of each argument is as expected.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to terminate the argument list with <A HREF=#MG_NULL>MG_NULL</A> in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record in which to set values</DD><DT><I>< attrCode ></I></DT><DD>the attribute record code to set</DD><DT><I>< attrVal ></I></DT><DD>the attribute value to which <I>attrCode</I> is set</DD><DT><I>...</I></DT><DD>the argument list is in pairs of <I>attrCode</I> and <I>attrVal</I> ending 
with <A HREF=#MG_NULL>MG_NULL</A> terminator</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of attribute code/address pairs set successfully.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* poly;
short texture = 1;
short material = 1;

mgSetAttList (poly,
&#32       fltPolyMaterial, material,
&#32       fltPolyTexture, texture,
&#32       MG_NULL);</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">texture = 1
material = 1
mgSetAttList (poly,
&#32       fltPolyMaterial, material,
&#32       fltPolyTexture, texture)</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetAttList>mgGetAttList</A>, <A HREF=#mgGetAttBuf>mgGetAttBuf</A>, <A HREF=#mgSetAttBuf>mgSetAttBuf</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetAutoUpdatePriorityFlag><H1 CLASS="APISYMBOL">mgSetAutoUpdatePriorityFlag</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetAutoUpdatePriorityFlag</B> - sets the preference that 
determines if <A HREF=#mgSetAttList>mgSetAttList</A> called on a node to set its relative priority 
attribute automatically repositions the node among its siblings according 
to the priority value set.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgSetAutoUpdatePriorityFlag</B> (</TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>flag</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetAutoUpdatePriorityFlag</B> tells <A HREF=#mgSetAttList>mgSetAttList</A> 
how to act when called on a node to set one of the relative priority 
attributes <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyPrio</A>
, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltObject>fltObjPrio</A>
, or 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltGroup>fltGrpPrio</A>
. 
If <I>flag</I> is <A HREF=#mgbool>MG_TRUE</A> (the default), <A HREF=#mgSetAttList>mgSetAttList</A> 
will reposition the node such that all siblings to its left have 
priority values less than or equal to the new value set. 
If <I>flag</I> is <A HREF=#mgbool>MG_FALSE</A> (the default), <A HREF=#mgSetAttList>mgSetAttList</A> 
will not change the position of the node.</P></DD><DD><P>The default value for this preference is <A HREF=#mgbool>MG_TRUE</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>flag</I></DT><DD>whether or not to reposition the node when 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyPrio</A>
, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltObject>fltObjPrio</A>
 or 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltGroup>fltGrpPrio</A>
 is set by <A HREF=#mgSetAttList>mgSetAttList</A>.</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetAttList>mgSetAttList</A>, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyPrio</A>
, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltObject>fltObjPrio</A>
, 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltGroup>fltGrpPrio</A>
</DD></DL>
<HR>
<LEFT><A NAME=mgSetCaption><H1 CLASS="APISYMBOL">mgSetCaption</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetCaption</B> - sets caption string for a control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgSetCaption</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>string</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetCaption</B> sets the caption of the specified <I>control</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the control whose caption will be set</DD><DT><I>string</I></DT><DD>the caption string</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCaption>mgGetCaption</A>, <A HREF=#mgSetTitle>mgSetTitle</A>, <A HREF=#mgGetTitle>mgGetTitle</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetColorIndex><H1 CLASS="APISYMBOL">mgSetColorIndex</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetColorIndex</B> - sets a color palette entry to the 
given red, green, and blue values.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetColorIndex</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>r</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>g</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>b</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a database node <I>db</I>, a color palette index <I>index</I>, 
and <I>red</I>, <I>green</I>, and <I>blue</I> color values, 
<I>mgSetColorIndex</I> sets the color of the given index in the 
database&#146s color palette.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the color palette index to change</DD><DT><I>r</I></DT><DD>the red value, which ranges from 0 to 255</DD><DT><I>g</I></DT><DD>the green value, which ranges from 0 to 255</DD><DT><I>b</I></DT><DD>the blue value, which ranges from 0 to 255</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if <I>db</I> contains a valid database and 
<I>index</I> represents a valid palette index, otherwise returns <A HREF=#mgbool>MG_FALSE</A>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRGB2Index>mgRGB2Index</A>, <A HREF=#mgGetColorIndexByName>mgGetColorIndexByName</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetColorRGBA><H1 CLASS="APISYMBOL">mgSetColorRGBA</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetColorRGBA</B> - sets the attribute values in a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltColorRGBA>fltColorRGBA</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetColorRGBA</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>colorRgbaCode</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>red</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>green</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>blue</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>alpha</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a record, <I>rec</I>, and the name of one of its <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltColorRGBA>fltColorRGBA</A>
 attribute records, <I>colorRgbaCode</I>, 
<B>mgSetColorRGBA</B> sets the <I>red</I>, <I>green</I>, <I>blue</I>, and <I>alpha</I> attribute values in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltColorRGBA>fltColorRGBA</A>
 
attribute record.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record whose <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltColorRGBA>fltColorRGBA</A>
 record is to be set</DD><DT><I>colorRgbaCode</I></DT><DD>the name of the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltColorRGBA>fltColorRGBA</A>
 attribute code of <I>rec</I></DD><DT><I>red</I></DT><DD>the red value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltColorRGBA>fltColorRGBA</A>
 attribute record</DD><DT><I>green</I></DT><DD>the green value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltColorRGBA>fltColorRGBA</A>
 attribute record</DD><DT><I>blue</I></DT><DD>the blue value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltColorRGBA>fltColorRGBA</A>
 attribute record</DD><DT><I>alpha</I></DT><DD>the alpha value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltColorRGBA>fltColorRGBA</A>
 attribute record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCoord3d>mgSetCoord3d</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetComment><H1 CLASS="APISYMBOL">mgSetComment</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetComment</B> - assigns comment text to a node record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetComment</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>comment</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetComment</B> allocates space and copies <I>comment</I> into the comment text of the node 
record <I>rec</I>. Pre-existing comments are deleted before the new comment space is allocated. 
Note that vertex node records do not have comment text.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node record whose comment text is to be set</DD><DT><I>comment</I></DT><DD>the comment text for the node record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise,
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetComment>mgGetComment</A>, <A HREF=#mgDeleteComment>mgDeleteComment</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetCompressVertexTableFlag><H1 CLASS="APISYMBOL">mgSetCompressVertexTableFlag</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetCompressVertexTableFlag</B> - sets the preference that 
determines if the vertex table of the OpenFlight file is compressed when 
saved by <A HREF=#mgWriteDb>mgWriteDb</A>, <A HREF=#mgSaveAsDb>mgSaveAsDb</A>, or <A HREF=#mgExportDb>mgExportDb</A>.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgSetCompressVertexTableFlag</B> (</TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>flag</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Normally, when an OpenFlight file is saved, the vertices 
contained in the file are compressed such that only "unique" vertices 
are written in the table.  This results in smaller file sizes but can 
take much longer to write.</P></DD><DD><P>The default value for this preference is <A HREF=#mgbool>MG_TRUE</A>.</P></DD><DD><P>If <I>flag</I> is 
<A HREF=#mgbool>MG_TRUE</A> (the default), vertex tables will be compressed 
when writing OpenFlight files.  If <I>flag</I> is <A HREF=#mgbool>MG_FALSE</A>, 
vertex tables will not be compressed.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>flag</I></DT><DD>whether or not to compress vertex table on write</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWriteDb>mgWriteDb</A>, <A HREF=#mgSaveAsDb>mgSaveAsDb</A>, or <A HREF=#mgExportDb>mgExportDb</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetConstructEdgeColor><H1 CLASS="APISYMBOL">mgSetConstructEdgeColor</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetConstructEdgeColor</B> - sets the color of a 
construction edge.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgSetConstructEdgeColor</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>constructEdge</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgconstructcolor>mgconstructcolor</A></TD><TD><I>constructColor</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetConstructEdgeColor</B> sets the color of a construction 
edge <I>constructEdge</I> to the specified pre-defined color 
<I>constructColor</I>.</P></DD><DD><P>See <A HREF=#mgconstructcolor>mgconstructcolor</A> for the list of pre-defined colors. 
By default, construction edge nodes are created using color 
<A HREF=#mgconstructcolor>MCCOLOR_RED</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>constructEdge</I></DT><DD>the construction edge to color</DD><DT><I>constructColor</I></DT><DD>the color</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewConstructEdge>mgNewConstructEdge</A>, <A HREF=#mgSetConstructEdgeCoords>mgSetConstructEdgeCoords</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetConstructEdgeCoords><H1 CLASS="APISYMBOL">mgSetConstructEdgeCoords</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetConstructEdgeCoords</B> - sets the endpoint coordinates 
of a construction edge node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgSetConstructEdgeCoords</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>constructEdge</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetConstructEdgeCoords</B> sets the coordinates of the endpoints 
of a construction edge node <I>constructEdge</I> to the specified values in 
<I>coord1</I> and <I>coord3</I>.</P></DD><DD><P>If either of the coordinate parameters (<I>coord1</I> or <I>coord2</I>) are 
MG_NULL, that particular coordinate will not be set.  In this way you can 
reposition one endpoint of the construction edge without affecting the other.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>constructEdge</I></DT><DD>the construction edge to 
set coordinates for</DD><DT><I>coord1</I></DT><DD>address of record containing 
coordinates of first vertex of 
construction edge</DD><DT><I>coord2</I></DT><DD>address of record containing 
coordinates of second vertex of 
construction edge</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewConstructEdge>mgNewConstructEdge</A>, <A HREF=#mgSetConstructEdgeColor>mgSetConstructEdgeColor</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetConstructVertexColor><H1 CLASS="APISYMBOL">mgSetConstructVertexColor</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetConstructVertexColor</B> - sets the color of a 
construction vertex node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgSetConstructVertexColor</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>constructVtx</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgconstructcolor>mgconstructcolor</A></TD><TD><I>constructColor</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetConstructVertexColor</B> sets the color of a construction 
vertex node <I>constructVtx</I> to the specified pre-defined color 
<I>constructColor</I>.</P></DD><DD><P>See <A HREF=#mgconstructcolor>mgconstructcolor</A> for the list of pre-defined colors. 
By default, construction vertex nodes are created using color 
<A HREF=#mgconstructcolor>MCCOLOR_RED</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>constructVtx</I></DT><DD>the construction vertex to color</DD><DT><I>constructColor</I></DT><DD>the color</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewConstructVertex>mgNewConstructVertex</A>, <A HREF=#mgSetConstructVertexCoords>mgSetConstructVertexCoords</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetConstructVertexCoords><H1 CLASS="APISYMBOL">mgSetConstructVertexCoords</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetConstructVertexCoords</B> - sets the coordinates of a 
construction vertex node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgSetConstructVertexCoords</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>constructVtx</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetConstructVertexCoords</B> sets the coordinates of a construction 
vertex node <I>constructVtx</I> to the specified values in 
<I>coord</I>.</P></DD><DD><P>If <I>coord</I> is not specified, no action is taken.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>constructVtx</I></DT><DD>the construction vertex to 
set coordinates for</DD><DT><I>coord</I></DT><DD>address of record containing 
coordinates for construction vertex</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewConstructVertex>mgNewConstructVertex</A>, <A HREF=#mgSetConstructVertexColor>mgSetConstructVertexColor</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetCoord2i><H1 CLASS="APISYMBOL">mgSetCoord2i</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetCoord2i</B> - sets all three attribute values in a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord2i>fltCoord2i</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetCoord2i</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>y</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a record, <I>rec</I>, and the name of one of its <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord2i>fltCoord2i</A>
 attribute records, 
<B>mgSetCoord2i</B> sets the <I>x</I> and <I>y</I> attribute values in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord2i>fltCoord2i</A>
 attribute record.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record whose <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord2i>fltCoord2i</A>
 record is to be set</DD><DT><I>code</I></DT><DD>the name of the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord2i>fltCoord2i</A>
 attribute code of <I>rec</I></DD><DT><I>x</I></DT><DD>the x value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord2i>fltCoord2i</A>
 attribute record</DD><DT><I>y</I></DT><DD>the y value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord2i>fltCoord2i</A>
 attribute record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCoord3d>mgSetCoord3d</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetCoord3d><H1 CLASS="APISYMBOL">mgSetCoord3d</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetCoord3d</B> - sets all three attribute values in a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3d</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetCoord3d</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>y</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>z</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a record <I>rec</I>, and the name of one of its <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3d</A>
 attribute records, <I>code</I>, 
<B>mgSetCoord3d</B> sets the x, y, z attribute values in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3d</A>
 attribute record 
<I>code</I>.</P></DD><DD><P>For setting vertex coordinates, it is much more efficient to call the 
convenience function <A HREF=#mgSetVtxCoord>mgSetVtxCoord</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record whose <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3d</A>
 record is to be set</DD><DT><I>code</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3d</A>
 attribute record code</DD><DT><I>x</I></DT><DD>the x value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3d</A>
 attribute record</DD><DT><I>y</I></DT><DD>the y value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3d</A>
 attribute record</DD><DT><I>z</I></DT><DD>the z value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3d</A>
 attribute record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCoord3f>mgSetCoord3f</A>, <A HREF=#mgSetCoord2i>mgSetCoord2i</A>, <A HREF=#mgSetVtxCoord>mgSetVtxCoord</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetCoord3f><H1 CLASS="APISYMBOL">mgSetCoord3f</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetCoord3f</B> - sets all three attribute values in a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3f>fltCoord3f</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetCoord3f</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>y</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>z</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a record <I>rec</I>, and the name of one of its <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3f>fltCoord3f</A>
 attribute records, <I>code</I>, 
<B>mgSetCoord3f</B> sets the x, y, z attribute values in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3f>fltCoord3f</A>
 attribute record 
<I>code</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record whose <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3f>fltCoord3f</A>
 record is to be set</DD><DT><I>code</I></DT><DD>the name of the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3f>fltCoord3f</A>
 attribute record of <I>rec</I></DD><DT><I>x</I></DT><DD>the x value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3f>fltCoord3f</A>
 attribute record</DD><DT><I>y</I></DT><DD>the y value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3f>fltCoord3f</A>
 attribute record</DD><DT><I>z</I></DT><DD>the z value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3f>fltCoord3f</A>
 attribute record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCoord3d>mgSetCoord3d</A>, <A HREF=#mgGetCoord3f>mgGetCoord3f</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetCurrentAltColor><H1 CLASS="APISYMBOL">mgSetCurrentAltColor</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetCurrentAltColor</B> - sets the current alternate modeling color 
index and intensity.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetCurrentAltColor</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>intensity</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetCurrentAltColor</B> sets the current alternate modeling color 
palette <I>index</I> and <I>intensity</I> for database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>index to set current alternate modeling color</DD><DT><I>intensity</I></DT><DD>intensity to set current alternate modeling color</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if current alternate modeling color for <I>db</I> 
could be set, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCurrentAltColor>mgGetCurrentAltColor</A>, <A HREF=#mgSetCurrentAltColorRGB>mgSetCurrentAltColorRGB</A>, <A HREF=#mgSetCurrentColor>mgSetCurrentColor</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetCurrentAltColorRGB><H1 CLASS="APISYMBOL">mgSetCurrentAltColorRGB</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetCurrentAltColorRGB</B> - sets the current alternate modeling color 
to an index and intensity that matches RGB values.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetCurrentAltColorRGB</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>red</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>green</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>blue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetCurrentAltColorRGB</B> sets the current alternate modeling color 
palette <I>index</I> and <I>intensity</I> for database <I>db</I> to values that 
most closely match the specified <I>red</I>, <I>green</I>, and <I>blue</I> values.</P></DD><DD><P>The color palette for <I>db</I> is searched for the color that 
most closely matches the specified RGB values.  The current alternate 
modeling color is set to the color palette entry found.</P></DD><DD><P>The input color values are expected to be in the range 0..255.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>red</I></DT><DD>red component to match</DD><DT><I>green</I></DT><DD>green component to match</DD><DT><I>blue</I></DT><DD>blue component to match</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if current alternate modeling color for <I>db</I> 
could be set, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCurrentAltColorRGB>mgGetCurrentAltColorRGB</A>, <A HREF=#mgSetCurrentAltColor>mgSetCurrentAltColor</A>, <A HREF=#mgSetCurrentColorRGB>mgSetCurrentColorRGB</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetCurrentColor><H1 CLASS="APISYMBOL">mgSetCurrentColor</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetCurrentColor</B> - sets the current primary modeling color 
index and intensity.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetCurrentColor</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>intensity</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetCurrentColor</B> sets the current primary modeling color 
palette <I>index</I> and <I>intensity</I> for database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>index to set current primary modeling color</DD><DT><I>intensity</I></DT><DD>intensity to set current primary modeling color</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if current primary modeling color for <I>db</I> 
could be set, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCurrentColor>mgGetCurrentColor</A>, <A HREF=#mgSetCurrentColorRGB>mgSetCurrentColorRGB</A>, <A HREF=#mgSetCurrentAltColor>mgSetCurrentAltColor</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetCurrentColorName><H1 CLASS="APISYMBOL">mgSetCurrentColorName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetCurrentColorName</B> - sets the current name of a 
particular color palette entry.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetCurrentColorName</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>name</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Each color palette entry can have a list of names associated with it. 
One of these names is always the current name for that entry. 
Given a database node, <I>db</I>, and an index of a color palette entry, 
<I>index</I>, <B>mgSetCurrentColorName</B> sets the current name of the given 
color index to <I>name</I>. An index of -1 causes the routine to search 
the color name table for <I>name</I>, and make it the current name for it&#146s 
own index.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index in the color palette, 
-1 to search the name symbol table</DD><DT><I>name</I></DT><DD>the current name for the given color palette entry</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgDeleteColorName>mgDeleteColorName</A>, <A HREF=#mgNewColorName>mgNewColorName</A>, <A HREF=#mgGetCurrentColorName>mgGetCurrentColorName</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetCurrentColorRGB><H1 CLASS="APISYMBOL">mgSetCurrentColorRGB</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetCurrentColorRGB</B> - sets the current primary modeling color 
to an index and intensity that matches RGB values.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetCurrentColorRGB</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>red</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>green</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>blue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetCurrentColorRGB</B> sets the current primary modeling color 
palette <I>index</I> and <I>intensity</I> for database <I>db</I> to values that 
most closely match the specified <I>red</I>, <I>green</I>, and <I>blue</I> values.</P></DD><DD><P>The color palette for <I>db</I> is searched for the color that 
most closely matches the specified RGB values.  The current primary 
modeling color ise set to the color palette entry found.</P></DD><DD><P>The input color values are expected to be in the range 0..255.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>red</I></DT><DD>red component to match</DD><DT><I>green</I></DT><DD>green component to match</DD><DT><I>blue</I></DT><DD>blue component to match</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if current primary modeling color for <I>db</I> 
could be set, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCurrentColorRGB>mgGetCurrentColorRGB</A>, <A HREF=#mgSetCurrentColor>mgSetCurrentColor</A>, <A HREF=#mgSetCurrentAltColorRGB>mgSetCurrentAltColorRGB</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetCurrentDb><H1 CLASS="APISYMBOL">mgSetCurrentDb</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetCurrentDb</B> - sets a database as the current database.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgSetCurrentDb</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a database node, <I>db</I>, <B>mgSetCurrentDb</B> sets 
this database as the current database.  If the database is a new current 
database, the color palette associated with this database is loaded.</P></DD><DD><P>Note: This function is for use in stand-alone applications only, 
and should never be called from inside a plug-in.  Doing so may yield 
undefined results.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database to make current</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCurrentDb>mgGetCurrentDb</A>, <A HREF=#mgRec2Db>mgRec2Db</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetCurrentEyePoint><H1 CLASS="APISYMBOL">mgSetCurrentEyePoint</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetCurrentEyePoint</B> - sets the current eyepoint<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetCurrentEyePoint</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>eyeRec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetCurrentEyePoint</B> sets the current eyepoint and refreshes the 
scene.  The <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltEyePoint>fltEyePoint</A>
 record <I>eyeRec</I> must have previously been 
obtained by <A HREF=#mgGetNewEyePoint>mgGetNewEyePoint</A> or <A HREF=#mgGetEyePoint>mgGetEyePoint</A></P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>eyeRec</I></DT><DD>the eyepoint record to set</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the current eyepoint for <I>db</I> 
could be set, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCurrentEyePoint>mgGetCurrentEyePoint</A>, <A HREF=#mgGetEyePoint>mgGetEyePoint</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetCurrentGridPoints><H1 CLASS="APISYMBOL">mgSetCurrentGridPoints</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetCurrentGridPoints</B> - sets the current modeling grid using 
three points.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetCurrentGridPoints</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>origin</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>xAxis</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>third</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetCurrentGridPoints</B> sets the position and orientation of the 
grid in the current Creator graphics view using three points. 
These points are <I>origin</I>, <I>xAxis</I>, and <I>third</I> where <I>origin</I> is the 
origin of the grid, <I>xAxis</I> is a point on the x axis of the grid and <I>third</I> 
is a point that along with <I>origin</I> and <I>xAxis</I> define the plane in which 
the grid is located.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>origin</I></DT><DD>3D coordinate defining the grid origin</DD><DT><I>xAxis</I></DT><DD>3D coordinate defining the x axis point 
of the grid</DD><DT><I>third</I></DT><DD>3D coordinate defining the third point 
on the grid plane</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCurrentGridPoints>mgGetCurrentGridPoints</A>, <A HREF=#mgGetCurrentGridMatrix>mgGetCurrentGridMatrix</A>, <A HREF=#mgGetCurrentTrackPlane>mgGetCurrentTrackPlane</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetCurrentLightPointAnimation><H1 CLASS="APISYMBOL">mgSetCurrentLightPointAnimation</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetCurrentLightPointAnimation</B> - sets the current modeling 
light point animation index.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetCurrentLightPointAnimation</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetCurrentLightPointAnimation</B> sets the current modeling 
light point animation palette <I>index</I> for database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>index to set current modeling light point animation</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if current modeling light point animation 
for <I>db</I> could be set, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCurrentLightPointAnimation>mgGetCurrentLightPointAnimation</A>, 
<A HREF=#mgSetCurrentLightPointAppearance>mgSetCurrentLightPointAppearance</A>, 
<A HREF=#mgGetCurrentLightPointAppearance>mgGetCurrentLightPointAppearance</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetCurrentLightPointAppearance><H1 CLASS="APISYMBOL">mgSetCurrentLightPointAppearance</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetCurrentLightPointAppearance</B> - sets the current modeling 
light point appearance index.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetCurrentLightPointAppearance</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetCurrentLightPointAppearance</B> sets the current modeling 
light point appearance palette <I>index</I> for database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>index to set current modeling light point appearance</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if current modeling light point appearance 
for <I>db</I> could be set, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCurrentLightPointAppearance>mgGetCurrentLightPointAppearance</A>, 
<A HREF=#mgSetCurrentLightPointAnimation>mgSetCurrentLightPointAnimation</A>, 
<A HREF=#mgGetCurrentLightPointAnimation>mgGetCurrentLightPointAnimation</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetCurrentLightSource><H1 CLASS="APISYMBOL">mgSetCurrentLightSource</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetCurrentLightSource</B> - sets the current modeling light source 
index.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetCurrentLightSource</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetCurrentLightSource</B> sets the current modeling light source 
palette <I>index</I> for database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>index to set current modeling light source</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if current modeling light source for <I>db</I> 
could be set, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCurrentLightSource>mgGetCurrentLightSource</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetCurrentLineStyle><H1 CLASS="APISYMBOL">mgSetCurrentLineStyle</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetCurrentLineStyle</B> - sets the current modeling line style 
index.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetCurrentLineStyle</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetCurrentLineStyle</B> sets the current modeling line style 
palette <I>index</I> for database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>index to set current modeling line style</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if current modeling line style for <I>db</I> 
could be set, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCurrentLineStyle>mgGetCurrentLineStyle</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetCurrentLookAt><H1 CLASS="APISYMBOL">mgSetCurrentLookAt</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetCurrentLookAt</B> - sets the current eyepoint in 
"look at" form.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetCurrentLookAt</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>eyex</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>eyey</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>eyez</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>centerx</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>centery</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>centerz</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>upx</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>upy</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>upz</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetCurrentLookAt</B> sets the current eyepoint using "look at" 
style parameters and refreshes the scene.  The "look at" parameters include 
3 sets of values. 
The first set, <I>eyex</I>, <I>eyey</I>, and <I>eyez</I> is the position of 
the eye point. 
The second set, <I>centerx</I>, <I>centery</I>, <I>centerz</I> is the position 
of the reference point. 
The third set, <I>upx</I>, <I>upy</I>, and <I>upz</I> is the direction of the 
up vector.</P></DD><DD><P>This function sets the current eyepoint as derived from an eye 
point, a reference point indicating the center of the scene, and an 
up vector.  The up vector must not be parallel to the line of sight from 
the eye to the reference point.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>eyex</I></DT><DD>the x component of the eyepoint position</DD><DT><I>eyey</I></DT><DD>the y component of the eyepoint position</DD><DT><I>eyez</I></DT><DD>the z component of the eyepoint position</DD><DT><I>centerx</I></DT><DD>the x component of the reference point</DD><DT><I>centery</I></DT><DD>the y component of the reference point</DD><DT><I>centerz</I></DT><DD>the z component of the reference point</DD><DT><I>upx</I></DT><DD>the i component of the up vector</DD><DT><I>upy</I></DT><DD>the j component of the up vector</DD><DT><I>upz</I></DT><DD>the k component of the up vector</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the current eyepoint for <I>db</I> 
could be set, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCurrentLookAt>mgGetCurrentLookAt</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetCurrentMaterial><H1 CLASS="APISYMBOL">mgSetCurrentMaterial</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetCurrentMaterial</B> - sets the current modeling material 
index.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetCurrentMaterial</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetCurrentMaterial</B> sets the current modeling material 
palette <I>index</I> for database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>index to set current modeling material</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCurrentMaterial>mgGetCurrentMaterial</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetCurrentShader><H1 CLASS="APISYMBOL">mgSetCurrentShader</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetCurrentShader</B> - sets the current modeling shader 
index.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetCurrentShader</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetCurrentShader</B> sets the current modeling shader 
palette <I>index</I> for database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>index to set current modeling shader</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCurrentShader>mgGetCurrentShader</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetCurrentSound><H1 CLASS="APISYMBOL">mgSetCurrentSound</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetCurrentSound</B> - sets the current modeling sound 
index.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetCurrentSound</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetCurrentSound</B> sets the current modeling sound 
palette <I>index</I> for database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>index to set current modeling sound</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if current modeling sound for <I>db</I> 
could be set, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCurrentSound>mgGetCurrentSound</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetCurrentSubTexture><H1 CLASS="APISYMBOL">mgSetCurrentSubTexture</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetCurrentSubTexture</B> - sets the current modeling subtexture 
index.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetCurrentSubTexture</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetCurrentSubTexture</B> sets the current modeling subtexture 
palette <I>index</I> for database <I>db</I>.  Subtexture indices are contiguous 
and range from 0..N-1 where N is the value returned by <A HREF=#mgSubTextureCount>mgSubTextureCount</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>index to set current modeling subtexture</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if current modeling subtexture for <I>db</I> 
could be set, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCurrentSubTexture>mgGetCurrentSubTexture</A>, <A HREF=#mgGetCurrentTexture>mgGetCurrentTexture</A>, <A HREF=#mgSetCurrentTexture>mgSetCurrentTexture</A>, 
<A HREF=#mgGetCurrentTextureLayer>mgGetCurrentTextureLayer</A>, <A HREF=#mgSetCurrentTextureLayer>mgSetCurrentTextureLayer</A>, 
<A HREF=#mgGetCurrentTextureMapping>mgGetCurrentTextureMapping</A>, <A HREF=#mgSetCurrentTextureMapping>mgSetCurrentTextureMapping</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetCurrentTexture><H1 CLASS="APISYMBOL">mgSetCurrentTexture</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetCurrentTexture</B> - sets the current modeling texture 
index.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetCurrentTexture</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetCurrentTexture</B> sets the current modeling texture 
palette <I>index</I> for database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>index to set current modeling texture</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if current modeling texture for <I>db</I> 
could be set, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCurrentTexture>mgGetCurrentTexture</A>, <A HREF=#mgGetCurrentSubTexture>mgGetCurrentSubTexture</A>, <A HREF=#mgSetCurrentSubTexture>mgSetCurrentSubTexture</A>, 
<A HREF=#mgGetCurrentTextureLayer>mgGetCurrentTextureLayer</A>, <A HREF=#mgSetCurrentTextureLayer>mgSetCurrentTextureLayer</A>, 
<A HREF=#mgGetCurrentTextureMapping>mgGetCurrentTextureMapping</A>, <A HREF=#mgSetCurrentTextureMapping>mgSetCurrentTextureMapping</A>, <A HREF=#mgSelectTextureIndex>mgSelectTextureIndex</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetCurrentTextureLayer><H1 CLASS="APISYMBOL">mgSetCurrentTextureLayer</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetCurrentTextureLayer</B> - sets the current modeling 
texture layer.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetCurrentTextureLayer</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>layer</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetCurrentTextureLayer</B> sets the current modeling texture 
<I>layer</I> for database <I>db</I>.  To select a specific texture layer, 
set <I>layer</I> to 0-7 (0 is the base layer). 
To select "Blend", set <I>layer</I> to -1.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>layer</I></DT><DD>the modeling texture layer to set</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if current modeling texture layer 
for <I>db</I> could be set, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCurrentTextureLayer>mgGetCurrentTextureLayer</A>, <A HREF=#mgGetCurrentTexture>mgGetCurrentTexture</A>, <A HREF=#mgSetCurrentTexture>mgSetCurrentTexture</A>, 
<A HREF=#mgGetCurrentTextureLayer>mgGetCurrentTextureLayer</A>, 
<A HREF=#mgGetCurrentTextureMapping>mgGetCurrentTextureMapping</A>, <A HREF=#mgSetCurrentTextureMapping>mgSetCurrentTextureMapping</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetCurrentTextureMapping><H1 CLASS="APISYMBOL">mgSetCurrentTextureMapping</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetCurrentTextureMapping</B> - sets the current modeling texture 
mapping index.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetCurrentTextureMapping</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetCurrentTextureMapping</B> sets the current modeling texture mapping 
palette <I>index</I> for database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>index to set current modeling texture mapping</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if current modeling texture mapping for <I>db</I> 
could be set, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCurrentTextureMapping>mgGetCurrentTextureMapping</A>, <A HREF=#mgGetCurrentTexture>mgGetCurrentTexture</A>, <A HREF=#mgSetCurrentTexture>mgSetCurrentTexture</A>, 
<A HREF=#mgGetCurrentSubTexture>mgGetCurrentSubTexture</A>, <A HREF=#mgSetCurrentSubTexture>mgSetCurrentSubTexture</A> 
<A HREF=#mgGetCurrentTextureLayer>mgGetCurrentTextureLayer</A>, <A HREF=#mgSetCurrentTextureLayer>mgSetCurrentTextureLayer</A>,</DD></DL>
<HR>
<LEFT><A NAME=mgSetCursor><H1 CLASS="APISYMBOL">mgSetCursor</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetCursor</B> - sets the cursor shape.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgSetCursor</B> (</TD><TD><A HREF=#mgcursor>mgcursor</A></TD><TD><I>cursor</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetCursor</B> sets the cursor shape according to the 
specified <I>cursor</I>.  To restore the cursor to the default shape 
(arrow), specify <I>cursor</I> as <A HREF=#MG_NULL>MG_NULL</A>,</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>cursor</I></DT><DD>the cursor to use</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example displays the predefined "wait" cursor 
while it does some processing.</DT><DT><PRE CLASS="EXAMPLE">// get the predefined cursor for "wait"
mgcursor waitCursor = mgResourceGetCursor (NULL, MCURS_WAIT);

// set the cursor to show the user the plug-in is busy
mgSetCursor (waitCursor);

// do some processing...

// when done, reset the cursor to the default
mgSetCursor (MG_NULL);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgLoadResource>mgLoadResource</A>, <A HREF=#mgResourceGetCursor>mgResourceGetCursor</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetDbModified><H1 CLASS="APISYMBOL">mgSetDbModified</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetDbModified</B> - sets the modified state of a database.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetDbModified</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>modified</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetDbModified</B> sets or clears the modified state of the database 
<I>db</I> according to <I>modified</I>.  If <I>modified</I> is <A HREF=#mgbool>MG_TRUE</A>, <I>db</I> 
will be marked as modified (or "dirty").  If <I>modified</I> is <A HREF=#mgbool>MF_FALSE</A>, 
<I>db</I> will be marked as not modified.</P></DD><DD><P>Note: This function is only applicable in the Creator modeler environment. 
If called from the stand application environment, the results are not 
reliable.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database whose modified state is to be set</DD><DT><I>modified</I></DT><DD>the modified state to set on the database</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the modified state of the database 
was successfully set, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgIsDbModified>mgIsDbModified</A>, <A HREF=#mgIsDbUntitled>mgIsDbUntitled</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetEnabled><H1 CLASS="APISYMBOL">mgSetEnabled</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetEnabled</B> - enables or disables a control in a dialog.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgSetEnabled</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>enabled</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Depending on the value of the parameter <I>enabled</I>, <B>mgSetEnabled</B> will 
either enable (<A HREF=#mgbool>MG_TRUE</A>) or disable (<A HREF=#mgbool>MG_FALSE</A>) the 
<I>control</I>.  Controls that are enabled can accept user input.</P></DD><DD><P>If the control you specify to this function has any buddy controls 
associated, the buddy controls are also enabled/disabled accordingly.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the control to enable or disable</DD><DT><I>enabled</I></DT><DD>enum mgbool <A HREF=#mgbool>MG_TRUE</A> to enable control, 
<A HREF=#mgbool>MG_FALSE</A> to disable control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgIsEnabled>mgIsEnabled</A>, <A HREF=#mgSetVisible>mgSetVisible</A>, <A HREF=#mgIsVisible>mgIsVisible</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetEyePoint><H1 CLASS="APISYMBOL">mgSetEyePoint</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetEyePoint</B> - stores an eyepoint record into the database.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgSetEyePoint</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>eyeRec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetEyePoint</B> stores the eyepoint record <I>eyeRec</I> in the position 
defined by <I>index</I> in the database <I>db</I>, <I>index</I> must be between 1 
and 9.  Eyepoint 0 is reserved for use by Presagis.</P></DD><DD><P>The <I>eyeRec</I> you pass here must have been created using <A HREF=#mgGetNewEyePoint>mgGetNewEyePoint</A>.</P></DD><DD><P>Note: The attribute <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltEyePoint>fltEyeActive</A>
 must be set for the eyepoint 
to be considered valid.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database record</DD><DT><I>index</I></DT><DD>index into the eyepoint palette</DD><DT><I>eyeRec</I></DT><DD>a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltEyePoint>fltEyePoint</A>
 record</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetEyePoint>mgGetEyePoint</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetFocus><H1 CLASS="APISYMBOL">mgSetFocus</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetFocus</B> - sets the keyboard focus to a control in a dialog.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetFocus</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetFocus</B> sets the keyboard focus to the specified <I>control</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgFindGuiById>mgFindGuiById</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetFocusVertex><H1 CLASS="APISYMBOL">mgSetFocusVertex</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetFocusVertex</B> - set the current focus vertex.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgSetFocusVertex</B> (</TD><TD><A HREF=#mgeditorcontext>mgeditorcontext</A></TD><TD><I>editorContext</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>vertexRec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetFocusVertex</B> sets the focus vertex to the specified 
vertex node, <I>vertexRec</I> for the specified editor context, <I>editorContext</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>editorContext</I></DT><DD>the editor context used to identify 
the database in which the focus vertex 
is to be set</DD><DT><I>vertexRec</I></DT><DD>the vertex node to become the new 
focus vertex</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgEditorSetFocusVertexFunc>mgEditorSetFocusVertexFunc</A>, <A HREF=#mgFocusVertexListAddItem>mgFocusVertexListAddItem</A>, 
<A HREF=#mgClearFocusVertex>mgClearFocusVertex</A>, <A HREF=#mgGetFocusVertex>mgGetFocusVertex</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetFreezeLODCentersFlag><H1 CLASS="APISYMBOL">mgSetFreezeLODCentersFlag</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetFreezeLODCentersFlag</B> - sets the preference that determines 
if LOD (<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLod>fltLod</A>
 node centers are re-calculated when database files are saved 
by <A HREF=#mgWriteDb>mgWriteDb</A>, <A HREF=#mgSaveAsDb>mgSaveAsDb</A>, or <A HREF=#mgExportDb>mgExportDb</A>.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgSetFreezeLODCentersFlag</B> (</TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>flag</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When an OpenFlight file is saved, the OpenFlight API can optionally re-calculate 
LOD centers automatically before writing the file.  This can be useful if you 
change any geometry contained in a LOD and you do not want to re-calculate 
the LOD center in your application.  Sometimes, however, this is not desirable. 
When it is not desirable there are two ways to tell the API to not re-calculate 
LOD centers.  First, you can control this per LOD node using the 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLod>fltLodFreezeCenter</A>
 attribute on the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLod>fltLod</A>
 node. 
If you set the value of this attribute on the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLod>fltLod</A>
 node to <A HREF=#mgbool>MG_TRUE</A>, 
the OpenFlight API will never re-calculate the center of that LOD.  Second, if you call 
<B>mgSetFreezeLODCentersFlag</B> with <I>flag</I> set to <A HREF=#mgbool>MG_TRUE</A>, the API will 
not recalculate ANY LOD center (regardless of the value of <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLod>fltLodFreezeCenter</A>
 
on the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLod>fltLod</A>
 node).</P></DD><DD><P>If <I>flag</I> is <A HREF=#mgbool>MG_FALSE</A> (the default), LOD centers will be 
re-calculated for all <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLod>fltLod</A>
 nodes in the database whose <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLod>fltLodFreezeCenter</A>
 
values are <A HREF=#mgbool>MG_FALSE</A>.  If <I>flag</I> is <A HREF=#mgbool>MG_TRUE</A>, no LOD centers 
will be re-calcuated.</P></DD><DD><P>The default value for this preference is <A HREF=#mgbool>MG_FALSE</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>flag</I></DT><DD>whether or not to freeze lod centers</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWriteDb>mgWriteDb</A>, <A HREF=#mgSaveAsDb>mgSaveAsDb</A>, <A HREF=#mgExportDb>mgExportDb</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetGuiCallback><H1 CLASS="APISYMBOL">mgSetGuiCallback</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetGuiCallback</B> - sets callback function for a control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgSetGuiCallback</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>callbackMask</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgguifunc>mgguifunc</A></TD><TD><I>callback</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetGuiCallback</B> assigns a callback function to the specified 
<I>control</I>.</P></DD><DD><P>You select which control events the callback function is to be called 
for using the parameter <I>callbackMask</I>.  The value for this parameter may be 
any bitwise combination of <A HREF=#MGCB_ACTIVATE>MGCB_ACTIVATE</A>, <A HREF=#MGCB_REFRESH>MGCB_REFRESH</A> and <A HREF=#MGCB_DRAW>MGCB_DRAW</A>.</P></DD><DD><P>The <A HREF=#MGCB_ACTIVATE>MGCB_ACTIVATE</A> and <A HREF=#MGCB_REFRESH>MGCB_REFRESH</A> events are sent to all sent to 
all control types.  The <A HREF=#MGCB_DRAW>MGCB_DRAW</A> event is only sent to GL control types.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the control whose callback function is to be set</DD><DT><I>callbackMask</I></DT><DD>mask indicating which control events are selected for callback function</DD><DT><I>callback</I></DT><DD>the control callback function</DD><DT><I>userData</I></DT><DD>user data to be passed to callback function when it is called</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgFindGuiById>mgFindGuiById</A>, <A HREF=#mgguifunc>mgguifunc</A>, <A HREF=#MGCB_ACTIVATE>MGCB_ACTIVATE</A>, 
<A HREF=#MGCB_REFRESH>MGCB_REFRESH</A>, <A HREF=#MGCB_DRAW>MGCB_DRAW</A>, <A HREF=#mgSetGuiToolAction>mgSetGuiToolAction</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetGuiToolAction><H1 CLASS="APISYMBOL">mgSetGuiToolAction</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetGuiToolAction</B> - binds a plug-in tool action to a control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgSetGuiToolAction</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgtoolaction>mgtoolaction</A></TD><TD><I>toolAction</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetGuiToolAction</B> binds the plug-in tool action 
<I>toolAction</I> to the specified <I>control</I>.  If your plug-in tool dialog 
allows keyboard shortcuts to activate controls it contains, you do so via 
plug-in tool actions.  Use this function to "bind" a plug-in tool action to 
a specific control in your dialog.  Use <A HREF=#mgToolActionSetShortCut>mgToolActionSetShortCut</A> to assign 
a shortcut key sequence to a plug-in tool action.</P></DD><DD><P>See the example code in <A HREF=#mgPluginToolNewAction>mgPluginToolNewAction</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the control to bind <I>toolAction</I> to</DD><DT><I>toolAction</I></DT><DD>the tool action to bind to <I>control</I></DD></DL></DD></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginToolNewAction>mgPluginToolNewAction</A>, <A HREF=#mgPluginToolFreeAction>mgPluginToolFreeAction</A>, 
<A HREF=#mgToolActionSetShortCut>mgToolActionSetShortCut</A>, <A HREF=#mgToolActionGetShortCut>mgToolActionGetShortCut</A>, 
<A HREF=#mgSetGuiCallback>mgSetGuiCallback</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetMatrix><H1 CLASS="APISYMBOL">mgSetMatrix</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetMatrix</B> - sets the attribute values in a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMatrix>fltMatrix</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetMatrix</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>matrixCode</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a record <I>rec</I> which contains a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMatrix>fltMatrix</A>
 record identified 
by the record code <I>matrixCode</I>, <B>mgSetMatrix</B> sets the corresponding matrix 
of <I>rec</I> using the values contained in <I>matrix</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>a node or record containing a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMatrix>fltMatrix</A>
 record</DD><DT><I>matrixCode</I></DT><DD>the record code of the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMatrix>fltMatrix</A>
 to set</DD><DT><I>matrix</I></DT><DD>the matrix whose values will be copied</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> if <I>rec</I> 
has no such matrix or otherwise unsuccessful.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetMatrix>mgGetMatrix</A>, <A HREF=#mgHasXform>mgHasXform</A>, <A HREF=#mgGetXform>mgGetXform</A>, <A HREF=#mgGetXformType>mgGetXformType</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetMatTextureLayer><H1 CLASS="APISYMBOL">mgSetMatTextureLayer</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetMatTextureLayer</B> - sets attribute values in a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMatTextureLayer>fltMatTextureLayer</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetMatTextureLayer</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>matTextureCode</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>textureIndex</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>textureLayer</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a record, <I>rec</I>, and the name of one of its <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMatTextureLayer>fltMatTextureLayer</A>
 attribute records, 
<I>matTextureCode</I>, <B>mgSetMatTextureLayer</B> sets the <I>textureIndex</I> and <I>textureLayer</I> attribute 
values in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMatTextureLayer>fltMatTextureLayer</A>
 attribute record.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record from which to get the 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMatTextureLayer>fltMatTextureLayer</A>
 attribute code</DD><DT><I>matTextureCode</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMatTextureLayer>fltMatTextureLayer</A>
 attribute code</DD><DT><I>textureIndex</I></DT><DD>the texture index value</DD><DT><I>textureLayer</I></DT><DD>the texture layer value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetMatTextureLayer>mgGetMatTextureLayer</A>, <A HREF=#mgSetNormColor>mgSetNormColor</A></DD></DL>
<HR>
<LEFT><A NAME=mgsetmaxidfunc><H1 CLASS="APISYMBOL">mgsetmaxidfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgsetmaxidfunc</B> - Set Max Id function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool (*<B>mgsetmaxidfunc</B>) ( <TD><A HREF=#mgrec>mgrec*</A> <TD><I>db</I>, 
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A> <TD><I>code</I>, 
<TR><TD></TD><TD>int <TD><I>no</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for set max id (extension node helper) functions. 
If your data extension declares one or more new node types, you must assign 
a set max id function to your data extension of this form.</P></DD><DD><P>Set max id functions are called after nodes of your new type 
are created and are responsible for storing the index passed into the 
header tag-along data field corresponding to this node type.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database into which the new node was created</DD><DT><I>code</I></DT><DD>the record code of the new node created</DD><DT><I>no</I></DT><DD>the index used to name the new node</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful; returns <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterSite>mgRegisterSite</A>, <A HREF=#mggetmaxidfunc>mggetmaxidfunc</A>, <A HREF=#mggetheadercodefunc>mggetheadercodefunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetMessagesEnabled><H1 CLASS="APISYMBOL">mgSetMessagesEnabled</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetMessagesEnabled</B> - enables or disables system messages.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgSetMessagesEnabled</B> (</TD><TD><A HREF=#mgmessageseverityenum>mgmessageseverityenum</A></TD><TD><I>severity</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>enabled</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>According to the switch <I>enabled</I>, <B>mgSetMessagesEnabled</B> 
either enables (<A HREF=#mgbool>MG_TRUE</A>) or disables (<A HREF=#mgbool>MG_FALSE</A>) 
the display of messages of level <I>severity</I> within the stand-alone 
program environment. By default, messages for all severities are enabled.</P></DD><DD><P>Note: Within the modeler environment, messages are always enabled 
and cannot be disabled.  For this reason, this function is ignored when 
invoked from within the modeler environment.</P></DD><DD><P>You can invoke this function before you call <A HREF=#mgInit>mgInit</A> in the stand 
alone program environment to turn on or off messages displayed by 
the OpenFlight API initialization function.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>severity</I></DT><DD>severity level of the messages 
to enable or disable</DD><DT><I>enabled</I></DT><DD><A HREF=#mgbool>MG_TRUE</A> to enable messages, 
<A HREF=#mgbool>MG_FALSE</A> to disable them</DD></DL></DD></DL>
<DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show how to disable all messages 
before calling <A HREF=#mgInit>mgInit</A> and then re-enabling them after.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">// disable all messages
mgSetMessagesEnabled (MMSG_STATUS, MG_FALSE);
mgSetMessagesEnabled (MMSG_WARNING, MG_FALSE);
mgSetMessagesEnabled (MMSG_ERROR, MG_FALSE);

mgInit (argc, argv);

// re-enable all messages
mgSetMessagesEnabled (MMSG_STATUS, MG_TRUE);
mgSetMessagesEnabled (MMSG_WARNING, MG_TRUE);
mgSetMessagesEnabled (MMSG_ERROR, MG_TRUE);

// continue with stand-alone application processing</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE"># disable all messages
mgSetMessagesEnabled (MMSG_STATUS, MG_FALSE)
mgSetMessagesEnabled (MMSG_WARNING, MG_FALSE)
mgSetMessagesEnabled (MMSG_ERROR, MG_FALSE)

mgInit (argc, argv)

# re-enable all messages
mgSetMessagesEnabled (MMSG_STATUS, MG_TRUE)
mgSetMessagesEnabled (MMSG_WARNING, MG_TRUE)
mgSetMessagesEnabled (MMSG_ERROR, MG_TRUE)

# continue with stand-alone script processing</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetMessagesEnabled>mgGetMessagesEnabled</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetModelingMode><H1 CLASS="APISYMBOL">mgSetModelingMode</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetModelingMode</B> - sets current modeling mode.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetModelingMode</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>mode</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetModelingMode</B> sets the current modeling mode 
for the specified database <I>db</I> to the specified level, <I>mode</I>.</P></DD><DD><P>Use this function to set modeling mode to any node type except edge. 
Note that the edge modeling mode is a special case of vertex mode. Since there 
is no "edge" type in OpenFlight, you must use <A HREF=#mgSetModelingModeEdge>mgSetModelingModeEdge</A> 
to set modeling mode to edge.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database to set modeling mode for</DD><DT><I>mode</I></DT><DD>the modeling mode to set</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) set the modeling mode 
to different levels:</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgbool ok;

// set modeling mode to group
ok = mgSetModelingMode (db, fltGroup);

// set modeling mode to vertex
ok = mgSetModelingMode (db, fltVertex);

// set modeling mode to edge
ok = mgSetModelingModeEdge (db);</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE"># set modeling mode to group
ok = mgSetModelingMode (db, fltGroup)

# set modeling mode to vertex
ok = mgSetModelingMode (db, fltVertex)

# set modeling mode to edge
ok = mgSetModelingModeEdge (db)</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetActivationDb>mgGetActivationDb</A>, 
<A HREF=#mgGetModelingMode>mgGetModelingMode</A>, <A HREF=#mgSetModelingModeEdge>mgSetModelingModeEdge</A>, <A HREF=#mgIsModelingModeEdge>mgIsModelingModeEdge</A>, 
<A HREF=#mgGetModelingParent>mgGetModelingParent</A>, <A HREF=#mgGetModelingParentMatrix>mgGetModelingParentMatrix</A>, <A HREF=#mgGetDefaultModelingParent>mgGetDefaultModelingParent</A>, 
<A HREF=#mgSetModelingParent>mgSetModelingParent</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetModelingModeEdge><H1 CLASS="APISYMBOL">mgSetModelingModeEdge</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetModelingModeEdge</B> - sets current modeling mode to edge.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetModelingModeEdge</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetModelingModeEdge</B> sets the current modeling mode 
for the specified database <I>db</I> to edge.  The edge modeling mode is a special case 
of vertex mode.  Since there is no "edge" type in OpenFlight, you must use this 
function to set the modeling mode to edge.  Use <A HREF=#mgSetModelingMode>mgSetModelingMode</A> to set 
all other modes.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database to set modeling mode for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>See <A HREF=#mgSetModelingMode>mgSetModelingMode</A> for an example of how you might set the 
modeling modes to different levels.</DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetActivationDb>mgGetActivationDb</A>, 
<A HREF=#mgGetModelingMode>mgGetModelingMode</A>, <A HREF=#mgSetModelingMode>mgSetModelingMode</A>, <A HREF=#mgIsModelingModeEdge>mgIsModelingModeEdge</A>, 
<A HREF=#mgGetModelingParent>mgGetModelingParent</A>, <A HREF=#mgGetModelingParentMatrix>mgGetModelingParentMatrix</A>, <A HREF=#mgGetDefaultModelingParent>mgGetDefaultModelingParent</A>, <A HREF=#mgSetModelingParent>mgSetModelingParent</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetModelingParent><H1 CLASS="APISYMBOL">mgSetModelingParent</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetModelingParent</B> - sets the current modeling parent.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetModelingParent</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>parent</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetModelingParent</B> sets the current modeling parent node 
for the specified database <I>db</I> to <I>parent</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database to set modeling parent for</DD><DT><I>parent</I></DT><DD>the node to set as parent</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>parent</I> is already the current modeling parent, 
if <I>parent</I> is contained within an externally referenced database in <I>db</I> 
or if <I>parent</I> is otherwise not eligible to be a parent node.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetActivationDb>mgGetActivationDb</A>, 
<A HREF=#mgGetModelingMode>mgGetModelingMode</A>, <A HREF=#mgSetModelingMode>mgSetModelingMode</A>, <A HREF=#mgIsModelingModeEdge>mgIsModelingModeEdge</A>, <A HREF=#mgSetModelingModeEdge>mgSetModelingModeEdge</A>, 
<A HREF=#mgGetModelingParent>mgGetModelingParent</A>, <A HREF=#mgGetModelingParentMatrix>mgGetModelingParentMatrix</A>, <A HREF=#mgGetDefaultModelingParent>mgGetDefaultModelingParent</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetName><H1 CLASS="APISYMBOL">mgSetName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetName</B> - assigns a name to a node record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetName</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>name</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetName</B> sets the name of a node <I>rec</I> to <I>name</I>. 
The <I>name</I> must be unique in the database containing <I>rec</I>, 
otherwise the function will fail.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node record</DD><DT><I>name</I></DT><DD>the new name of the node record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>name</I> is NULL or an empty string.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<HR>
<LEFT><A NAME=mgSetNameUnique><H1 CLASS="APISYMBOL">mgSetNameUnique</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetNameUnique</B> - assigns a unique name to a node record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetNameUnique</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>name</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetNameUnique</B> sets the name of a node <I>rec</I> based on <I>name</I>. 
If <I>name</I> is unique in the database containing <I>rec</I>, <I>name</I> will be assigned. 
If <I>name</I> is not unique in the database containing <I>rec</I>, a name derived from <I>name</I> 
will be assigned.  The derived name assigned will be the first unique name of the form 
name_N where N is 1,2,3, etc. If <I>name</I> is already of the form name_N, the derived name 
assigned will be the first unique name of the form name_M where M is N+1, N+2, N+3, etc.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the node record</DD><DT><I>name</I></DT><DD>the name on which the new node name is based</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">char* name;
mgbool status;

status = mgSetNameUnique (node, "building");
if (status == MG_TRUE) {
   char* name = mgGetName (node);
   // name may be building, building_1, building_2, etc
   mgFree (name);
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<HR>
<LEFT><A NAME=mgSetNewOverwriteFlag><H1 CLASS="APISYMBOL">mgSetNewOverwriteFlag</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetNewOverwriteFlag</B> - sets the preference that 
determines if <A HREF=#mgNewDb>mgNewDb</A> and <A HREF=#mgSaveAsDb>mgSaveAsDb</A> overwrite a file when 
instructed to create a file that already exists.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgSetNewOverwriteFlag</B> (</TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>flag</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetNewOverwriteFlag</B> tells <A HREF=#mgNewDb>mgNewDb</A> and <A HREF=#mgSaveAsDb>mgSaveAsDb</A> 
how to act when asked to create a file that already exists.  If <I>flag</I> is 
<A HREF=#mgbool>MG_TRUE</A>, <A HREF=#mgNewDb>mgNewDb</A>, and <A HREF=#mgSaveAsDb>mgSaveAsDb</A> overwrite the existing 
file.  If <I>flag</I> is <A HREF=#mgbool>MG_FALSE</A> (the default), <A HREF=#mgNewDb>mgNewDb</A> 
and <A HREF=#mgSaveAsDb>mgSaveAsDb</A> fail and return.</P></DD><DD><P>The default value for this preference is <A HREF=#mgbool>MG_FALSE</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>flag</I></DT><DD>whether or not to overwrite an existing file</DD></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* db;
mgSetNewOverwriteFlag (MG_TRUE);
db = mgNewDb ("file1.flt");</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSaveAsDb>mgSaveAsDb</A>, <A HREF=#mgNewDb>mgNewDb</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetNormColor><H1 CLASS="APISYMBOL">mgSetNormColor</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetNormColor</B> - sets attribute values in a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltNormColor>fltNormColor</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetNormColor</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>normColorCode</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>red</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>green</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>blue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a record, <I>rec</I>, and the name of one of its <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltNormColor>fltNormColor</A>
 attribute records, <I>normColorCode</I>, 
<B>mgSetNormColor</B> sets the <I>red</I>, <I>green</I>, and <I>blue</I> attribute values in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltNormColor>fltNormColor</A>
 
attribute record.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record whose <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltNormColor>fltNormColor</A>
 record is to be set</DD><DT><I>normColorCode</I></DT><DD>the name of the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltNormColor>fltNormColor</A>
 attribute code of <I>rec</I></DD><DT><I>red</I></DT><DD>the red value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltNormColor>fltNormColor</A>
 attribute record</DD><DT><I>green</I></DT><DD>the green value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltNormColor>fltNormColor</A>
 attribute record</DD><DT><I>blue</I></DT><DD>the blue value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltNormColor>fltNormColor</A>
 attribute record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetNormColor>mgGetNormColor</A>, <A HREF=#mgSetColorRGBA>mgSetColorRGBA</A>, <A HREF=#mgSetMatTextureLayer>mgSetMatTextureLayer</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetNotifierEnabled><H1 CLASS="APISYMBOL">mgSetNotifierEnabled</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetNotifierEnabled</B> - enables or disables a notifier.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgSetNotifierEnabled</B> (</TD><TD><A HREF=#mgnotifier>mgnotifier</A></TD><TD><I>notifier</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>enabled</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Depending on the value of the parameter <I>enabled</I>, <B>mgSetNotifierEnabled</B> 
either enables (<A HREF=#mgbool>MG_TRUE</A>) or disables (<A HREF=#mgbool>MG_FALSE</A>) the specified 
<I>notifier</I>.</P></DD><DD><P>A notifier that is enabled reports events; one that is disabled 
does not.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>notifier</I></DT><DD>the notifier to enable/disable</DD><DT><I>enabled</I></DT><DD>enum mgbool <A HREF=#mgbool>MG_TRUE</A> to enable 
notifier, <A HREF=#mgbool>MG_FALSE</A> to disable it</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterNotifier>mgRegisterNotifier</A>, <A HREF=#mgUnregisterNotifier>mgUnregisterNotifier</A>, <A HREF=#mgSetAllNotifiersEnabled>mgSetAllNotifiersEnabled</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetOpenCreateFlag><H1 CLASS="APISYMBOL">mgSetOpenCreateFlag</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetOpenCreateFlag</B> - sets the preference that 
determines if a new database is created when <A HREF=#mgOpenDb>mgOpenDb</A> is instructed 
to open a file that does not exist.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgSetOpenCreateFlag</B> (</TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>flag</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetOpenCreateFlag</B> tells <A HREF=#mgOpenDb>mgOpenDb</A> how to act when it 
is asked to open a database that does not exist. 
If <I>flag</I> is <A HREF=#mgbool>MG_TRUE</A>, <A HREF=#mgNewDb>mgNewDb</A> is called to create a new file. 
If <I>flag</I> is <A HREF=#mgbool>MG_FALSE</A> (the default), <A HREF=#mgOpenDb>mgOpenDb</A> fails and returns.</P></DD><DD><P>The default value for this preference is <A HREF=#mgbool>MG_FALSE</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>flag</I></DT><DD>whether or not to create a new database</DD></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* db;
mgSetOpenCreateFlag (MG_TRUE);
db = mgOpenDb ("file1.flt");</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgOpenDb>mgOpenDb</A>, <A HREF=#mgNewDb>mgNewDb</A>, <A HREF=#mgSetNewOverwriteFlag>mgSetNewOverwriteFlag</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetPaneLayout><H1 CLASS="APISYMBOL">mgSetPaneLayout</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetPaneLayout</B> - sets the current pane layout.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetPaneLayout</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgpanelayout>mgpanelayout</A></TD><TD><I>layout</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetPaneLayout</B> sets the current layout of <I>db</I> to the <I>layout</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>layout</I></DT><DD>the address of the struct to 
containing the layout record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewPaneLayout>mgNewPaneLayout</A>, <A HREF=#mgFreePaneLayout>mgFreePaneLayout</A>, <A HREF=#mgGetPaneLayout>mgGetPaneLayout</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetPixmap><H1 CLASS="APISYMBOL">mgSetPixmap</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetPixmap</B> - sets a pixmap for a control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgSetPixmap</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgpixmap>mgpixmap</A></TD><TD><I>pixmap</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetPixmap</B> sets the pixmap of the specified <I>control</I>.</P></DD><DD><P>For push button and toggle button controls, this function will assign 
the specified <I>pixmap</I> to the control so that it will be drawn in place of 
the text caption.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the control whose pixmap is to be set</DD><DT><I>pixmap</I></DT><DD>the pixmap to assign to the control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>The following example sets the pixmap on a control to be the 
predefined open file pixmap.</DT><DT><PRE CLASS="EXAMPLE">mggui control;

// get the predefined pixmap for "open file"
mgpixmap pixmap = mgResourceGetPixmap (NULL, MPIXMAP_OPENFILE);

// assign the pixmap to the control
mgSetPixmap (control, pixmap);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCaption>mgSetCaption</A>, <A HREF=#mgGetCaption>mgGetCaption</A>, <A HREF=#mgResourceGetPixmap>mgResourceGetPixmap</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetPlane><H1 CLASS="APISYMBOL">mgSetPlane</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetPlane</B> - sets all four attribute values in a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDPlane>fltDPlane</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetPlane</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>code</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>a</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>b</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>c</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>d</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a record <I>rec</I>, and the name of one of its <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDPlane>fltDPlane</A>
 attribute records, <I>code</I>, 
<B>mgSetPlane</B> sets the a, b, c, d attribute values in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDPlane>fltDPlane</A>
 attribute record 
<I>code</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record whose <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDPlane>fltDPlane</A>
 record is to be set</DD><DT><I>code</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDPlane>fltDPlane</A>
 attribute record code</DD><DT><I>a</I></DT><DD>the a value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDPlane>fltDPlane</A>
 attribute record</DD><DT><I>b</I></DT><DD>the b value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDPlane>fltDPlane</A>
 attribute record</DD><DT><I>c</I></DT><DD>the c value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDPlane>fltDPlane</A>
 attribute record</DD><DT><I>d</I></DT><DD>the d value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDPlane>fltDPlane</A>
 attribute record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetPlane>mgGetPlane</A>, <A HREF=#mgSetAttList>mgSetAttList</A>, <A HREF=#mgSetAttBuf>mgSetAttBuf</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetPluginFolder><H1 CLASS="APISYMBOL">mgSetPluginFolder</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetPluginFolder</B> - sets the plug-in runtime directory.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetPluginFolder</B> (</TD><TD>const char*</TD><TD><I>folder</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetPluginFolder</B> sets the folder (or folders) from which plug-ins 
will be loaded for stand-alone application environments. Before calling <A HREF=#mgInit>mgInit</A> 
you can use&#32this function to override this location. To specify a single folder, 
simply pass a single path for <I>folder</I>. To specify more then one folder, pass 
a semi-colon delimited list of paths for <I>folder</I>.</P></DD><DD><P>Note that if you specify multiple plug-in folders and the Creator plug-in folder is 
one of them, you must specify the Creator plug-in folder as the first in the list. If 
you specify multiple folders and don't specify the Creator plug-in folder, the order 
is not important.</P></DD><DD><P>Since plug-ins are loaded by <A HREF=#mgInit>mgInit</A>, you must call <B>mgSetPluginFolder</B> 
before calling <A HREF=#mgInit>mgInit</A>. This function is ignored if called in the Creator 
modeling environment.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>folder</I></DT><DD>the plug-in folder(s) to search</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if called after <A HREF=#mgInit>mgInit</A> or from a plug-in in the Creator 
modeling environment.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>In this example, the stand-alone program uses <B>mgSetPluginFolder</B> to 
set the location of the plug-in runtime directory. In this case, the stand-alone 
program wants to load Creator plug-ins and its own set of plug-ins.</DT><DT><PRE CLASS="EXAMPLE">// set the plug-in folders
// the Creator plug-in folder must be the first in the list
// the custom plug-in folder(s) must come after
mgSetPluginFolder ("C:/Presagis/Suite14/Creator/config/plugins;D:/MyPlugins");

// has to be called before mgInit
mgInit (argc, argv)</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetMessagesEnabled>mgGetMessagesEnabled</A>, <A HREF=#mgInit>mgInit</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetPolyAltColorName><H1 CLASS="APISYMBOL">mgSetPolyAltColorName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetPolyAltColorName</B> - sets the alternate color name 
of a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetPolyAltColorName</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>poly</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>name</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record, <I>poly</I>, 
and a string, <I>name</I>, <B>mgSetPolyAltColorName</B> stores <I>name</I> as the 
alternate color name for <I>poly</I>. If the name given is not in the color palette, 
<B>mgSetPolyAltColorName</B> returns <A HREF=#mgbool>MG_FALSE</A>.</P></DD><DD><P>To clear the alternate color name for a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
, 
set <I>name</I> to NULL or the empty string.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>poly</I></DT><DD>a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 record</DD><DT><I>name</I></DT><DD>the alternate color name</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise..
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetPolyAltColorName>mgGetPolyAltColorName</A>, 
<A HREF=#mgGetPolyColorName>mgGetPolyColorName</A>, <A HREF=#mgSetPolyColorName>mgSetPolyColorName</A>, 
<A HREF=#mgNewColorName>mgNewColorName</A>, <A HREF=#mgGetNextColorName>mgGetNextColorName</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetPolyAltColorRGB><H1 CLASS="APISYMBOL">mgSetPolyAltColorRGB</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetPolyAltColorRGB</B> - sets the alternate RGB color values in 
a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetPolyAltColorRGB</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>red</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>green</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>blue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record, <I>rec</I>, this function 
sets the red, green, and blue alternate color values of <I>rec</I> to the given 
<I>red</I>, <I>green</I>, and <I>blue</I> values.</P></DD><DD><P>Note that if the database containing 
<I>rec</I> is color index mode, this function will convert the given color values 
to the closest index and intensity pair and set the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyAltColor</A>
 and 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyAltIntensity</A>
 attributes of <I>rec</I> accordingly.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record on which to 
set the color values</DD><DT><I>red</I></DT><DD>the red value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyAltColor</A>
 attribute record</DD><DT><I>green</I></DT><DD>the green value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyAltColor</A>
 attribute record</DD><DT><I>blue</I></DT><DD>the blue value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyAltColor</A>
 attribute record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* poly;
mgrec* mesh;
short r, g, b;
mgbool status;

r = g = b = 50;
poly = mgNewRec (fltPolygon);
mesh = mgNewRec (fltMesh);
status = mgSetPolyAltColorRGB (poly, r, g, b);
status = mgSetPolyAltColorRGB (mesh, r, g, b);</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetPolyAltColorRGB>mgGetPolyAltColorRGB</A>, <A HREF=#mgSetPolyColorRGB>mgSetPolyColorRGB</A>, <A HREF=#mgGetPolyColorRGB>mgGetPolyColorRGB</A>, 
<A HREF=#mgGetVtxColorRGB>mgGetVtxColorRGB</A>, <A HREF=#mgSetVtxColorRGB>mgSetVtxColorRGB</A>, 
<A HREF=#mgGetVtxColorRGBA>mgGetVtxColorRGBA</A>, <A HREF=#mgSetVtxColorRGBA>mgSetVtxColorRGBA</A>, 
<A HREF=#mgSetAttList>mgSetAttList</A>, <A HREF=#mgSetAttBuf>mgSetAttBuf</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetPolyColorName><H1 CLASS="APISYMBOL">mgSetPolyColorName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetPolyColorName</B> - sets the color name of a 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetPolyColorName</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>poly</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>name</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record, <I>poly</I>, 
and a string, <I>name</I>, <B>mgSetPolyColorName</B> stores <I>name</I> as 
the color name for <I>poly</I>. If the name given is not in the color palette, 
<B>mgSetPolyColorName</B> returns <A HREF=#mgbool>MG_FALSE</A>.</P></DD><DD><P>To clear the color name for a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
, 
set <I>name</I> to NULL or the empty string.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>poly</I></DT><DD>a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 record</DD><DT><I>name</I></DT><DD>the color name</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise..
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetPolyColorName>mgGetPolyColorName</A>, 
<A HREF=#mgGetPolyAltColorName>mgGetPolyAltColorName</A>, <A HREF=#mgSetPolyAltColorName>mgSetPolyAltColorName</A>, 
<A HREF=#mgNewColorName>mgNewColorName</A>, <A HREF=#mgGetNextColorName>mgGetNextColorName</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetPolyColorRGB><H1 CLASS="APISYMBOL">mgSetPolyColorRGB</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetPolyColorRGB</B> - sets the primary RGB color values in 
a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetPolyColorRGB</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>red</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>green</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>blue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record, <I>rec</I>, this function 
sets the red, green, and blue primary color values of <I>rec</I> to the given 
<I>red</I>, <I>green</I>, and <I>blue</I> values.</P></DD><DD><P>Note that if the database containing 
<I>rec</I> is color index mode, this function will convert the given color values 
to the closest index and intensity pair and set the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyPrimeColor</A>
 and 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyPrimeIntensity</A>
 attributes of <I>rec</I> accordingly.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record on which to 
set the color values</DD><DT><I>red</I></DT><DD>the red value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyPrimeColor</A>
 attribute record</DD><DT><I>green</I></DT><DD>the green value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyPrimeColor</A>
 attribute record</DD><DT><I>blue</I></DT><DD>the blue value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyPrimeColor</A>
 attribute record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* poly;
mgrec* mesh;
short r, g, b;
mgbool status;

r = g = b = 50;
poly = mgNewRec (fltPolygon);
mesh = mgNewRec (fltMesh);
status = mgSetPolyColorRGB (poly, r, g, b);
status = mgSetPolyColorRGB (mesh, r, g, b);</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetPolyColorRGB>mgGetPolyColorRGB</A>, <A HREF=#mgSetPolyAltColorRGB>mgSetPolyAltColorRGB</A>, <A HREF=#mgGetPolyAltColorRGB>mgGetPolyAltColorRGB</A>, 
<A HREF=#mgGetVtxColorRGB>mgGetVtxColorRGB</A>, <A HREF=#mgSetVtxColorRGB>mgSetVtxColorRGB</A>, 
<A HREF=#mgGetVtxColorRGBA>mgGetVtxColorRGBA</A>, <A HREF=#mgSetVtxColorRGBA>mgSetVtxColorRGBA</A>, 
<A HREF=#mgSetAttList>mgSetAttList</A>, <A HREF=#mgSetAttBuf>mgSetAttBuf</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetPolyCurrentAltColor><H1 CLASS="APISYMBOL">mgSetPolyCurrentAltColor</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetPolyCurrentAltColor</B> - sets the alternate color attribute in 
a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record to the current alternate modeling color.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetPolyCurrentAltColor</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record, <I>rec</I>, this function 
sets its alternate color attribute according to the current alternate modeling color 
selected by the user in Creator for database <I>db</I>.<P>
If <I>db</I> is color index mode, this 
function will set the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyAltColor</A>
 and <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyAltIntensity</A>
 
attributes of <I>rec</I>.  If <I>db</I> is RGB color mode, this function will set 
the alternate red, green and blue color values of <I>rec</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database whose current alternate modeling color 
will be used</DD><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record on 
which to set the color attribute</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* poly;
mgbool status;

poly = mgNewRec (fltPolygon);
// set alternate color attribute to the current alternate color in the palette
status = mgSetPolyCurrentAltColor (db, poly);</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetPolyCurrentColor>mgSetPolyCurrentColor</A>, <A HREF=#mgSetPolyCurrentMaterial>mgSetPolyCurrentMaterial</A>, 
<A HREF=#mgSetPolyAltColorRGB>mgSetPolyAltColorRGB</A>, <A HREF=#mgSetPolyColorRGB>mgSetPolyColorRGB</A>, 
<A HREF=#mgSetVtxColorRGB>mgSetVtxColorRGB</A>, <A HREF=#mgSetVtxColorRGBA>mgSetVtxColorRGBA</A>, 
<A HREF=#mgSetAttList>mgSetAttList</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetPolyCurrentColor><H1 CLASS="APISYMBOL">mgSetPolyCurrentColor</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetPolyCurrentColor</B> - sets the primary color attribute in 
a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record to the current primary modeling color.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetPolyCurrentColor</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record, <I>rec</I>, this function 
sets its primary color attribute according to the current primary modeling color 
selected by the user in Creator for database <I>db</I>.<P>
If <I>db</I> is color index mode, this 
function will set the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyPrimeColor</A>
 and <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyPrimeIntensity</A>
 
attributes of <I>rec</I>.  If <I>db</I> is RGB color mode, this function will set 
the primary red, green and blue color values of <I>rec</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database whose current primary modeling color 
will be used</DD><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record on 
which to set the color attribute</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* poly;
mgbool status;

poly = mgNewRec (fltPolygon);
// set primary color attribute to the current primary color in the palette
status = mgSetPolyCurrentColor (db, poly);</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetPolyCurrentAltColor>mgSetPolyCurrentAltColor</A>, <A HREF=#mgSetPolyCurrentMaterial>mgSetPolyCurrentMaterial</A>, 
<A HREF=#mgSetPolyColorRGB>mgSetPolyColorRGB</A>, <A HREF=#mgSetPolyAltColorRGB>mgSetPolyAltColorRGB</A>, 
<A HREF=#mgSetVtxColorRGB>mgSetVtxColorRGB</A>, <A HREF=#mgSetVtxColorRGBA>mgSetVtxColorRGBA</A>, 
<A HREF=#mgSetAttList>mgSetAttList</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetPolyCurrentMaterial><H1 CLASS="APISYMBOL">mgSetPolyCurrentMaterial</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetPolyCurrentMaterial</B> - sets the material attribute in 
a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record to the current modeling material.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetPolyCurrentMaterial</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record, <I>rec</I>, this function 
sets its material attribute (<B>fltPolyMaterial</B>) according to the current 
modeling material selected by the user in Creator for database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database whose current modeling material 
will be used</DD><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record on 
which to set the material attribute</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* poly;
mgbool status;

poly = mgNewRec (fltPolygon);
// set material attribute to the current material in the palette
status = mgSetPolyCurrentMaterial (db, poly);</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetPolyCurrentColor>mgSetPolyCurrentColor</A>, <A HREF=#mgSetPolyCurrentAltColor>mgSetPolyCurrentAltColor</A>, 
<A HREF=#mgSetPolyColorRGB>mgSetPolyColorRGB</A>, <A HREF=#mgSetPolyAltColorRGB>mgSetPolyAltColorRGB</A>, 
<A HREF=#mgSetVtxColorRGB>mgSetVtxColorRGB</A>, <A HREF=#mgSetVtxColorRGBA>mgSetVtxColorRGBA</A>, 
<A HREF=#mgSetAttList>mgSetAttList</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetPolyCurrentShader><H1 CLASS="APISYMBOL">mgSetPolyCurrentShader</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetPolyCurrentShader</B> - sets the shader attribute in 
a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record to the current modeling shader.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetPolyCurrentShader</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record, <I>rec</I>, this function 
sets its shader attribute (<B>fltPolyShader</B>) according to the current 
modeling shader selected by the user in Creator for database <I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database whose current modeling shader 
will be used</DD><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record on 
which to set the shader attribute</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* poly;
mgbool status;

poly = mgNewRec (fltPolygon);
// set shader attribute to the current material in the palette
status = mgSetPolyCurrentShader (db, poly);</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetPolyCurrentColor>mgSetPolyCurrentColor</A>, <A HREF=#mgSetPolyCurrentAltColor>mgSetPolyCurrentAltColor</A>, 
<A HREF=#mgSetPolyColorRGB>mgSetPolyColorRGB</A>, <A HREF=#mgSetPolyAltColorRGB>mgSetPolyAltColorRGB</A>, 
<A HREF=#mgSetVtxColorRGB>mgSetVtxColorRGB</A>, <A HREF=#mgSetVtxColorRGBA>mgSetVtxColorRGBA</A>, 
<A HREF=#mgSetAttList>mgSetAttList</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetPolyCurrentTexture><H1 CLASS="APISYMBOL">mgSetPolyCurrentTexture</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetPolyCurrentTexture</B> - sets the texture attribute in 
a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record to the current modeling texture.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetPolyCurrentTexture</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>layer</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record, <I>rec</I>, this function 
sets its texture attribute for the given <I>layer</I> according to the current 
modeling texture selected by the user in Creator for database <I>db</I>.</P></DD><DD><P>The parameter <I>layer</I> is a number between 0-7, representing the 
layer you want to set and corresponds to the attributes:<BR> 
0 : <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyTexture</A>
<BR> 
1 : <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltLayerTexture1</A>
<BR> 
2 : <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltLayerTexture2</A>
<BR> 
3 : <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltLayerTexture3</A>
<BR> 
4 : <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltLayerTexture4</A>
<BR> 
5 : <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltLayerTexture5</A>
<BR> 
6 : <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltLayerTexture6</A>
<BR> 
7 : <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltLayerTexture7</A>
<BR></P></DD><DD><P>If you specify any other value for <I>layer</I>, the function will fail.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database whose current modeling texture 
will be used</DD><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record on 
which to set the texture attribute</DD><DT><I>layer</I></DT><DD>the layer number 0..7</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* poly;
mgbool status;

poly = mgNewRec (fltPolygon);
// set texture attribute for layer 0 to the current texture in the palette
status = mgSetPolyCurrentTexture (db, poly, 0);</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetPolyCurrentColor>mgSetPolyCurrentColor</A>, <A HREF=#mgSetPolyCurrentAltColor>mgSetPolyCurrentAltColor</A>, 
<A HREF=#mgSetPolyColorRGB>mgSetPolyColorRGB</A>, <A HREF=#mgSetPolyAltColorRGB>mgSetPolyAltColorRGB</A>, 
<A HREF=#mgSetVtxColorRGB>mgSetVtxColorRGB</A>, <A HREF=#mgSetVtxColorRGBA>mgSetVtxColorRGBA</A>, 
<A HREF=#mgSetAttList>mgSetAttList</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetPolyCurrentTextureMapping><H1 CLASS="APISYMBOL">mgSetPolyCurrentTextureMapping</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetPolyCurrentTextureMapping</B> - sets the texture mapping 
attribute in a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record to the current 
modeling texture mapping.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetPolyCurrentTextureMapping</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>layer</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record, <I>rec</I>, this function 
sets its texture mapping attribute for the given <I>layer</I> according to the current 
modeling texture mapping selected by the user in Creator for database <I>db</I>.</P></DD><DD><P>The parameter <I>layer</I> is a number between 0-7, representing the 
layer you want to set and corresponds to the attributes:<BR> 
0 : <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyTexmap</A>
<BR> 
1 : <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltLayerTexmap1</A>
<BR> 
2 : <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltLayerTexmap2</A>
<BR> 
3 : <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltLayerTexmap3</A>
<BR> 
4 : <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltLayerTexmap4</A>
<BR> 
5 : <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltLayerTexmap5</A>
<BR> 
6 : <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltLayerTexmap6</A>
<BR> 
7 : <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltLayerTexmap7</A>
<BR></P></DD><DD><P>If you specify any other value for <I>layer</I>, the function will fail.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database whose current modeling texture 
mapping will be used</DD><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 record on 
which to set the texture mapping attribute</DD><DT><I>layer</I></DT><DD>the layer number 0..7</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* poly;
mgbool status;

poly = mgNewRec (fltPolygon);
// set texture mapping attribute for layer 0 to the
// current texture mapping in the palette
status = mgSetPolyCurrentTexture (db, poly, 0);</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetPolyCurrentColor>mgSetPolyCurrentColor</A>, <A HREF=#mgSetPolyCurrentAltColor>mgSetPolyCurrentAltColor</A>, 
<A HREF=#mgSetPolyColorRGB>mgSetPolyColorRGB</A>, <A HREF=#mgSetPolyAltColorRGB>mgSetPolyAltColorRGB</A>, 
<A HREF=#mgSetVtxColorRGB>mgSetVtxColorRGB</A>, <A HREF=#mgSetVtxColorRGBA>mgSetVtxColorRGBA</A>, 
<A HREF=#mgSetAttList>mgSetAttList</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetReadExtFlag><H1 CLASS="APISYMBOL">mgSetReadExtFlag</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetReadExtFlag</B> - sets the preference that determines if 
<A HREF=#mgOpenDb>mgOpenDb</A> reads external reference database files contained in 
database files being opened.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgSetReadExtFlag</B> (</TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>flag</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetReadExtFlag</B> tells <A HREF=#mgOpenDb>mgOpenDb</A> how to act when it finds 
an external reference node in a database being opened.  If <I>flag</I> is 
<A HREF=#mgbool>MG_TRUE</A>, <A HREF=#mgOpenDb>mgOpenDb</A> will read external references.  If 
<I>flag</I> is <A HREF=#mgbool>MG_FALSE</A> (the default), <A HREF=#mgOpenDb>mgOpenDb</A> 
will not read external references.</P></DD><DD><P>The default value for this preference is <A HREF=#mgbool>MG_FALSE</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>flag</I></DT><DD>whether or not to read external references</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgOpenDb>mgOpenDb</A>, <A HREF=#mgSetReadTexturesFlag>mgSetReadTexturesFlag</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetReadImageGeoInfoFunc><H1 CLASS="APISYMBOL">mgSetReadImageGeoInfoFunc</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetReadImageGeoInfoFunc</B> - sets a get geoinfo function. 
for an image importer plug-in tool.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgSetReadImageGeoInfoFunc</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>pluginTool</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgimagegetgeoinfofunc>mgimagegetgeoinfofunc</A></TD><TD><I>getGeoInfoFunc</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When you register an image importer plug-in tool, you can add a 
get geoinfo function using <B>mgSetReadImageGeoInfoFunc</B>.  The function 
you register is called when the OpenFlight API needs to get georeferencing information 
about an image that your tool has opened.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in module that registered 
the image importer plug-in tool</DD><DT><I>pluginTool</I></DT><DD>the image importer plug-in tool to 
which the get geoinfo function is to be 
added</DD><DT><I>getGeoInfoFunc</I></DT><DD>the get geoinfo function</DD><DT><I>userData</I></DT><DD>user defined data that 
will be passed to <I>getGeoInfoFunc</I> 
when it is called</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetReadTexturesFlag><H1 CLASS="APISYMBOL">mgSetReadTexturesFlag</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetReadTexturesFlag</B> - sets the preference that determines if 
<A HREF=#mgOpenDb>mgOpenDb</A> reads texture files referenced by database files being opened.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgSetReadTexturesFlag</B> (</TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>flag</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetReadTexturesFlag</B> tells <A HREF=#mgOpenDb>mgOpenDb</A> how to act when it finds 
a texture file in the palette of a database being opened. If <I>flag</I> is 
<A HREF=#mgbool>MG_TRUE</A>, <A HREF=#mgOpenDb>mgOpenDb</A> will read the texture and its attributes into 
memory. If <I>flag</I> is <A HREF=#mgbool>MG_FALSE</A>, <A HREF=#mgOpenDb>mgOpenDb</A> will not read the texture 
into memory. When a texture is read into memory, both its texels and attributes 
will be accessible by your stand-alone application, plug-in or script. If a texture 
is not read into memory and you try to access its attributes, you will get incorrect 
results.</P></DD><DD><P>Note that reading textures can consume both processing and memory resources. 
Unless your application explicitly needs to access the texels or attributes of a texture, 
it is much more efficient to set this preference to <A HREF=#mgbool>MG_FALSE</A>. When you do this, 
<A HREF=#mgOpenDb>mgOpenDb</A> will run much faster and will require less memory resources for your database.</P></DD><DD><P>The default value for this preference is <A HREF=#mgbool>MG_TRUE</A> in the stand-alone 
application environment, <A HREF=#mgbool>MG_FALSE</A> for plug-ins and scripts run in the 
Creator modeling environment.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>flag</I></DT><DD>whether or not to read textures</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgOpenDb>mgOpenDb</A>, <A HREF=#mgSetReadExtFlag>mgSetReadExtFlag</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetRegistryString><H1 CLASS="APISYMBOL">mgSetRegistryString</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetRegistryString</B> - sets the value of a Creator registry key.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetRegistryString</B> (</TD><TD>const char*</TD><TD><I>keyName</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>keyString</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetRegistryString</B> sets the value of the specified Creator registry 
key <I>keyName</I> to the string specified by <I>keyString</I>.</P></DD><DD><P>This function is only applicable on the Windows operation system platform 
in the Creator modeler environment.  This function will always return <A HREF=#mgbool>MG_FALSE</A> 
when called by a stand-alone application or from any code running on IRIX.</P></DD><DD><P>The key is written to the Windows system registry corresponding to that 
currently in use by the running version of Creator.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>keyName</I></DT><DD>the name of the key to set in the Creator 
registry</DD><DT><I>keyString</I></DT><DD>the value for the key</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the the key was set successfully, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetRegistryString>mgGetRegistryString</A>, <A HREF=#mgGetRegistryRoot>mgGetRegistryRoot</A>, 
<A HREF=#mgLoadResource>mgLoadResource</A>, <A HREF=#mgGetModuleHandle>mgGetModuleHandle</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetSaveNonIndexedLightPoints><H1 CLASS="APISYMBOL">mgSetSaveNonIndexedLightPoints</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetSaveNonIndexedLightPoints</B> - sets the preference that 
determines how light point records are saved in an OpenFlight file.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgSetSaveNonIndexedLightPoints</B> (</TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>flag</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetSaveNonIndexedLightPoints</B> tells <A HREF=#mgWriteDb>mgWriteDb</A> and <A HREF=#mgSaveAsDb>mgSaveAsDb</A> 
how to write light point records in the OpenFlight file.  If <I>flag</I> is 
<A HREF=#mgbool>MG_TRUE</A>, light points will be saved in the "non-indexed" format 
used in OpenFlight 15.7 and earlier.  This format is represented in the 
OpenFlight format as raw record code 111.  If <I>flag</I> is <A HREF=#mgbool>MG_FALSE</A> 
(the default), light points will be saved in the "indexed" format introduced 
in OpenFlight 15.8.  This format is represented in the 
OpenFlight format as raw record code 130.</P></DD><DD><P>The default value for this preference is <A HREF=#mgbool>MG_FALSE</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>flag</I></DT><DD>whether or not to save light points in the 
non-indexed format</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWriteDb>mgWriteDb</A>, <A HREF=#mgSaveAsDb>mgSaveAsDb</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetSaveUnreferencedUVs><H1 CLASS="APISYMBOL">mgSetSaveUnreferencedUVs</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetSaveUnreferencedUVs</B> - sets the preference that 
determines how unreferenced UV records are saved in an OpenFlight file.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgSetSaveUnreferencedUVs</B> (</TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>flag</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetSaveUnreferencedUVs</B> tells <A HREF=#mgWriteDb>mgWriteDb</A> and <A HREF=#mgSaveAsDb>mgSaveAsDb</A> 
how to write UV records on vertex and multitexture records in the OpenFlight 
file. If <I>flag</I> is <A HREF=#mgbool>MG_TRUE</A>, all UV records, regardless of whether 
or not they are referenced in the file, will be saved. If <I>flag</I> is <A HREF=#mgbool>MG_FALSE</A>, 
only UVs that are referenced will be saved.</P></DD><DD><P>The default value for this preference is <A HREF=#mgbool>MG_FALSE</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>flag</I></DT><DD>whether or not to save unreferenced UVs</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWriteDb>mgWriteDb</A>, <A HREF=#mgSaveAsDb>mgSaveAsDb</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetSwitchBit><H1 CLASS="APISYMBOL">mgSetSwitchBit</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetSwitchBit</B> - sets the on/off status of a specific 
bit within a switch mask.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetSwitchBit</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maskNo</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>bitNo</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>on</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSwitch>fltSwitch</A>
 node, <I>rec</I>, <B>mgSetSwitchBit</B> sets 
the value of the bit specified by <I>bitNo</I> within the mask <I>maskNo</I> 
on or off based on the value of <I>on</I>.</P></DD><DD><P>The value of <I>bitNo</I> must be between 0 and the number of 
children of <I>rec</I> minus 1 (the first child is <I>bitNo</I> 0). 
Similarly, the value of <I>maskNo</I> must be between 0 and the 
number of masks of <I>rec</I> minus 1 (the first mask is <I>maskNo</I> 0).</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSwitch>fltSwitch</A>
 node</DD><DT><I>maskNo</I></DT><DD>mask index starting from 0</DD><DT><I>bitNo</I></DT><DD>bit number starting from 0</DD><DT><I>on</I></DT><DD>value to set bits to</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>maskNo</I> does not specify a valid mask of <I>rec</I>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetSwitchMaskCount>mgGetSwitchMaskCount</A>, 
<A HREF=#mgGetSwitchMaskNo>mgGetSwitchMaskNo</A>, 
<A HREF=#mgGetSwitchBit>mgGetSwitchBit</A>, 
<A HREF=#mgGetSwitchMaskName>mgGetSwitchMaskName</A>, 
<A HREF=#mgAddSwitchMask>mgAddSwitchMask</A>, 
<A HREF=#mgDeleteSwitchMask>mgDeleteSwitchMask</A>, 
<A HREF=#mgInitSwitchMask>mgInitSwitchMask</A>, 
<A HREF=#mgSetSwitchMaskName>mgSetSwitchMaskName</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetSwitchDistance><H1 CLASS="APISYMBOL">mgSetSwitchDistance</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetSwitchDistance</B> - sets the current switch distance for a 
database<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetSwitchDistance</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>distance</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetSwitchDistance</B> sets the current switch distance for the database 
<I>db</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>distance</I></DT><DD>the switch distance</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetSwitchDistance>mgGetSwitchDistance</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetSwitchMaskName><H1 CLASS="APISYMBOL">mgSetSwitchMaskName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetSwitchMaskName</B> - sets the name of a switch mask.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetSwitchMaskName</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maskNo</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>name</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetSwitchMaskName</B> sets the name of mask <I>maskNo</I> on 
the switch node <I>rec</I> to the string <I>name</I>.</P></DD><DD><P>The value of <I>maskNo</I> must be between 0 and the number of masks 
of <I>rec</I> minus 1 (the first mask is <I>maskNo</I> 0).</P></DD><DD><P>To clear the name of a mask, set <I>name</I> to <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSwitch>fltSwitch</A>
 node</DD><DT><I>maskNo</I></DT><DD>switch mask number starting from 0</DD><DT><I>name</I></DT><DD>the name to assign to the mask</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise. 
This function will fail if <I>maskNo</I> does not specify a valid mask of <I>rec</I>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetSwitchMaskName>mgGetSwitchMaskName</A>, 
<A HREF=#mgGetSwitchMaskCount>mgGetSwitchMaskCount</A>, 
<A HREF=#mgGetSwitchMaskNo>mgGetSwitchMaskNo</A>, 
<A HREF=#mgGetSwitchBit>mgGetSwitchBit</A>, 
<A HREF=#mgAddSwitchMask>mgAddSwitchMask</A>, 
<A HREF=#mgDeleteSwitchMask>mgDeleteSwitchMask</A>, 
<A HREF=#mgInitSwitchMask>mgInitSwitchMask</A>, 
<A HREF=#mgSetSwitchBit>mgSetSwitchBit</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetTextString><H1 CLASS="APISYMBOL">mgSetTextString</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetTextString</B> - assigns a string to a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltText>fltText</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char* <B>mgSetTextString</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>name</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a text record, <I>rec</I>, <B>mgSetTextString</B> allocates space and copies <I>name</I> 
into <I>rec</I>'s string</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record</DD><DT><I>name</I></DT><DD>the string to be copied from</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetTextString>mgGetTextString</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetTextureAttributes><H1 CLASS="APISYMBOL">mgSetTextureAttributes</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetTextureAttributes</B> - sets the attributes of a texture 
palette entry.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgSetTextureAttributes</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>imgRec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a database node, <I>db</I>, and a texture palette entry 
specified by <I>index</I>, <B>mgSetTextureAttributes</B> sets the attributes 
record of the texture palette entry to the given attributes record, 
<I>imgRec</I> of type <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltImage>fltImage</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the texture palette entry</DD><DT><I>imgRec</I></DT><DD>a pointer to the attributes record</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetTextureAttributes>mgGetTextureAttributes</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetTextureGeoCtlPt><H1 CLASS="APISYMBOL">mgSetTextureGeoCtlPt</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetTextureGeoCtlPt</B> - sets the control points used 
to geo reference an image for a georeference info object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetTextureGeoCtlPt</B> (</TD><TD><A HREF=#mgimagegeoinfo>mgimagegeoinfo</A></TD><TD><I>geoInfo</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>imageX</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>imageY</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>projX</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>projY</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetTextureGeoCtlPt</B> sets a specified control point, <I>index</I> used 
to geo reference the image for the specified georeference info object, 
<I>geoInfo</I> to the specified values, <I>imageX</I>, <I>imageY</I>, <I>projX</I> and <I>projY</I>. 
The values <I>imageX</I> and <I>imageY</I> specify the location of the control point in image 
coordinates relative to the origin specified by <A HREF=#mgSetTextureGeoImageOrigin>mgSetTextureGeoImageOrigin</A>. 
The values <I>projX</I> and <I>projY</I> specify the location of the control point in the 
projected coordinate system specified by <A HREF=#mgSetTextureGeoProjection>mgSetTextureGeoProjection</A>.  If the 
projection was specified as <A HREF=#MIMG_GEOPROJ_GEODETIC>MIMG_GEOPROJ_GEODETIC</A>, these coordinates will be 
in degrees Longitude and Latitude respectively.  If the projection was specified 
as <A HREF=#MIMG_GEOPROJ_UTM>MIMG_GEOPROJ_UTM</A>, these coordinates will be in meters of Northing and 
Easting respectively.</P></DD><DD><P>When the image get geo info function, <A HREF=#mgimagegetgeoinfofunc>mgimagegetgeoinfofunc</A> 
is called for an image importer plug-in tool, the get geo info function 
uses this function to set a control point for the georeference info 
object.</P></DD><DD><P>The default valuea are 0.0, 0.0, 0.0 and 0.0.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>geoInfo</I></DT><DD>the georeference info object</DD><DT><I>index</I></DT><DD>the index of control point to set</DD><DT><I>imageX</I></DT><DD>the image x of the control point</DD><DT><I>imageY</I></DT><DD>the image y of control point</DD><DT><I>projX</I></DT><DD>the projected x of control point</DD><DT><I>projY</I></DT><DD>the projected y of control point</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgSetReadImageGeoInfoFunc>mgSetReadImageGeoInfoFunc</A>, 
<A HREF=#mgSetTextureGeoType>mgSetTextureGeoType</A>, <A HREF=#mgSetTextureGeoProjection>mgSetTextureGeoProjection</A>, 
<A HREF=#mgSetTextureGeoEarthModel>mgSetTextureGeoEarthModel</A>, <A HREF=#mgSetTextureGeoUTMZone>mgSetTextureGeoUTMZone</A>, 
<A HREF=#mgSetTextureGeoUTMHemisphere>mgSetTextureGeoUTMHemisphere</A>, <A HREF=#mgSetTextureGeoImageOrigin>mgSetTextureGeoImageOrigin</A>, 
<A HREF=#mgSetTextureGeoNumCtlPts>mgSetTextureGeoNumCtlPts</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetTextureGeoEarthModel><H1 CLASS="APISYMBOL">mgSetTextureGeoEarthModel</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetTextureGeoEarthModel</B> - sets the Earth model (Ellipsoid) 
attribute for a georeference info object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetTextureGeoEarthModel</B> (</TD><TD><A HREF=#mgimagegeoinfo>mgimagegeoinfo</A></TD><TD><I>geoInfo</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>earthModel</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetTextureGeoEarthModel</B> sets the Earth model (Ellipsoid) 
attribute for the specified georeference info object <I>geoInfo</I> to 
the specified value <I>earthModel</I>.</P></DD><DD><P>When the image get geo info function, <A HREF=#mgimagegetgeoinfofunc>mgimagegetgeoinfofunc</A> 
is called for an image importer plug-in tool, the get geo info function 
uses this function to set the Earth model attribute for the georeference 
info object.</P></DD><DD><P>Valid values for the Earth model attribute 
are <A HREF=#MIMG_GEOEARTH_WGS84>MIMG_GEOEARTH_WGS84</A>, <A HREF=#MIMG_GEOEARTH_WGS72>MIMG_GEOEARTH_WGS72</A>, 
<A HREF=#MIMG_GEOEARTH_BESSEL>MIMG_GEOEARTH_BESSEL</A>, and <A HREF=#MIMG_GEOEARTH_CLARK1866>MIMG_GEOEARTH_CLARK1866</A>.</P></DD><DD><P>The default value is <A HREF=#MIMG_GEOEARTH_WGS84>MIMG_GEOEARTH_WGS84</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>geoInfo</I></DT><DD>the georeference info object</DD><DT><I>earthModel</I></DT><DD>the Earth model attribute value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgSetReadImageGeoInfoFunc>mgSetReadImageGeoInfoFunc</A>, 
<A HREF=#mgSetTextureGeoType>mgSetTextureGeoType</A>, <A HREF=#mgSetTextureGeoProjection>mgSetTextureGeoProjection</A>, 
<A HREF=#mgSetTextureGeoUTMZone>mgSetTextureGeoUTMZone</A>, 
<A HREF=#mgSetTextureGeoUTMHemisphere>mgSetTextureGeoUTMHemisphere</A>, <A HREF=#mgSetTextureGeoImageOrigin>mgSetTextureGeoImageOrigin</A>, 
<A HREF=#mgSetTextureGeoNumCtlPts>mgSetTextureGeoNumCtlPts</A>, <A HREF=#mgSetTextureGeoCtlPt>mgSetTextureGeoCtlPt</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetTextureGeoImageOrigin><H1 CLASS="APISYMBOL">mgSetTextureGeoImageOrigin</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetTextureGeoImageOrigin</B> - sets the image origin 
attribute for a georeference info object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetTextureGeoImageOrigin</B> (</TD><TD><A HREF=#mgimagegeoinfo>mgimagegeoinfo</A></TD><TD><I>geoInfo</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>imageOrigin</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetTextureGeoImageOrigin</B> sets the image origin 
attribute for the specified georeference info object <I>geoInfo</I> 
to the specified value <I>imageOrigin</I>.  The image origin specifies 
the origin and the positive y direction used by image geographic 
control points.</P></DD><DD><P>When the image get geo info function, <A HREF=#mgimagegetgeoinfofunc>mgimagegetgeoinfofunc</A> 
is called for an image importer plug-in tool, the get geo info function 
uses this function to set the image origin attribute for the georeference 
info object.</P></DD><DD><P>Valid values for the image origin attribute 
are <A HREF=#MIMG_GEOIMAGEORIGIN_LL>MIMG_GEOIMAGEORIGIN_LL</A> (the image origin is in the lower left corner 
and y increases toward the top), and <A HREF=#MIMG_GEOIMAGEORIGIN_UL>MIMG_GEOIMAGEORIGIN_UL</A> (the image 
origin is in the upper left corner of the image and increases toward the 
bottom).</P></DD><DD><P>The default value is <A HREF=#MIMG_GEOIMAGEORIGIN_LL>MIMG_GEOIMAGEORIGIN_LL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>geoInfo</I></DT><DD>the georeference info object</DD><DT><I>imageOrigin</I></DT><DD>the hemisphere attribute value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgSetReadImageGeoInfoFunc>mgSetReadImageGeoInfoFunc</A>, 
<A HREF=#mgSetTextureGeoType>mgSetTextureGeoType</A>, <A HREF=#mgSetTextureGeoProjection>mgSetTextureGeoProjection</A>, 
<A HREF=#mgSetTextureGeoEarthModel>mgSetTextureGeoEarthModel</A>, <A HREF=#mgSetTextureGeoUTMZone>mgSetTextureGeoUTMZone</A>, 
<A HREF=#mgSetTextureGeoUTMHemisphere>mgSetTextureGeoUTMHemisphere</A>, 
<A HREF=#mgSetTextureGeoNumCtlPts>mgSetTextureGeoNumCtlPts</A>, <A HREF=#mgSetTextureGeoCtlPt>mgSetTextureGeoCtlPt</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetTextureGeoNumCtlPts><H1 CLASS="APISYMBOL">mgSetTextureGeoNumCtlPts</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetTextureGeoNumCtlPts</B> - sets the number of control 
points attribute (used to geo reference the image) for a georeference 
info object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetTextureGeoNumCtlPts</B> (</TD><TD><A HREF=#mgimagegeoinfo>mgimagegeoinfo</A></TD><TD><I>geoInfo</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>numCoords</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><A HREF=#mgSetTextureGeoImageOrigin>mgSetTextureGeoImageOrigin</A> sets the number of control points 
attribute for the specified georeference info object <I>geoInfo</I> to 
the specified value <I>numCoords</I>.</P></DD><DD><P>When the image get geo info function, <A HREF=#mgimagegetgeoinfofunc>mgimagegetgeoinfofunc</A> 
is called for an image importer plug-in tool, the get geo info function 
uses this function to set the number of control points attribute for the 
georeference info object.</P></DD><DD><P>Valid values for the number of control points attribute 
are any positive integer.</P></DD><DD><P>The default value is 0.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>geoInfo</I></DT><DD>the georeference info object</DD><DT><I>numCoords</I></DT><DD>the number of control points</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgSetReadImageGeoInfoFunc>mgSetReadImageGeoInfoFunc</A>, 
<A HREF=#mgSetTextureGeoType>mgSetTextureGeoType</A>, <A HREF=#mgSetTextureGeoProjection>mgSetTextureGeoProjection</A>, 
<A HREF=#mgSetTextureGeoEarthModel>mgSetTextureGeoEarthModel</A>, <A HREF=#mgSetTextureGeoUTMZone>mgSetTextureGeoUTMZone</A>, 
<A HREF=#mgSetTextureGeoUTMHemisphere>mgSetTextureGeoUTMHemisphere</A>, <A HREF=#mgSetTextureGeoImageOrigin>mgSetTextureGeoImageOrigin</A>, 
<A HREF=#mgSetTextureGeoCtlPt>mgSetTextureGeoCtlPt</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetTextureGeoProjection><H1 CLASS="APISYMBOL">mgSetTextureGeoProjection</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetTextureGeoProjection</B> - sets the map projection 
attribute for a georeference info object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetTextureGeoProjection</B> (</TD><TD><A HREF=#mgimagegeoinfo>mgimagegeoinfo</A></TD><TD><I>geoInfo</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>projection</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetTextureGeoProjection</B> sets the map projection 
attribute for the specified georeference info object <I>geoInfo</I> 
to the specified value <I>projection</I>.</P></DD><DD><P>When the image get geo info function, <A HREF=#mgimagegetgeoinfofunc>mgimagegetgeoinfofunc</A> 
is called for an image importer plug-in tool, the get geo info function 
uses this function to set the map projection attribute for the georeference 
info object.</P></DD><DD><P>Valid values for the projection attribute 
are <A HREF=#MIMG_GEOPROJ_GEODETIC>MIMG_GEOPROJ_GEODETIC</A>, and <A HREF=#MIMG_GEOPROJ_UTM>MIMG_GEOPROJ_UTM</A>.</P></DD><DD><P>The default value is <A HREF=#MIMG_GEOEARTH_WGS84>MIMG_GEOEARTH_WGS84</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>geoInfo</I></DT><DD>the georeference info object</DD><DT><I>projection</I></DT><DD>the map projection attribute value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgSetReadImageGeoInfoFunc>mgSetReadImageGeoInfoFunc</A>, 
<A HREF=#mgSetTextureGeoType>mgSetTextureGeoType</A>, 
<A HREF=#mgSetTextureGeoEarthModel>mgSetTextureGeoEarthModel</A>, <A HREF=#mgSetTextureGeoUTMZone>mgSetTextureGeoUTMZone</A>, 
<A HREF=#mgSetTextureGeoUTMHemisphere>mgSetTextureGeoUTMHemisphere</A>, <A HREF=#mgSetTextureGeoImageOrigin>mgSetTextureGeoImageOrigin</A>, 
<A HREF=#mgSetTextureGeoNumCtlPts>mgSetTextureGeoNumCtlPts</A>, <A HREF=#mgSetTextureGeoCtlPt>mgSetTextureGeoCtlPt</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetTextureGeoType><H1 CLASS="APISYMBOL">mgSetTextureGeoType</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetTextureGeoType</B> - sets the geographic control type 
attribute for a georeference info object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetTextureGeoType</B> (</TD><TD><A HREF=#mgimagegeoinfo>mgimagegeoinfo</A></TD><TD><I>geoInfo</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>type</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetTextureGeoType</B> sets the geographic control type 
attribute for the specified georeference info object <I>geoInfo</I> 
to the specified value <I>type</I>.</P></DD><DD><P>When the image get geo info function, <A HREF=#mgimagegetgeoinfofunc>mgimagegetgeoinfofunc</A> 
is called for an image importer plug-in tool, the get geo info function 
uses this function to set the geographic control type attribute for the 
georeference info object.</P></DD><DD><P>Valid values for the geographic control type attribute 
are <A HREF=#MIMG_GEOTYPE_CTRLPT>MIMG_GEOTYPE_CTRLPT</A>.</P></DD><DD><P>The default value is <A HREF=#MIMG_GEOTYPE_CTRLPT>MIMG_GEOTYPE_CTRLPT</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>geoInfo</I></DT><DD>the georeference info object</DD><DT><I>type</I></DT><DD>the geographic control type attribute value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgSetReadImageGeoInfoFunc>mgSetReadImageGeoInfoFunc</A>, 
<A HREF=#mgSetTextureGeoProjection>mgSetTextureGeoProjection</A>, 
<A HREF=#mgSetTextureGeoEarthModel>mgSetTextureGeoEarthModel</A>, <A HREF=#mgSetTextureGeoUTMZone>mgSetTextureGeoUTMZone</A>, 
<A HREF=#mgSetTextureGeoUTMHemisphere>mgSetTextureGeoUTMHemisphere</A>, <A HREF=#mgSetTextureGeoImageOrigin>mgSetTextureGeoImageOrigin</A>, 
<A HREF=#mgSetTextureGeoNumCtlPts>mgSetTextureGeoNumCtlPts</A>, <A HREF=#mgSetTextureGeoCtlPt>mgSetTextureGeoCtlPt</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetTextureGeoUTMHemisphere><H1 CLASS="APISYMBOL">mgSetTextureGeoUTMHemisphere</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetTextureGeoUTMHemisphere</B> - sets the hemisphere 
attribute for a georeference info object for the UTM ptojection.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetTextureGeoUTMHemisphere</B> (</TD><TD><A HREF=#mgimagegeoinfo>mgimagegeoinfo</A></TD><TD><I>geoInfo</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>hemisphere</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetTextureGeoUTMHemisphere</B> sets the hemisphere 
attribute for the specified georeference info object <I>geoInfo</I> to the 
specified value <I>hemisphere</I> for the UTM ptojection, <A HREF=#MIMG_GEOPROJ_UTM>MIMG_GEOPROJ_UTM</A>.</P></DD><DD><P>When the image get geo info function, <A HREF=#mgimagegetgeoinfofunc>mgimagegetgeoinfofunc</A> 
is called for an image importer plug-in tool, the get geo info function 
uses this function to set the hemisphere attribute for the georeference 
info object.</P></DD><DD><P>Valid values for the hemisphere attribute 
are <A HREF=#MIMG_GEOHEMISPHERE_NORTH>MIMG_GEOHEMISPHERE_NORTH</A>, and <A HREF=#MIMG_GEOHEMISPHERE_SOUTH>MIMG_GEOHEMISPHERE_SOUTH</A>.</P></DD><DD><P>The default value is <A HREF=#MIMG_GEOHEMISPHERE_NORTH>MIMG_GEOHEMISPHERE_NORTH</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>geoInfo</I></DT><DD>the georeference info object</DD><DT><I>hemisphere</I></DT><DD>the hemisphere attribute value 
for UTM projection</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgSetReadImageGeoInfoFunc>mgSetReadImageGeoInfoFunc</A>, 
<A HREF=#mgSetTextureGeoType>mgSetTextureGeoType</A>, <A HREF=#mgSetTextureGeoProjection>mgSetTextureGeoProjection</A>, 
<A HREF=#mgSetTextureGeoEarthModel>mgSetTextureGeoEarthModel</A>, <A HREF=#mgSetTextureGeoUTMZone>mgSetTextureGeoUTMZone</A>, 
<A HREF=#mgSetTextureGeoImageOrigin>mgSetTextureGeoImageOrigin</A>, 
<A HREF=#mgSetTextureGeoNumCtlPts>mgSetTextureGeoNumCtlPts</A>, <A HREF=#mgSetTextureGeoCtlPt>mgSetTextureGeoCtlPt</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetTextureGeoUTMZone><H1 CLASS="APISYMBOL">mgSetTextureGeoUTMZone</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetTextureGeoUTMZone</B> - sets the UTM zone 
attribute for a georeference info object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetTextureGeoUTMZone</B> (</TD><TD><A HREF=#mgimagegeoinfo>mgimagegeoinfo</A></TD><TD><I>geoInfo</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>zone</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetTextureGeoUTMZone</B> sets the UTM zone 
attribute for the specified georeference info object <I>geoInfo</I> to the 
specified value <I>zone</I>.</P></DD><DD><P>When the image get geo info function, <A HREF=#mgimagegetgeoinfofunc>mgimagegetgeoinfofunc</A> 
is called for an image importer plug-in tool, the get geo info function 
uses this function to set the UTM zone attribute for the georeference 
info object.</P></DD><DD><P>Valid values for the UTM zone attribute are 1 through 60.</P></DD><DD><P>There is no default value for this attribute, so this attribute 
must be set if the projection was set to <A HREF=#MIMG_GEOPROJ_UTM>MIMG_GEOPROJ_UTM</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>geoInfo</I></DT><DD>the georeference info object</DD><DT><I>zone</I></DT><DD>the UTM zone attribute value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgSetReadImageGeoInfoFunc>mgSetReadImageGeoInfoFunc</A>, 
<A HREF=#mgSetTextureGeoType>mgSetTextureGeoType</A>, <A HREF=#mgSetTextureGeoProjection>mgSetTextureGeoProjection</A>, 
<A HREF=#mgSetTextureGeoEarthModel>mgSetTextureGeoEarthModel</A>, 
<A HREF=#mgSetTextureGeoUTMHemisphere>mgSetTextureGeoUTMHemisphere</A>, <A HREF=#mgSetTextureGeoImageOrigin>mgSetTextureGeoImageOrigin</A>, 
<A HREF=#mgSetTextureGeoNumCtlPts>mgSetTextureGeoNumCtlPts</A>, <A HREF=#mgSetTextureGeoCtlPt>mgSetTextureGeoCtlPt</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetTextureHeight><H1 CLASS="APISYMBOL">mgSetTextureHeight</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetTextureHeight</B> - sets height attribute for an image 
object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetTextureHeight</B> (</TD><TD><A HREF=#mgimageinfo>mgimageinfo</A></TD><TD><I>textureInfo</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>height</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetTextureHeight</B> sets the height attribute for the specified 
image object <I>textureInfo</I> to the specified value <I>height</I>.</P></DD><DD><P>When the image get info function, <A HREF=#mgimagegetinfofunc>mgimagegetinfofunc</A> is called for an image 
importer plug-in tool, the get info function will use this function 
to set the height attribute for the image object.</P></DD><DD><P>There is no default value for this attribute, so this attribute must be set.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>textureInfo</I></DT><DD>the image object</DD><DT><I>height</I></DT><DD>the height attribute value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgSetTextureWidth>mgSetTextureWidth</A>, 
<A HREF=#mgSetTextureType>mgSetTextureType</A>, <A HREF=#mgSetTextureSampleSize>mgSetTextureSampleSize</A>, 
<A HREF=#mgSetTextureTiledFlag>mgSetTextureTiledFlag</A>, <A HREF=#mgSetTextureMinMax>mgSetTextureMinMax</A>, 
<A HREF=#mgSetTextureTransparentValue>mgSetTextureTransparentValue</A>, <A HREF=#mgSetTextureSignedFlag>mgSetTextureSignedFlag</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetTextureMinMax><H1 CLASS="APISYMBOL">mgSetTextureMinMax</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetTextureMinMax</B> - sets the minimum and maximum texel value 
attributes for an image object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetTextureMinMax</B> (</TD><TD><A HREF=#mgimageinfo>mgimageinfo</A></TD><TD><I>textureInfo</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>min</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>max</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetTextureMinMax</B> sets the minimum and maximum texel value 
attributes for the specified image object <I>textureInfo</I> to the 
specified values <I>min</I> and  <I>max</I>.</P></DD><DD><P>When the image get info function, <A HREF=#mgimagegetinfofunc>mgimagegetinfofunc</A> is called for an image 
importer plug-in tool, the get info function uses this function 
to set the tiled attribute for the image object.</P></DD><DD><P>The default value for the minimum is 0.0 and the maximum is 255.0.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>textureInfo</I></DT><DD>the image object</DD><DT><I>min</I></DT><DD>the minimum texel value attribute value</DD><DT><I>max</I></DT><DD>the maximum texel value attribute value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgSetTextureWidth>mgSetTextureWidth</A>, 
<A HREF=#mgSetTextureHeight>mgSetTextureHeight</A>, <A HREF=#mgSetTextureType>mgSetTextureType</A>, 
<A HREF=#mgSetTextureSampleSize>mgSetTextureSampleSize</A>, <A HREF=#mgSetTextureTiledFlag>mgSetTextureTiledFlag</A>, 
<A HREF=#mgSetTextureTransparentValue>mgSetTextureTransparentValue</A>, <A HREF=#mgSetTextureSignedFlag>mgSetTextureSignedFlag</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetTextureName><H1 CLASS="APISYMBOL">mgSetTextureName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetTextureName</B> - sets the name of a texture palette entry.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgSetTextureName</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>textureName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetTextureName</B> sets the name of the texture palette entry, 
specified by <I>index</I>, to <I>textureName</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the  index of the texture palette entry</DD><DT><I>textureName</I></DT><DD>the new name of the texture</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetTextureName>mgGetTextureName</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetTexturePosition><H1 CLASS="APISYMBOL">mgSetTexturePosition</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetTexturePosition</B> - sets the position of a texture 
palette entry.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgSetTexturePosition</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>y</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetTexturePosition</B> sets the position of the lower left corner 
of the specified texture palette entry in a database&#146s texture palette 
(as displayed in MultiGen Creator). The position is in pixels relative 
to the lower left corner of the palette.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the texture palette entry</DD><DT><I>x</I></DT><DD>the x position of the texture, in pixels</DD><DT><I>y</I></DT><DD>the y position of the texture, in pixels</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetTexturePosition>mgGetTexturePosition</A>, <A HREF=#mgReadTexture>mgReadTexture</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetTextureSampleSize><H1 CLASS="APISYMBOL">mgSetTextureSampleSize</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetTextureSampleSize</B> - sets sample size attribute for 
an image object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetTextureSampleSize</B> (</TD><TD><A HREF=#mgimageinfo>mgimageinfo</A></TD><TD><I>textureInfo</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>sampleSize</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetTextureSampleSize</B> sets the sample size attribute for 
the specified 
image object <I>textureInfo</I> to the specified value <I>sampleSize</I>.</P></DD><DD><P>When the image get info function, <A HREF=#mgimagegetinfofunc>mgimagegetinfofunc</A> is called 
for an image importer plug-in tool, the get info function uses this function 
to set the sample size attribute for the image object.</P></DD><DD><P>Valid values for the sample size attribute 
are 8 bits per texel per component and 16 bits per texel per component.</P></DD><DD><P>The default value for this attribute is 8 per texel per component.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>textureInfo</I></DT><DD>the image object</DD><DT><I>sampleSize</I></DT><DD>the sample size attribute value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgSetTextureWidth>mgSetTextureWidth</A>, 
<A HREF=#mgSetTextureHeight>mgSetTextureHeight</A>, <A HREF=#mgSetTextureType>mgSetTextureType</A>, 
<A HREF=#mgSetTextureTiledFlag>mgSetTextureTiledFlag</A>, <A HREF=#mgSetTextureMinMax>mgSetTextureMinMax</A>, 
<A HREF=#mgSetTextureTransparentValue>mgSetTextureTransparentValue</A>, <A HREF=#mgSetTextureSignedFlag>mgSetTextureSignedFlag</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetTextureSignedFlag><H1 CLASS="APISYMBOL">mgSetTextureSignedFlag</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetTextureSignedFlag</B> - sets the signed flag 
attribute for an image object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetTextureSignedFlag</B> (</TD><TD><A HREF=#mgimageinfo>mgimageinfo</A></TD><TD><I>textureInfo</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>isSigned</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetTextureSignedFlag</B> sets the signed flag 
attribute for the specified image object <I>textureInfo</I> to the 
specified value <I>isSigned</I>.  If this value is set to <A HREF=#mgbool>MG_TRUE</A> 
the texel values will be interpreted as signed values. If this value is set 
to <A HREF=#mgbool>MG_FALSE</A> the texel values will be interpreted as unsigned values.</P></DD><DD><P>When the image get info function, <A HREF=#mgimagegetinfofunc>mgimagegetinfofunc</A> is called for an image 
importer plug-in tool, the get info function uses this function 
to set the tiled attribute for the image object.</P></DD><DD><P>Valid values for the signed flag attribute 
are <A HREF=#mgbool>MG_TRUE</A> and <A HREF=#mgbool>MG_FALSE</A>.</P></DD><DD><P>The default value is <A HREF=#mgbool>MG_FALSE</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>textureInfo</I></DT><DD>the image object</DD><DT><I>isSigned</I></DT><DD>the signed flag attribute value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgSetTextureWidth>mgSetTextureWidth</A>, 
<A HREF=#mgSetTextureHeight>mgSetTextureHeight</A>, <A HREF=#mgSetTextureType>mgSetTextureType</A>, 
<A HREF=#mgSetTextureSampleSize>mgSetTextureSampleSize</A>, <A HREF=#mgSetTextureTiledFlag>mgSetTextureTiledFlag</A>, 
<A HREF=#mgSetTextureMinMax>mgSetTextureMinMax</A>, <A HREF=#mgSetTextureTransparentValue>mgSetTextureTransparentValue</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetTextureTexels><H1 CLASS="APISYMBOL">mgSetTextureTexels</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetTextureTexels</B> - sets the texels of a texture palette entry.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgSetTextureTexels</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>unsigned char*</TD><TD><I>texels</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetTextureTexels</B> sets the texels for the texture palette 
entry specified by <I>index</I>.  The width, height, and type of the new 
image must match the width, height, and type of the original image.</P></DD><DD><P>Note: The OpenFlight API will take ownership of the texels you pass in so 
after you call <B>mgSetTextureTexels</B>, you should not further modify them, free 
them  or assign these texels to yet another texture in the database.  Furthermore, 
the texels you pass here should not be those returned from <A HREF=#mgGetTextureTexels>mgGetTextureTexels</A>. 
Doing any of these will lead to unexpected results and may cause a crash.</P></DD><DD><P>See <A HREF=#mgReadImage>mgReadImage</A> for a description of the memory layout 
for the texels expected.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the index of the texture palette entry</DD><DT><I>texels</I></DT><DD>a pointer to the new texels</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetTextureTexels>mgGetTextureTexels</A>, <A HREF=#mgReadImage>mgReadImage</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetTextureTiledFlag><H1 CLASS="APISYMBOL">mgSetTextureTiledFlag</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetTextureTiledFlag</B> - sets tiled attribute for 
an image object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetTextureTiledFlag</B> (</TD><TD><A HREF=#mgimageinfo>mgimageinfo</A></TD><TD><I>textureInfo</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>isTiled</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetTextureTiledFlag</B> sets the tiled attribute for 
the specified image object <I>textureInfo</I> to the 
specified value <I>isTiled</I>.</P></DD><DD><P>When the image get info function, <A HREF=#mgimagegetinfofunc>mgimagegetinfofunc</A> is called for an image 
importer plug-in tool, the get info function uses this function 
to set the tiled attribute for the image object.</P></DD><DD><P>Valid values for the sample size attribute 
are <A HREF=#mgbool>MG_FALSE</A>.</P></DD><DD><P>The default value for this attribute is <A HREF=#mgbool>MG_FALSE</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>textureInfo</I></DT><DD>the image object</DD><DT><I>isTiled</I></DT><DD>the tiled attribute value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgSetTextureWidth>mgSetTextureWidth</A>, 
<A HREF=#mgSetTextureHeight>mgSetTextureHeight</A>, <A HREF=#mgSetTextureType>mgSetTextureType</A>, 
<A HREF=#mgSetTextureSampleSize>mgSetTextureSampleSize</A>, <A HREF=#mgSetTextureMinMax>mgSetTextureMinMax</A>, 
<A HREF=#mgSetTextureTransparentValue>mgSetTextureTransparentValue</A>, <A HREF=#mgSetTextureSignedFlag>mgSetTextureSignedFlag</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetTextureTransparentValue><H1 CLASS="APISYMBOL">mgSetTextureTransparentValue</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetTextureTransparentValue</B> - sets the transparent texel 
value attribute for an image object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetTextureTransparentValue</B> (</TD><TD><A HREF=#mgimageinfo>mgimageinfo</A></TD><TD><I>textureInfo</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>transparentValue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetTextureTransparentValue</B> sets the transparent texel value 
attribute for the specified image object <I>textureInfo</I> to the 
specified value <I>transparentValue</I>.  This should only be called for images 
which have a transparent texel value as this function also sets the 
hasTranspVal flag (and there is no way to clear the flag).</P></DD><DD><P>When the image get info function, <A HREF=#mgimagegetinfofunc>mgimagegetinfofunc</A> is called for an image 
importer plug-in tool, the get info function uses this function 
to set the tiled attribute for the image object.</P></DD><DD><P>The default value is 0 with the hasTranspVal flag set to <A HREF=#mgbool>MG_FALSE</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>textureInfo</I></DT><DD>the image object</DD><DT><I>transparentValue</I></DT><DD>the transparent texel value attribute value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgSetTextureWidth>mgSetTextureWidth</A>, 
<A HREF=#mgSetTextureHeight>mgSetTextureHeight</A>, <A HREF=#mgSetTextureType>mgSetTextureType</A>, 
<A HREF=#mgSetTextureSampleSize>mgSetTextureSampleSize</A>, <A HREF=#mgSetTextureTiledFlag>mgSetTextureTiledFlag</A>, 
<A HREF=#mgSetTextureMinMax>mgSetTextureMinMax</A>, <A HREF=#mgSetTextureSignedFlag>mgSetTextureSignedFlag</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetTextureType><H1 CLASS="APISYMBOL">mgSetTextureType</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetTextureType</B> - sets type attribute for an image object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetTextureType</B> (</TD><TD><A HREF=#mgimageinfo>mgimageinfo</A></TD><TD><I>textureInfo</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>type</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetTextureType</B> sets the type attribute for the specified 
image object <I>textureInfo</I> to the specified value <I>type</I>.</P></DD><DD><P>When the image get info function, <A HREF=#mgimagegetinfofunc>mgimagegetinfofunc</A> is called for an image 
importer plug-in tool, the get info function will use this function 
to set the type attribute for the image object.</P></DD><DD><P>Valid values for the image type attribute 
are <A HREF=#MIMG_INT>MIMG_INT</A>, <A HREF=#MIMG_INTA>MIMG_INTA</A>, 
<A HREF=#MIMG_RGB>MIMG_RGB</A>, and <A HREF=#MIMG_RGBA>MIMG_RGBA</A>.</P></DD><DD><P>There is no default value for this attribute, so this attribute must be set.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>textureInfo</I></DT><DD>the image object</DD><DT><I>type</I></DT><DD>the image type attribute value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgSetTextureWidth>mgSetTextureWidth</A>, 
<A HREF=#mgSetTextureHeight>mgSetTextureHeight</A>, <A HREF=#mgSetTextureSampleSize>mgSetTextureSampleSize</A>, 
<A HREF=#mgSetTextureTiledFlag>mgSetTextureTiledFlag</A>, <A HREF=#mgSetTextureMinMax>mgSetTextureMinMax</A>, 
<A HREF=#mgSetTextureTransparentValue>mgSetTextureTransparentValue</A>, <A HREF=#mgSetTextureSignedFlag>mgSetTextureSignedFlag</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetTextureWidth><H1 CLASS="APISYMBOL">mgSetTextureWidth</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetTextureWidth</B> - sets width attribute for an image info 
object.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetTextureWidth</B> (</TD><TD><A HREF=#mgimageinfo>mgimageinfo</A></TD><TD><I>textureInfo</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>width</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetTextureWidth</B> sets the width attribute for the specified 
image info object <I>textureInfo</I> to the specified value <I>width</I>.</P></DD><DD><P>When the image get info function, <A HREF=#mgimagegetinfofunc>mgimagegetinfofunc</A> is called 
for an image importer plug-in tool, the get info function uses this function 
to set the width attribute for the image info object.</P></DD><DD><P>There is no default value for this attribute, so this attribute 
must be set.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>textureInfo</I></DT><DD>the image info object</DD><DT><I>width</I></DT><DD>the width attribute value</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, 
<A HREF=#mgSetTextureHeight>mgSetTextureHeight</A>, <A HREF=#mgSetTextureType>mgSetTextureType</A>, 
<A HREF=#mgSetTextureSampleSize>mgSetTextureSampleSize</A>, <A HREF=#mgSetTextureTiledFlag>mgSetTextureTiledFlag</A>, 
<A HREF=#mgSetTextureMinMax>mgSetTextureMinMax</A>, <A HREF=#mgSetTextureTransparentValue>mgSetTextureTransparentValue</A>, 
<A HREF=#mgSetTextureSignedFlag>mgSetTextureSignedFlag</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetTitle><H1 CLASS="APISYMBOL">mgSetTitle</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetTitle</B> - sets the title string for a dialog.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgSetTitle</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>dialog</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>string</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetTitle</B> sets the title of the specified <I>dialog</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>dialog</I></DT><DD>the dialog whose title will be set</DD><DT><I>string</I></DT><DD>the title string</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetTitle>mgGetTitle</A>, <A HREF=#mgGetCaption>mgGetCaption</A>, <A HREF=#mgSetCaption>mgSetCaption</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetUserData><H1 CLASS="APISYMBOL">mgSetUserData</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetUserData</B> - sets the user data pointer of a record.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgSetUserData</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>ptr</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetUserData</B> sets the user data associated to the specified 
record <I>rec</I> to the value <I>ptr</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record</DD><DT><I>ptr</I></DT><DD>the data pointer</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetUserData>mgGetUserData</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetVector><H1 CLASS="APISYMBOL">mgSetVector</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetVector</B> - sets the attribute values in a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVector>fltVector</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetVector</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>vectorCode</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>i</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>j</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>k</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a record <I>rec</I>, and the name of one of its <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVector>fltVector</A>
 attribute records, 
<I>vectorCode</I>, <B>mgSetVector</B> sets the i, j, k attribute values in the 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVector>fltVector</A>
 attribute record.</P></DD><DD><P>For setting vertex normals, it is much more efficient to call the 
convenience function <A HREF=#mgSetVtxNormal>mgSetVtxNormal</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record whose <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVector>fltVector</A>
 record is to be set</DD><DT><I>vectorCode</I></DT><DD>the name of the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVector>fltVector</A>
 attribute record of <I>rec</I></DD><DT><I>i</I></DT><DD>the i value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVector>fltVector</A>
 attribute record</DD><DT><I>j</I></DT><DD>the j value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVector>fltVector</A>
 attribute record</DD><DT><I>k</I></DT><DD>the k value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVector>fltVector</A>
 attribute record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCoord3d>mgSetCoord3d</A>, <A HREF=#mgSetVectord>mgSetVectord</A>, <A HREF=#mgSetVtxNormal>mgSetVtxNormal</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetVectord><H1 CLASS="APISYMBOL">mgSetVectord</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetVectord</B> - sets the attribute values in a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVectord>fltVectord</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetVectord</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>vectorCode</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>i</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>j</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>k</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a record <I>rec</I>, and the name of one of its <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVectord>fltVectord</A>
 attribute records, 
<I>vectorCode</I>, <B>mgSetVectord</B> sets the i, j, k attribute values in the 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVectord>fltVectord</A>
 attribute record.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record whose <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVectord>fltVectord</A>
 record is to be set</DD><DT><I>vectorCode</I></DT><DD>the name of the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVectord>fltVectord</A>
 attribute record of <I>rec</I></DD><DT><I>i</I></DT><DD>the i value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVectord>fltVectord</A>
 attribute record</DD><DT><I>j</I></DT><DD>the j value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVectord>fltVectord</A>
 attribute record</DD><DT><I>k</I></DT><DD>the k value to set in the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVectord>fltVectord</A>
 attribute record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetCoord3d>mgSetCoord3d</A>, <A HREF=#mgSetVector>mgSetVector</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetVisible><H1 CLASS="APISYMBOL">mgSetVisible</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetVisible</B> - displays or hides a control in a dialog.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgSetVisible</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>visible</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Depending on the value of the parameter <I>visible</I>, <B>mgSetVisible</B> 
either displays (<A HREF=#mgbool>MG_TRUE</A>) or hides (<A HREF=#mgbool>MG_FALSE</A>) the 
<I>control</I>.  Controls that are visible can be seen on the dialog.</P></DD><DD><P>If the control you specify to this function has any buddy controls 
associated, the buddy controls are also hidden/displayed accordingly.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the control to display or hide</DD><DT><I>visible</I></DT><DD>enum mgbool <A HREF=#mgbool>MG_TRUE</A> to display control, 
<A HREF=#mgbool>MG_FALSE</A> to hide control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgIsVisible>mgIsVisible</A>, <A HREF=#mgSetEnabled>mgSetEnabled</A>, <A HREF=#mgIsEnabled>mgIsEnabled</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetVtxBackColorRGB><H1 CLASS="APISYMBOL">mgSetVtxBackColorRGB</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetVtxBackColorRGB</B> - sets the RGB back color values 
for a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetVtxBackColorRGB</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>vtx</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>red</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>green</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>blue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record, <I>vtx</I>, <B>mgSetVtxBackColorRGB</B> sets the red, green, and blue 
values of its back color to the given <I>red</I>, <I>green</I>, and <I>blue</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>vtx</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record on which to set the color values</DD><DT><I>red</I></DT><DD>the red value to set</DD><DT><I>green</I></DT><DD>the green value to set</DD><DT><I>blue</I></DT><DD>the blue value to set</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetVtxColorRGBA>mgSetVtxColorRGBA</A>, <A HREF=#mgGetVtxBackColorRGB>mgGetVtxBackColorRGB</A>, 
<A HREF=#mgGetVtxColorRGB>mgGetVtxColorRGB</A>, <A HREF=#mgGetVtxColorRGBA>mgGetVtxColorRGBA</A>, 
<A HREF=#mgGetPolyColorRGB>mgGetPolyColorRGB</A>, <A HREF=#mgSetPolyColorRGB>mgSetPolyColorRGB</A>, 
<A HREF=#mgGetPolyAltColorRGB>mgGetPolyAltColorRGB</A>, <A HREF=#mgSetPolyAltColorRGB>mgSetPolyAltColorRGB</A>, 
<A HREF=#mgSetAttList>mgSetAttList</A>, <A HREF=#mgSetAttBuf>mgSetAttBuf</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetVtxColorName><H1 CLASS="APISYMBOL">mgSetVtxColorName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetVtxColorName</B> - sets the color name of a 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetVtxColorName</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>vtx</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>name</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record, <I>vtx</I>, 
and a string, <I>name</I>, <B>mgSetVtxColorName</B> stores <I>name</I> as 
the color name for <I>vtx</I>. If the name given is not in the color palette, 
<B>mgSetVtxColorName</B> returns <A HREF=#mgbool>MG_FALSE</A>.</P></DD><DD><P>To clear the color name for a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
, 
set <I>name</I> to NULL or the empty string.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>vtx</I></DT><DD>a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record</DD><DT><I>name</I></DT><DD>the color name</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise..
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetVtxColorName>mgGetVtxColorName</A>, <A HREF=#mgGetPolyColorName>mgGetPolyColorName</A>, 
<A HREF=#mgGetPolyAltColorName>mgGetPolyAltColorName</A>, 
<A HREF=#mgNewColorName>mgNewColorName</A>, <A HREF=#mgGetNextColorName>mgGetNextColorName</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetVtxColorRGB><H1 CLASS="APISYMBOL">mgSetVtxColorRGB</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetVtxColorRGB</B> - sets the RGB color values in a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetVtxColorRGB</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>vtx</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>red</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>green</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>blue</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record, <I>vtx</I>, <B>mgSetVtxColorRGB</B> sets the red, green, and blue 
values of its <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVColor</A>
 attribute to the given <I>red</I>, <I>green</I>, and <I>blue</I>.</P></DD><DD><P>Note that if the database containing 
<I>vtx</I> is color index mode, this function will convert the given color values 
to the closest index and intensity pair and set the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVColor</A>
 and 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVIntensity</A>
 attributes of <I>vtx</I> accordingly.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>vtx</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record on which to set the color values</DD><DT><I>red</I></DT><DD>the red value to set</DD><DT><I>green</I></DT><DD>the green value to set</DD><DT><I>blue</I></DT><DD>the blue value to set</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetVtxColorRGBA>mgSetVtxColorRGBA</A>, <A HREF=#mgGetVtxColorRGB>mgGetVtxColorRGB</A>, <A HREF=#mgGetVtxColorRGBA>mgGetVtxColorRGBA</A>, 
<A HREF=#mgGetPolyColorRGB>mgGetPolyColorRGB</A>, <A HREF=#mgSetPolyColorRGB>mgSetPolyColorRGB</A>, 
<A HREF=#mgGetPolyAltColorRGB>mgGetPolyAltColorRGB</A>, <A HREF=#mgSetPolyAltColorRGB>mgSetPolyAltColorRGB</A>, 
<A HREF=#mgSetAttList>mgSetAttList</A>, <A HREF=#mgSetAttBuf>mgSetAttBuf</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetVtxColorRGBA><H1 CLASS="APISYMBOL">mgSetVtxColorRGBA</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetVtxColorRGBA</B> - sets the RGBA color values in a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetVtxColorRGBA</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>vtx</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>red</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>green</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>blue</I>,</TD></TR>
<TR><TD></TD><TD>short</TD><TD><I>alpha</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record, <I>vtx</I>, <B>mgSetVtxColorRGBA</B> sets the red, green and 
blue values of its <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVColor</A>
 attribute to the given <I>red</I>, <I>green</I>, 
<I>blue</I>. Similarly the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVAlpha</A>
 attribute is set according to <I>alpha</I>.</P></DD><DD><P>Note that if the database containing 
<I>vtx</I> is color index mode, this function will convert the given color values 
to the closest index and intensity pair and set the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVColor</A>
 and 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVIntensity</A>
 attributes of <I>vtx</I> accordingly. The <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVAlpha</A>
 
attribute is set independently.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>vtx</I></DT><DD>the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record on which to set the color values</DD><DT><I>red</I></DT><DD>the red value to set</DD><DT><I>green</I></DT><DD>the green value to set</DD><DT><I>blue</I></DT><DD>the blue value to set</DD><DT><I>alpha</I></DT><DD>the alpha value to set</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetVtxColorRGB>mgSetVtxColorRGB</A>, <A HREF=#mgGetVtxColorRGB>mgGetVtxColorRGB</A>, <A HREF=#mgGetVtxColorRGBA>mgGetVtxColorRGBA</A>, 
<A HREF=#mgGetPolyColorRGB>mgGetPolyColorRGB</A>, <A HREF=#mgSetPolyColorRGB>mgSetPolyColorRGB</A>, 
<A HREF=#mgGetPolyAltColorRGB>mgGetPolyAltColorRGB</A>, <A HREF=#mgSetPolyAltColorRGB>mgSetPolyAltColorRGB</A>, 
<A HREF=#mgSetAttList>mgSetAttList</A>, <A HREF=#mgSetAttBuf>mgSetAttBuf</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetVtxCoord><H1 CLASS="APISYMBOL">mgSetVtxCoord</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetVtxCoord</B> - sets the x,y,z coordinate of a 
vertex record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetVtxCoord</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>x</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>y</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>z</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetVtxCoord</B> sets the <I>x</I>, <I>y</I>, and <I>z</I> values of the 
vertex coordinate of a vertex record <I>rec</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>a vertex record</DD><DT><I>x</I></DT><DD>x coordinate</DD><DT><I>y</I></DT><DD>y coordinate</DD><DT><I>z</I></DT><DD>z coordinate</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the coordinate values were set 
successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetVtxCoord>mgGetVtxCoord</A>, <A HREF=#mgSetCoord3d>mgSetCoord3d</A></DD></DL>
<HR>
<LEFT><A NAME=mgSetVtxNormal><H1 CLASS="APISYMBOL">mgSetVtxNormal</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSetVtxNormal</B> - sets the normal vector of a 
vertex record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSetVtxNormal</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>i</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>j</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>k</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSetVtxNormal</B> sets the <I>i</I>, <I>j</I>, and <I>k</I> values of the 
vertex normal vector of a vertex record <I>rec</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>a vertex record</DD><DT><I>i</I></DT><DD>i component of the normal vector</DD><DT><I>j</I></DT><DD>j component of the normal vector</DD><DT><I>k</I></DT><DD>k component of the normal vector</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if the vertex normal was set, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetPolyNormal>mgGetPolyNormal</A>, <A HREF=#mgGetVtxNormal>mgGetVtxNormal</A>, <A HREF=#mgRemoveVtxNormal>mgRemoveVtxNormal</A></DD></DL>
<HR>
<LEFT><A NAME=mgShaderAddFragmentProgram><H1 CLASS="APISYMBOL">mgShaderAddFragmentProgram</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgShaderAddFragmentProgram</B> - adds a fragment program to a shader.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgShaderAddFragmentProgram</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>shader</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>programFileName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgShaderAddFragmentProgram</B> adds the fragment program specified by 
<I>programFileName</I> to the specified <I>shader</I>.</P></DD><DD><P>Note: GLSL shaders can have zero or more fragment programs.  Cg shaders 
can have at most one. If you call this function for a GLSL shader, the fragment 
program is added to the shader.  If you call this function for a Cg shader, 
the existing fragment program on the shader (if any) will be replaced.  If the 
Cg shader does not yet have a fragment program assigned, this function will 
assign one.  For Cg shaders, this function is equivalent to calling 
<A HREF=#mgSetAttList>mgSetAttList</A> on the shader for attribute 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltShaderPalette>fltShaderFragmentProgramFilename</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>shader</I></DT><DD>the GLSL shader</DD><DT><I>programFileName</I></DT><DD>the GLSL shader fragment program file</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgShaderDeleteFragmentProgramNth>mgShaderDeleteFragmentProgramNth</A>, <A HREF=#mgShaderSetFragmentProgramNth>mgShaderSetFragmentProgramNth</A>, 
<A HREF=#mgShaderGetFragmentProgramNth>mgShaderGetFragmentProgramNth</A>, 
<A HREF=#mgShaderAddVertexProgram>mgShaderAddVertexProgram</A></DD></DL>
<HR>
<LEFT><A NAME=mgShaderAddVertexProgram><H1 CLASS="APISYMBOL">mgShaderAddVertexProgram</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgShaderAddVertexProgram</B> - adds a vertex program to a shader.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgShaderAddVertexProgram</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>shader</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>programFileName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgShaderAddVertexProgram</B> adds the vertex program specified by 
<I>programFileName</I> to the specified <I>shader</I>.</P></DD><DD><P>Note: GLSL shaders can have zero or more vertex programs.  Cg shaders 
can have at most one. If you call this function for a GLSL shader, the vertex 
program is added to the shader.  If you call this function for a Cg shader, 
the existing vertex program on the shader (if any) will be replaced.  If the 
Cg shader does not yet have a vertex program assigned, this function will 
assign one.  For Cg shaders, this function is equivalent to calling 
<A HREF=#mgSetAttList>mgSetAttList</A> on the shader for attribute 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltShaderPalette>fltShaderVertexProgramFilename</A>
.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>shader</I></DT><DD>the shader</DD><DT><I>programFileName</I></DT><DD>the shader vertex program file</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgShaderDeleteVertexProgramNth>mgShaderDeleteVertexProgramNth</A>, <A HREF=#mgShaderSetVertexProgramNth>mgShaderSetVertexProgramNth</A>, 
<A HREF=#mgShaderGetVertexProgramNth>mgShaderGetVertexProgramNth</A>, 
<A HREF=#mgShaderAddFragmentProgram>mgShaderAddFragmentProgram</A></DD></DL>
<HR>
<LEFT><A NAME=mgShaderDeleteFragmentProgramNth><H1 CLASS="APISYMBOL">mgShaderDeleteFragmentProgramNth</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgShaderDeleteFragmentProgramNth</B> - deletes a fragment program 
from a GLSL shader.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgShaderDeleteFragmentProgramNth</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>shader</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>nth</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgShaderDeleteFragmentProgramNth</B> deletes the <I>nth</I> fragment program 
from the specified GLSL <I>shader</I>.  The first fragment program is specified 
by <I>nth</I> equal to 0.</P></DD><DD><P>Note: If <I>shader</I> is not a GLSL shader, this function will fail.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>shader</I></DT><DD>the GLSL shader</DD><DT><I>nth</I></DT><DD>the index of the GLSL fragment program 
file to delete</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if <I>shader</I> is a GLSL shader and the 
<I>nth</I> fragment program was deleted successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgShaderAddFragmentProgram>mgShaderAddFragmentProgram</A>, <A HREF=#mgShaderSetFragmentProgramNth>mgShaderSetFragmentProgramNth</A>, 
<A HREF=#mgShaderGetFragmentProgramNth>mgShaderGetFragmentProgramNth</A>, 
<A HREF=#mgShaderDeleteVertexProgramNth>mgShaderDeleteVertexProgramNth</A></DD></DL>
<HR>
<LEFT><A NAME=mgShaderDeleteVertexProgramNth><H1 CLASS="APISYMBOL">mgShaderDeleteVertexProgramNth</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgShaderDeleteVertexProgramNth</B> - deletes a vertex program 
from a GLSL shader.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgShaderDeleteVertexProgramNth</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>shader</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>nth</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgShaderDeleteVertexProgramNth</B> deletes the <I>nth</I> vertex program 
from the specified GLSL <I>shader</I>.  The first vertex program is specified 
by <I>nth</I> equal to 0.</P></DD><DD><P>Note: If <I>shader</I> is not a GLSL shader, this function will fail.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>shader</I></DT><DD>the GLSL shader</DD><DT><I>nth</I></DT><DD>the index of the GLSL vertex program 
file to delete</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if <I>shader</I> is a GLSL shader and the 
<I>nth</I> vertex program was deleted successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgShaderAddVertexProgram>mgShaderAddVertexProgram</A>, <A HREF=#mgShaderSetVertexProgramNth>mgShaderSetVertexProgramNth</A>, 
<A HREF=#mgShaderGetVertexProgramNth>mgShaderGetVertexProgramNth</A>, 
<A HREF=#mgShaderDeleteFragmentProgramNth>mgShaderDeleteFragmentProgramNth</A></DD></DL>
<HR>
<LEFT><A NAME=mgShaderGetFragmentProgramNth><H1 CLASS="APISYMBOL">mgShaderGetFragmentProgramNth</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgShaderGetFragmentProgramNth</B> - gets the file name for a 
fragment program on a shader.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char* <B>mgShaderGetFragmentProgramNth</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>shader</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>nth</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgShaderGetFragmentProgramNth</B> gets the program file name for the 
<I>nth</I> fragment program on the specified <I>shader</I>.  The first fragment 
program is specified by <I>nth</I> equal to 0.</P></DD><DD><P>If <I>shader</I> is a GLSL shader and <I>nth</I> does not refer 
to an existing fragment progrom on the GLSL shader, this function will fail. 
If <I>shader</I> is a Cg shader and <I>nth</I> is 0, this function will return 
"the" fragment program on the Cg shader. 
If <I>shader</I> is a Cg shader and <I>nth</I> is not 0 or the Cg shader does 
not have a fragment program, this function will fail.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned string in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>shader</I></DT><DD>the shader</DD><DT><I>nth</I></DT><DD>the index of the fragment program 
file to get</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the name of the <I>nth</I> fragment program if found, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgShaderAddFragmentProgram>mgShaderAddFragmentProgram</A>, <A HREF=#mgShaderSetFragmentProgramNth>mgShaderSetFragmentProgramNth</A>, 
<A HREF=#mgShaderDeleteFragmentProgramNth>mgShaderDeleteFragmentProgramNth</A>, 
<A HREF=#mgShaderGetVertexProgramNth>mgShaderGetVertexProgramNth</A></DD></DL>
<HR>
<LEFT><A NAME=mgShaderGetLocatorFunc><H1 CLASS="APISYMBOL">mgShaderGetLocatorFunc</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgShaderGetLocatorFunc</B> - gets the current 
shader file locator function.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD> mgfilelocatorfunc <B>mgShaderGetLocatorFunc</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgShaderGetLocatorFunc</B> returns the current shader file 
locator function.  In this way, you can query the current locator 
function and then call it as part of the locator function you set 
up or call it directly for other file location processing your 
application or plug-in requires.</P></DD><DD><P>Note: Although only stand-alone applications can override 
the shader file locator, stand-alone applications as well as 
plug-ins can obtain it.  This allows both stand-alone applications 
and plug-ins to "mimic" the behavior of the default file locator 
when locating files as part of their processing.</P></DD></DT></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgShaderSetLocatorFunc>mgShaderSetLocatorFunc</A>, <A HREF=#mgTextureGetLocatorFunc>mgTextureGetLocatorFunc</A>, 
<A HREF=#mgExtRefGetLocatorFunc>mgExtRefGetLocatorFunc</A>, <A HREF=#mgfilelocatorfunc>mgfilelocatorfunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgShaderGetSavePathType><H1 CLASS="APISYMBOL">mgShaderGetSavePathType</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgShaderGetSavePathType</B> - gets the save path type for 
the shaders in a database.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgsavepathtype <B>mgShaderGetSavePathType</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgShaderGetSavePathType</B> returns how the names of the shaders in 
a database <I>db</I> will be saved when they are written to the database file 
on disk.</P></DD><DD><P>The save names of shaders in a database are the actual names that 
are saved in the OpenFlight database file.  The save names may or may not 
include the full path specifications of the shader files.  The may have 
partial path information (relative) or may include no path information.</P></DD><DD><P>The possible return values are:<BR> 
<A HREF=#mgsavepathtype>MSPT_ABSOLUTE</A> - The save names will include the 
full path specification (if known).<BR> 
<A HREF=#mgsavepathtype>MSPT_RELATIVE</A> - The save names will be relative 
names and will begin with the character sequence "./".<BR> 
<A HREF=#mgsavepathtype>MSPT_NOPATH</A> -  The save names will include no path 
information and will simply be the name part of the file name.<BR> 
<A HREF=#mgsavepathtype>MSPT_UNKNOWN</A> - The save name type could not be 
determined.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgsavepathtype>MSPT_ABSOLUTE</A>, 
<A HREF=#mgsavepathtype>MSPT_RELATIVE</A> or <A HREF=#mgsavepathtype>MSPT_NOPATH</A> 
if successful, <A HREF=#mgsavepathtype>MSPT_UNKNOWN</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgsavepathtype>mgsavepathtype</A>, <A HREF=#mgShaderSetSavePathType>mgShaderSetSavePathType</A></DD></DL>
<HR>
<LEFT><A NAME=mgShaderGetVertexProgramNth><H1 CLASS="APISYMBOL">mgShaderGetVertexProgramNth</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgShaderGetVertexProgramNth</B> - gets the file name for a 
vertex program on a shader.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>char* <B>mgShaderGetVertexProgramNth</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>shader</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>nth</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgShaderGetVertexProgramNth</B> gets the program file name for the 
<I>nth</I> vertex program on the specified <I>shader</I>.  The first vertex 
program is specified by <I>nth</I> equal to 0.</P></DD><DD><P>If <I>shader</I> is a GLSL shader and <I>nth</I> does not refer 
to an existing vertex progrom on the GLSL shader, this function will fail. 
If <I>shader</I> is a Cg shader and <I>nth</I> is 0, this function will return 
"the" vertex program on the Cg shader. 
If <I>shader</I> is a Cg shader and <I>nth</I> is not 0 or the Cg shader does 
not have a vertex program this function will fail.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The string returned is dynamically allocated and must 
be deallocated by the caller when it is no longer needed using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>It is not necessary to free the returned string in Python.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>shader</I></DT><DD>the shader</DD><DT><I>nth</I></DT><DD>the index of the vertex program 
file to get</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the name of the <I>nth</I> vertex program if found, <A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgShaderAddVertexProgram>mgShaderAddVertexProgram</A>, <A HREF=#mgShaderSetVertexProgramNth>mgShaderSetVertexProgramNth</A>, 
<A HREF=#mgShaderDeleteVertexProgramNth>mgShaderDeleteVertexProgramNth</A>, 
<A HREF=#mgShaderGetFragmentProgramNth>mgShaderGetFragmentProgramNth</A></DD></DL>
<HR>
<LEFT><A NAME=mgShaderSetFragmentProgramNth><H1 CLASS="APISYMBOL">mgShaderSetFragmentProgramNth</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgShaderSetFragmentProgramNth</B> - sets the file name 
for an existing fragment program on a GLSL shader.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgShaderSetFragmentProgramNth</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>shader</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>nth</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>programFileName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgShaderSetFragmentProgramNth</B> sets the file name for the 
<I>nth</I> fragment program on the specified GLSL <I>shader</I>.  The first 
fragment program is specified by <I>nth</I> equal to 0.</P></DD><DD><P>Note: If <I>shader</I> is not a GLSL shader or <I>nth</I> does not refer 
to an existing fragment progrom on the GLSL shader, this function will fail.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>shader</I></DT><DD>the GLSL shader</DD><DT><I>nth</I></DT><DD>the index of the GLSL fragment program 
file to set</DD><DT><I>programFileName</I></DT><DD>the GLSL shader fragment program file</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if <I>shader</I> is a GLSL shader and the 
<I>nth</I> fragment program was set successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgShaderAddVertexProgram>mgShaderAddVertexProgram</A>, <A HREF=#mgShaderSetVertexProgramNth>mgShaderSetVertexProgramNth</A>, 
<A HREF=#mgShaderGetFragmentProgramNth>mgShaderGetFragmentProgramNth</A>, 
<A HREF=#mgShaderDeleteFragmentProgramNth>mgShaderDeleteFragmentProgramNth</A></DD></DL>
<HR>
<LEFT><A NAME=mgShaderSetLocatorFunc><H1 CLASS="APISYMBOL">mgShaderSetLocatorFunc</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgShaderSetLocatorFunc</B> - sets the shader file locator 
function.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgShaderSetLocatorFunc</B> (</TD><TD><A HREF=#mgfilelocatorfunc>mgfilelocatorfunc</A></TD><TD><I>locatorFunc</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgShaderSetLocatorFunc</B> allows you to setup a shader file locator 
function used by the OpenFlight API to "locate" shader files referenced 
within OpenFlight databases.  When a database file is opened using the 
API, the current shader file locator function set will be called to 
locate the shader file.  In this way, your application can override 
the way the OpenFlight API locates shader files.</P></DD><DD><P>Note: This function is for use in stand-alone applications only, 
and should never be called from inside a plug-in.  Doing so may yield 
undefined results.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>locatorFunc</I></DT><DD>the shader file locator function</DD><DT><I>userData</I></DT><DD>user defined data that will be 
passed to <I>locatorFunc</I> when it is 
called</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if shader locator function 
could be set,  <A HREF=#mgbool>MG_FALSE</A>otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgShaderGetLocatorFunc>mgShaderGetLocatorFunc</A>, <A HREF=#mgTextureSetLocatorFunc>mgTextureSetLocatorFunc</A>, 
<A HREF=#mgExtRefSetLocatorFunc>mgExtRefSetLocatorFunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgShaderSetSavePathType><H1 CLASS="APISYMBOL">mgShaderSetSavePathType</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgShaderSetSavePathType</B> - Sets the save path type for all the 
shaders in a database<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgShaderSetSavePathType</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgsavepathtype>mgsavepathtype</A></TD><TD><I>saveType</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgShaderSetSavePathType</B> specifies how the names of the shaders in 
a database <I>db</I> will be saved when they are written to the database file 
on disk.</P></DD><DD><P>The save names of shaders in a database are the actual names that 
are saved in the OpenFlight database file.  The save names may or may not 
include the full path specifications of the shader files.  The may have 
partial path information (relative) or may include no path information.</P></DD><DD><P>This function allows you to specify how these save names are written 
for shaders in the palette.  All shader names in a database must be saved 
with the same save path type.  For example, you cannot save some shaders 
with absolute file names and others with relative names.</P></DD><DD><P>This function accepts the following values for <I>saveType</I>:<BR> 
<A HREF=#mgsavepathtype>MSPT_ABSOLUTE</A> - The save names will include the 
full path specification (if known).<BR> 
<A HREF=#mgsavepathtype>MSPT_RELATIVE</A> - The save names will be relative 
names and will begin with the character sequence "./".<BR> 
<A HREF=#mgsavepathtype>MSPT_NOPATH</A> -  The save names will include no path 
information and will simply be the name part of the file name.</P></DD><DD><P>If you specify any value other than one listed here (specifically 
<A HREF=#mgsavepathtype>MSPT_UNKNOWN</A>) as <I>saveType</I>, this function will fail.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>saveType</I></DT><DD>the save path type for shaders</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgShaderGetSavePathType>mgShaderGetSavePathType</A></DD></DL>
<HR>
<LEFT><A NAME=mgShaderSetVertexProgramNth><H1 CLASS="APISYMBOL">mgShaderSetVertexProgramNth</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgShaderSetVertexProgramNth</B> - sets the file name 
for an existing vertex program on a GLSL shader.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgShaderSetVertexProgramNth</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>shader</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>nth</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>programFileName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgShaderSetVertexProgramNth</B> sets the file name for the 
<I>nth</I> vertex program on the specified GLSL <I>shader</I>.  The first 
vertex program is specified by <I>nth</I> equal to 0.</P></DD><DD><P>Note: If <I>shader</I> is not a GLSL shader or <I>nth</I> does not refer 
to an existing vertex progrom on the GLSL shader, this function will fail.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>shader</I></DT><DD>the GLSL shader</DD><DT><I>nth</I></DT><DD>the index of the GLSL vertex program 
file to set</DD><DT><I>programFileName</I></DT><DD>the GLSL shader vertex program file</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if <I>shader</I> is a GLSL shader and the 
<I>nth</I> vertex program was set successfully, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgShaderAddFragmentProgram>mgShaderAddFragmentProgram</A>, <A HREF=#mgShaderSetFragmentProgramNth>mgShaderSetFragmentProgramNth</A>, 
<A HREF=#mgShaderGetVertexProgramNth>mgShaderGetVertexProgramNth</A>, 
<A HREF=#mgShaderDeleteVertexProgramNth>mgShaderDeleteVertexProgramNth</A></DD></DL>
<HR>
<LEFT><A NAME=mgShowDialog><H1 CLASS="APISYMBOL">mgShowDialog</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgShowDialog</B> - displays a dialog.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgShowDialog</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>dialog</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgShowDialog</B> displays a dialog on the screen.</P></DD><DD><P>If the show dialog event has been selected for the dialog function, it 
is sent.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>dialog</I></DT><DD>dialog to display</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetDialog>mgResourceGetDialog</A>, <A HREF=#mgHideDialog>mgHideDialog</A>, <A HREF=#mgDestroyDialog>mgDestroyDialog</A>, <A HREF=#mgRefreshDialog>mgRefreshDialog</A></DD></DL>
<HR>
<LEFT><A NAME=mgShowHelpContext><H1 CLASS="APISYMBOL">mgShowHelpContext</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgShowHelpContext</B> - display context sensitive help.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgShowHelpContext</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mghelpcontext>mghelpcontext</A></TD><TD><I>helpContext</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgShowHelpContext</B> displays online help for the specified help 
context, <I>helpContext</I>.  If the help context exists in the plug-in's 
help file, that topic will be displayed.  If you specify <A HREF=#MG_NULL>MG_NULL</A> 
for <I>helpContext</I> or the help context does not exist, the entire help 
file will be displayed.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in module for which context 
sensitive help is to be displayed</DD><DT><I>helpContext</I></DT><DD>the help context to display</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterHelpFile>mgRegisterHelpFile</A>, <A HREF=#mgPluginSetHelpContext>mgPluginSetHelpContext</A>, 
<A HREF=#mgGuiSetHelpContext>mgGuiSetHelpContext</A>, <A HREF=#MTA_HELPCONTEXT>MTA_HELPCONTEXT</A></DD></DL>
<HR>
<LEFT><A NAME=mgShowPalette><H1 CLASS="APISYMBOL">mgShowPalette</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgShowPalette</B> - displays a database palette window.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgShowPalette</B> (</TD><TD><A HREF=#mgpaletteid>mgpaletteid</A></TD><TD><I>paletteId</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgShowPalette</B> displays the database palette specified 
<I>paletteId</I>.  If the palette is not already displayed, it will be.  If 
the palette is already displayed but occluded by another window, it will 
be brought to the top of the window order on the desktop.</P></DD><DD><P>See <A HREF=#mgpaletteid>mgpaletteid</A> for a complete list of palettes you can 
display with this function.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>paletteId</I></DT><DD>the palette to show</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show how to display the 
Creator texture palette.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgShowPalette (MPID_TEXTUREPALETTE);</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgShowPalette (MPID_TEXTUREPALETTE)</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<HR>
<LEFT><A NAME=mgStringIdsMatch><H1 CLASS="APISYMBOL">mgStringIdsMatch</H1></A></LEFT>
<DL>
<DT><H3>MACRO NAME</H3></DT>
<DD><B>mgStringIdsMatch</B> - Checks if two string definition identifiers match.<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgStringIdsMatch</B> (</TD><TD><A HREF=#></A></TD><TD><I>id1</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>id2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns 1 if identifiers match, 0 otherwise.
</DD></DL><DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>id1</I></DT><DD>A string definition identifier</DD><DT><I>id2</I></DT><DD>Another string definition identifier</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPixmapIdsMatch>mgPixmapIdsMatch</A>, <A HREF=#mgControlIdsMatch>mgControlIdsMatch</A>, 
<A HREF=#mgCursorIdsMatch>mgCursorIdsMatch</A></DD></DL>
<HR>
<LEFT><A NAME=mgStringListCount><H1 CLASS="APISYMBOL">mgStringListCount</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgStringListCount</B> - returns the length of a string list.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgStringListCount</B> (</TD><TD><A HREF=#mgstringlist>mgstringlist</A></TD><TD><I>strings</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgStringListCount</B> returns the number of strings contained in the string 
list <I>strings</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>strings</I></DT><DD>the string list to get length for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns returns the number of strings contained in the string 
list <I>strings</I>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgListGetStrings>mgListGetStrings</A>, <A HREF=#mgListGetSelectedStrings>mgListGetSelectedStrings</A>, <A HREF=#mgPromptDialogFile>mgPromptDialogFile</A>, 
<A HREF=#mgPromptDialogTexture>mgPromptDialogTexture</A></DD></DL>
<HR>
<LEFT><A NAME=mgSubTextureAdd><H1 CLASS="APISYMBOL">mgSubTextureAdd</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSubTextureAdd</B> - adds subtexture definitions to a texture 
attribute record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgSubTextureAdd</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>imgRec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgsubtexturedata>mgsubtexturedata</A></TD><TD><I>subTextureData[]</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>n</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSubTextureAdd</B> adds <I>n</I> subtexture definitions to the specified 
texture attribute record <I>imgRec</I> (of type <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltImage>fltImage</A>
).  The subtexture 
definitions are passed via the array <I>subTextureData</I>. 
The number of subtextures actually added is returned.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>imgRec</I></DT><DD>the texture attribute record</DD><DT><I>subTextureData[]</I></DT><DD>the array of subtexture definitions to be added</DD><DT><I>n</I></DT><DD>the number of subtextures in the 
array <I>subTextureData</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of subtextures added.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* imgRec = mgGetTextureAttributes (db, textureIndex);
mgsubtexturedata subtextures[2];

// set the data for each element of the sequence
strcpy (subtextures[0].name, "Subtexture 1");
subtextures[0].l = 0;
subtextures[0].b = 0;
subtextures[0].r = 31;
subtextures[0].t = 63;

strcpy (subtextures[1].name, "Subtexture 2");
subtextures[1].l = 32;
subtextures[1].b = 0;
subtextures[1].r = 63;
subtextures[1].t = 63;

// add these subtextures to the existing subtextures
mgSubTextureAdd (imgRec, subtextures, 2);</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">imgRec = mgGetTextureAttributes (db, textureIndex)
# allocate 2 elements for the subtexture data
subtextures = mgsubtexturedata(2)

# set the data for each subtexture
subtextures[0].name = "Subtexture 1"
subtextures[0].l = 0
subtextures[0].b = 0
subtextures[0].r = 31
subtextures[0].t = 63

subtextures[1].name = "Subtexture 2"
subtextures[1].l = 32
subtextures[1].b = 0
subtextures[1].r = 63
subtextures[1].t = 63

# add these subtextures to the existing subtextures
mgSubTextureAdd (imgRec, subtextures, 2)</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSubTextureDelete>mgSubTextureDelete</A>, <A HREF=#mgSubTextureGet>mgSubTextureGet</A>,  <A HREF=#mgSubTextureCount>mgSubTextureCount</A>, 
<A HREF=#mgsubtexturedata>mgsubtexturedata</A></DD></DL>
<HR>
<LEFT><A NAME=mgSubTextureCount><H1 CLASS="APISYMBOL">mgSubTextureCount</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSubTextureCount</B> - gets the number of subtextures defined 
in a texture attribute record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgSubTextureCount</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>imgRec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSubTextureCount</B> returns the number of subtextures 
in the specified texture attribute record <I>imgRec</I> (of type <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltImage>fltImage</A>
).</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>imgRec</I></DT><DD>the texture attribute record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of subtextures contained in the texture attribute 
record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSubTextureAdd>mgSubTextureAdd</A>, <A HREF=#mgSubTextureDelete>mgSubTextureDelete</A>, <A HREF=#mgSubTextureGet>mgSubTextureGet</A>, 
<A HREF=#mgSubTextureGetBounds>mgSubTextureGetBounds</A></DD></DL>
<HR>
<LEFT><A NAME=mgSubTextureDelete><H1 CLASS="APISYMBOL">mgSubTextureDelete</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSubTextureDelete</B> - Deletes a subtexture definition with the 
given index.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSubTextureDelete</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>imgRec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSubTextureDelete</B> deletes a subtexture definition at index <I>index</I> 
from the specified texture attribute record <I>imgRec</I> (of type <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltImage>fltImage</A>
). 
Subtexture indices are contiguous and range from 0..N-1 where N is the value 
returned by <A HREF=#mgSubTextureCount>mgSubTextureCount</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>imgRec</I></DT><DD>the texture attribute record</DD><DT><I>index</I></DT><DD>the index to be deleted</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSubTextureAdd>mgSubTextureAdd</A>, <A HREF=#mgSubTextureGet>mgSubTextureGet</A>, <A HREF=#mgSubTextureCount>mgSubTextureCount</A></DD></DL>
<HR>
<LEFT><A NAME=mgSubTextureGet><H1 CLASS="APISYMBOL">mgSubTextureGet</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSubTextureGet</B> - gets the subtexture definitions from a 
texture attribute record.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgSubTextureGet</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>imgRec</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgsubtexturedata>mgsubtexturedata</A></TD><TD><I>subTextureData[]</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>arrayLen</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>numSubTextures, subTextureData <B>mgSubTextureGet</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>imgRec</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSubTextureGet</B> gets the subtexture definitions of the specified 
texture attribute record <I>imgRec</I> (of type <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltImage>fltImage</A>
).</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P><B>mgSubTextureGet</B> writes the data into the output parameter <I>subTextureData</I>. 
The size of the array is specified by <I>arrayLen</I>.  The number of subtexture definitions 
actually written into the array is returned.  You can determine the actual number of 
subtexture definitions contained in a texture attribute record by calling 
<A HREF=#mgSubTextureCount>mgSubTextureCount</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P><B>mgSubTextureGet</B> returns the subtexture definitions. The number 
of subtexture definitions included is also returned.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>imgRec</I></DT><DD>the texture attribute record</DD><DT><I>subTextureData[]</I></DT><DD>the array of subtexture records to be filled in</DD><DT><I>arrayLen</I></DT><DD>the size of the array <I>subTextureData</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>numSubTextures</DT><DD>The number of subtexture records being returned.</DD><DT>subTextureData</DT><DD>The records returned.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* imgRec = mgGetTextureAttributes (db, textureIndex);
int num;
num = mgSubTextureCount (imgRec);
if (num &gt 0) {
   int numGot;
   mgsubtexturedata* subTexures;
   subTexures = (mgsubtexturedata*) mgMalloc (num * sizeof(mgsubtexturedata));
   numGot = mgSubTextureGet (imgRec, subTexures, num);
   for (int i = 0; i &lt numGot; ++i)
   {
      printf("Subtexture %d :\\n", i+1);
      printf("   name: %s\\n", subTexures[i].name);
      printf("   l,b,r,t: %d %d %d %d\\n", subTexures[i].l,
&#32 subTexures[i].b, subTexures[i].r, subTexures[i].t);
   }

   // free the allocated subtexture data when you're done with it
   mgFree (subTexures);
}</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">imgRec = mgGetTextureAttributes (db, textureIndex)
num,subTexures = mgSubTextureGet (imgRec)
for i in range (0, num):
   print "Subtexture",i+1,":"
   subTexture = subTexures[i]
   print "   name:",subTexture.name
   print "   l,b,r,t:",subTexture.l,subTexture.b,subTexture.r,subTexture.t</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSubTextureAdd>mgSubTextureAdd</A>, <A HREF=#mgSubTextureDelete>mgSubTextureDelete</A>, <A HREF=#mgSubTextureCount>mgSubTextureCount</A>, 
<A HREF=#mgSubTextureGetBounds>mgSubTextureGetBounds</A></DD></DL>
<HR>
<LEFT><A NAME=mgSubTextureGetBounds><H1 CLASS="APISYMBOL">mgSubTextureGetBounds</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgSubTextureGetBounds</B> - gets the bounds of a subtexture 
from a texture attribute record.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgSubTextureGetBounds</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>imgRec</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>left</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>bottom</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>right</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>top</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, left, bottom, right, top <B>mgSubTextureGetBounds</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>imgRec</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgSubTextureGetBounds</B> gets the bounds (left, bottom, right and top 
coordinates) of the subtexture at the specified <I>index</I> within the specified 
texture attribute record <I>imgRec</I> (of type <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltImage>fltImage</A>
).  The bounds are 
returned in the output parameters, <I>left</I>, <I>bottom</I>, <I>right</I> and <I>top</I>.</P></DD><DD><P>Subtexture indices are contiguous and range from 0..N-1 where N is the value 
returned by <A HREF=#mgSubTextureCount>mgSubTextureCount</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>imgRec</I></DT><DD>the texture attribute record</DD><DT><I>left</I></DT><DD>address of value to receive lower left x coordinate of subtexture</DD><DT><I>bottom</I></DT><DD>address of value to receive lower left y coordinate of subtexture</DD><DT><I>right</I></DT><DD>address of value to receive upper right x coordinate of subtexture</DD><DT><I>top</I></DT><DD>address of value to receive upper right y coordinate of subtexture</DD><DT><I>index</I></DT><DD>the index of the subtexture</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>left</DT><DD>If function is successful, left contains the retrieved left value, otherwise 
left is undefined.</DD><DT>bottom</DT><DD>If function is successful, bottom contains the retrieved bottom value, otherwise 
bottom is undefined.</DD><DT>right</DT><DD>If function is successful, right contains the retrieved right value, otherwise 
right is undefined.</DD><DT>top</DT><DD>If function is successful, top contains the retrieved top value, otherwise 
top is undefined.</DD></DL></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSubTextureGet>mgSubTextureGet</A>, <A HREF=#mgSubTextureCount>mgSubTextureCount</A></DD></DL>
<HR>
<LEFT><A NAME=mgTabRulerDeleteTab><H1 CLASS="APISYMBOL">mgTabRulerDeleteTab</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTabRulerDeleteTab</B> - deletes a tab from a tab ruler control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgTabRulerDeleteTab</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>tabIndex</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTabRulerDeleteTab</B> deletes the tab in the tab ruler control 
that is associated with the GL control <I>control</I> at index <I>tabIndex</I></P></DD><DD><P>The first tab is at index 1.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>tab ruler control</DD><DT><I>tabIndex</I></DT><DD>index of tab to remove</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewTabRuler>mgNewTabRuler</A>, <A HREF=#mgFreeTabRuler>mgFreeTabRuler</A>, <A HREF=#mgTabRulerSetOptions>mgTabRulerSetOptions</A>, <A HREF=#mgTabRulerGetTabCount>mgTabRulerGetTabCount</A>, 
<A HREF=#mgTabRulerSetTabPosition>mgTabRulerSetTabPosition</A>, <A HREF=#mgTabRulerSetTabPosition>mgTabRulerSetTabPosition</A>, 
<A HREF=#mgTabRulerSetTabFrozen>mgTabRulerSetTabFrozen</A>, <A HREF=#mgTabRulerNewTab>mgTabRulerNewTab</A>, 
<A HREF=#mgTabRulerGetSelectedTab>mgTabRulerGetSelectedTab</A>, <A HREF=#mgTabRulerSelectTab>mgTabRulerSelectTab</A>, <A HREF=#mgTabRulerSetGuiCallback>mgTabRulerSetGuiCallback</A>, <A HREF=#mgTabRulerSetMouseCallback>mgTabRulerSetMouseCallback</A></DD></DL>
<HR>
<LEFT><A NAME=mgTabRulerGetSelectedTab><H1 CLASS="APISYMBOL">mgTabRulerGetSelectedTab</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTabRulerGetSelectedTab</B> - returns the index of the selected tab 
in a tab ruler control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgTabRulerGetSelectedTab</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTabRulerGetSelectedTab</B> returns the index of the selected tab in the tab ruler control 
that is associated with the GL control <I>control</I></P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>tab ruler control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>The index of the selected tab is returned, or -1 if no tab is selected.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewTabRuler>mgNewTabRuler</A>, <A HREF=#mgFreeTabRuler>mgFreeTabRuler</A>, <A HREF=#mgTabRulerSetOptions>mgTabRulerSetOptions</A>, <A HREF=#mgTabRulerGetTabCount>mgTabRulerGetTabCount</A>, 
<A HREF=#mgTabRulerSetTabPosition>mgTabRulerSetTabPosition</A>, <A HREF=#mgTabRulerSetTabPosition>mgTabRulerSetTabPosition</A>, 
<A HREF=#mgTabRulerSetTabFrozen>mgTabRulerSetTabFrozen</A>, <A HREF=#mgTabRulerDeleteTab>mgTabRulerDeleteTab</A>, 
<A HREF=#mgTabRulerNewTab>mgTabRulerNewTab</A>, <A HREF=#mgTabRulerSelectTab>mgTabRulerSelectTab</A>, <A HREF=#mgTabRulerSetGuiCallback>mgTabRulerSetGuiCallback</A>, <A HREF=#mgTabRulerSetMouseCallback>mgTabRulerSetMouseCallback</A></DD></DL>
<HR>
<LEFT><A NAME=mgTabRulerGetTabCount><H1 CLASS="APISYMBOL">mgTabRulerGetTabCount</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTabRulerGetTabCount</B> - returns the number of tabs on a tab ruler control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgTabRulerGetTabCount</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTabRulerGetTabCount</B> returns the number of tabs on the tab ruler control, 
that is associated with the GL control <I>control</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>tab ruler control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the number of tabs on the tab ruler <I>control</I>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewTabRuler>mgNewTabRuler</A>, <A HREF=#mgFreeTabRuler>mgFreeTabRuler</A>, <A HREF=#mgTabRulerSetOptions>mgTabRulerSetOptions</A>, <A HREF=#mgTabRulerGetTabPosition>mgTabRulerGetTabPosition</A>, 
<A HREF=#mgTabRulerSetTabPosition>mgTabRulerSetTabPosition</A>, <A HREF=#mgTabRulerSetTabFrozen>mgTabRulerSetTabFrozen</A>, 
<A HREF=#mgTabRulerNewTab>mgTabRulerNewTab</A>, <A HREF=#mgTabRulerDeleteTab>mgTabRulerDeleteTab</A>, 
<A HREF=#mgTabRulerGetSelectedTab>mgTabRulerGetSelectedTab</A>, <A HREF=#mgTabRulerSelectTab>mgTabRulerSelectTab</A>, <A HREF=#mgTabRulerSetGuiCallback>mgTabRulerSetGuiCallback</A>, <A HREF=#mgTabRulerSetMouseCallback>mgTabRulerSetMouseCallback</A></DD></DL>
<HR>
<LEFT><A NAME=mgTabRulerGetTabPosition><H1 CLASS="APISYMBOL">mgTabRulerGetTabPosition</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTabRulerGetTabPosition</B> - returns the position of a tab on 
a tab ruler control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgTabRulerGetTabPosition</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>tabIndex</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTabRulerGetTabPosition</B> returns the position of tab <I>tabIndex</I> on 
the tab ruler control that is associated with the GL control <I>control</I>.</P></DD><DD><P>The first tab is at index 1.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>tab ruler control</DD><DT><I>tabIndex</I></DT><DD>index of tab to retrieve position for</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>The position of tab <I>tabIndex</I> on the tab ruler control <I>control</I>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewTabRuler>mgNewTabRuler</A>, <A HREF=#mgFreeTabRuler>mgFreeTabRuler</A>, <A HREF=#mgTabRulerSetOptions>mgTabRulerSetOptions</A>, <A HREF=#mgTabRulerSetOptions>mgTabRulerSetOptions</A>, <A HREF=#mgTabRulerGetTabCount>mgTabRulerGetTabCount</A>, 
<A HREF=#mgTabRulerSetTabPosition>mgTabRulerSetTabPosition</A>, <A HREF=#mgTabRulerSetTabFrozen>mgTabRulerSetTabFrozen</A>, 
<A HREF=#mgTabRulerNewTab>mgTabRulerNewTab</A>, <A HREF=#mgTabRulerDeleteTab>mgTabRulerDeleteTab</A>, 
<A HREF=#mgTabRulerGetSelectedTab>mgTabRulerGetSelectedTab</A>, <A HREF=#mgTabRulerSelectTab>mgTabRulerSelectTab</A>, <A HREF=#mgTabRulerSetGuiCallback>mgTabRulerSetGuiCallback</A>, <A HREF=#mgTabRulerSetMouseCallback>mgTabRulerSetMouseCallback</A></DD></DL>
<HR>
<LEFT><A NAME=mgTabRulerNewTab><H1 CLASS="APISYMBOL">mgTabRulerNewTab</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTabRulerNewTab</B> - creates a new tab in a tab ruler control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgTabRulerNewTab</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>tabPosition</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTabRulerNewTab</B> creates a new tab in the tab ruler control 
that is associated with the GL control <I>control</I> at position <I>tabPosition</I></P></DD><DD><P>The first tab is at index 1.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>tab ruler control</DD><DT><I>tabPosition</I></DT><DD>position of new tab</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>The index of the newly created tab is returned.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewTabRuler>mgNewTabRuler</A>, <A HREF=#mgFreeTabRuler>mgFreeTabRuler</A>, <A HREF=#mgTabRulerSetOptions>mgTabRulerSetOptions</A>, <A HREF=#mgTabRulerGetTabCount>mgTabRulerGetTabCount</A>, 
<A HREF=#mgTabRulerSetTabPosition>mgTabRulerSetTabPosition</A>, <A HREF=#mgTabRulerSetTabPosition>mgTabRulerSetTabPosition</A>, 
<A HREF=#mgTabRulerSetTabFrozen>mgTabRulerSetTabFrozen</A>, <A HREF=#mgTabRulerDeleteTab>mgTabRulerDeleteTab</A>, 
<A HREF=#mgTabRulerGetSelectedTab>mgTabRulerGetSelectedTab</A>, <A HREF=#mgTabRulerSelectTab>mgTabRulerSelectTab</A>, <A HREF=#mgTabRulerSetGuiCallback>mgTabRulerSetGuiCallback</A>, <A HREF=#mgTabRulerSetMouseCallback>mgTabRulerSetMouseCallback</A></DD></DL>
<HR>
<LEFT><A NAME=mgTabRulerRangeDrawCallback><H1 CLASS="APISYMBOL">mgTabRulerRangeDrawCallback</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTabRulerRangeDrawCallback</B> - modifies the appearance of a tab 
ruler control to show ranges.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgTabRulerRangeDrawCallback</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>gui</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcontrolid>mgcontrolid</A></TD><TD><I>controlId</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgguicallbackreason>mgguicallbackreason</A></TD><TD><I>callbackReason</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>callData</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTabRulerRangeDrawCallback</B> modifies the appearance of a tab ruler 
<I>control</I> by connecting adjacent tabs together with a bracket. This combined with <A HREF=#mgTabRulerRangeMouseCallback>mgTabRulerRangeMouseCallback</A> 
converts the tab ruler control to deal in ranges of values.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>gui</I></DT><DD>control in the dialog to hide</DD><DT><I>controlId</I></DT><DD>the identifier of gui</DD><DT><I>callbackReason</I></DT><DD>the control event that 
triggered the callback</DD><DT><I>userData</I></DT><DD>user data passed through</DD><DT><I>callData</I></DT><DD>call data passed through</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewTabRuler>mgNewTabRuler</A>, <A HREF=#mgFreeTabRuler>mgFreeTabRuler</A>, <A HREF=#mgTabRulerSetOptions>mgTabRulerSetOptions</A>, <A HREF=#mgTabRulerGetTabPosition>mgTabRulerGetTabPosition</A>, 
<A HREF=#mgTabRulerSetTabPosition>mgTabRulerSetTabPosition</A>, <A HREF=#mgTabRulerSetTabFrozen>mgTabRulerSetTabFrozen</A>, 
<A HREF=#mgTabRulerNewTab>mgTabRulerNewTab</A>, <A HREF=#mgTabRulerDeleteTab>mgTabRulerDeleteTab</A>, 
<A HREF=#mgTabRulerGetSelectedTab>mgTabRulerGetSelectedTab</A>, <A HREF=#mgTabRulerSelectTab>mgTabRulerSelectTab</A>, <A HREF=#mgTabRulerSetMouseCallback>mgTabRulerSetMouseCallback</A></DD></DL>
<HR>
<LEFT><A NAME=mgTabRulerRangeMouseCallback><H1 CLASS="APISYMBOL">mgTabRulerRangeMouseCallback</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTabRulerRangeMouseCallback</B> - modifies the mouse handling 
for a tab ruler control, to select ranges.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgTabRulerRangeMouseCallback</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>gui</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcontrolid>mgcontrolid</A></TD><TD><I>controlId</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgglmouseaction>mgglmouseaction</A></TD><TD><I>mouseAction</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>callData</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTabRulerRangeMouseCallback</B> modifies the mouse handling of a tab ruler 
<I>control</I> by treating the range between tabs as part of the tab. This combined with the <A HREF=#mgTabRulerRangeDrawCallback>mgTabRulerRangeDrawCallback</A> 
modifies the functionality of a tab ruler control to deal in ranges of values.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>gui</I></DT><DD>control in the dialog to hide</DD><DT><I>controlId</I></DT><DD>the identifier of gui</DD><DT><I>mouseAction</I></DT><DD>the control event that 
triggered the callback</DD><DT><I>userData</I></DT><DD>user data passed through</DD><DT><I>callData</I></DT><DD>call data passed through</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewTabRuler>mgNewTabRuler</A>, <A HREF=#mgFreeTabRuler>mgFreeTabRuler</A>, <A HREF=#mgTabRulerSetOptions>mgTabRulerSetOptions</A>, <A HREF=#mgTabRulerGetTabPosition>mgTabRulerGetTabPosition</A>, 
<A HREF=#mgTabRulerSetTabPosition>mgTabRulerSetTabPosition</A>, <A HREF=#mgTabRulerSetTabFrozen>mgTabRulerSetTabFrozen</A>, 
<A HREF=#mgTabRulerNewTab>mgTabRulerNewTab</A>, <A HREF=#mgTabRulerDeleteTab>mgTabRulerDeleteTab</A>, 
<A HREF=#mgTabRulerGetSelectedTab>mgTabRulerGetSelectedTab</A>, <A HREF=#mgTabRulerSelectTab>mgTabRulerSelectTab</A>, <A HREF=#mgTabRulerSetMouseCallback>mgTabRulerSetMouseCallback</A></DD></DL>
<HR>
<LEFT><A NAME=mgTabRulerSelectTab><H1 CLASS="APISYMBOL">mgTabRulerSelectTab</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTabRulerSelectTab</B> - selects a tab in a tab ruler control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgTabRulerSelectTab</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>tabIndex</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTabRulerSelectTab</B> selects the tab in the tab ruler control 
that is associated with the GL control <I>control</I> at index <I>tabIndex</I></P></DD><DD><P>The first tab is at index 1.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>tab ruler control</DD><DT><I>tabIndex</I></DT><DD>index of tab to select, or -1 to clear selection</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewTabRuler>mgNewTabRuler</A>, <A HREF=#mgFreeTabRuler>mgFreeTabRuler</A>, <A HREF=#mgTabRulerSetOptions>mgTabRulerSetOptions</A>, <A HREF=#mgTabRulerGetTabCount>mgTabRulerGetTabCount</A>, 
<A HREF=#mgTabRulerSetTabPosition>mgTabRulerSetTabPosition</A>, <A HREF=#mgTabRulerSetTabPosition>mgTabRulerSetTabPosition</A>, 
<A HREF=#mgTabRulerSetTabFrozen>mgTabRulerSetTabFrozen</A>, <A HREF=#mgTabRulerNewTab>mgTabRulerNewTab</A>, 
<A HREF=#mgTabRulerGetSelectedTab>mgTabRulerGetSelectedTab</A>, <A HREF=#mgTabRulerNewTab>mgTabRulerNewTab</A>, <A HREF=#mgTabRulerSetGuiCallback>mgTabRulerSetGuiCallback</A>, <A HREF=#mgTabRulerSetMouseCallback>mgTabRulerSetMouseCallback</A></DD></DL>
<HR>
<LEFT><A NAME=mgTabRulerSetGuiCallback><H1 CLASS="APISYMBOL">mgTabRulerSetGuiCallback</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTabRulerSetGuiCallback</B> - sets callback function for a tab ruler control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgTabRulerSetGuiCallback</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>callbackMask</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgguifunc>mgguifunc</A></TD><TD><I>callback</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTabRulerSetGuiCallback</B> assigns a callback function to the specified tab ruler 
<I>control</I>.</P></DD><DD><P>You select which control events the callback function is to be called 
for using the parameter <I>callbackMask</I>.  The value for this parameter may be 
any bitwise combination of <B>MTRUL_TAB_SELECTED</B>, <B>MTRUL_TAB_DESELECTED</B>, <B>MTRUL_TAB_DRAGGED</B> 
<B>MTRUL_TAB_BUMPED</B>, <B>MTRUL_TAB_CHANGED</B>, <B>MTRUL_TAB_CREATED</B>, <B>MTRUL_TAB_DELETED</B> and 
<B>MTRUL_TAB_RELEASED</B></P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the control whose callback function is to be set</DD><DT><I>callbackMask</I></DT><DD>mask indicating which control events are selected for callback function</DD><DT><I>callback</I></DT><DD>the control callback function</DD><DT><I>userData</I></DT><DD>user data to be passed to callback function when it is called</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewTabRuler>mgNewTabRuler</A>, <A HREF=#mgFreeTabRuler>mgFreeTabRuler</A>, <A HREF=#mgTabRulerSetOptions>mgTabRulerSetOptions</A>, <A HREF=#mgTabRulerGetTabPosition>mgTabRulerGetTabPosition</A>, 
<A HREF=#mgTabRulerSetTabPosition>mgTabRulerSetTabPosition</A>, <A HREF=#mgTabRulerSetTabFrozen>mgTabRulerSetTabFrozen</A>, 
<A HREF=#mgTabRulerNewTab>mgTabRulerNewTab</A>, <A HREF=#mgTabRulerDeleteTab>mgTabRulerDeleteTab</A>, 
<A HREF=#mgTabRulerGetSelectedTab>mgTabRulerGetSelectedTab</A>, <A HREF=#mgTabRulerSelectTab>mgTabRulerSelectTab</A>, <A HREF=#mgTabRulerSetMouseCallback>mgTabRulerSetMouseCallback</A></DD></DL>
<HR>
<LEFT><A NAME=mgTabRulerSetMouseCallback><H1 CLASS="APISYMBOL">mgTabRulerSetMouseCallback</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTabRulerSetMouseCallback</B> - sets mouse callback function for a tab ruler control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgTabRulerSetMouseCallback</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>actionMask</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgglmousefunc>mgglmousefunc</A></TD><TD><I>callback</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><A HREF=#mgTabRulerSetGuiCallback>mgTabRulerSetGuiCallback</A> assigns a mouse callback function to the specified tab ruler 
<I>control</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the control whose callback function is to be set</DD><DT><I>actionMask</I></DT><DD>mask indicating which mouse actions are selected 
for mouse function</DD><DT><I>callback</I></DT><DD>the control callback function</DD><DT><I>userData</I></DT><DD>user data to be passed to callback function when it is called</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewTabRuler>mgNewTabRuler</A>, <A HREF=#mgFreeTabRuler>mgFreeTabRuler</A>, <A HREF=#mgTabRulerSetOptions>mgTabRulerSetOptions</A>, <A HREF=#mgTabRulerGetTabPosition>mgTabRulerGetTabPosition</A>, 
<A HREF=#mgTabRulerSetTabPosition>mgTabRulerSetTabPosition</A>, <A HREF=#mgTabRulerSetTabFrozen>mgTabRulerSetTabFrozen</A>, 
<A HREF=#mgTabRulerNewTab>mgTabRulerNewTab</A>, <A HREF=#mgTabRulerDeleteTab>mgTabRulerDeleteTab</A>, 
<A HREF=#mgTabRulerGetSelectedTab>mgTabRulerGetSelectedTab</A>, <A HREF=#mgTabRulerSelectTab>mgTabRulerSelectTab</A>, <A HREF=#mgTabRulerSetGuiCallback>mgTabRulerSetGuiCallback</A></DD></DL>
<HR>
<LEFT><A NAME=mgTabRulerSetOptions><H1 CLASS="APISYMBOL">mgTabRulerSetOptions</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTabRulerSetOptions</B> - changes options for a tab ruler control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgTabRulerSetOptions</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#></A></TD><TD><I>...</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTabRulerSetOptions</B> changes the options for an existing tab ruler control. 
<I>control</I>, is the GL control that has an associated tab ruler control.</P></DD><DD><P>The variable arguments are a set of key/value pairs, where key is a 32-bit value. The 
key/value list MUST be terminated with a tag of 'MG_NULL'.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>GL control to associate with a tab ruler control</DD><DT><I>...</I></DT><DD>optional input parameters in variable 
argument style using <A HREF=#mgtabruleroption>mgtabruleroption</A> as the keys</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success. If the function succeeds, 
the options for the tab ruler <I>control</I> were successfully changed.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewTabRuler>mgNewTabRuler</A>, <A HREF=#mgFreeTabRuler>mgFreeTabRuler</A>, <A HREF=#mgTabRulerGetTabCount>mgTabRulerGetTabCount</A>, <A HREF=#mgTabRulerGetTabPosition>mgTabRulerGetTabPosition</A>, 
<A HREF=#mgTabRulerSetTabPosition>mgTabRulerSetTabPosition</A>, <A HREF=#mgTabRulerSetTabFrozen>mgTabRulerSetTabFrozen</A>, 
<A HREF=#mgTabRulerNewTab>mgTabRulerNewTab</A>, <A HREF=#mgTabRulerDeleteTab>mgTabRulerDeleteTab</A>, 
<A HREF=#mgTabRulerGetSelectedTab>mgTabRulerGetSelectedTab</A>, <A HREF=#mgTabRulerSelectTab>mgTabRulerSelectTab</A>, <A HREF=#mgtabruleroption>mgtabruleroption</A></DD></DL>
<HR>
<LEFT><A NAME=mgTabRulerSetTabFrozen><H1 CLASS="APISYMBOL">mgTabRulerSetTabFrozen</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTabRulerSetTabFrozen</B> - freezes or unfreezes a tab on a tab ruler control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgTabRulerSetTabFrozen</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>tabIndex</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>tabFrozen</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTabRulerSetTabFrozen</B> sets the tab <I>tabIndex</I> on the tab ruler control 
that is associated with the GL control <I>control</I> to frozen. A frozen tab cannot be moved.</P></DD><DD><P>The first tab is at index 1.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>tab ruler control</DD><DT><I>tabIndex</I></DT><DD>index of tab to set frozen</DD><DT><I>tabFrozen</I></DT><DD>new forzen state of tab</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success. If the function succeeds, 
the tab <I>tabIndex</I> was set to <I>tabFrozen</I>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewTabRuler>mgNewTabRuler</A>, <A HREF=#mgFreeTabRuler>mgFreeTabRuler</A>, <A HREF=#mgTabRulerSetOptions>mgTabRulerSetOptions</A>, <A HREF=#mgTabRulerGetTabCount>mgTabRulerGetTabCount</A>, 
<A HREF=#mgTabRulerSetTabPosition>mgTabRulerSetTabPosition</A>, <A HREF=#mgTabRulerSetTabPosition>mgTabRulerSetTabPosition</A>, 
<A HREF=#mgTabRulerNewTab>mgTabRulerNewTab</A>, <A HREF=#mgTabRulerDeleteTab>mgTabRulerDeleteTab</A>, 
<A HREF=#mgTabRulerGetSelectedTab>mgTabRulerGetSelectedTab</A>, <A HREF=#mgTabRulerSelectTab>mgTabRulerSelectTab</A>, <A HREF=#mgTabRulerSetGuiCallback>mgTabRulerSetGuiCallback</A>, <A HREF=#mgTabRulerSetMouseCallback>mgTabRulerSetMouseCallback</A></DD></DL>
<HR>
<LEFT><A NAME=mgTabRulerSetTabPosition><H1 CLASS="APISYMBOL">mgTabRulerSetTabPosition</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTabRulerSetTabPosition</B> - sets the position of a tab on a 
tab ruler control<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgTabRulerSetTabPosition</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>tabIndex</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>tabPosition</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTabRulerSetTabPosition</B> sets the position of tab <I>tabIndex</I> on the tab ruler control <I>control</I>.</P></DD><DD><P>The first tab is at index 1.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>tab ruler control</DD><DT><I>tabIndex</I></DT><DD>index of tab to set position for</DD><DT><I>tabPosition</I></DT><DD>new position of tab</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewTabRuler>mgNewTabRuler</A>, <A HREF=#mgFreeTabRuler>mgFreeTabRuler</A>, <A HREF=#mgTabRulerSetOptions>mgTabRulerSetOptions</A>, <A HREF=#mgTabRulerGetTabCount>mgTabRulerGetTabCount</A>, 
<A HREF=#mgTabRulerGetTabPosition>mgTabRulerGetTabPosition</A>, <A HREF=#mgTabRulerSetTabFrozen>mgTabRulerSetTabFrozen</A>, 
<A HREF=#mgTabRulerNewTab>mgTabRulerNewTab</A>, <A HREF=#mgTabRulerDeleteTab>mgTabRulerDeleteTab</A>, 
<A HREF=#mgTabRulerGetSelectedTab>mgTabRulerGetSelectedTab</A>, <A HREF=#mgTabRulerSelectTab>mgTabRulerSelectTab</A>, <A HREF=#mgTabRulerSetGuiCallback>mgTabRulerSetGuiCallback</A>, <A HREF=#mgTabRulerSetMouseCallback>mgTabRulerSetMouseCallback</A></DD></DL>
<HR>
<LEFT><A NAME=mgTextAppendString><H1 CLASS="APISYMBOL">mgTextAppendString</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTextAppendString</B> - appends text to a text control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgTextAppendString</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>string</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTextAppendString</B> appends to the existing text displayed in 
the specified text <I>control</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the text control</DD><DT><I>string</I></DT><DD>the text string to append to the control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgTextClear>mgTextClear</A>, <A HREF=#mgTextSetString>mgTextSetString</A>, 
<A HREF=#mgTextSetInteger>mgTextSetInteger</A>, <A HREF=#mgTextSetFloat>mgTextSetFloat</A>, <A HREF=#mgTextSetDouble>mgTextSetDouble</A>, 
<A HREF=#mgTextSetDMS>mgTextSetDMS</A>, <A HREF=#mgTextSetFilename>mgTextSetFilename</A></DD></DL>
<HR>
<LEFT><A NAME=mgTextClear><H1 CLASS="APISYMBOL">mgTextClear</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTextClear</B> - clears text in text control<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgTextClear</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTextClear</B> clears the text displayed in the specified 
text <I>control</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the text control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgTextSetString>mgTextSetString</A>, <A HREF=#mgTextSetInteger>mgTextSetInteger</A>, <A HREF=#mgTextSetFloat>mgTextSetFloat</A>, 
<A HREF=#mgTextSetDouble>mgTextSetDouble</A>, <A HREF=#mgTextSetDMS>mgTextSetDMS</A>, <A HREF=#mgTextSetFilename>mgTextSetFilename</A></DD></DL>
<HR>
<LEFT><A NAME=mgTextGetDMS><H1 CLASS="APISYMBOL">mgTextGetDMS</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTextGetDMS</B> - retrieves double precision floating point 
value represented in DMS (degrees, minutes, seconds) format from text a 
control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgTextGetDMS</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>dmsVal</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fmtString</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTextGetDMS</B> attempts to interpret the text value displayed 
in the specified text <I>control</I> as a double precision floating point 
value.  The text is assumed to be formatted as a DMS string as described 
below.</P></DD><DD><P>Depending on the <I>fmtString</I> you specify, you can specify how 
you expect the text in the control to be formatted.  You must specify 
either <A HREF=#MDFMT_LAT>MDFMT_LAT</A> or <A HREF=#MDFMT_LON>MDFMT_LON</A> as described here.</P></DD><DD><P>If you specify <A HREF=#MDFMT_LAT>MDFMT_LAT</A> 
in <I>fmtString</I>, the text in the control is expected to be a latitude 
measurement expressed in the form: <B>DD~MM'SS"H</B>, where DD is the number of 
degrees, MM is the number of minutes, SS is the number of seconds and H 
is either 'N' or 'S' depending on whether the value lies in the northern 
or southern hemisphere, respectively.</P></DD><DD><P>If you specify <A HREF=#MDFMT_LON>MDFMT_LON</A> 
in <I>fmtString</I>, the text in the control is expected to be a longitude 
measurement expressed in the form: <B>DD~MM'SS"H</B>, where DD is the number of 
degrees, MM is the number of minutes, SS is the number of seconds and H 
is either 'E' or 'W' depending on whether the value lies in the eastern 
or western hemisphere, respectively.</P></DD><DD><P>By convention, values entered in the northern and eastern hemispheres 
are returned as positive (0.0 .. 180.0).  Values entered in the southern and 
western hemispheres are returned as negative (-180 .. 0.0).</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the text control</DD><DT><I>dmsVal</I></DT><DD>address of double value to receive numeric value 
in decimal degrees from text control</DD><DT><I>fmtString</I></DT><DD>latitude/longitude formatting string</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.  If function 
is successful, <I>dmsVal</I> contains the corresponding numeric value in 
decimal degrees, otherwise <I>dmsVal</I> is undefined.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgTextSetDMS>mgTextSetDMS</A>, 
<A HREF=#mgTextGetString>mgTextGetString</A>, <A HREF=#mgTextGetInteger>mgTextGetInteger</A>, <A HREF=#mgTextGetFloat>mgTextGetFloat</A>, <A HREF=#mgTextGetDouble>mgTextGetDouble</A></DD></DL>
<HR>
<LEFT><A NAME=mgTextGetDouble><H1 CLASS="APISYMBOL">mgTextGetDouble</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTextGetDouble</B> - retrieves double precision floating point 
value from text a control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgTextGetDouble</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>double*</TD><TD><I>doubleVal</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTextGetDouble</B> attempts to interpret the text value displayed 
in the specified text <I>control</I> as a double precision floating point value.</P></DD><DD><P>If the text displayed 
does in fact represent a double precision floating point value, the value is 
returned in the parameter 
<I>doubleVal</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the text control</DD><DT><I>doubleVal</I></DT><DD>address of double value to receive numeric value 
from text control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.  If function 
is successful, <I>doubleVal</I> contains the corresponding numeric value, otherwise 
<I>doubleVal</I> is undefined.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgTextSetDouble>mgTextSetDouble</A>, 
<A HREF=#mgTextGetString>mgTextGetString</A>, <A HREF=#mgTextGetInteger>mgTextGetInteger</A>, <A HREF=#mgTextGetFloat>mgTextGetFloat</A>, <A HREF=#mgTextGetDMS>mgTextGetDMS</A></DD></DL>
<HR>
<LEFT><A NAME=mgTextGetFloat><H1 CLASS="APISYMBOL">mgTextGetFloat</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTextGetFloat</B> - retrieves single precision floating point 
value from text a control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgTextGetFloat</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>float*</TD><TD><I>floatVal</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTextGetFloat</B> attempts to interpret the text value displayed 
in the specified text <I>control</I> as a single precision floating point value.</P></DD><DD><P>If the text displayed 
represents a single precision floating point value, the value is 
returned in the parameter <I>floatVal</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the text control</DD><DT><I>floatVal</I></DT><DD>address of float value to receive numeric value 
from text control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.  If function 
is successful, <I>floatVal</I> contains the corresponding numeric value, otherwise 
<I>floatVal</I> is undefined.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgTextSetFloat>mgTextSetFloat</A>, 
<A HREF=#mgTextGetString>mgTextGetString</A>, <A HREF=#mgTextGetInteger>mgTextGetInteger</A>, <A HREF=#mgTextGetDouble>mgTextGetDouble</A>, <A HREF=#mgTextGetDMS>mgTextGetDMS</A></DD></DL>
<HR>
<LEFT><A NAME=mgTextGetInteger><H1 CLASS="APISYMBOL">mgTextGetInteger</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTextGetInteger</B> - retrieves integer value from text a control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgTextGetInteger</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>intVal</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTextGetInteger</B> attempts to interpret the text value displayed 
in the specified text <I>control</I> as an integer value.</P></DD><DD><P>If the text displayed 
does represent an integer value, the value will be returned in the parameter 
<I>intVal</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the text control</DD><DT><I>intVal</I></DT><DD>address of integer value to receive numeric value 
from text control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.  If function 
is successful, <I>intVal</I> contains the corresponding numeric value, otherwise 
<I>intVal</I> is undefined.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgTextSetInteger>mgTextSetInteger</A>, 
<A HREF=#mgTextGetString>mgTextGetString</A>, <A HREF=#mgTextGetString>mgTextGetString</A>, <A HREF=#mgTextGetFloat>mgTextGetFloat</A>, <A HREF=#mgTextGetDouble>mgTextGetDouble</A>, <A HREF=#mgTextGetDMS>mgTextGetDMS</A></DD></DL>
<HR>
<LEFT><A NAME=mgTextGetSelection><H1 CLASS="APISYMBOL">mgTextGetSelection</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTextGetSelection</B> - retrieves the selected text from a text control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgTextGetSelection</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>string</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maxLen</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTextGetSelection</B> retrieves the selected portion of the 
text displayed in the specified text <I>control</I>.</P></DD><DD><P>The selected text is truncated and 
null terminated if it is longer than <I>maxLen</I> characters.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the text control</DD><DT><I>string</I></DT><DD>character buffer to hold selected text retrieved</DD><DT><I>maxLen</I></DT><DD>the maximum number of characters to store in <I>string</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgTextGetSelectionRange>mgTextGetSelectionRange</A>, 
<A HREF=#mgTextGetString>mgTextGetString</A>, <A HREF=#mgTextGetInteger>mgTextGetInteger</A>, <A HREF=#mgTextGetFloat>mgTextGetFloat</A>, 
<A HREF=#mgTextGetDouble>mgTextGetDouble</A>, <A HREF=#mgTextGetDMS>mgTextGetDMS</A></DD></DL>
<HR>
<LEFT><A NAME=mgTextGetSelectionRange><H1 CLASS="APISYMBOL">mgTextGetSelectionRange</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTextGetSelectionRange</B> - retrieves the selection range 
from a text control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgTextGetSelectionRange</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>start</I>,</TD></TR>
<TR><TD></TD><TD>int*</TD><TD><I>end</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTextGetSelectionRange</B> retrieves the start and end positions 
of the currently selected text displayed in the specified text <I>control</I>.</P></DD><DD><P>The first position in a text control is at index 0.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the text control</DD><DT><I>start</I></DT><DD>address of integer value to receive start position</DD><DT><I>end</I></DT><DD>address of integer value to receive end position</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success. 
If successful, the output parameters <I>start</I> and <I>end</I> will contain 
the start and end positions, respectively, otherwise they are undefined.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><B>mgTextSetSelection</B>, 
<A HREF=#mgTextGetString>mgTextGetString</A>, <A HREF=#mgTextGetInteger>mgTextGetInteger</A>, <A HREF=#mgTextGetFloat>mgTextGetFloat</A>, 
<A HREF=#mgTextGetDouble>mgTextGetDouble</A>, <A HREF=#mgTextGetDMS>mgTextGetDMS</A></DD></DL>
<HR>
<LEFT><A NAME=mgTextGetString><H1 CLASS="APISYMBOL">mgTextGetString</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTextGetString</B> - retrieves text from a text control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgTextGetString</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>string</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maxLen</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTextGetString</B> retrieves the text displayed in the specified 
text <I>control</I>.</P></DD><DD><P>The text is truncated and 
null terminated if it is longer than <I>maxLen</I> characters.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the text control</DD><DT><I>string</I></DT><DD>character buffer to hold text retrieved</DD><DT><I>maxLen</I></DT><DD>the maximum number of characters to store in <I>string</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgTextSetString>mgTextSetString</A>, <A HREF=#mgTextGetInteger>mgTextGetInteger</A>, <A HREF=#mgTextGetFloat>mgTextGetFloat</A>, 
<A HREF=#mgTextGetDouble>mgTextGetDouble</A>, <A HREF=#mgTextGetDMS>mgTextGetDMS</A></DD></DL>
<HR>
<LEFT><A NAME=mgTextSelectAll><H1 CLASS="APISYMBOL">mgTextSelectAll</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTextSelectAll</B> - selects all the text in a text control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgTextSelectAll</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTextSelectAll</B> selects all the characters displayed in the 
specified text <I>control</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the text control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<HR>
<LEFT><A NAME=mgTextSelectRange><H1 CLASS="APISYMBOL">mgTextSelectRange</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTextSelectRange</B> - selects a range of text in a text control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgTextSelectRange</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>firstPos</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>lastPos</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTextSelectRange</B> selects the specified range of characters 
displayed in the specified text <I>control</I>.</P></DD><DD><P>The first position is at index 0.</P></DD><DD><P>If <I>firstPos</I> is 0 and <I>lastPos</I> is -1, all the text in the text control is selected. 
If <I>firstPos</I> is -1, any current selection is removed. The caret is placed at the end of the selection 
indicated by the greater of the two values <I>firstPos</I> and <I>lastPos</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the text control</DD><DT><I>firstPos</I></DT><DD>position of first character to select</DD><DT><I>lastPos</I></DT><DD>position of last character to select</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<HR>
<LEFT><A NAME=mgTextSetDMS><H1 CLASS="APISYMBOL">mgTextSetDMS</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTextSetDMS</B> - displays DMS (degrees, minutes, seconds) 
formatted text in a text control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgTextSetDMS</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>dmsVal</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fmtString</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTextSetDMS</B> displays the specified double value <I>dmsVal</I> 
(assumed to be in decimal degrees) in the specified text <I>control</I> 
formatted as degrees, minutes and seconds.</P></DD><DD><P>Depending on the <I>fmtString</I> you specify, you can control the 
format of the string displayed in the text control.  You must specify 
either <A HREF=#MDFMT_LAT>MDFMT_LAT</A> or <A HREF=#MDFMT_LON>MDFMT_LON</A> as described below.</P></DD><DD><P>If you specify <A HREF=#MDFMT_LAT>MDFMT_LAT</A> 
in <I>fmtString</I>, <I>dmsVal</I> is converted to a latitude measurement and is 
displayed in the form: <B>DD~MM'SS"H</B>, where DD is the number of degrees, MM is 
the number of minutes, SS is the number of seconds and H is either 'N' or 'S' 
depending on whether the value lies in the northern or southern hemisphere, 
respectively.</P></DD><DD><P>If you specify <A HREF=#MDFMT_LON>MDFMT_LON</A> 
in <I>fmtString</I>, <I>dmsVal</I> is converted to a longitude measurement and is 
displayed in the form: <B>DD~MM'SS"H</B>, where DD is the number of degrees, MM is 
the number of minutes, SS is the number of seconds and H is either 'E' or 'W' 
depending on whether the value lies in the eastern or western hemisphere, 
respectively.</P></DD><DD><P>By convention, values in the northern and eastern hemispheres are 
positive (0.0 .. 180.0).  Values in the southern and western hemispheres 
are negative (-180 .. 0.0).  If you specify a value outside these ranges, 
the results are undefined.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the text control</DD><DT><I>dmsVal</I></DT><DD>double precision floating point value 
in decimal degrees to format and display</DD><DT><I>fmtString</I></DT><DD>latitude/longitude formatting string</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>Here are some examples.</DT><DT><PRE CLASS="EXAMPLE">mgstatus status;

// will display 37~30'00"N in text control
status = mgTextSetDMS (text, 37.5, MDFMT_LAT);

// will display 123~15'00"W in text control
status = mgTextSetDMS (text, -123.25, MDFMT_LON);</PRE></DT></DL></DD></DL>

<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgTextGetDMS>mgTextGetDMS</A>, 
<A HREF=#mgTextSetString>mgTextSetString</A>, <A HREF=#mgTextSetInteger>mgTextSetInteger</A>, <A HREF=#mgTextSetFloat>mgTextSetFloat</A>, 
<A HREF=#mgTextSetDouble>mgTextSetDouble</A></DD></DL>
<HR>
<LEFT><A NAME=mgTextSetDouble><H1 CLASS="APISYMBOL">mgTextSetDouble</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTextSetDouble</B> - displays double precision floating point 
formatted text in a text control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgTextSetDouble</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>doubleVal</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fmtString</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTextSetDouble</B> displays the specified double value <I>doubleVal</I> using 
the specified <B>printf</B> style formatting string <I>fmtString</I> in the specified text 
<I>control</I>.</P></DD><DD><P>If you specify <A HREF=#MG_NULL>MG_NULL</A> in <I>fmtString</I>, the default double 
precision floating point formatting string "%lf" is used.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the text control</DD><DT><I>doubleVal</I></DT><DD>double precision floating point value to display</DD><DT><I>fmtString</I></DT><DD><B>printf</B> style formatting string</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgTextGetDouble>mgTextGetDouble</A>, 
<A HREF=#mgTextSetString>mgTextSetString</A>, <A HREF=#mgTextSetInteger>mgTextSetInteger</A>, <A HREF=#mgTextSetFloat>mgTextSetFloat</A>, <A HREF=#mgTextSetDMS>mgTextSetDMS</A>, 
<A HREF=#mgTextSetFilename>mgTextSetFilename</A></DD></DL>
<HR>
<LEFT><A NAME=mgTextSetEditable><H1 CLASS="APISYMBOL">mgTextSetEditable</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTextSetEditable</B> - enables or disables editing of a text control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgTextSetEditable</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>editable</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Depending on the value of the parameter <I>editable</I>, <B>mgTextSetEditable</B> 
either enables (<A HREF=#mgbool>MG_TRUE</A>) or disables (<A HREF=#mgbool>MG_FALSE</A>) the editing of 
a text control.</P></DD><DD><P>Text controls that are editable can be modified by the user.  Text controls 
that are not editable can be used to display "read-only" values.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the text control</DD><DT><I>editable</I></DT><DD>enum mgbool <A HREF=#mgbool>MG_TRUE</A> to allow 
editing, <A HREF=#mgbool>MG_FALSE</A> to disallow editing</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<HR>
<LEFT><A NAME=mgTextSetFilename><H1 CLASS="APISYMBOL">mgTextSetFilename</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTextSetFilename</B> - displays a file name in a text control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgTextSetFilename</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fileName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTextSetFilename</B> displays the specified <I>fileName</I> string in the 
specified text <I>control</I> in such a way that the name and extension parts of 
the file name are guaranteed to be visible.</P></DD><DD><P>This function is useful when used with left justified static text controls 
that may not be "wide" enough to display the full file name (including path, name 
and extension parts).  In such a control, the name and extension parts of long 
file names may get truncated and may become unviewable.</P></DD><DD><P>If you use this function to display 
a file name in a text control and the file name is too long to fit completely, 
the name is truncated from the left until the remainder can be displayed, ensuring 
that the name and extension parts are visible.</P></DD><DD><P>When a file name is truncated in this way, it is prepended with "..." 
to indicate to the user that the full name is not displayed.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the text control</DD><DT><I>fileName</I></DT><DD>the file name string to load into the control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgTextSetString>mgTextSetString</A>, <A HREF=#mgTextSetInteger>mgTextSetInteger</A>, <A HREF=#mgTextSetFloat>mgTextSetFloat</A>, 
<A HREF=#mgTextSetDouble>mgTextSetDouble</A>, <A HREF=#mgTextSetDMS>mgTextSetDMS</A></DD></DL>
<HR>
<LEFT><A NAME=mgTextSetFloat><H1 CLASS="APISYMBOL">mgTextSetFloat</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTextSetFloat</B> - displays single precision floating point 
formatted text in a text control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgTextSetFloat</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>float</TD><TD><I>floatVal</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fmtString</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTextSetFloat</B> displays the specified float value <I>floatVal</I> using 
the specified <B>printf</B> style formatting string <I>fmtString</I> in the specified text 
<I>control</I>.</P></DD><DD><P>If you specify <A HREF=#MG_NULL>MG_NULL</A> in <I>fmtString</I>, the default single 
precision floating point formatting string "%f" will be used.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the text control</DD><DT><I>floatVal</I></DT><DD>single precision floating point value to display</DD><DT><I>fmtString</I></DT><DD><B>printf</B> style formatting string</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgTextGetFloat>mgTextGetFloat</A>, 
<A HREF=#mgTextSetString>mgTextSetString</A>, <A HREF=#mgTextSetInteger>mgTextSetInteger</A>, <A HREF=#mgTextSetDouble>mgTextSetDouble</A>, <A HREF=#mgTextSetDMS>mgTextSetDMS</A>, 
<A HREF=#mgTextSetFilename>mgTextSetFilename</A></DD></DL>
<HR>
<LEFT><A NAME=mgTextSetInteger><H1 CLASS="APISYMBOL">mgTextSetInteger</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTextSetInteger</B> - displays integer formatted text in a text control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgTextSetInteger</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>intVal</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fmtString</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTextSetInteger</B> displays the specified integer value <I>intVal</I> using 
the specified <B>printf</B> style formatting string <I>fmtString</I> in the specified text 
<I>control</I>.</P></DD><DD><P>If you specify <A HREF=#MG_NULL>MG_NULL</A> in <I>fmtString</I>, the default integer formatting 
string "%d" is used.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the text control</DD><DT><I>intVal</I></DT><DD>integer value to display</DD><DT><I>fmtString</I></DT><DD><B>printf</B> style formatting string</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgTextGetInteger>mgTextGetInteger</A>, 
<A HREF=#mgTextSetString>mgTextSetString</A>, <A HREF=#mgTextSetFloat>mgTextSetFloat</A>, <A HREF=#mgTextSetDouble>mgTextSetDouble</A>, <A HREF=#mgTextSetDMS>mgTextSetDMS</A>, 
<A HREF=#mgTextSetFilename>mgTextSetFilename</A></DD></DL>
<HR>
<LEFT><A NAME=mgTextSetSpinBuddy><H1 CLASS="APISYMBOL">mgTextSetSpinBuddy</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTextSetSpinBuddy</B> - associates a spin buddy control 
to a text control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgTextSetSpinBuddy</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>spinControl</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTextSetSpinBuddy</B> associates the specified spin buddy control, 
<I>spinControl</I>, to the specified text <I>control</I>.</P></DD><DD><P>A spin buddy control will direct user input from itself to the 
associated text control.  As the user clicks the up or down arrows of 
the spin control, the value of the text control will increase or decrease 
accordingly.</P></DD><DD><P>The amount that the text control value will increase/decrease when 
either arrow of the spin buddy control is pressed can be set by calling 
<A HREF=#mgTextSetSpinIncrement>mgTextSetSpinIncrement</A>.  The default spin increment is 1.0.</P></DD><DD><P>A text control can have at most one spin buddy control.  Furthermore, 
once you associate a spin buddy control to a given text control using this 
function, you cannot change which spin buddy is associated to that text 
control by calling this function again.</P></DD><DD><P>After associating a buddy control to a text control, the two controls 
will behave as one.  In particular, when calling <A HREF=#mgSetEnabled>mgSetEnabled</A> or 
<A HREF=#mgSetVisible>mgSetVisible</A> for the text control, both the text and the buddy 
control will be affected simultaneously and automatically.  Furthermore, 
when accessing the resulting composite control, you must use the text 
control object, not the buddy control object.  Performing operations on the 
buddy control explicitly is not supported and the results are undefined.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the text control</DD><DT><I>spinControl</I></DT><DD>the spin control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgTextSetSpinIncrement>mgTextSetSpinIncrement</A>, <A HREF=#mgTextSetTextFormat>mgTextSetTextFormat</A>, <A HREF=#mgSetGuiCallback>mgSetGuiCallback</A></DD></DL>
<HR>
<LEFT><A NAME=mgTextSetSpinIncrement><H1 CLASS="APISYMBOL">mgTextSetSpinIncrement</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTextSetSpinIncrement</B> - sets the spin increment for 
a text control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgTextSetSpinIncrement</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>increment</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTextSetSpinIncrement</B> sets the spin increment value for the 
specified text <I>control</I> to the specified value, <I>increment</I>.</P></DD><DD><P>The spin increment value is the value that a text control is 
incremented or decremented when the user clicks the up/down arrow buttons 
of the spin buddy control associated to the text control. The default value 
for this spin increment is 1.0.</P></DD><DD><P>If <I>increment</I> is positive, the up arrow of the spin control will 
increase the value of the text control and the down arrow will decrease it. 
If <I>increment</I> is negative, the up arrow will decrease the text's value 
and the down arrow will increase it.</P></DD><DD><P>This function is only meaningful for a text control that has a 
spin buddy control.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the text control</DD><DT><I>increment</I></DT><DD>the increment value for the control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgTextSetSpinBuddy>mgTextSetSpinBuddy</A>, <A HREF=#mgTextSetTextFormat>mgTextSetTextFormat</A></DD></DL>
<HR>
<LEFT><A NAME=mgTextSetString><H1 CLASS="APISYMBOL">mgTextSetString</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTextSetString</B> - displays text in a text control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgTextSetString</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>string</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTextSetString</B> sets the text displayed in the specified 
text <I>control</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the text control</DD><DT><I>string</I></DT><DD>the text string to load into the control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgTextClear>mgTextClear</A>, <A HREF=#mgTextAppendString>mgTextAppendString</A>, 
<A HREF=#mgTextSetInteger>mgTextSetInteger</A>, <A HREF=#mgTextSetFloat>mgTextSetFloat</A>, <A HREF=#mgTextSetDouble>mgTextSetDouble</A>, 
<A HREF=#mgTextSetDMS>mgTextSetDMS</A>, <A HREF=#mgTextSetFilename>mgTextSetFilename</A></DD></DL>
<HR>
<LEFT><A NAME=mgTextSetTextFormat><H1 CLASS="APISYMBOL">mgTextSetTextFormat</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTextSetTextFormat</B> - sets the text format string for 
a text control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgTextSetTextFormat</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fmtString</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTextSetTextFormat</B> sets the format string for the text control 
that has a spin buddy control.  The format string, <I>fmtString</I>, is assumed 
to be a <B>printf</B> style format string and is used to automatically format 
the numeric value that is displayed in the text control when the associated 
spin buddy is activated.</P></DD><DD><P>The default format string for a text control is "%lf".</P></DD><DD><P>This function is only meaningful for a text control that has a 
spin buddy control.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the text control</DD><DT><I>fmtString</I></DT><DD>the format string for the text buddy</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgTextSetSpinBuddy>mgTextSetSpinBuddy</A>, <A HREF=#mgTextSetSpinIncrement>mgTextSetSpinIncrement</A></DD></DL>
<HR>
<LEFT><A NAME=mgTextureGetLocatorFunc><H1 CLASS="APISYMBOL">mgTextureGetLocatorFunc</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTextureGetLocatorFunc</B> - gets the current 
texture file locator function.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD> mgfilelocatorfunc <B>mgTextureGetLocatorFunc</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTextureGetLocatorFunc</B> returns the current texture file 
locator function.  In this way, you can query the current locator 
function and then call it as part of the locator function you set 
up or call it directly for other file location processing your 
application or plug-in requires.</P></DD><DD><P>Note: Although only stand-alone applications can override 
the texture file locator, stand-alone applications as well as 
plug-ins can obtain it.  This allows both stand-alone applications 
and plug-ins to "mimic" the behavior of the default file locator 
when locating files as part of their processing.</P></DD></DT></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgTextureSetLocatorFunc>mgTextureSetLocatorFunc</A>, <A HREF=#mgExtRefGetLocatorFunc>mgExtRefGetLocatorFunc</A>, 
<A HREF=#mgShaderGetLocatorFunc>mgShaderGetLocatorFunc</A>, <A HREF=#mgfilelocatorfunc>mgfilelocatorfunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgTextureGetSavePathType><H1 CLASS="APISYMBOL">mgTextureGetSavePathType</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTextureGetSavePathType</B> - gets the save path type for 
the textures in a database.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgsavepathtype <B>mgTextureGetSavePathType</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTextureGetSavePathType</B> returns how the names of the textures in 
a database <I>db</I> will be saved when they are written to the database file 
on disk.</P></DD><DD><P>The save names of textures in a database are the actual names that 
are saved in the OpenFlight database file.  The save names may or may not 
include the full path specifications of the texture files.  The may have 
partial path information (relative) or may include no path information.</P></DD><DD><P>The possible return values are:<BR> 
<A HREF=#mgsavepathtype>MSPT_ABSOLUTE</A> - The save names will include the 
full path specification (if known).<BR> 
<A HREF=#mgsavepathtype>MSPT_RELATIVE</A> - The save names will be relative 
names and will begin with the character sequence "./".<BR> 
<A HREF=#mgsavepathtype>MSPT_NOPATH</A> -  The save names will include no path 
information and will simply be the name part of the file name.<BR> 
<A HREF=#mgsavepathtype>MSPT_UNKNOWN</A> - The save name type could not be 
determined.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgsavepathtype>MSPT_ABSOLUTE</A>, 
<A HREF=#mgsavepathtype>MSPT_RELATIVE</A> or <A HREF=#mgsavepathtype>MSPT_NOPATH</A> 
if successful, <A HREF=#mgsavepathtype>MSPT_UNKNOWN</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgsavepathtype>mgsavepathtype</A>, <A HREF=#mgTextureSetSavePathType>mgTextureSetSavePathType</A>, <A HREF=#mgGetTextureSaveName>mgGetTextureSaveName</A></DD></DL>
<HR>
<LEFT><A NAME=mgTextureSetLocatorFunc><H1 CLASS="APISYMBOL">mgTextureSetLocatorFunc</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTextureSetLocatorFunc</B> - sets the texture file locator 
function.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgTextureSetLocatorFunc</B> (</TD><TD><A HREF=#mgfilelocatorfunc>mgfilelocatorfunc</A></TD><TD><I>locatorFunc</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTextureSetLocatorFunc</B> allows you to setup a texture file locator 
function used by the OpenFlight API to "locate" texture files referenced 
within OpenFlight databases.  When a database file is opened using the 
OpenFlight API API, the current texture file locator function set will 
be called to locate the texture file.  In this way, your application can 
override the way the API locates texture files.</P></DD><DD><P>Note: This function is for use in stand-alone applications only, 
and should never be called from inside a plug-in.  Doing so may yield 
undefined results.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>locatorFunc</I></DT><DD>the texture file locator function</DD><DT><I>userData</I></DT><DD>user defined data that will be 
passed to <I>locatorFunc</I> when it is 
called</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgTextureGetLocatorFunc>mgTextureGetLocatorFunc</A>, <A HREF=#mgExtRefSetLocatorFunc>mgExtRefSetLocatorFunc</A>, 
<A HREF=#mgShaderSetLocatorFunc>mgShaderSetLocatorFunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgTextureSetSavePathType><H1 CLASS="APISYMBOL">mgTextureSetSavePathType</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgTextureSetSavePathType</B> - Sets the save path type for all the 
textures in a database.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgTextureSetSavePathType</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgsavepathtype>mgsavepathtype</A></TD><TD><I>saveType</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgTextureSetSavePathType</B> specifies how the names of the textures in 
a database <I>db</I> will be saved when they are written to the database file 
on disk.</P></DD><DD><P>The save names of textures in a database are the actual names that 
are saved in the OpenFlight database file.  The save names may or may not 
include the full path specifications of the texture files.  The may have 
partial path information (relative) or may include no path information.</P></DD><DD><P>This function allows you to specify how these save names are written 
for textures in the palette.  All texture names in a database must be saved 
with the same save path type.  For example, you cannot save some textures 
with absolute file names and others with relative names.</P></DD><DD><P>This function accepts the following values for <I>saveType</I>:<BR> 
<A HREF=#mgsavepathtype>MSPT_ABSOLUTE</A> - The save names will include the 
full path specification (if known).<BR> 
<A HREF=#mgsavepathtype>MSPT_RELATIVE</A> - The save names will be relative 
names and will begin with the character sequence "./".<BR> 
<A HREF=#mgsavepathtype>MSPT_NOPATH</A> -  The save names will include no path 
information and will simply be the name part of the file name.</P></DD><DD><P>If you specify any value other than one listed here (specifically 
<A HREF=#mgsavepathtype>MSPT_UNKNOWN</A>) as <I>saveType</I>, this function will fail.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>saveType</I></DT><DD>the save path type for textures</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgTextureGetSavePathType>mgTextureGetSavePathType</A>, <A HREF=#mgGetTextureSaveName>mgGetTextureSaveName</A></DD></DL>
<HR>
<LEFT><A NAME=mgtimerfunc><H1 CLASS="APISYMBOL">mgtimerfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgtimerfunc</B> - Timer function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool (*<B>mgtimerfunc</B>) ( <TD><A HREF=#mgtimer>mgtimer</A> <TD><I>timerId</I>, 
<TR><TD></TD><TD>void* <TD><I>userData</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for timer functions. 
When you create a timer object using <A HREF=#mgRegisterTimer>mgRegisterTimer</A>, you will provide a 
timer function of this form that will be called when your timer expires.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>timerId</I></DT><DD>the timer object that identifies the timer that has expired</DD><DT><I>userData</I></DT><DD>user defined data specified when timer was submitted</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Return <A HREF=#mgbool>MG_TRUE</A> if you want to resubmit the timer 
request, <A HREF=#mgbool>MG_FALSE</A> otherwise.  In this way you can set up a 
recurring timer object by returning <A HREF=#mgbool>MG_TRUE</A>.
</DD></DL><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterTimer>mgRegisterTimer</A>, <A HREF=#mgUnregisterTimer>mgUnregisterTimer</A></DD></DL>
<HR>
<LEFT><A NAME=mgToggleButtonGetState><H1 CLASS="APISYMBOL">mgToggleButtonGetState</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgToggleButtonGetState</B> - retrieves the state of a toggle button control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgToggleButtonGetState</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgToggleButtonGetState</B> retrieves the selection state of the specified 
toggle button <I>control</I>.</P></DD><DD><P>In two state toggle button controls, 1 indicates that the control 
is selected (or checked), and 0 indicates that it is not.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the toggle button control</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns 1 if the control is selected, 0 otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><B>mgToggleButtonGetState</B>, <A HREF=#mgSetEnabled>mgSetEnabled</A>, <A HREF=#mgIsEnabled>mgIsEnabled</A>, 
<A HREF=#mgSetVisible>mgSetVisible</A>, <A HREF=#mgIsVisible>mgIsVisible</A></DD></DL>
<HR>
<LEFT><A NAME=mgToggleButtonSetState><H1 CLASS="APISYMBOL">mgToggleButtonSetState</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgToggleButtonSetState</B> - sets the state of a toggle button control.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgToggleButtonSetState</B> (</TD><TD><A HREF=#mggui>mggui</A></TD><TD><I>control</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>state</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgToggleButtonSetState</B> sets the selection state of the specified 
toggle button <I>control</I>.</P></DD><DD><P>In two state toggle button controls, 1 indicates that the control 
is selected (or checked), and 0 indicates that it is not.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>control</I></DT><DD>the toggle button control</DD><DT><I>state</I></DT><DD>the state of the control (1 is selected, 0 
is not selected)</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgToggleButtonGetState>mgToggleButtonGetState</A>, <A HREF=#mgSetEnabled>mgSetEnabled</A>, <A HREF=#mgIsEnabled>mgIsEnabled</A>, 
<A HREF=#mgSetVisible>mgSetVisible</A>, <A HREF=#mgIsVisible>mgIsVisible</A></DD></DL>
<HR>
<LEFT><A NAME=mgToolActionGetName><H1 CLASS="APISYMBOL">mgToolActionGetName</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgToolActionGetName</B> - gets the name of a plug-in tool action.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgToolActionGetName</B> (</TD><TD><A HREF=#mgtoolaction>mgtoolaction</A></TD><TD><I>toolAction</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>actionName</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maxLen</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><I>mgToolActionGetName</I> returns the name of the plug-in tool action 
<I>toolAction</I>&#32in the output string <I>actionName</I>.  The output string is truncated 
and null terminated if it is longer than <I>maxLen</I> characters.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>toolAction</I></DT><DD>the tool action</DD><DT><I>actionName</I></DT><DD>character buffer to hold name 
of tool action</DD><DT><I>maxLen</I></DT><DD>the maximum number of characters to 
store in <I>actionName</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success. 
If successful, the output parameter <I>actionName</I> will contain the 
name of the plug-in tool action, otherwise it is undefined.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPluginToolNewAction>mgPluginToolNewAction</A>, <A HREF=#mgPluginToolFreeAction>mgPluginToolFreeAction</A>, <A HREF=#mgPluginToolGetAction>mgPluginToolGetAction</A>, 
<A HREF=#mgToolActionSetShortCut>mgToolActionSetShortCut</A>, <A HREF=#mgToolActionGetShortCut>mgToolActionGetShortCut</A>, 
<A HREF=#mgToolActionGetShortCutString>mgToolActionGetShortCutString</A></DD></DL>
<HR>
<LEFT><A NAME=mgToolActionGetShortCut><H1 CLASS="APISYMBOL">mgToolActionGetShortCut</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgToolActionGetShortCut</B> - gets a plug-in tool action shortcut 
key sequence.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgToolActionGetShortCut</B> (</TD><TD><A HREF=#mgtoolaction>mgtoolaction</A></TD><TD><I>toolAction</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgkeysequence>mgkeysequence*</A></TD><TD><I>keySequence</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><I>mgToolActionGetShortCut</I> returns the key sequence representing 
the shortcut assigned to the plug-in tool action <I>toolAction</I> in the 
output parameter <I>keySequence</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>toolAction</I></DT><DD>the tool action</DD><DT><I>keySequence</I></DT><DD>the key sequence that is currently 
set as the shortcut for this action</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success. 
If successful, the output parameter <I>keySequence</I> will contain the 
shortcut key sequence of the plug-in tool action, otherwise it is undefined.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgToolActionSetShortCut>mgToolActionSetShortCut</A>, <A HREF=#mgSetGuiToolAction>mgSetGuiToolAction</A>, 
<A HREF=#mgPluginToolNewAction>mgPluginToolNewAction</A>, <A HREF=#mgPluginToolFreeAction>mgPluginToolFreeAction</A>, 
<A HREF=#mgPluginToolGetAction>mgPluginToolGetAction</A>, <A HREF=#mgToolActionGetName>mgToolActionGetName</A>, 
<A HREF=#mgToolActionGetShortCutString>mgToolActionGetShortCutString</A></DD></DL>
<HR>
<LEFT><A NAME=mgToolActionGetShortCutString><H1 CLASS="APISYMBOL">mgToolActionGetShortCutString</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgToolActionGetShortCutString</B> - gets a plug-in tool action 
shortcut key string.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgToolActionGetShortCutString</B> (</TD><TD><A HREF=#mgtoolaction>mgtoolaction</A></TD><TD><I>toolAction</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>shortCutString</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>maxLen</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><I>mgToolActionGetShortCutString</I> returns the string representation 
of the shortcut assigned to the plug-in tool action <I>toolAction</I> in the 
output parameter <I>shortCutString</I>. The output string is truncated 
and null terminated if it is longer than <I>maxLen</I> characters.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>toolAction</I></DT><DD>the tool action</DD><DT><I>shortCutString</I></DT><DD>character buffer to hold short cut 
string of tool action</DD><DT><I>maxLen</I></DT><DD>the maximum number of characters to 
store in <I>shortCutString</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success. 
If successful, the output parameter <I>shortCutString</I> will contain the 
string representation of the shorcut assigned to the plug-in tool action, 
otherwise it is undefined.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgToolActionGetName>mgToolActionGetName</A>, <A HREF=#mgToolActionGetShortCut>mgToolActionGetShortCut</A>, 
<A HREF=#mgPluginToolNewAction>mgPluginToolNewAction</A>, <A HREF=#mgPluginToolFreeAction>mgPluginToolFreeAction</A>, <A HREF=#mgPluginToolGetAction>mgPluginToolGetAction</A>, 
<A HREF=#mgToolActionSetShortCut>mgToolActionSetShortCut</A>, <A HREF=#mgSetGuiToolAction>mgSetGuiToolAction</A>,</DD></DL>
<HR>
<LEFT><A NAME=mgToolActionSetShortCut><H1 CLASS="APISYMBOL">mgToolActionSetShortCut</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgToolActionSetShortCut</B> - sets a plug-in tool action shortcut 
key sequence.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus <B>mgToolActionSetShortCut</B> (</TD><TD><A HREF=#mgtoolaction>mgtoolaction</A></TD><TD><I>toolAction</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgkeysequence>mgkeysequence*</A></TD><TD><I>keySequence</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><I>mgToolActionSetShortCut</I> sets the shortcut key sequence for 
the plug-in tool action <I>toolAction</I> to <I>keySequence</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>toolAction</I></DT><DD>the tool action</DD><DT><I>keySequence</I></DT><DD>the key sequence to set as the shortcut 
for this action</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Use <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> to check return value for success.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgToolActionGetShortCut>mgToolActionGetShortCut</A>, <A HREF=#mgSetGuiToolAction>mgSetGuiToolAction</A>, 
<A HREF=#mgPluginToolNewAction>mgPluginToolNewAction</A>, <A HREF=#mgPluginToolFreeAction>mgPluginToolFreeAction</A>, 
<A HREF=#mgPluginToolGetAction>mgPluginToolGetAction</A>, <A HREF=#mgToolActionGetName>mgToolActionGetName</A>, 
<A HREF=#mgToolActionGetShortCutString>mgToolActionGetShortCutString</A></DD></DL>
<HR>
<LEFT><A NAME=mgtoolstartfunc><H1 CLASS="APISYMBOL">mgtoolstartfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgtoolstartfunc</B> - Start function for Database Importer/Exporter, 
Viewer and Editor Tools<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgstatus (*<B>mgtoolstartfunc</B>) ( <TD><A HREF=#mgplugintool>mgplugintool</A> <TD><I>pluginTool</I>, 
<TR><TD></TD><TD>void* <TD><I>userData</I>, 
<TR><TD></TD><TD>void* <TD><I>callData</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for plug-in tool start functions. 
When you register a plug-in tool, provide a start function 
of this form that is called when your plug-in tool is invoked in Creator.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginTool</I></DT><DD>the plug-in tool</DD><DT><I>userData</I></DT><DD>user defined data specified when tool registered</DD><DT><I>callData</I></DT><DD>pointer to tool specific callback record <BR> 
For image importer plug-in tools, this points to 
an <A HREF=#mgimportercallbackrec>mgimportercallbackrec</A> record<BR> 
For image exporter plug-in tools, this points to 
an <A HREF=#mgexportercallbackrec>mgexportercallbackrec</A> record<BR> 
For viewer plug-in tools, this points to 
an <A HREF=#mgviewercallbackrec>mgviewercallbackrec</A> record<BR> 
For editor plug-in tools, this points to 
an <A HREF=#mgeditorcallbackrec>mgeditorcallbackrec</A> record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Currently the value returned by <A HREF=#mgtoolstartfunc>mgtoolstartfunc</A> is ignored and 
reserved for future enhancement.  For now always return <A HREF=#MSTAT_OK>MSTAT_OK</A>.
</DD></DL><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImporter>mgRegisterImporter</A>, <A HREF=#mgRegisterExporter>mgRegisterExporter</A>, <A HREF=#mgRegisterViewer>mgRegisterViewer</A>, 
<A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=mgUnloadResource><H1 CLASS="APISYMBOL">mgUnloadResource</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgUnloadResource</B> - unload a resource.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgUnloadResource</B> (</TD><TD><A HREF=#mgresource>mgresource</A></TD><TD><I>resource</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgUnloadResource</B> frees all internal structures used to represent 
a resource loaded by <A HREF=#mgLoadResource>mgLoadResource</A>.</P></DD><DD><P>After calling this function, the individual resource items contained 
in the resource become unavailable. Typically call this 
function one time when your plug-in module exits.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>resource</I></DT><DD>the resource to unload</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgLoadResource>mgLoadResource</A></DD></DL>
<HR>
<LEFT><A NAME=mgUnproject><H1 CLASS="APISYMBOL">mgUnproject</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgUnproject</B> - unprojects database coordinates into 
projection coordinates.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgprojcoord <B>mgUnproject</B> (</TD><TD>const <A HREF=#mgcoord3d>mgcoord3d*</A></TD><TD><I>coord</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgUnproject</B> unprojects database coordinates into projection coordinates. 
This function performs the same function as <A HREF=#mgProjectionConvertXYZtoLLE>mgProjectionConvertXYZtoLLE</A>.  If 
you need to convert multiple coordinates consecutively, it is more efficient to 
use <A HREF=#mgProjectionConvertXYZtoLLE>mgProjectionConvertXYZtoLLE</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>coord</I></DT><DD>projection coordinates to project</DD><DT><I>db</I></DT><DD>database containing the projection to use</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the projection coordinates represented by <I>coord</I>.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgprojcoord>mgprojcoord</A>, <A HREF=#mgcoord3d>mgcoord3d</A>, 
<A HREF=#mgProject>mgProject</A>, <A HREF=#mgProjectionConvertXYZtoLLE>mgProjectionConvertXYZtoLLE</A></DD></DL>
<HR>
<LEFT><A NAME=mgUnregisterAllNotifiers><H1 CLASS="APISYMBOL">mgUnregisterAllNotifiers</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgUnregisterAllNotifiers</B> - unregisters all notifiers for 
a plug-in tool.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgUnregisterAllNotifiers</B> (</TD><TD><A HREF=#mgplugintool>mgplugintool</A></TD><TD><I>pluginTool</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgUnregisterAllNotifiers</B> unregisters all notifiers 
currently registered for the specified plug-in tool <I>pluginTool</I>. 
Unregistering a notifier disables and destroys it.</P></DD><DD><P>Unregister a notifier when you are finished with it. 
Disable a notifier if you just want to stop the notifier from 
reporting events temporarily.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>pluginTool</I></DT><DD>the plug-in tool for which all notifiers 
are being unregistered</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterNotifier>mgRegisterNotifier</A>, <A HREF=#mgSetNotifierEnabled>mgSetNotifierEnabled</A></DD></DL>
<HR>
<LEFT><A NAME=mgUnregisterAllTools><H1 CLASS="APISYMBOL">mgUnregisterAllTools</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgUnregisterAllTools</B> - unregisters all tools for a plug-in.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgUnregisterAllTools</B> (</TD><TD><A HREF=#mgplugin>mgplugin</A></TD><TD><I>plugin</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgUnregisterAllTools</B> unregisters all previously registered tools 
for a specified plug-in module <B>plugin</B>.</P></DD><DD><P>After calling this function, all tools registered for the plug-in 
become inaccessible.  You should only call this function from your 
plug-in termination function <A HREF=#mgpExit>mgpExit</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>plugin</I></DT><DD>the plug-in module to unregister all tools for</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 3</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImporter>mgRegisterImporter</A>, <A HREF=#mgRegisterExporter>mgRegisterExporter</A>, <A HREF=#mgRegisterViewer>mgRegisterViewer</A>, 
<A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A></DD></DL>
<HR>
<LEFT><A NAME=mgUnregisterNotifier><H1 CLASS="APISYMBOL">mgUnregisterNotifier</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgUnregisterNotifier</B> - unregisters a notifier.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgUnregisterNotifier</B> (</TD><TD><A HREF=#mgnotifier>mgnotifier</A></TD><TD><I>notifier</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgUnregisterNotifier</B> unregisters the specified <I>notifier</I>. 
Unregistering a notifier disables and destroys it.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>notifier</I></DT><DD>the notifier to unregister</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterNotifier>mgRegisterNotifier</A>, <A HREF=#mgRegisterPaletteNotifier>mgRegisterPaletteNotifier</A>, <A HREF=#mgSetNotifierEnabled>mgSetNotifierEnabled</A></DD></DL>
<HR>
<LEFT><A NAME=mgUnregisterTimer><H1 CLASS="APISYMBOL">mgUnregisterTimer</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgUnregisterTimer</B> - remove a timer request.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgUnregisterTimer</B> (</TD><TD><A HREF=#mgtimer>mgtimer</A></TD><TD><I>timerId</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgUnregisterTimer</B> removes a timer request identified by <I>timerId</I> 
if it has not yet expired.  The timer object <I>timerId</I> was returned from 
<A HREF=#mgRegisterTimer>mgRegisterTimer</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>timerId</I></DT><DD>timer object to remove</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterTimer>mgRegisterTimer</A>, <A HREF=#mgtimerfunc>mgtimerfunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgUnRemove><H1 CLASS="APISYMBOL">mgUnRemove</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgUnRemove</B> - unremoves a node record that was 
temporarily delete using <A HREF=#mgRemove>mgRemove</A>.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgrec* <B>mgUnRemove</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><A HREF=#mgRemove>mgRemove</A> unremoves the specified node record 
<I>rec</I> that was previously removed by calling <A HREF=#mgRemove>mgRemove</A>.</P></DD><DD><P>Records that are unremoved in this way cannot be re-attached 
in the database.  It is the caller's responsibility to attach the record 
back into the hierarchy at the appropriate place.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>rec</I></DT><DD>the record to unremove</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <I>rec</I> if  <I>rec</I> could be successfully unremoved, 
<A HREF=#MG_NULL>MG_NULL</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 4</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRemove>mgRemove</A>, <A HREF=#mgDelete>mgDelete</A>, <A HREF=#mgDetach>mgDetach</A></DD></DL>
<HR>
<LEFT><A NAME=mgUpdateTextureMapping><H1 CLASS="APISYMBOL">mgUpdateTextureMapping</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgUpdateTextureMapping</B> - updates the internal data of 
a texture mapping.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgUpdateTextureMapping</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>tmRec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgUpdateTextureMapping</B> updates internal data structures 
associated with a texture mapping palette entry, <I>tmRec</I>.  You must 
call this after you modify any field of the texture mapping palette 
entry to make sure the internal data in the entry is updated properly.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>tmRec</I></DT><DD>the texture mapping record to update</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewTextureMapping>mgNewTextureMapping</A>, <A HREF=#mgSetAttList>mgSetAttList</A></DD></DL>
<HR>
<LEFT><A NAME=mgValidAttach><H1 CLASS="APISYMBOL">mgValidAttach</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgValidAttach</B> - determines whether an attach operation would be valid.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgValidAttach</B> (</TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>parentCode</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgcode>mgcode</A></TD><TD><I>childCode</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgValidAttach</B> checks if a node or transformation record whose code is 
<I>childCode</I> could be attached to a node whose code is <I>parentCode</I> using one 
of <A HREF=#mgAttach>mgAttach</A>, <A HREF=#mgAppend>mgAppend</A> or <A HREF=#mgInsert>mgInsert</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>parentCode</I></DT><DD>the parent record code</DD><DT><I>childCode</I></DT><DD>the child record code</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if attach would be valid, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgAttach>mgAttach</A>, <A HREF=#mgAppend>mgAppend</A>, <A HREF=#mgInsert>mgInsert</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectordCross><H1 CLASS="APISYMBOL">mgVectordCross</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectordCross</B> - calculates the cross product of 
two vectors.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgvectord <B>mgVectordCross</B> (</TD><TD>const <A HREF=#mgvectord>mgvectord*</A></TD><TD><I>vector1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgvectord>mgvectord*</A></TD><TD><I>vector2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectordCross</B> calculates and returns a double precision 
vector record representing the cross product of the two vectors 
<I>vector1</I> x <I>vector2</I>.</P></DD><DD><P>The original vectors <I>vector1</I> and <I>vector2</I> are 
not affected.  The output vector is not unitized explicitly.</P></DD><DD><P>Note: For efficiency, <I>vector1</I> and <I>vector2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>vector1</I></DT><DD>address of first vector</DD><DT><I>vector2</I></DT><DD>address of second vector</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision vector record (<I>vector1</I> x <I>vector2</I>).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgVectordDot>mgVectordDot</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectordDot><H1 CLASS="APISYMBOL">mgVectordDot</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectordDot</B> - calculates the dot product of 
two vectors.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>double <B>mgVectordDot</B> (</TD><TD>const <A HREF=#mgvectord>mgvectord*</A></TD><TD><I>vector1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgvectord>mgvectord*</A></TD><TD><I>vector2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectordDot</B> calculates and returns the dot product of 
the two vectors <I>vector1</I> DOT <I>vector2</I>.</P></DD><DD><P>The original vectors <I>vector1</I> and <I>vector2</I> are not affected.</P></DD><DD><P>Note: For efficiency, <I>vector1</I> and <I>vector2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>vector1</I></DT><DD>address of first vector</DD><DT><I>vector2</I></DT><DD>address of second vector</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision floating point value (<I>vector1</I> DOT <I>vector2</I>).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgVectordCross>mgVectordCross</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectordEqual><H1 CLASS="APISYMBOL">mgVectordEqual</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectordEqual</B> - checks to see if two double precision 
vectors are exactly equal.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgVectordEqual</B> (</TD><TD>const <A HREF=#mgvectord>mgvectord*</A></TD><TD><I>vector1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgvectord>mgvectord*</A></TD><TD><I>vector2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><A HREF=#mgVectorfEqual>mgVectorfEqual</A> compares two double precision vectors, 
<I>vector1</I> and <I>vector2</I> to see if they are exactly equal.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>vector1</I></DT><DD>first vector to check for equality</DD><DT><I>vector2</I></DT><DD>second vector to check for equality</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if <I>vector1</I> and <I>vector2</I> are equal, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectord>mgvectord</A>, <A HREF=#mgVectordUnitize>mgVectordUnitize</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectordFromLine><H1 CLASS="APISYMBOL">mgVectordFromLine</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectordFromLine</B> - makes a vector from a line record.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgvectord <B>mgVectordFromLine</B> (</TD><TD>const <A HREF=#mglined>mglined*</A></TD><TD><I>line</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectordFromLine</B> returns a double precision vector record 
representing the vector from the first coordinate to the second coordinate 
of the specified line record, <I>line</I>.</P></DD><DD><P>The original line record <I>line</I> is not affected.  The resulting 
vector is not unitized.</P></DD><DD><P>Note: For efficiency, <I>line</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>line</I></DT><DD>line used to derive vector</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns double precision vector record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mglined>mglined</A>, <A HREF=#mgvectord>mgvectord</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectordLerp><H1 CLASS="APISYMBOL">mgVectordLerp</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectordLerp</B> - calculates the linear interpoloation between 
two vectors.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgvectord <B>mgVectordLerp</B> (</TD><TD>const <A HREF=#mgvectord>mgvectord*</A></TD><TD><I>vector1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgvectord>mgvectord*</A></TD><TD><I>vector2</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>amount</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectordLerp</B> calculates and returns the linear interpolation between 
two vectors <I>vector1</I> and <I>vector2</I>.  The <I>amount</I> parameter is the amount 
to interpolate between the two vectors where 0.0 is equal to <I>vector1</I>, 
0.1 is very near <I>vector1</I>, 0.5 is half-way in between, etc.</P></DD><DD><P>The original vectors <I>vector1</I> and <I>vector2</I> are not affected.</P></DD><DD><P>Note: For efficiency, <I>vector1</I> and <I>vector2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>vector1</I></DT><DD>address of first vector</DD><DT><I>vector2</I></DT><DD>address of second vector</DD><DT><I>amount</I></DT><DD>amount to interpolate between 
<I>vector1</I> and <I>vector2</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision vector record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectord>mgvectord</A>, <A HREF=#mgVectordDot>mgVectordDot</A>, <A HREF=#mgVectordCross>mgVectordCross</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectordNegate><H1 CLASS="APISYMBOL">mgVectordNegate</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectordNegate</B> - calculates vector multiplied by -1.0.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgvectord <B>mgVectordNegate</B> (</TD><TD>const <A HREF=#mgvectord>mgvectord*</A></TD><TD><I>vector</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectordNegate</B> calculates and returns the product of double 
precision floating point vector and -1.0.</P></DD><DD><P>The original vector <I>vector</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>vector</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>vector</I></DT><DD>address of vector</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision vector record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectord>mgvectord</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectordNegativeXAxis><H1 CLASS="APISYMBOL">mgVectordNegativeXAxis</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectordNegativeXAxis</B> - returns (-1.0, 0.0, 0.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgvectord <B>mgVectordNegativeXAxis</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectordNegativeXAxis</B> returns (-1.0, 0.0, 0.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (-1.0, 0.0, 0.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectord>mgvectord</A>, 
<A HREF=#mgVectordXAxis>mgVectordXAxis</A>, 
<A HREF=#mgVectordYAxis>mgVectordYAxis</A>, <A HREF=#mgVectordNegativeYAxis>mgVectordNegativeYAxis</A>, 
<A HREF=#mgVectordZAxis>mgVectordZAxis</A>, <A HREF=#mgVectordNegativeZAxis>mgVectordNegativeZAxis</A>, <A HREF=#mgVectordZero>mgVectordZero</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectordNegativeYAxis><H1 CLASS="APISYMBOL">mgVectordNegativeYAxis</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectordNegativeYAxis</B> - returns (0.0, -1.0, 0.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgvectord <B>mgVectordNegativeYAxis</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectordNegativeYAxis</B> returns (0.0, -1.0, 0.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (0.0, -1.0, 0.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectord>mgvectord</A>, 
<A HREF=#mgVectordXAxis>mgVectordXAxis</A>, <A HREF=#mgVectordNegativeXAxis>mgVectordNegativeXAxis</A>, 
<A HREF=#mgVectordYAxis>mgVectordYAxis</A>, 
<A HREF=#mgVectordZAxis>mgVectordZAxis</A>, <A HREF=#mgVectordNegativeZAxis>mgVectordNegativeZAxis</A>, <A HREF=#mgVectordZero>mgVectordZero</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectordNegativeZAxis><H1 CLASS="APISYMBOL">mgVectordNegativeZAxis</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectordNegativeZAxis</B> - returns (0.0, 0.0, -1.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgvectord <B>mgVectordNegativeZAxis</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectordNegativeZAxis</B> returns (0.0, 0.0, -1.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (0.0, 0.0, -1.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectord>mgvectord</A>, 
<A HREF=#mgVectordXAxis>mgVectordXAxis</A>, <A HREF=#mgVectordNegativeXAxis>mgVectordNegativeXAxis</A>, 
<A HREF=#mgVectordYAxis>mgVectordYAxis</A>, <A HREF=#mgVectordNegativeYAxis>mgVectordNegativeYAxis</A>, 
<A HREF=#mgVectordZAxis>mgVectordZAxis</A>, <A HREF=#mgVectordZero>mgVectordZero</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectordSetUnitized><H1 CLASS="APISYMBOL">mgVectordSetUnitized</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectordSetUnitized</B> - unitize a vector.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgVectordSetUnitized</B> (</TD><TD><A HREF=#mgvectord>mgvectord*</A></TD><TD><I>vec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectordSetUnitized</B> unitizes the specified double precision 
vector record <I>vec</I>.</P></DD><DD><P>This function changes the components of the vector <I>vec</I> passed 
directly.</P></DD><DD><P>Note: For efficiency, <I>vec</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>. 
If the magnitude of <I>vec</I> is less than 0.000000000001, it is set 
to (0,0,1).</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>vec</I></DT><DD>address of vector to unitize</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectord>mgvectord</A>, <A HREF=#mgVectordUnitize>mgVectordUnitize</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectordToCoord3d><H1 CLASS="APISYMBOL">mgVectordToCoord3d</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectordToCoord3d</B> - converts a double precision floating 
point vector to a 3D double precision floating point coordinate.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgcoord3d <B>mgVectordToCoord3d</B> (</TD><TD>const <A HREF=#mgvectord>mgvectord*</A></TD><TD><I>vec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectordToCoord3d</B> converts the specified double precision 
floating point vector <I>vec</I> to a 3D double precision floating point 
coordinate.</P></DD><DD><P>The original vector <I>vec</I> is not affected.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>vec</I></DT><DD>address of double precision vector to convert</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a 3D double precision floating point coordinate.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgVectorfToVectord>mgVectorfToVectord</A>, <A HREF=#mgVectordToVectorf>mgVectordToVectorf</A>, <A HREF=#mgCoord3dToVectord>mgCoord3dToVectord</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectordToVectorf><H1 CLASS="APISYMBOL">mgVectordToVectorf</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectordToVectorf</B> - converts a vector from double 
to single precision floating point.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgvectorf <B>mgVectordToVectorf</B> (</TD><TD>const <A HREF=#mgvectord>mgvectord*</A></TD><TD><I>vec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectordToVectorf</B> converts the specified double precision 
floating point vector <I>vec</I> to a single precision floating point vector.</P></DD><DD><P>The original vector <I>vec</I> is not affected.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>vec</I></DT><DD>address of double precision vector to convert</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns single precision vector record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgVectorfToVectord>mgVectorfToVectord</A>, <A HREF=#mgVectordToCoord3d>mgVectordToCoord3d</A>, <A HREF=#mgCoord3dToVectord>mgCoord3dToVectord</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectordTransform><H1 CLASS="APISYMBOL">mgVectordTransform</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectordTransform</B> - transforms a double precision 
vector using a specified matrix.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgvectord <B>mgVectordTransform</B> (</TD><TD>const <A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgvectord>mgvectord*</A></TD><TD><I>vec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectordTransform</B> applies the specified <I>matrix</I> to the 
specified double precision floating point vector <I>vec</I> and 
returns the resulting vector.</P></DD><DD><P>The original vector <I>vec</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>matrix</I> and <I>vec</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to apply to <I>vec</I></DD><DT><I>vec</I></DT><DD>vector to transform</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the transformed double precision vector record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectord>mgvectord</A>, <A HREF=#mgmatrix>mgmatrix</A>, <A HREF=#mgVectorfTransform>mgVectorfTransform</A>, 
<A HREF=#mgCoord3dTransform>mgCoord3dTransform</A>, <A HREF=#mgCoord3fTransform>mgCoord3fTransform</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectordUnitize><H1 CLASS="APISYMBOL">mgVectordUnitize</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectordUnitize</B> - calculates vector coordinates scaled 
uniformly to have a length of 1.0.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgvectord <B>mgVectordUnitize</B> (</TD><TD>const <A HREF=#mgvectord>mgvectord*</A></TD><TD><I>vec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectordUnitize</B> calculates and returns double precision vector 
coordinates scaled uniformly to have a length of 1.0.</P></DD><DD><P>The original vector <I>vec</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>vec</I> is not verified 
before being dereferenced. You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>vec</I></DT><DD>vector to unitize</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a double precision vector record. 
If the magnitude of <I>vec</I> is less than 0.000000000001, this 
function returns (0,0,1).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectord>mgvectord</A>, <A HREF=#mgVectordSetUnitized>mgVectordSetUnitized</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectordXAxis><H1 CLASS="APISYMBOL">mgVectordXAxis</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectordXAxis</B> - returns (1.0, 0.0, 0.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgvectord <B>mgVectordXAxis</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectordXAxis</B> returns (1.0, 0.0, 0.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (1.0, 0.0, 0.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectord>mgvectord</A>, 
<A HREF=#mgVectordYAxis>mgVectordYAxis</A>, <A HREF=#mgVectordNegativeYAxis>mgVectordNegativeYAxis</A>, 
<A HREF=#mgVectordZAxis>mgVectordZAxis</A>, <A HREF=#mgVectordNegativeZAxis>mgVectordNegativeZAxis</A>, <A HREF=#mgVectordZero>mgVectordZero</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectordYAxis><H1 CLASS="APISYMBOL">mgVectordYAxis</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectordYAxis</B> - returns (0.0, 1.0, 0.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgvectord <B>mgVectordYAxis</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectordYAxis</B> returns (0.0, 1.0, 0.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (0.0, 1.0, 0.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectord>mgvectord</A>, 
<A HREF=#mgVectordXAxis>mgVectordXAxis</A>, <A HREF=#mgVectordNegativeXAxis>mgVectordNegativeXAxis</A>, 
<A HREF=#mgVectordNegativeYAxis>mgVectordNegativeYAxis</A>, 
<A HREF=#mgVectordZAxis>mgVectordZAxis</A>, <A HREF=#mgCoord3dNegativeZAxis>mgCoord3dNegativeZAxis</A>, <A HREF=#mgVectordZero>mgVectordZero</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectordZAxis><H1 CLASS="APISYMBOL">mgVectordZAxis</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectordZAxis</B> - returns (0.0, 0.0, 1.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgvectord <B>mgVectordZAxis</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectordZAxis</B> returns (0.0, 0.0, 1.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (0.0, 0.0, 1.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectord>mgvectord</A>, 
<A HREF=#mgVectordXAxis>mgVectordXAxis</A>, <A HREF=#mgVectordNegativeXAxis>mgVectordNegativeXAxis</A>, 
<A HREF=#mgVectordYAxis>mgVectordYAxis</A>, <A HREF=#mgVectordNegativeYAxis>mgVectordNegativeYAxis</A>, 
<A HREF=#mgVectordNegativeZAxis>mgVectordNegativeZAxis</A>, <A HREF=#mgVectordZero>mgVectordZero</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectordZero><H1 CLASS="APISYMBOL">mgVectordZero</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectordZero</B> - returns (0.0, 0.0, 0.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgvectord <B>mgVectordZero</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectordZero</B> returns (0.0, 0.0, 0.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (0.0, 0.0, 0.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectord>mgvectord</A>, 
<A HREF=#mgVectordXAxis>mgVectordXAxis</A>, <A HREF=#mgVectordYAxis>mgVectordYAxis</A>, <A HREF=#mgVectordNegativeYAxis>mgVectordNegativeYAxis</A>, 
<A HREF=#mgVectordZAxis>mgVectordZAxis</A>, <A HREF=#mgVectordNegativeZAxis>mgVectordNegativeZAxis</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectorfCross><H1 CLASS="APISYMBOL">mgVectorfCross</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectorfCross</B> - calculates the cross product of 
two vectors.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgvectorf <B>mgVectorfCross</B> (</TD><TD>const <A HREF=#mgvectorf>mgvectorf*</A></TD><TD><I>vector1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgvectorf>mgvectorf*</A></TD><TD><I>vector2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectorfCross</B> calculates and returns a double precision 
vector record representing the cross product of the two vectors 
<I>vector1</I> x <I>vector2</I>.</P></DD><DD><P>The original vectors <I>vector1</I> and <I>vector2</I> are 
not affected.  The output vector is not unitized explicitly.</P></DD><DD><P>Note: For efficiency, <I>vector1</I> and <I>vector2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>vector1</I></DT><DD>address of first vector</DD><DT><I>vector2</I></DT><DD>address of second vector</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a single precision vector record (<I>vector1</I> x <I>vector2</I>).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgVectorfDot>mgVectorfDot</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectorfDot><H1 CLASS="APISYMBOL">mgVectorfDot</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectorfDot</B> - calculates the dot product of 
two vectors.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>float <B>mgVectorfDot</B> (</TD><TD>const <A HREF=#mgvectorf>mgvectorf*</A></TD><TD><I>vector1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgvectorf>mgvectorf*</A></TD><TD><I>vector2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectorfDot</B> calculates and returns the dot product of 
the two vectors <I>vector1</I> DOT <I>vector2</I>.</P></DD><DD><P>The original vectors <I>vector1</I> and <I>vector2</I> are not affected.</P></DD><DD><P>Note: For efficiency, <I>vector1</I> and <I>vector2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>vector1</I></DT><DD>address of first vector</DD><DT><I>vector2</I></DT><DD>address of second vector</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a single precision floating point value (<I>vector1</I> DOT <I>vector2</I>).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgVectorfCross>mgVectorfCross</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectorfEqual><H1 CLASS="APISYMBOL">mgVectorfEqual</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectorfEqual</B> - checks to see if two single precision 
vectors are exactly equal.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgVectorfEqual</B> (</TD><TD>const <A HREF=#mgvectorf>mgvectorf*</A></TD><TD><I>vector1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgvectorf>mgvectorf*</A></TD><TD><I>vector2</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectorfEqual</B> compares two single precision vectors, 
<I>vector1</I> and <I>vector2</I> to see if they are exactly equal.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>vector1</I></DT><DD>first vector to check for equality</DD><DT><I>vector2</I></DT><DD>second vector to check for equality</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if <I>vector1</I> and <I>vector2</I> are equal, 
<A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectorf>mgvectorf</A>, <A HREF=#mgVectorfUnitize>mgVectorfUnitize</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectorfLerp><H1 CLASS="APISYMBOL">mgVectorfLerp</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectorfLerp</B> - calculates the linear interpoloation between 
two vectors.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgvectorf <B>mgVectorfLerp</B> (</TD><TD>const <A HREF=#mgvectorf>mgvectorf*</A></TD><TD><I>vector1</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgvectorf>mgvectorf*</A></TD><TD><I>vector2</I>,</TD></TR>
<TR><TD></TD><TD>double</TD><TD><I>amount</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectorfLerp</B> calculates and returns the linear interpolation between 
two vectors <I>vector1</I> and <I>vector2</I>.  The <I>amount</I> parameter is the amount 
to interpolate between the two vectors where 0.0 is equal to <I>vector1</I>, 
0.1 is very near <I>vector1</I>, 0.5 is half-way in between, etc.</P></DD><DD><P>The original vectors <I>vector1</I> and <I>vector2</I> are not affected.</P></DD><DD><P>Note: For efficiency, <I>vector1</I> and <I>vector2</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>vector1</I></DT><DD>address of first vector</DD><DT><I>vector2</I></DT><DD>address of second vector</DD><DT><I>amount</I></DT><DD>amount to interpolate between 
<I>vector1</I> and <I>vector2</I></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a single precision vector record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectorf>mgvectorf</A>, <A HREF=#mgVectorfDot>mgVectorfDot</A>, <A HREF=#mgVectorfCross>mgVectorfCross</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectorfNegate><H1 CLASS="APISYMBOL">mgVectorfNegate</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectorfNegate</B> - calculates vector multiplied by -1.0.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgvectorf <B>mgVectorfNegate</B> (</TD><TD>const <A HREF=#mgvectorf>mgvectorf*</A></TD><TD><I>vector</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectorfNegate</B> calculates and returns the product of double 
precision floating point vector and -1.0.</P></DD><DD><P>The original vector <I>vector</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>vector</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>vector</I></DT><DD>address of vector</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a single precision vector record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectorf>mgvectorf</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectorfNegativeXAxis><H1 CLASS="APISYMBOL">mgVectorfNegativeXAxis</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectorfNegativeXAxis</B> - returns (-1.0, 0.0, 0.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgvectorf <B>mgVectorfNegativeXAxis</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectorfNegativeXAxis</B> returns (-1.0, 0.0, 0.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (-1.0, 0.0, 0.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectorf>mgvectorf</A>, 
<A HREF=#mgVectorfXAxis>mgVectorfXAxis</A>, 
<A HREF=#mgVectorfYAxis>mgVectorfYAxis</A>, <A HREF=#mgVectorfNegativeYAxis>mgVectorfNegativeYAxis</A>, 
<A HREF=#mgVectorfZAxis>mgVectorfZAxis</A>, <A HREF=#mgVectorfNegativeZAxis>mgVectorfNegativeZAxis</A>, <A HREF=#mgVectorfZero>mgVectorfZero</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectorfNegativeYAxis><H1 CLASS="APISYMBOL">mgVectorfNegativeYAxis</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectorfNegativeYAxis</B> - returns (0.0, -1.0, 0.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgvectorf <B>mgVectorfNegativeYAxis</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectorfNegativeYAxis</B> returns (0.0, -1.0, 0.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (0.0, -1.0, 0.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectorf>mgvectorf</A>, 
<A HREF=#mgVectorfXAxis>mgVectorfXAxis</A>, <A HREF=#mgVectorfNegativeXAxis>mgVectorfNegativeXAxis</A>, 
<A HREF=#mgVectorfYAxis>mgVectorfYAxis</A>, 
<A HREF=#mgVectorfZAxis>mgVectorfZAxis</A>, <A HREF=#mgVectorfNegativeZAxis>mgVectorfNegativeZAxis</A>, <A HREF=#mgVectorfZero>mgVectorfZero</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectorfNegativeZAxis><H1 CLASS="APISYMBOL">mgVectorfNegativeZAxis</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectorfNegativeZAxis</B> - returns (0.0, 0.0, -1.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgvectorf <B>mgVectorfNegativeZAxis</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectorfNegativeZAxis</B> returns (0.0, 0.0, -1.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (0.0, 0.0, -1.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectorf>mgvectorf</A>, 
<A HREF=#mgVectorfXAxis>mgVectorfXAxis</A>, <A HREF=#mgVectorfNegativeXAxis>mgVectorfNegativeXAxis</A>, 
<A HREF=#mgVectorfYAxis>mgVectorfYAxis</A>, <A HREF=#mgVectorfNegativeYAxis>mgVectorfNegativeYAxis</A>, 
<A HREF=#mgVectorfZAxis>mgVectorfZAxis</A>, <A HREF=#mgVectorfZero>mgVectorfZero</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectorfSetUnitized><H1 CLASS="APISYMBOL">mgVectorfSetUnitized</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectorfSetUnitized</B> - unitize a vector.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>void <B>mgVectorfSetUnitized</B> (</TD><TD><A HREF=#mgvectorf>mgvectorf*</A></TD><TD><I>vec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectorfSetUnitized</B> unitizes the specified single precision 
vector record <I>vec</I>.</P></DD><DD><P>This function changes the components of the vector <I>vec</I> passed 
directly.</P></DD><DD><P>Note: For efficiency, <I>vec</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>vec</I></DT><DD>address of vector to unitize</DD></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectorf>mgvectorf</A>, <A HREF=#mgVectorfUnitize>mgVectorfUnitize</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectorfToVectord><H1 CLASS="APISYMBOL">mgVectorfToVectord</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectorfToVectord</B> - converts a vector from single 
to double precision floating point.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION &nbsp; &nbsp; &nbsp; (Not Available For Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgvectord <B>mgVectorfToVectord</B> (</TD><TD>const <A HREF=#mgvectorf>mgvectorf*</A></TD><TD><I>vec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectorfToVectord</B> converts the specified singe precision 
floating point vector <I>vec</I> to a double precision floating point vector.</P></DD><DD><P>The original vector <I>vec</I> is not affected.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>vec</I></DT><DD>address of single precision vector to convert</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns double precision vector record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgVectordToVectorf>mgVectordToVectorf</A>, <A HREF=#mgVectordToCoord3d>mgVectordToCoord3d</A>, <A HREF=#mgCoord3dToVectord>mgCoord3dToVectord</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectorfTransform><H1 CLASS="APISYMBOL">mgVectorfTransform</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectorfTransform</B> - transforms a single precision 
vector using a specified matrix.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgvectorf <B>mgVectorfTransform</B> (</TD><TD>const <A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>matrix</I>,</TD></TR>
<TR><TD></TD><TD>const <A HREF=#mgvectorf>mgvectorf*</A></TD><TD><I>vec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectorfTransform</B> applies the specified <I>matrix</I> to the 
specified single precision floating point vector <I>vec</I> and 
returns the resulting vector.</P></DD><DD><P>The original vector <I>vec</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>matrix</I> and <I>vec</I> are not verified 
before being dereferenced.  You must not pass either of these as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>matrix</I></DT><DD>matrix to apply to <I>vec</I></DD><DT><I>vec</I></DT><DD>vector to transform</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns the transformed single precision vector record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectord>mgvectord</A>, <A HREF=#mgmatrix>mgmatrix</A>, <A HREF=#mgVectordTransform>mgVectordTransform</A>, 
<A HREF=#mgCoord3dTransform>mgCoord3dTransform</A>, <A HREF=#mgCoord3fTransform>mgCoord3fTransform</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectorfUnitize><H1 CLASS="APISYMBOL">mgVectorfUnitize</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectorfUnitize</B> - calculates vector coordinates scaled 
uniformly to have a length of 1.0.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgvectorf <B>mgVectorfUnitize</B> (</TD><TD>const <A HREF=#mgvectorf>mgvectorf*</A></TD><TD><I>vec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><A HREF=#mgVectordUnitize>mgVectordUnitize</A> calculates and returns single precision vector 
coordinates scaled uniformly to have a length of 1.0.</P></DD><DD><P>The original vector <I>vec</I> is not affected.</P></DD><DD><P>Note: For efficiency, <I>vec</I> is not verified 
before being dereferenced.  You must not pass as <A HREF=#MG_NULL>MG_NULL</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>vec</I></DT><DD>vector to unitize</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns a single precision vector record.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectorf>mgvectorf</A>, <A HREF=#mgVectorfSetUnitized>mgVectorfSetUnitized</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectorfXAxis><H1 CLASS="APISYMBOL">mgVectorfXAxis</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectorfXAxis</B> - returns (1.0, 0.0, 0.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgvectorf <B>mgVectorfXAxis</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectorfXAxis</B> returns (1.0, 0.0, 0.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (1.0, 0.0, 0.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectorf>mgvectorf</A>, 
<A HREF=#mgVectorfYAxis>mgVectorfYAxis</A>, <A HREF=#mgVectorfNegativeYAxis>mgVectorfNegativeYAxis</A>, 
<A HREF=#mgVectorfZAxis>mgVectorfZAxis</A>, <A HREF=#mgVectorfNegativeZAxis>mgVectorfNegativeZAxis</A>, <A HREF=#mgVectorfZero>mgVectorfZero</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectorfYAxis><H1 CLASS="APISYMBOL">mgVectorfYAxis</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectorfYAxis</B> - returns (0.0, 1.0, 0.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgvectorf <B>mgVectorfYAxis</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectorfYAxis</B> returns (0.0, 1.0, 0.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (0.0, 1.0, 0.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectorf>mgvectorf</A>, 
<A HREF=#mgVectorfXAxis>mgVectorfXAxis</A>, <A HREF=#mgVectorfNegativeXAxis>mgVectorfNegativeXAxis</A>, 
<A HREF=#mgVectorfNegativeYAxis>mgVectorfNegativeYAxis</A>, 
<A HREF=#mgVectorfZAxis>mgVectorfZAxis</A>, <A HREF=#mgCoord3dNegativeZAxis>mgCoord3dNegativeZAxis</A>, <A HREF=#mgVectorfZero>mgVectorfZero</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectorfZAxis><H1 CLASS="APISYMBOL">mgVectorfZAxis</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectorfZAxis</B> - returns (0.0, 0.0, 1.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgvectorf <B>mgVectorfZAxis</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectorfZAxis</B> returns (0.0, 0.0, 1.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (0.0, 0.0, 1.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectorf>mgvectorf</A>, 
<A HREF=#mgVectorfXAxis>mgVectorfXAxis</A>, <A HREF=#mgVectorfNegativeXAxis>mgVectorfNegativeXAxis</A>, 
<A HREF=#mgVectorfYAxis>mgVectorfYAxis</A>, <A HREF=#mgVectorfNegativeYAxis>mgVectorfNegativeYAxis</A>, 
<A HREF=#mgVectorfNegativeZAxis>mgVectorfNegativeZAxis</A>, <A HREF=#mgVectorfZero>mgVectorfZero</A></DD></DL>
<HR>
<LEFT><A NAME=mgVectorfZero><H1 CLASS="APISYMBOL">mgVectorfZero</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgVectorfZero</B> - returns (0.0, 0.0, 0.0).<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD> mgvectorf <B>mgVectorfZero</B> ( void ) </DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgVectorfZero</B> returns (0.0, 0.0, 0.0).</P></DD></DT></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns (0.0, 0.0, 0.0).
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectorf>mgvectorf</A>, 
<A HREF=#mgVectorfXAxis>mgVectorfXAxis</A>, <A HREF=#mgVectorfYAxis>mgVectorfYAxis</A>, <A HREF=#mgVectorfNegativeYAxis>mgVectorfNegativeYAxis</A>, 
<A HREF=#mgVectorfZAxis>mgVectorfZAxis</A>, <A HREF=#mgVectorfNegativeZAxis>mgVectorfNegativeZAxis</A></DD></DL>
<HR>
<LEFT><A NAME=mgWalk><H1 CLASS="APISYMBOL">mgWalk</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgWalk</B> - walks a node hierarchy and performs an action at each node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgWalk</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>node</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgwalkfunc>mgwalkfunc</A></TD><TD><I>preAction</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgwalkfunc>mgwalkfunc</A></TD><TD><I>postAction</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>flags</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgWalk</B> traverses from any <I>node</I> down the hierarchy and visits the 
nodes within the tree using a depth-first traversal.  The diagram below shows the 
order in which the nodes in a simple hierarchy below <I>db</I> would be visited.<BR> 
<IMG SRC="../common/mgwalkorder.jpg">
</P></DD><DD><P>The types of nodes visited are based 
on traversal modifiers specified in <I>flags</I>.  The <I>flags</I> parameter is a bitwise 
combination of the following:</P></DD><DD><P><A HREF=#MWALK_NEXT>MWALK_NEXT</A> - Setting this mask causes the walk to visit siblings of the 
top node being walked as well as the children of these siblings.<BR> 
By default, siblings of the top node being walked are not visited.</P></DD><DD><P><A HREF=#MWALK_VERTEX>MWALK_VERTEX</A> - Setting this mask causes the walk to visit vertex nodes. 
Note that the mask <A HREF=#MWALK_ON>MWALK_ON</A> does not affect whether a vertex node is visited 
because vertex nodes are always <B>On</B>.<BR> 
By default, vertex nodes are not visited.</P></DD><DD><P><A HREF=#MWALK_MASTER>MWALK_MASTER</A> - Setting this mask causes the walk to visit referenced nodes. 
If you set this mask without setting <A HREF=#MWALK_MASTERALL>MWALK_MASTERALL</A>, referenced nodes will only 
be visited one time no matter how many times they are referenced in the database. 
Set <A HREF=#MWALK_MASTERALL>MWALK_MASTERALL</A> to visit referenced nodes once each time they are referenced.<BR> 
By default, referenced nodes are not visited.</P></DD><DD><P><A HREF=#MWALK_MASTERALL>MWALK_MASTERALL</A> - Setting this mask causes the walk 
to visit referenced nodes once each time they are referenced.<BR> 
By default, referenced nodes are not visited.</P></DD><DD><P><A HREF=#MWALK_ON>MWALK_ON</A> - Setting this mask causes the walk to visit only nodes that are 
currently <B>On</B>.  Nodes are <B>Off</B> if they are not part of the current level of 
detail or if they have been explicitly "toggled off" by the modeler.<BR> 
By default, all nodes are visited whether they are <B>On</B> or <B>Off</B>.</P></DD><DD><P><A HREF=#MWALK_NOREADONLY>MWALK_NOREADONLY</A> - Setting this mask causes the walk 
to not visit read-only nodes (external nodes, for example).<BR> 
By default, read-only nodes are visited.</P></DD><DD><P><A HREF=#MWALK_NONESTED>MWALK_NONESTED</A> - Setting this mask causes the walk 
to not visit nested nodes (subfaces, for example).<BR> 
By default, nested nodes are visited.</P></DD><DD><P><A HREF=#MWALK_MATRIXSTACK>MWALK_MATRIXSTACK</A> - Setting this mask causes the walk to accumulate a 
matrix stack while visiting the nodes. This matrix stack can be accessed during 
either of the walk actions functions to return the using the function 
<A HREF=#mgWalkGetMatrix>mgWalkGetMatrix</A>.<BR> 
By default, no matrix stack is accumulated.</P></DD><DD><P>At each node visited, two user-provided 
functions (<I>preAction</I> and <I>postAction</I>) are invoked to perform necessary 
tasks.  The <I>preAction</I> function is invoked before the node's children are 
traversed, and <I>postAction</I> is invoked after the node's children have been 
traversed. As an option, the traversal can be terminated by either the 
<I>preAction</I> or <I>postAction</I> function returning <A HREF=#mgbool>MG_FALSE</A>. Note, 
however that returning <A HREF=#mgbool>MG_FALSE</A> in your <I>postAction</I> function 
will not stop nodes below the current node from being visited because by 
the time the <I>postAction</I> function is called for any node, that node&#146s children 
have already been visited.  Returning <A HREF=#mgbool>MG_FALSE</A> in your <I>preAction</I> 
function, however, will stop nodes below the current node from being visited.</P></DD><DD><P>Specifying <A HREF=#MG_NULL>MG_NULL</A> for either <I>preAction</I> or <I>postAction</I> is valid. 
If either function is not specified in this way, that action function is simply 
skipped during the walk.</P></DD><DD><P>In general you should not change the hierarchy of the <I>node</I> being traversed 
(or any of its descendants) in your <I>preAction</I> or <I>postAction</I> function. If you 
do change the hierarchy during the <B>mgWalk</B>, be aware that you may change the 
behavior of the <B>mgWalk</B> and may get unexpected results.  Here are some things 
to note if you do change the hierarchy during the <B>mgWalk</B>:<P>
<UL>
<P>
<LI CLASS="NOINDENT">
 
You can safely delete (<A HREF=#mgDelete>mgDelete</A>) the node currently being visited in the <I>postAction</I> function. 
</LI>
<P>
<LI CLASS="NOINDENT">
 
If you delete (<A HREF=#mgDelete>mgDelete</A>) the node currently being visited in the <I>preAction</I> function, its 
descendants will not be visited. 
</LI>
<P>
<LI CLASS="NOINDENT">
 
If you attach (<A HREF=#mgAttach>mgAttach</A> or <A HREF=#mgAppend>mgAppend</A>) nodes below the node currently being visited in the 
<I>postAction</I> function, the new nodes will not be visited. 
</LI>
<P>
<LI CLASS="NOINDENT">
 
If you attach (<A HREF=#mgAttach>mgAttach</A> or <A HREF=#mgAppend>mgAppend</A>) nodes below the node currently being visited in the 
<I>preAction</I> function, the <B>mgWalk</B> behavior is undefined. 
</LI>
<P>
<LI CLASS="NOINDENT">
 
If you attach (<A HREF=#mgInsert>mgInsert</A>) nodes immediately after the node currently being visited in the 
<I>preAction</I> or <I>postAction</I> function, the new nodes will not be visited. 
</LI>
<P>
</UL>
</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>node</I></DT><DD>the starting node of the traversal</DD><DT><I>preAction</I></DT><DD>the function that is invoked 
before any of the node's children have been visited</DD><DT><I>postAction</I></DT><DD>the function that is invoked 
after all the node's children have been visited</DD><DT><I>userData</I></DT><DD>pointer to user defined data that will be passed 
to <I>preAction</I> and <I>postAction</I> callback functions</DD><DT><I>flags</I></DT><DD>traversal modifiers that allow you to select 
certain types of nodes for visiting. 
This parameter is the bitwise combination of the following masks:<BR> 
<A HREF=#MWALK_NEXT>MWALK_NEXT</A><BR> <A HREF=#MWALK_VERTEX>MWALK_VERTEX</A><BR> <A HREF=#MWALK_MASTER>MWALK_MASTER</A><BR> 
<A HREF=#MWALK_MASTERALL>MWALK_MASTERALL</A><BR> <A HREF=#MWALK_ON>MWALK_ON</A><BR> <A HREF=#MWALK_NOREADONLY>MWALK_NOREADONLY</A><BR> 
<A HREF=#MWALK_NONESTED>MWALK_NONESTED</A><BR> <A HREF=#MWALK_MATRIXSTACK>MWALK_MATRIXSTACK</A></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if traversal successful, <A HREF=#mgbool>MG_FALSE</A> if 
traversal unsuccessful or if terminated by one of the action functions.
</DD></DL><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) traverse the hierarchy <I>db</I> 
and print out the name of each node as they are visited.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">static mgbool PreWalkFunc (mgrec* db, mgrec* parent, mgrec* rec, void* userData)
{
   char* name = mgGetName (rec);
   int* numNodesOnH = (int*) userData;
   // only count the nodes in the pre-walk func, it you count in post-walk, you
   // would count each node twice
   *numNodesOnH = *numNodesOnH + 1;
   printf ("PreWalkFunc : %s&#92;n", name);
   mgFree (name);
   return (MG_TRUE);
}
static mgbool PostWalkFunc (mgrec* db, mgrec* parent, mgrec* rec, void* userData)
{
   char* name = mgGetName (rec);
   printf ("PostWalkFunc: %s&#92;n", name);
   mgFree (name);
   return (MG_TRUE);
}

int numNodesOn = 0;
// visit all the nodes that are "ON" under db
mgWalk (db, PreWalkFunc, PostWalkFunc, &numNodesOn, MWALK_ON);
printf ("Number of nodes: %d&#92;n", numNodesOn);</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">class numNodesOn:
   pass

def PreWalkFunc (db, parent, rec, i):
   print "PreWalkFunc :",mgGetName(rec)
   i.count = i.count + 1
   return MG_TRUE

def PostWalkFunc (db, parent, rec, i):
   print "PostWalkFunc:",mgGetName(rec)
   return MG_TRUE

db = mgGetCurrentDb ()
i = numNodesOn()
i.count = 0

mgWalk (db, PreWalkFunc, PostWalkFunc, i, MWALK_ON)
print "Number of nodes:",i.count</PRE></DT></DL></DD></DL>
<DL><DT><H3>EXAMPLE OUTPUT</H3></DT><DD><DL><DT>The following is the output produced by these examples run 
on the hierarchy shown in the diagram above.  This output shows you 
the order in which the <I>preAction</I> or <I>postAction</I> are called 
in the context of the depth-first traversal on <I>db</I>.</DT><DT><PRE CLASS="EXAMPLE">PreWalkFunc : db 
PreWalkFunc : g1 
PreWalkFunc : g2 
PreWalkFunc : o7 
PreWalkFunc : p6 
PostWalkFunc: p6 
PreWalkFunc : p5 
PostWalkFunc: p5 
PreWalkFunc : p4 
PostWalkFunc: p4 
PostWalkFunc: o7 
PreWalkFunc : o11 
PreWalkFunc : p24 
PostWalkFunc: p24 
PreWalkFunc : p8 
PostWalkFunc: p8 
PostWalkFunc: o11 
PostWalkFunc: g2 
PostWalkFunc: g1 
PostWalkFunc: db 
Number of nodes: 10</PRE></DT></DL></DD></DL>


<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWalkEx>mgWalkEx</A>, <A HREF=#mgWalkRecList>mgWalkRecList</A>, <A HREF=#mgWalkGetMatrix>mgWalkGetMatrix</A>, <A HREF=#mgGetNext>mgGetNext</A>, <A HREF=#mgGetPrevious>mgGetPrevious</A>, 
<A HREF=#mgGetParent>mgGetParent</A>, <A HREF=#mgGetChild>mgGetChild</A>, 
<A HREF=#mgGetNestedParent>mgGetNestedParent</A>, <A HREF=#mgGetNestedChild>mgGetNestedChild</A>, <A HREF=#mgGetReference>mgGetReference</A>, 
<A HREF=#mgGetChildNth>mgGetChildNth</A>, <A HREF=#mgGetAttrChild>mgGetAttrChild</A>, 
<A HREF=#mgFind>mgFind</A>, <A HREF=#mgFindEx>mgFindEx</A></DD></DL>
<HR>
<LEFT><A NAME=mgWalkEx><H1 CLASS="APISYMBOL">mgWalkEx</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgWalkEx</B> - walks a node hierarchy and performs an action at each node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgWalkEx</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>node</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgmatrix>mgmatrix</A></TD><TD><I>startMatrix</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgwalkfunc>mgwalkfunc</A></TD><TD><I>preAction</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgwalkfunc>mgwalkfunc</A></TD><TD><I>postAction</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>flags</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgWalkEx</B> performs the same function as <A HREF=#mgWalk>mgWalk</A>, but in addition, it allows you 
to specify a starting matrix, <I>startMatrix</I>, to use when accumulating a matrix stack during 
the traversal.</P></DD><DD><P>Note: If <I>flags</I> does not specify <A HREF=#MWALK_MATRIXSTACK>MWALK_MATRIXSTACK</A>, <I>startMatrix</I> is ignored 
and no matrix stack is accumulated during traversal.</P></DD><DD><P>For more information on <B>mgWalkEx</B>, see <A HREF=#mgWalk>mgWalk</A>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>node</I></DT><DD>the starting node of the traversal</DD><DT><I>startMatrix</I></DT><DD>the starting matrix to use when accumulating a matrix 
stack during the traversal - ignored if <A HREF=#MWALK_MATRIXSTACK>MWALK_MATRIXSTACK</A> 
is not specified in <I>flags</I></DD><DT><I>preAction</I></DT><DD>the function that is invoked 
before any of the node's children have been visited</DD><DT><I>postAction</I></DT><DD>the function that is invoked 
after all the node's children have been visited</DD><DT><I>userData</I></DT><DD>pointer to user defined data that will be passed to 
<I>preAction</I> and <I>postAction</I> callback functions</DD><DT><I>flags</I></DT><DD>traversal modifiers that allow you to select 
certain types of nodes for visiting. 
This parameter is the bitwise combination of the following masks:<BR> 
<A HREF=#MWALK_NEXT>MWALK_NEXT</A><BR> <A HREF=#MWALK_VERTEX>MWALK_VERTEX</A><BR> <A HREF=#MWALK_MASTER>MWALK_MASTER</A><BR> 
<A HREF=#MWALK_MASTERALL>MWALK_MASTERALL</A><BR> <A HREF=#MWALK_ON>MWALK_ON</A><BR> <A HREF=#MWALK_NOREADONLY>MWALK_NOREADONLY</A><BR> 
<A HREF=#MWALK_NONESTED>MWALK_NONESTED</A><BR> <A HREF=#MWALK_MATRIXSTACK>MWALK_MATRIXSTACK</A></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if traversal successful, <A HREF=#mgbool>MG_FALSE</A> if 
traversal unsuccessful or if terminated by one of the action functions.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkRecList>mgWalkRecList</A>, <A HREF=#mgWalkGetMatrix>mgWalkGetMatrix</A>, <A HREF=#mgGetNext>mgGetNext</A>, <A HREF=#mgGetPrevious>mgGetPrevious</A>, 
<A HREF=#mgGetParent>mgGetParent</A>, <A HREF=#mgGetChild>mgGetChild</A>, <A HREF=#mgGetNestedParent>mgGetNestedParent</A>, <A HREF=#mgGetNestedChild>mgGetNestedChild</A>, 
<A HREF=#mgGetReference>mgGetReference</A>, <A HREF=#mgGetChildNth>mgGetChildNth</A>, <A HREF=#mgGetAttrChild>mgGetAttrChild</A>, 
<A HREF=#mgFind>mgFind</A>, <A HREF=#mgFindEx>mgFindEx</A>, <A HREF=#mgIterateRecList>mgIterateRecList</A></DD></DL>
<HR>
<LEFT><A NAME=mgwalkfunc><H1 CLASS="APISYMBOL">mgwalkfunc</H1></A></LEFT>
<DL>
<DT><H3>CALLBACK NAME</H3></DT>
<DD><B>mgwalkfunc</B> - Walk/Find callback function<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool (*<B>mgwalkfunc</B>) ( <TD><A HREF=#mgrec>mgrec*</A> <TD><I>db</I>, 
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A> <TD><I>parent</I>, 
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A> <TD><I>rec</I>, 
<TR><TD></TD><TD>void* <TD><I>userData</I> );</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the signature for walk/find callback functions.</P></DD><DD><P>When you call <A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A> or <A HREF=#mgWalkRecList>mgWalkRecList</A>, you 
specify a pre-visit and/or a post-visit function of this form. 
These functions are called before and after a node is visited, 
respectively.</P></DD><DD><P>When you call <A HREF=#mgFind>mgFind</A> or <A HREF=#mgFindEx>mgFindEx</A>, you specify a 
match function of this form.</P></DD><DD><P>When you call <A HREF=#mgIterateRecList>mgIterateRecList</A>, you specify an iterate 
function of this form.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database containing the node being visited</DD><DT><I>parent</I></DT><DD>the parent of the node being visited (<A HREF=#MG_NULL>MG_NULL</A> if <I>rec</I> is <I>db</I>)</DD><DT><I>rec</I></DT><DD>the node currently being visited</DD><DT><I>userData</I></DT><DD>user defined data specified in call to <A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, 
<A HREF=#mgFind>mgFind</A>, <A HREF=#mgFindEx>mgFindEx</A>, <A HREF=#mgWalkRecList>mgWalkRecList</A>, <A HREF=#mgIterateRecList>mgIterateRecList</A></DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>When used for <A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A> or <A HREF=#mgWalkRecList>mgWalkRecList</A>, return 
<A HREF=#mgbool>MG_TRUE</A> to continue traversal, <A HREF=#mgbool>MG_FALSE</A> to terminate.<BR> 
When used for <A HREF=#mgFind>mgFind</A> or <A HREF=#mgFindEx>mgFindEx</A>, return 
<A HREF=#mgbool>MG_TRUE</A> to add the node to the record list returned, 
<A HREF=#mgbool>MG_FALSE</A> otherwise. 
When used for <A HREF=#mgIterateRecList>mgIterateRecList</A>, return 
<A HREF=#mgbool>MG_TRUE</A> to continue iteration of the record list, 
<A HREF=#mgbool>MG_FALSE</A> to terminate.
</DD></DL><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, <A HREF=#mgWalkRecList>mgWalkRecList</A>, <A HREF=#mgFind>mgFind</A>, <A HREF=#mgFindEx>mgFindEx</A>, 
<A HREF=#mgIterateRecList>mgIterateRecList</A></DD></DL>
<HR>
<LEFT><A NAME=mgWalkGetMatrix><H1 CLASS="APISYMBOL">mgWalkGetMatrix</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgWalkGetMatrix</B> - returns the current matrix accumulated so far during 
an <A HREF=#mgWalk>mgWalk</A> or <A HREF=#mgWalkEx>mgWalkEx</A> traversal.<P></DD>
</DL>
<DL>
<DT><H3>C SPECIFICATION</H3></DT>
<DD>
<TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgWalkGetMatrix</B> (</TD><TD>void*</TD><TD><I>userdata</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgmatrix>mgmatrix*</A></TD><TD><I>matrix</I> );</TD>
</TR>
</TABLE>
</DD>
</DL>
<DL>
<DT><H3>PYTHON SPECIFICATION</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool, mgmatrix <B>mgWalkGetMatrix</B> (</TD><TD>void*</TD><TD><I>userdata</I> )</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgWalkGetMatrix</B> calculates and returns the current matrix accumulated 
during a traversal initiated by either <A HREF=#mgWalk>mgWalk</A> or <A HREF=#mgWalkEx>mgWalkEx</A> with flags that include 
<A HREF=#MWALK_MATRIXSTACK>MWALK_MATRIXSTACK</A>.</P></DD><DD><P>The matrix accumulated is formed by multiplying together all the matrices of the nodes 
contained in the path from the root of the traversal to the current node of the traversal. 
When you use <A HREF=#mgWalkEx>mgWalkEx</A> to traverse, you can specify the starting or "root" matrix of the 
traversal.</P></DD><DD><P>Note: This function can only be called from within the users preaction or postaction 
callback during <A HREF=#mgWalk>mgWalk</A> or <A HREF=#mgWalkEx>mgWalkEx</A>.  If you call this function in any other context, 
or call this function without having specified <A HREF=#MWALK_MATRIXSTACK>MWALK_MATRIXSTACK</A> when you called 
<A HREF=#mgWalk>mgWalk</A> or <A HREF=#mgWalkEx>mgWalkEx</A>, it will fail.</P></DD><DD><P>If <B>mgWalkGetMatrix</B> is called during the preaction callback, it includes the matrix 
applied to the current node (if any).  If called during the postaction callback, it does not 
include the matrix applied to the current node.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>userdata</I></DT><DD>pointer passed to <A HREF=#mgWalk>mgWalk</A> or <A HREF=#mgWalkEx>mgWalkEx</A> identifying 
the user defined data</DD><DT><I>matrix</I></DT><DD>the address of a matrix to receive 
the composite of all transformations accumulated thus 
far during the traversal</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD><DL><DT>mgbool</DT><DD><A HREF=#mgbool>MG_TRUE</A> if the matrix is returned, <A HREF=#mgbool>MG_FALSE</A> otherwise.</DD><DT>mgmatrix</DT><DD>If function is successful, contains the matrix representing 
the cumulative transformations applied to this point during the traversal, otherwise undefined.</DD></DL></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">static mgbool PreWalkFunc (mgrec* db, mgrec* parent, mgrec* rec, void* userData)
{
   mgmatrix mat;
   mgbool ok = mgWalkGetMatrix (userData, &mat);
   if (ok == MG_TRUE)
   {
      // mat contains cumulative transformations applied to this
      // point (including this node rec) during the traversal
   }
   return (MG_TRUE);
}
static mgbool PostWalkFunc (mgrec* db, mgrec* parent, mgrec* rec, void* userData)
{
   mgmatrix mat;
   mgbool ok = mgWalkGetMatrix (userData, &mat);
   if (ok == MG_TRUE)
   {
      // mat contains cumulative transformations applied to this
      // point (but NOT including this node rec) during the traversal
   }
   return (MG_TRUE);
}
// both of the following are equivalent
mgWalkEx (db, MG_NULL, PreWalkFunc, PostWalkFunc, MG_NULL, MWALK_MATRIXSTACK);
mgWalk (db, PreWalkFunc, PostWalkFunc, MG_NULL, MWALK_MATRIXSTACK);</PRE></DT></DL></DD></DL>
<DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">def PreWalkFunc (db, parent, rec, userData):
   ok, mat = mgWalkGetMatrix (userData)
   if (ok == MG_TRUE):
      print mat[0],mat[1],mat[2],mat[3]
      print mat[4],mat[5],mat[6],mat[7]
      print mat[8],mat[9],mat[10],mat[11]
      print mat[12],mat[13],mat[14],mat[15]
      print "-"
      # mat contains cumulative transformations applied to this
      # point (including this node rec) during the traversal
   else:
      print "Error"
   return MG_TRUE

def PostWalkFunc (db, parent, rec, userData):
   ok, mat = mgWalkGetMatrix (userData)
   if (ok == MG_TRUE):
      print mat[0],mat[1],mat[2],mat[3]
      print mat[4],mat[5],mat[6],mat[7]
      print mat[8],mat[9],mat[10],mat[11]
      print mat[12],mat[13],mat[14],mat[15]
      print "-"
      # mat contains cumulative transformations applied to this
      # point (but NOT including this node rec) during the traversal
   else:
      print "Error"
   return MG_TRUE

db = mgGetCurrentDb ()
# both of the following are equivalent
mgWalkEx (db, None, PreWalkFunc, PostWalkFunc, None, MWALK_MATRIXSTACK)
mgWalk (db, PreWalkFunc, PostWalkFunc, None, MWALK_MATRIXSTACK);</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, <A HREF=#mgWalkRecList>mgWalkRecList</A>, <A HREF=#MWALK_MATRIXSTACK>MWALK_MATRIXSTACK</A></DD></DL>
<HR>
<LEFT><A NAME=mgWalkRecList><H1 CLASS="APISYMBOL">mgWalkRecList</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgWalkRecList</B> - iterates and traverses nodes in a record list and performs an action at each node.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgWalkRecList</B> (</TD><TD><A HREF=#mgreclist>mgreclist</A></TD><TD><I>recList</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgwalkfunc>mgwalkfunc</A></TD><TD><I>preAction</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgwalkfunc>mgwalkfunc</A></TD><TD><I>postAction</I>,</TD></TR>
<TR><TD></TD><TD>void*</TD><TD><I>userData</I>,</TD></TR>
<TR><TD></TD><TD>unsigned int</TD><TD><I>flags</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgWalkRecList</B> iterates the nodes contained in <I>recList</I> and performs <A HREF=#mgWalk>mgWalk</A> for 
each node.  It uses <I>flags</I> to control the&#32behavior of the traversal of each node.  See <A HREF=#mgWalk>mgWalk</A> 
for more information on the traversal, action functions (<I>preAction</I> and <I>postAction</I>) and <I>flags</I>.</P></DD><DD><P><B>mgWalkRecList</B> is very similar to <A HREF=#mgIterateRecList>mgIterateRecList</A> which iterates a record list but does 
not traverse the nodes.  If you just want to iterate the nodes in a record list but not traverse their 
children, use <A HREF=#mgIterateRecList>mgIterateRecList</A>.</P></DD><DD><P>Note that the <A HREF=#MWALK_NEXT>MWALK_NEXT</A> mask is ignored if specified in <I>flags</I>. Note also that if either 
your <I>preAction</I> or <I>postAction</I> function return <A HREF=#mgbool>MG_FALSE</A>, the traversal and the 
iteration are both stopped at that point.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>recList</I></DT><DD>the record list to iterate and traverse</DD><DT><I>preAction</I></DT><DD>the function that is invoked 
before any of the node's children have been visited</DD><DT><I>postAction</I></DT><DD>the function that is invoked 
after all the node's children have been visited</DD><DT><I>userData</I></DT><DD>pointer to user defined data that will be passed 
to <I>preAction</I> and <I>postAction</I> callback functions</DD><DT><I>flags</I></DT><DD>traversal modifiers that allow you to select 
certain types of nodes for visiting. 
This parameter is the bitwise combination of the following masks:<BR> 
<A HREF=#MWALK_VERTEX>MWALK_VERTEX</A><BR> <A HREF=#MWALK_MASTER>MWALK_MASTER</A><BR> 
<A HREF=#MWALK_MASTERALL>MWALK_MASTERALL</A><BR> <A HREF=#MWALK_ON>MWALK_ON</A><BR> <A HREF=#MWALK_NOREADONLY>MWALK_NOREADONLY</A><BR> 
<A HREF=#MWALK_NONESTED>MWALK_NONESTED</A><BR> <A HREF=#MWALK_MATRIXSTACK>MWALK_MATRIXSTACK</A><BR> note that 
<A HREF=#MWALK_NEXT>MWALK_NEXT</A> is ignored if specified</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if traversal successful, <A HREF=#mgbool>MG_FALSE</A> if 
traversal unsuccessful or if terminated by one of the action functions.
</DD></DL><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following example shows two ways to iterate and traverse the selected 
nodes in a database.</DT></DL></DD></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">static mgbool PreWalkFunc (mgrec* db, mgrec* parent, mgrec* rec, void* userData)
{
   // do something as you traverse this node (rec)
   return (MG_TRUE);
}
static mgbool PostWalkFunc (mgrec* db, mgrec* parent, mgrec* rec, void* userData)
{
   // do something as you traverse this node (rec)
   return (MG_TRUE);
}

// get the selected nodes of db in a record list
mgreclist selectList = mgGetSelectList (db);

// iterate and traverse each selected node using mgWalkRecList
mgWalkRecList (selectList, PreWalkFunc, PostWalkFunc, MG_NULL, MWALK_ON);

// calling mgWalkRecList is equivalent to the following:

mgrec* rec;
mgmatrix selectMatrix;
// manually iterate the nodes in the record list
// start with the first node...
rec = mgGetNextRecInList (selectList, &selectMatrix);
while (rec)
{
   // call mgWalk manually on this node...
   mgWalk (rec, PreWalkFunc, PostWalkFunc, MG_NULL, MWALK_ON);

   // then iterate to the next node in the record list
   rec = mgGetNextRecInList (selectList, &selectMatrix);
}

// and remember to free the record list when you're done with it
mgFreeRecList (selectList);</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 1</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgIterateRecList>mgIterateRecList</A>, <A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, <A HREF=#mgWalkGetMatrix>mgWalkGetMatrix</A>, 
<A HREF=#mgGetNext>mgGetNext</A>, <A HREF=#mgGetPrevious>mgGetPrevious</A>, <A HREF=#mgGetParent>mgGetParent</A>, <A HREF=#mgGetChild>mgGetChild</A>, 
<A HREF=#mgGetNestedParent>mgGetNestedParent</A>, <A HREF=#mgGetNestedChild>mgGetNestedChild</A>, <A HREF=#mgGetReference>mgGetReference</A>, 
<A HREF=#mgGetChildNth>mgGetChildNth</A>, <A HREF=#mgGetAttrChild>mgGetAttrChild</A>, 
<A HREF=#mgFind>mgFind</A>, <A HREF=#mgFindEx>mgFindEx</A></DD></DL>
<HR>
<LEFT><A NAME=mgWriteColorPalette><H1 CLASS="APISYMBOL">mgWriteColorPalette</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgWriteColorPalette</B> - writes a database&#146s color palette to a file.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgWriteColorPalette</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fileName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgWriteColorPalette</B> writes the color palette for database <I>db</I> 
to a file named <I>fileName</I>.</P></DD><DD><P>The resulting file can be read into another database using 
<A HREF=#mgReadColorPalette>mgReadColorPalette</A> or via the Load Palette command in the 
color palette in Creator.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database which contains the color 
palette to write</DD><DT><I>fileName</I></DT><DD>the color file name</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadColorPalette>mgReadColorPalette</A>, <A HREF=#mgReadDefaultColorPalette>mgReadDefaultColorPalette</A>, 
<A HREF=#mgWriteDefaultColorPalette>mgWriteDefaultColorPalette</A></DD></DL>
<HR>
<LEFT><A NAME=mgWriteDb><H1 CLASS="APISYMBOL">mgWriteDb</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgWriteDb</B> - writes an OpenFlight database to disk.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgWriteDb</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given the database, <I>db</I>, <B>mgWriteDb</B> writes this 
database to disk using the file name stored in the database header. 
The file name must first be opened and initialized with either the 
<A HREF=#mgOpenDb>mgOpenDb</A> or <A HREF=#mgNewDb>mgNewDb</A> functions, which associate the database 
with a file name.</P></DD><DD><P>Note: If you call this function in Creator, it will fail if <I>db</I> 
is open on the Creator desktop.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database to write</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec *db1, *db2;
db1 = mgOpenDb ("file1.flt");
db2 = mgNewDb ("newfile.flt");

// make some changes to the databases...

mgWriteDb (db1);
mgWriteDb (db2);

mgCloseDb (db1);
mgCloseDb (db2);</PRE></DT></DL></DD></DL>
<DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgOpenDb>mgOpenDb</A>, <A HREF=#mgNewDb>mgNewDb</A>, <A HREF=#mgCloseDb>mgCloseDb</A>, <A HREF=#mgSaveAsDb>mgSaveAsDb</A>, <A HREF=#mgExportDb>mgExportDb</A></DD></DL>
<HR>
<LEFT><A NAME=mgWriteDefaultColorPalette><H1 CLASS="APISYMBOL">mgWriteDefaultColorPalette</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgWriteDefaultColorPalette</B> - writes the default 
color palette to a file.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgWriteDefaultColorPalette</B> (</TD><TD>const char*</TD><TD><I>fileName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgWriteDefaultColorPalette</B> writes the default color palette 
to a file named <I>fileName</I>.</P></DD><DD><P>The resulting file can be read into another database using 
<A HREF=#mgReadColorPalette>mgReadColorPalette</A> or via the Load Palette command in the 
color palette in Creator.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>fileName</I></DT><DD>the color file name</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadColorPalette>mgReadColorPalette</A>, <A HREF=#mgReadDefaultColorPalette>mgReadDefaultColorPalette</A>, <A HREF=#mgWriteColorPalette>mgWriteColorPalette</A></DD></DL>
<HR>
<LEFT><A NAME=mgWriteImage><H1 CLASS="APISYMBOL">mgWriteImage</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgWriteImage</B> - writes an image to disk.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>mgWriteImage</B> (</TD><TD>const char*</TD><TD><I>textureName</I>,</TD></TR>
<TR><TD></TD><TD>unsigned char*</TD><TD><I>pixels</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>type</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>width</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>height</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgbool>mgbool</A></TD><TD><I>compress</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgWriteImage</B> writes an image to disk in the SGI RGB format 
with the given <I>textureName</I>.  The <I>pixels</I> you supply are expected 
to be packed in one of the formats supported by the OpenFlight API: <A HREF=#MIMG_INT>MIMG_INT</A>, 
<A HREF=#MIMG_INTA>MIMG_INTA</A>, <A HREF=#MIMG_RGB>MIMG_RGB</A>, or <A HREF=#MIMG_RGBA>MIMG_RGBA</A>.  These are the formats returned 
by functions such as <A HREF=#mgReadImage>mgReadImage</A> or <A HREF=#mgGetTextureTexels>mgGetTextureTexels</A>. 
If <B>compress</B> is <A HREF=#mgbool>MG_TRUE</A>, 
the image is compressed using SGI&#146s run-length encoding scheme.</P></DD><DD><P>See <A HREF=#mgReadImage>mgReadImage</A> for a description of the expected memory layout 
for <I>pixels</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>textureName</I></DT><DD>the name of the image file to create</DD><DT><I>pixels</I></DT><DD>the image pixels</DD><DT><I>type</I></DT><DD>the image type specifying how the <I>pixels</I> 
are packed - possible values are <A HREF=#MIMG_INT>MIMG_INT</A>, 
<A HREF=#MIMG_INTA>MIMG_INTA</A>, <A HREF=#MIMG_RGB>MIMG_RGB</A> and <A HREF=#MIMG_RGBA>MIMG_RGBA</A></DD><DT><I>width</I></DT><DD>the image width</DD><DT><I>height</I></DT><DD>the image height</DD><DT><I>compress</I></DT><DD>a flag specifying whether or not 
to compress the image</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#MIMG_NO_ERROR>MIMG_NO_ERROR</A> if successful, otherwise applicable 
texture error code.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadImage>mgReadImage</A>, <A HREF=#mgReadImageHeader>mgReadImageHeader</A>, <A HREF=#mgWriteTexture>mgWriteTexture</A></DD></DL>
<HR>
<LEFT><A NAME=mgWriteImageAttributes><H1 CLASS="APISYMBOL">mgWriteImageAttributes</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgWriteImageAttributes</B> - writes image attributes to disk.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgWriteImageAttributes</B> (</TD><TD>const char*</TD><TD><I>textureName</I>,</TD></TR>
<TR><TD></TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>rec</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Given a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltImage>fltImage</A>
 record, <I>rec</I>, and a <I>textureName</I>, 
<B>mgWriteImageAttribute</B> writes an image&#146s attributes file to disk 
using the given file name, <I>textureName</I> appended with ".attr".</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>textureName</I></DT><DD>the image attributes file name, 
without the extension ".attr"</DD><DT><I>rec</I></DT><DD>a pointer to the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltImage>fltImage</A>
 
(image attributes) record</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadImageAttributes>mgReadImageAttributes</A>, <A HREF=#mgWriteImage>mgWriteImage</A></DD></DL>
<HR>
<LEFT><A NAME=mgWriteLightPointFile><H1 CLASS="APISYMBOL">mgWriteLightPointFile</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgWriteLightPointFile</B> - writes a database&#146s light point 
appearance and animation palettes to a file.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgWriteLightPointFile</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fileName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgWriteLightPointFile</B> writes the light point appearance and 
animation palettes for database <I>db</I> to a file named <I>fileName</I>.</P></DD><DD><P>The resulting file can be read into another database using 
<A HREF=#mgReadLightPointFile>mgReadLightPointFile</A> or via the Load Palette command in the 
light point palette in Creator.</P></DD><DD><P>Note that even though the light point appearance and animation palettes 
are really separate, this function, as well as <A HREF=#mgReadLightPointFile>mgReadLightPointFile</A> groups 
the entries in both into one single file.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database that contains the light 
point appearance and animation palettes to write</DD><DT><I>fileName</I></DT><DD>the light point palette file name</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadLightPointFile>mgReadLightPointFile</A></DD></DL>
<HR>
<LEFT><A NAME=mgWriteLightSourceFile><H1 CLASS="APISYMBOL">mgWriteLightSourceFile</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgWriteLightSourceFile</B> - writes a database&#146s light source 
palette to a file.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgWriteLightSourceFile</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fileName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgWriteLightSourceFile</B> writes the light source palette for 
database <I>db</I> to a file named <I>fileName</I>.</P></DD><DD><P>The resulting file can be read into another database using 
<A HREF=#mgReadLightSourceFile>mgReadLightSourceFile</A> or via the Load Palette command in the 
light source palette in Creator.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>fileName</I></DT><DD>the name of the file to write</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadLightSourceFile>mgReadLightSourceFile</A></DD></DL>
<HR>
<LEFT><A NAME=mgWriteMaterialFile><H1 CLASS="APISYMBOL">mgWriteMaterialFile</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgWriteMaterialFile</B> - writes a database&#146s material palette 
to a file.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgWriteMaterialFile</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fileName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgWriteMaterialFile</B> writes the material palette for database <I>db</I> 
to a file named <I>fileName</I>.  This function writes extended material palette 
entries (OpenFlight version 16.3 and beyond).  If you need to write standard 
material palette entries (OpenFlight 16.2 and earlier), use the function 
<A HREF=#mgWriteMaterialFileVersion>mgWriteMaterialFileVersion</A>.</P></DD><DD><P>The resulting file can be read into another database using 
<A HREF=#mgReadMaterialFile>mgReadMaterialFile</A> or via the Load Palette command in the 
material palette in Creator.</P></DD><DD><P>Note that versions of Creator earlier 
than 3.4 will not recognize this material file format.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database that contains the material 
palette to write</DD><DT><I>fileName</I></DT><DD>the material palette file name</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWriteMaterialFileVersion>mgWriteMaterialFileVersion</A>, <A HREF=#mgReadMaterialFile>mgReadMaterialFile</A></DD></DL>
<HR>
<LEFT><A NAME=mgWriteMaterialFileVersion><H1 CLASS="APISYMBOL">mgWriteMaterialFileVersion</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgWriteMaterialFileVersion</B> - writes a database&#146s material 
palette to a file.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgWriteMaterialFileVersion</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fileName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgWriteMaterialFileVersion</B> writes the material palette for 
database <I>db</I> to a file named <I>fileName</I> using the specified 
material palette format <I>formatVersion</I>.  You can specify either 
<A HREF=#MEFV_1630>MEFV_1630</A> or <A HREF=#MEFV_1620>MEFV_1620</A> for <I>formatVersion</I>.  If you specify 
<A HREF=#MEFV_1630>MEFV_1630</A>, extended material palette entries (OpenFlight version 16.3 
and beyond) will be written.  If you specify <A HREF=#MEFV_1620>MEFV_1620</A>, standard 
material palette entries (OpenFlight 16.2 and earlier) will be written.</P></DD><DD><P>The resulting file can be read into another database using 
<A HREF=#mgReadMaterialFile>mgReadMaterialFile</A> or via the Load Palette command in the 
material palette in Creator.</P></DD><DD><P>Note that if you specify <A HREF=#MEFV_1630>MEFV_1630</A> for <I>formatVersion</I> 
versions of Creator earlier than 3.4 will not recognize this material 
file format.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database that contains the material 
palette to write</DD><DT><I>fileName</I></DT><DD>the material palette file name</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWriteMaterialFile>mgWriteMaterialFile</A>, <A HREF=#mgReadMaterialFile>mgReadMaterialFile</A></DD></DL>
<HR>
<LEFT><A NAME=mgWriteSoundFile><H1 CLASS="APISYMBOL">mgWriteSoundFile</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgWriteSoundFile</B> - writes a database&#146s sound palette to a file.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgWriteSoundFile</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>char*</TD><TD><I>fileName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgWriteSoundFile</B> writes the sound palette for database <I>db</I> 
to a file named <I>fileName</I>.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>fileName</I></DT><DD>the file name</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<HR>
<LEFT><A NAME=mgWriteTexture><H1 CLASS="APISYMBOL">mgWriteTexture</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgWriteTexture</B> - writes a texture palette entry to disk.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgWriteTexture</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>int</TD><TD><I>index</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>textureName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgWriteTexture</B> writes the specified texture image to disk in 
the SGI RGB format with the given <I>textureName</I>.  This function also 
writes the attributes corresponding to the texture to disk using the 
given <I>textureName</I> appended with ".attr".</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>index</I></DT><DD>the texture palette index</DD><DT><I>textureName</I></DT><DD>the name of the image file to create</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWriteImage>mgWriteImage</A>, <A HREF=#mgReadTexture>mgReadTexture</A></DD></DL>
<HR>
<LEFT><A NAME=mgWriteTextureMappingFile><H1 CLASS="APISYMBOL">mgWriteTextureMappingFile</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgWriteTextureMappingFile</B> - writes a database&#146s texture 
mapping palette to a file.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgWriteTextureMappingFile</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fileName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgWriteTextureMappingFile</B> writes the texture mapping palette for 
database <I>db</I> to a file named <I>fileName</I>.</P></DD><DD><P>The resulting file can be read into another database using 
<A HREF=#mgReadTextureMappingFile>mgReadTextureMappingFile</A> or via the Load Palette command in the 
texture mapping palette in Creator.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database that contains the 
texture mapping palette to write</DD><DT><I>fileName</I></DT><DD>the texture mapping palette file name</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadTextureMappingFile>mgReadTextureMappingFile</A></DD></DL>
<HR>
<LEFT><A NAME=mgWriteTexturePalette><H1 CLASS="APISYMBOL">mgWriteTexturePalette</H1></A></LEFT>
<DL>
<DT><H3>FUNCTION NAME</H3></DT>
<DD><B>mgWriteTexturePalette</B> - writes a database's texture palette 
to a file.<P></DD>
</DL>
<DL>
<DT><H3>SYNOPSIS &nbsp; &nbsp; &nbsp; (C and Python)</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>mgbool <B>mgWriteTexturePalette</B> (</TD><TD><A HREF=#mgrec>mgrec*</A></TD><TD><I>db</I>,</TD></TR>
<TR><TD></TD><TD>const char*</TD><TD><I>fileName</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P><B>mgWriteTexturePalette</B> writes the texture palette for database <I>db</I> 
to a file named <I>fileName</I>.</P></DD><DD><P>The resulting file can be read into another database using 
<A HREF=#mgReadTexturePalette>mgReadTexturePalette</A> or via the Load Palette command in the 
texture palette in Creator.</P></DD></DT></DL>
<DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>db</I></DT><DD>the database</DD><DT><I>fileName</I></DT><DD>the texture palette file name</DD></DL></DD></DL>
<DL><DT><H3>RETURNS</H3></DT><DD>Returns <A HREF=#mgbool>MG_TRUE</A> if successful, <A HREF=#mgbool>MG_FALSE</A> otherwise.
</DD></DL><DL><DT><H3>ACCESS LEVEL</H3><DD>Level 2</DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgReadTexturePalette>mgReadTexturePalette</A></DD></DL>
<HR>
<LEFT><A NAME=MSTAT_ISOK><H1 CLASS="APISYMBOL">MSTAT_ISOK</H1></A></LEFT>
<DL>
<DT><H3>MACRO NAME</H3></DT>
<DD><B>MSTAT_ISOK</B> - checks return value for success<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><TABLE CLASS="SYNOPSIS">
<TR>
<TD>int <B>MSTAT_ISOK</B> (</TD><TD><A HREF=#></A></TD><TD><I>status</I> );</TD>
</TR>
</TABLE></DD>
</DL>
<DL><DT><H3>RETURNS</H3></DT><DD>1 if success; 0, otherwise
</DD></DL><DL><DT><H3>PARAMETERS</H3></DT><DD><DL><DT><I>status</I></DT><DD>the return value</DD></DL></DD></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>If an OpenFlight API function returns a value of type <A HREF=#mgstatus>mgstatus</A>, you 
should use this macro to check return value for success.</P></DD></DT></DL>
<HR>
<LEFT><A NAME=MBT_CANCEL><H1 CLASS="APISYMBOL">MBT_CANCEL</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MBT_CANCEL</B> - Editor dialog button event <I>Cancel</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the button event that is sent to the 
button function for an editor tool when the user 
presses the <I>Cancel</I> button in the editor tool dialog.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSetButtonFunc>mgEditorSetButtonFunc</A></DD></DL>
<HR>
<LEFT><A NAME=MBT_DONE><H1 CLASS="APISYMBOL">MBT_DONE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MBT_DONE</B> - Editor dialog button event <I>Done</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the button event that is sent to the 
button function for an editor tool when the user 
presses the <I>Done</I> button in the editor tool dialog.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSetButtonFunc>mgEditorSetButtonFunc</A></DD></DL>
<HR>
<LEFT><A NAME=MBT_HELP><H1 CLASS="APISYMBOL">MBT_HELP</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MBT_HELP</B> - Editor dialog button event <I>Help</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the button event that is sent to the 
button function for an editor tool when the user 
presses the <I>Help</I> button in the editor tool dialog.</P></DD><DD><P>This editor dialog event is currently not used 
and is reserved for future enhancement.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSetButtonFunc>mgEditorSetButtonFunc</A></DD></DL>
<HR>
<LEFT><A NAME=MBT_NEXT><H1 CLASS="APISYMBOL">MBT_NEXT</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MBT_NEXT</B> - Editor dialog button event <I>Next</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the button event that is sent to the 
button function for an editor tool when the user 
presses the <I>Next</I> button in the editor tool dialog.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSetButtonFunc>mgEditorSetButtonFunc</A></DD></DL>
<HR>
<LEFT><A NAME=MBT_REDO><H1 CLASS="APISYMBOL">MBT_REDO</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MBT_REDO</B> - Editor dialog button event <I>Redo</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the button event that is sent to the 
button function for an editor tool when the user 
presses the <I>Redo</I> button in the editor tool dialog 
or invokes the Redo command in Creator while the editor 
tool dialog is active.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSetButtonFunc>mgEditorSetButtonFunc</A></DD></DL>
<HR>
<LEFT><A NAME=MBT_UNDO><H1 CLASS="APISYMBOL">MBT_UNDO</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MBT_UNDO</B> - Editor dialog button event <I>Undo</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the button event that is sent to the 
button function for an editor tool when the user 
presses the <I>Undo</I> button in the editor tool dialog 
or invokes the Undo command in Creator while the editor 
tool dialog is active.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSetButtonFunc>mgEditorSetButtonFunc</A></DD></DL>
<HR>
<LEFT><A NAME=MCURS_ARROW><H1 CLASS="APISYMBOL">MCURS_ARROW</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MCURS_ARROW</B> - Arrow Cursor Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
arrow cursor.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetCursor>mgResourceGetCursor</A>, <A HREF=#mgSetCursor>mgSetCursor</A></DD></DL>
<HR>
<LEFT><A NAME=MCURS_BUCKET><H1 CLASS="APISYMBOL">MCURS_BUCKET</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MCURS_BUCKET</B> - Bucket Cursor Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
bucket cursor.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetCursor>mgResourceGetCursor</A>, <A HREF=#mgSetCursor>mgSetCursor</A></DD></DL>
<HR>
<LEFT><A NAME=MCURS_CROSS><H1 CLASS="APISYMBOL">MCURS_CROSS</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MCURS_CROSS</B> - Cross Cursor Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
cross cursor (crosshair).</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetCursor>mgResourceGetCursor</A>, <A HREF=#mgSetCursor>mgSetCursor</A></DD></DL>
<HR>
<LEFT><A NAME=MCURS_EYEDROPPER><H1 CLASS="APISYMBOL">MCURS_EYEDROPPER</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MCURS_EYEDROPPER</B> - Eye Dropper Cursor Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
eye dropper cursor.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetCursor>mgResourceGetCursor</A>, <A HREF=#mgSetCursor>mgSetCursor</A></DD></DL>
<HR>
<LEFT><A NAME=MCURS_NO><H1 CLASS="APISYMBOL">MCURS_NO</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MCURS_NO</B> - No Cursor Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
no cursor (slashed circle).</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetCursor>mgResourceGetCursor</A>, <A HREF=#mgSetCursor>mgSetCursor</A></DD></DL>
<HR>
<LEFT><A NAME=MCURS_PEN><H1 CLASS="APISYMBOL">MCURS_PEN</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MCURS_PEN</B> - Pen Cursor Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
pen cursor.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetCursor>mgResourceGetCursor</A>, <A HREF=#mgSetCursor>mgSetCursor</A></DD></DL>
<HR>
<LEFT><A NAME=MCURS_SIZEALL><H1 CLASS="APISYMBOL">MCURS_SIZEALL</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MCURS_SIZEALL</B> - Size All Cursor Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
size-all cursor (four pointed arrow).</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetCursor>mgResourceGetCursor</A>, <A HREF=#mgSetCursor>mgSetCursor</A></DD></DL>
<HR>
<LEFT><A NAME=MCURS_SIZENESW><H1 CLASS="APISYMBOL">MCURS_SIZENESW</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MCURS_SIZENESW</B> - Size NE/SW Cursor Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
size ne/sw cursor (double pointed arrow pointing 
northeast and southwest).</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetCursor>mgResourceGetCursor</A>, <A HREF=#mgSetCursor>mgSetCursor</A></DD></DL>
<HR>
<LEFT><A NAME=MCURS_SIZENS><H1 CLASS="APISYMBOL">MCURS_SIZENS</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MCURS_SIZENS</B> - Size North/South Cursor Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
size north/south cursor (double pointed arrow pointing 
north and south).</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetCursor>mgResourceGetCursor</A>, <A HREF=#mgSetCursor>mgSetCursor</A></DD></DL>
<HR>
<LEFT><A NAME=MCURS_SIZENWSE><H1 CLASS="APISYMBOL">MCURS_SIZENWSE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MCURS_SIZENWSE</B> - Size NW/SE Cursor Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
size nw/se cursor (double pointed arrow pointing 
northwest and southeast).</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetCursor>mgResourceGetCursor</A>, <A HREF=#mgSetCursor>mgSetCursor</A></DD></DL>
<HR>
<LEFT><A NAME=MCURS_SIZEWE><H1 CLASS="APISYMBOL">MCURS_SIZEWE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MCURS_SIZEWE</B> - Size West/East Cursor Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
size west/east cursor (double pointed arrow pointing 
west and east).</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetCursor>mgResourceGetCursor</A>, <A HREF=#mgSetCursor>mgSetCursor</A></DD></DL>
<HR>
<LEFT><A NAME=MCURS_SPIN><H1 CLASS="APISYMBOL">MCURS_SPIN</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MCURS_SPIN</B> - Spin Cursor Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
spin cursor (hand with horizontally oriented 
arrow loop).</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetCursor>mgResourceGetCursor</A>, <A HREF=#mgSetCursor>mgSetCursor</A></DD></DL>
<HR>
<LEFT><A NAME=MCURS_SPLITH><H1 CLASS="APISYMBOL">MCURS_SPLITH</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MCURS_SPLITH</B> - Split Horizontal Cursor Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
split horizontal cursor.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetCursor>mgResourceGetCursor</A>, <A HREF=#mgSetCursor>mgSetCursor</A></DD></DL>
<HR>
<LEFT><A NAME=MCURS_SPLITV><H1 CLASS="APISYMBOL">MCURS_SPLITV</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MCURS_SPLITV</B> - Split Vertical Cursor Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
split vertical cursor.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetCursor>mgResourceGetCursor</A>, <A HREF=#mgSetCursor>mgSetCursor</A></DD></DL>
<HR>
<LEFT><A NAME=MCURS_UPARROW><H1 CLASS="APISYMBOL">MCURS_UPARROW</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MCURS_UPARROW</B> - Up Arrow Cursor Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
up arrow cursor.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetCursor>mgResourceGetCursor</A>, <A HREF=#mgSetCursor>mgSetCursor</A></DD></DL>
<HR>
<LEFT><A NAME=MCURS_WAIT><H1 CLASS="APISYMBOL">MCURS_WAIT</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MCURS_WAIT</B> - Wait Cursor Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
wait cursor (hourglass).</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetCursor>mgResourceGetCursor</A>, <A HREF=#mgSetCursor>mgSetCursor</A></DD></DL>
<HR>
<LEFT><A NAME=MCURS_ZOOMIN><H1 CLASS="APISYMBOL">MCURS_ZOOMIN</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MCURS_ZOOMIN</B> - Zoom In Cursor Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
zoom in cursor (magnifying glass with "+" symbol).</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetCursor>mgResourceGetCursor</A>, <A HREF=#mgSetCursor>mgSetCursor</A></DD></DL>
<HR>
<LEFT><A NAME=MCURS_ZOOMOUT><H1 CLASS="APISYMBOL">MCURS_ZOOMOUT</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MCURS_ZOOMOUT</B> - Zoom Out Cursor Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
zoom out cursor (magnifying glass with "-" symbol).</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetCursor>mgResourceGetCursor</A>, <A HREF=#mgSetCursor>mgSetCursor</A></DD></DL>
<HR>
<LEFT><A NAME=MDFMT_LAT><H1 CLASS="APISYMBOL">MDFMT_LAT</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MDFMT_LAT</B> - DMS (Degrees, Minutes, Seconds) 
format string for standard Latitude display<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the format string you will specify 
when calling <A HREF=#mgTextGetDMS>mgTextGetDMS</A> or <A HREF=#mgTextSetDMS>mgTextSetDMS</A> 
if the input or output string is formatted as a 
measurement of latitude.  The standard format for 
latitude display is <B>DD~MM'SS"H</B>, where DD is the 
number of degrees, MM is the number of minutes, 
SS is the number of seconds and H is either 'N' 
or 'S' depending on whether the value lies in 
the northern or southern hemisphere, respectively.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgTextGetDMS>mgTextGetDMS</A>, <A HREF=#mgTextSetDMS>mgTextSetDMS</A>, <A HREF=#MDFMT_LON>MDFMT_LON</A></DD></DL>
<HR>
<LEFT><A NAME=MDFMT_LON><H1 CLASS="APISYMBOL">MDFMT_LON</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MDFMT_LON</B> - DMS (Degrees, Minutes, Seconds) 
format string for standard Longitude display<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the format string you will specify 
when calling <A HREF=#mgTextGetDMS>mgTextGetDMS</A> or <A HREF=#mgTextSetDMS>mgTextSetDMS</A> 
if the input or output string is formatted as a 
measurement of longitude.  The standard format for 
longitude display is <B>DD~MM'SS"H</B>, where DD is the 
number of degrees, MM is the number of minutes, 
SS is the number of seconds and H is either 'E' 
or 'W' depending on whether the value lies in 
the eastern or western hemisphere, respectively.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgTextGetDMS>mgTextGetDMS</A>, <A HREF=#mgTextSetDMS>mgTextSetDMS</A>, <A HREF=#MDFMT_LAT>MDFMT_LAT</A></DD></DL>
<HR>
<LEFT><A NAME=MDUP_DERIVEDNAMES><H1 CLASS="APISYMBOL">MDUP_DERIVEDNAMES</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MDUP_DERIVEDNAMES</B> - Assign Derived Names<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Setting this mask causes <A HREF=#mgDuplicateEx>mgDuplicateEx</A> 
or <A HREF=#mgDuplicateToDbEx>mgDuplicateToDbEx</A> 
to assign names "derived" from the original nodes 
to all new nodes created.</P></DD><DD><P>The form of a derived name is "name_N" where 
<B>name</B> is the name of the original node and <B>N</B> 
is an integer such that "name_N" is unique in the 
database.</P></DD><DD><P>The alternative to derived names is standard 
names in which case you let the OpenFlight API choose a 
suitable default name for the duplicate nodes.</P></DD><DD><P>Note that assigning derived names is slower 
than assigning standard names.</P></DD><DD><P>By default, standard names are assigned 
to nodes created.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#MDUP_NODEONLY>MDUP_NODEONLY</A></DD></DL>
<HR>
<LEFT><A NAME=MDUP_NODEONLY><H1 CLASS="APISYMBOL">MDUP_NODEONLY</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MDUP_NODEONLY</B> - Duplicate Node Only<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Setting this mask causes <A HREF=#mgDuplicateEx>mgDuplicateEx</A> 
or <A HREF=#mgDuplicateToDbEx>mgDuplicateToDbEx</A> 
to duplicate only the node record specified 
None of its descendants will be duplicated.</P></DD><DD><P>By default, descendants are duplicated.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#MDUP_DERIVEDNAMES>MDUP_DERIVEDNAMES</A></DD></DL>
<HR>
<LEFT><A NAME=MEFN_OPENFLIGHT><H1 CLASS="APISYMBOL">MEFN_OPENFLIGHT</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MEFN_OPENFLIGHT</B> - Export Format Name <I>OpenFlight</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This export format name specifies the OpenFlight 
file format for <A HREF=#mgExportDb>mgExportDb</A>.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExportDb>mgExportDb</A></DD></DL>
<HR>
<LEFT><A NAME=MEFV_1540><H1 CLASS="APISYMBOL">MEFV_1540</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MEFV_1540</B> - Export Format Version OpenFlight 15.4<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This export format version specifies version 
15.4 for the Export Format <A HREF=#MEFN_OPENFLIGHT>MEFN_OPENFLIGHT</A> 
for <A HREF=#mgExportDb>mgExportDb</A>.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExportDb>mgExportDb</A></DD></DL>
<HR>
<LEFT><A NAME=MEFV_1560><H1 CLASS="APISYMBOL">MEFV_1560</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MEFV_1560</B> - Export Format Version OpenFlight 15.6<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This export format version specifies version 
15.6 for the Export Format <A HREF=#MEFN_OPENFLIGHT>MEFN_OPENFLIGHT</A> 
for <A HREF=#mgExportDb>mgExportDb</A>.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExportDb>mgExportDb</A></DD></DL>
<HR>
<LEFT><A NAME=MEFV_1570><H1 CLASS="APISYMBOL">MEFV_1570</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MEFV_1570</B> - Export Format Version OpenFlight 15.7<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This export format version specifies version 
15.7 for the Export Format <A HREF=#MEFN_OPENFLIGHT>MEFN_OPENFLIGHT</A> 
for <A HREF=#mgExportDb>mgExportDb</A>.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExportDb>mgExportDb</A></DD></DL>
<HR>
<LEFT><A NAME=MEFV_1580><H1 CLASS="APISYMBOL">MEFV_1580</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MEFV_1580</B> - Export Format Version OpenFlight 15.8<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This export format version specifies version 
15.8 for the Export Format <A HREF=#MEFN_OPENFLIGHT>MEFN_OPENFLIGHT</A> 
for <A HREF=#mgExportDb>mgExportDb</A>.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExportDb>mgExportDb</A></DD></DL>
<HR>
<LEFT><A NAME=MEFV_1600><H1 CLASS="APISYMBOL">MEFV_1600</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MEFV_1600</B> - Export Format Version OpenFlight 16.0<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This export format version specifies version 
16.0 for the Export Format <A HREF=#MEFN_OPENFLIGHT>MEFN_OPENFLIGHT</A> 
for <A HREF=#mgExportDb>mgExportDb</A>.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExportDb>mgExportDb</A></DD></DL>
<HR>
<LEFT><A NAME=MEFV_1610><H1 CLASS="APISYMBOL">MEFV_1610</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MEFV_1610</B> - Export Format Version OpenFlight 16.1<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This export format version specifies version 
16.1 for the Export Format <A HREF=#MEFN_OPENFLIGHT>MEFN_OPENFLIGHT</A> 
for <A HREF=#mgExportDb>mgExportDb</A>.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExportDb>mgExportDb</A></DD></DL>
<HR>
<LEFT><A NAME=MEFV_1620><H1 CLASS="APISYMBOL">MEFV_1620</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MEFV_1620</B> - Export Format Version OpenFlight 16.2<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This export format version specifies version 
16.2 for the Export Format <A HREF=#MEFN_OPENFLIGHT>MEFN_OPENFLIGHT</A> 
for <A HREF=#mgExportDb>mgExportDb</A> or <A HREF=#mgWriteMaterialFileVersion>mgWriteMaterialFileVersion</A>.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExportDb>mgExportDb</A>, <A HREF=#mgWriteMaterialFileVersion>mgWriteMaterialFileVersion</A></DD></DL>
<HR>
<LEFT><A NAME=MEFV_1630><H1 CLASS="APISYMBOL">MEFV_1630</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MEFV_1630</B> - Export Format Version OpenFlight 16.3<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This export format version specifies version 
16.3 for the Export Format <A HREF=#MEFN_OPENFLIGHT>MEFN_OPENFLIGHT</A> 
for <A HREF=#mgExportDb>mgExportDb</A> or <A HREF=#mgWriteMaterialFileVersion>mgWriteMaterialFileVersion</A>.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExportDb>mgExportDb</A>, <A HREF=#mgWriteMaterialFileVersion>mgWriteMaterialFileVersion</A></DD></DL>
<HR>
<LEFT><A NAME=MEFV_1640><H1 CLASS="APISYMBOL">MEFV_1640</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MEFV_1640</B> - Export Format Version OpenFlight 16.4<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This export format version specifies version 
16.4 for the Export Format <A HREF=#MEFN_OPENFLIGHT>MEFN_OPENFLIGHT</A> 
for <A HREF=#mgExportDb>mgExportDb</A> or <A HREF=#mgWriteMaterialFileVersion>mgWriteMaterialFileVersion</A>.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExportDb>mgExportDb</A>, <A HREF=#mgWriteMaterialFileVersion>mgWriteMaterialFileVersion</A></DD></DL>
<HR>
<LEFT><A NAME=MEFV_1650><H1 CLASS="APISYMBOL">MEFV_1650</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MEFV_1650</B> - Export Format Version OpenFlight 16.5<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This export format version specifies version 
16.5 for the Export Format <A HREF=#MEFN_OPENFLIGHT>MEFN_OPENFLIGHT</A> 
for <A HREF=#mgExportDb>mgExportDb</A> or <A HREF=#mgWriteMaterialFileVersion>mgWriteMaterialFileVersion</A>.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExportDb>mgExportDb</A>, <A HREF=#mgWriteMaterialFileVersion>mgWriteMaterialFileVersion</A></DD></DL>
<HR>
<LEFT><A NAME=MG_NULL><H1 CLASS="APISYMBOL">MG_NULL</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MG_NULL</B> - The NULL symbol<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>In the C language API, this is equivalent to NULL.</P></DD><DD><P>In OpenFlight Script, you should use the Python None keyword instead.</P></DD></DT></DL>
<HR>
<LEFT><A NAME=MGCB_ACTIVATE><H1 CLASS="APISYMBOL">MGCB_ACTIVATE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGCB_ACTIVATE</B> - Control event <I>Activate</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the control event that is sent to a 
control (via the control callback function) 
when the user activates the control.</P></DD><DD><P>When this event is sent to a text control, 
the <I>callData</I> parameter passed to the callback 
function will be a pointer to an object of type 
<A HREF=#mgtextactivatecallbackrec>mgtextactivatecallbackrec</A>.</P></DD><DD><P>When this event is sent to a scale control, 
the <I>callData</I> parameter passed to the callback 
function will be a pointer to an object of type 
<A HREF=#mgscaleactivatecallbackrec>mgscaleactivatecallbackrec</A>.</P></DD><DD><P>When this event is sent to a list control, 
the <I>callData</I> parameter passed to the callback 
function will be a pointer to an object of type 
<A HREF=#mglistactivatecallbackrec>mglistactivatecallbackrec</A>.</P></DD><DD><P>When this event is sent to a tab ruler control, 
the <I>callData</I> parameter passed to the callback 
function will be a pointer to an object of type 
<A HREF=#mgtabruleractivatecallbackrec>mgtabruleractivatecallbackrec</A>.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetGuiCallback>mgSetGuiCallback</A>, <A HREF=#mgguifunc>mgguifunc</A></DD></DL>
<HR>
<LEFT><A NAME=MGCB_DESTROY><H1 CLASS="APISYMBOL">MGCB_DESTROY</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGCB_DESTROY</B> - Dialog event <I>Destroy</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the dialog event that is sent 
to a dialog (via the dialog function) when it 
is destroyed.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetDialog>mgResourceGetDialog</A>, <A HREF=#mgResourceModalDialog>mgResourceModalDialog</A>, 
<A HREF=#mgdialogfunc>mgdialogfunc</A></DD></DL>
<HR>
<LEFT><A NAME=MGCB_DRAW><H1 CLASS="APISYMBOL">MGCB_DRAW</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGCB_DRAW</B> - Control event <I>Draw</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the control event that is sent 
to a GL control (via the control callback function) when it 
needs to be drawn.</P></DD><DD><P>When this event is sent to a GL control, 
the <I>callData</I> parameter passed to the callback 
function will be a pointer to an object of type 
<A HREF=#mggldrawcallbackrec>mggldrawcallbackrec</A>.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetGuiCallback>mgSetGuiCallback</A>, <A HREF=#mgguifunc>mgguifunc</A></DD></DL>
<HR>
<LEFT><A NAME=MGCB_HIDE><H1 CLASS="APISYMBOL">MGCB_HIDE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGCB_HIDE</B> - Dialog event <I>Hide</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the dialog event that is sent 
to a dialog (via the dialog function) when it 
changes from displayed to hidden.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetDialog>mgResourceGetDialog</A>, <A HREF=#mgResourceModalDialog>mgResourceModalDialog</A>, 
<A HREF=#mgdialogfunc>mgdialogfunc</A></DD></DL>
<HR>
<LEFT><A NAME=MGCB_INIT><H1 CLASS="APISYMBOL">MGCB_INIT</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGCB_INIT</B> - Dialog event <I>Initialize</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the dialog event that is sent 
to a dialog (via the dialog function) when it 
is initialized.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetDialog>mgResourceGetDialog</A>, <A HREF=#mgResourceModalDialog>mgResourceModalDialog</A>, 
<A HREF=#mgdialogfunc>mgdialogfunc</A></DD></DL>
<HR>
<LEFT><A NAME=MGCB_REFRESH><H1 CLASS="APISYMBOL">MGCB_REFRESH</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGCB_REFRESH</B> - Dialog/Control event <I>Refresh</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the dialog/control event that is sent 
to both dialogs and controls to notify them that 
they need to be refreshed.</P></DD><DD><P>Dialog events are sent to dialogs via 
the dialog function.</P></DD><DD><P>Control events are sent to controls via 
the control callback function.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetDialog>mgResourceGetDialog</A>, <A HREF=#mgResourceModalDialog>mgResourceModalDialog</A>, 
<A HREF=#mgdialogfunc>mgdialogfunc</A>, 
<A HREF=#mgSetGuiCallback>mgSetGuiCallback</A>, <A HREF=#mgguifunc>mgguifunc</A></DD></DL>
<HR>
<LEFT><A NAME=MGCB_SHOW><H1 CLASS="APISYMBOL">MGCB_SHOW</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGCB_SHOW</B> - Dialog event <I>Show</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the dialog event that is sent 
to a dialog (via the dialog function) when it 
changes from hidden to displayed.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetDialog>mgResourceGetDialog</A>, <A HREF=#mgResourceModalDialog>mgResourceModalDialog</A>, 
<A HREF=#mgdialogfunc>mgdialogfunc</A></DD></DL>
<HR>
<LEFT><A NAME=MGCB_SIZE><H1 CLASS="APISYMBOL">MGCB_SIZE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGCB_SIZE</B> - Dialog event <I>Size</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the dialog event that is sent 
to a dialog (via the dialog function) when the 
user changes its size.  A user can change a dialog's 
size by explicitly dragging the resize handles on 
the dialog or by minimizing or maximizing the dialog.</P></DD><DD><P>When this event is sent to a dialog, 
the <I>callData</I> parameter passed to the dialog 
function will be a pointer to an object of type 
<A HREF=#mgdialogsizecallbackrec>mgdialogsizecallbackrec</A>.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetDialog>mgResourceGetDialog</A>, <A HREF=#mgResourceModalDialog>mgResourceModalDialog</A>, 
<A HREF=#mgdialogfunc>mgdialogfunc</A></DD></DL>
<HR>
<LEFT><A NAME=MGD_DONTDRAWBELOW><H1 CLASS="APISYMBOL">MGD_DONTDRAWBELOW</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGD_DONTDRAWBELOW</B> - <A HREF=#mgstatus>mgstatus</A> return value for <A HREF=#mggraphicdrawfunc>mggraphicdrawfunc</A> 
indicating that nodes below extension node should not be drawn<P></DD>
</DL>
<HR>
<LEFT><A NAME=MGID_CANCEL><H1 CLASS="APISYMBOL">MGID_CANCEL</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGID_CANCEL</B> - The predefined identifier for 
the "Cancel" push button in a dialog<P></DD>
</DL>
<HR>
<LEFT><A NAME=MGID_HELP><H1 CLASS="APISYMBOL">MGID_HELP</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGID_HELP</B> - The predefined identifier for 
the "Help" push button in a editor tool 
dialog<P></DD>
</DL>
<HR>
<LEFT><A NAME=MGID_NEXT><H1 CLASS="APISYMBOL">MGID_NEXT</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGID_NEXT</B> - The predefined identifier for 
the "Next" push button in a editor tool 
dialog<P></DD>
</DL>
<HR>
<LEFT><A NAME=MGID_OK><H1 CLASS="APISYMBOL">MGID_OK</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGID_OK</B> - The predefined identifier for 
the "OK" push button in a dialog<P></DD>
</DL>
<HR>
<LEFT><A NAME=MGID_PROMPT><H1 CLASS="APISYMBOL">MGID_PROMPT</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGID_PROMPT</B> - The predefined identifier for 
the "Prompt" text control in a editor tool 
dialog<P></DD>
</DL>
<HR>
<LEFT><A NAME=MGID_REDO><H1 CLASS="APISYMBOL">MGID_REDO</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGID_REDO</B> - The predefined identifier for 
the "Redo" push button control in a editor tool 
dialog<P></DD>
</DL>
<HR>
<LEFT><A NAME=MGID_UNDO><H1 CLASS="APISYMBOL">MGID_UNDO</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGID_UNDO</B> - The predefined identifier for 
the "Undo" push button in a editor tool 
dialog<P></DD>
</DL>
<HR>
<LEFT><A NAME=MGLBS_NONE><H1 CLASS="APISYMBOL">MGLBS_NONE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGLBS_NONE</B> - Control Attribute GL Border Style <I>None</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Control Attribute <I>GL Border Style</I> 
<B>MCA_GLBORDERSTYLE</B>.</P></DD><DD><P>If you specify this value for <B>MCA_GLBORDERSTYLE</B> when 
you call <A HREF=#mgControlSetAttribute>mgControlSetAttribute</A>, no border will be drawn 
around the specified GL control. This is the default.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgControlSetAttribute>mgControlSetAttribute</A>, <A HREF=#mgSetGuiCallback>mgSetGuiCallback</A></DD></DL>
<HR>
<LEFT><A NAME=MGLBS_RAISED><H1 CLASS="APISYMBOL">MGLBS_RAISED</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGLBS_RAISED</B> - Control Attribute GL Border Style <I>Raised</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Control Attribute <I>GL Border Style</I> 
<B>MCA_GLBORDERSTYLE</B>.</P></DD><DD><P>If you specify this value for <B>MCA_GLBORDERSTYLE</B> when 
you call <A HREF=#mgControlSetAttribute>mgControlSetAttribute</A>, a raised frame will be drawn 
around the specified GL control.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgControlSetAttribute>mgControlSetAttribute</A>, <A HREF=#mgSetGuiCallback>mgSetGuiCallback</A></DD></DL>
<HR>
<LEFT><A NAME=MGLBS_SOLID><H1 CLASS="APISYMBOL">MGLBS_SOLID</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGLBS_SOLID</B> - Control Attribute GL Border Style <I>Solid</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Control Attribute <I>GL Border Style</I> 
<B>MCA_GLBORDERSTYLE</B>.</P></DD><DD><P>If you specify this value for <B>MCA_GLBORDERSTYLE</B> when 
you call <A HREF=#mgControlSetAttribute>mgControlSetAttribute</A>, a solid frame will be drawn 
around the specified GL control.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgControlSetAttribute>mgControlSetAttribute</A>, <A HREF=#mgSetGuiCallback>mgSetGuiCallback</A></DD></DL>
<HR>
<LEFT><A NAME=MGLBS_SUNKEN><H1 CLASS="APISYMBOL">MGLBS_SUNKEN</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGLBS_SUNKEN</B> - Control Attribute GL Border Style <I>Sunken</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Control Attribute <I>GL Border Style</I> 
<B>MCA_GLBORDERSTYLE</B>.</P></DD><DD><P>If you specify this value for <B>MCA_GLBORDERSTYLE</B> when 
you call <A HREF=#mgControlSetAttribute>mgControlSetAttribute</A>, a sunken frame will be drawn 
around the specified GL control.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgControlSetAttribute>mgControlSetAttribute</A>, <A HREF=#mgSetGuiCallback>mgSetGuiCallback</A></DD></DL>
<HR>
<LEFT><A NAME=MGMA_BUTTON><H1 CLASS="APISYMBOL">MGMA_BUTTON</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGMA_BUTTON</B> - GL Mouse Action <I>Button</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the GL mouse action that is reported 
to GL controls (via the GL mouse function) when the 
user presses, drags or releases a mouse button in 
the control.</P></DD><DD><P>When this action is reported, the <I>callData</I> 
parameter passed to the GL mouse function will be a 
pointer to an object of type <A HREF=#mgglmousebuttondatarec>mgglmousebuttondatarec</A>.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGLSetMouseFunc>mgGLSetMouseFunc</A>, <A HREF=#mgglmousefunc>mgglmousefunc</A></DD></DL>
<HR>
<LEFT><A NAME=MGMA_DOUBLECLICK><H1 CLASS="APISYMBOL">MGMA_DOUBLECLICK</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGMA_DOUBLECLICK</B> - GL Mouse Action <I>Double Click</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the GL mouse action that is reported 
to GL controls (via the GL mouse function) when the 
user double clicks a mouse button in the control.</P></DD><DD><P>When this action is reported, the <I>callData</I> 
parameter passed to the GL mouse function will be a 
pointer to an object of type 
<A HREF=#mgglmousedoubleclickdatarec>mgglmousedoubleclickdatarec</A>.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGLSetMouseFunc>mgGLSetMouseFunc</A>, <A HREF=#mgglmousefunc>mgglmousefunc</A></DD></DL>
<HR>
<LEFT><A NAME=MGMA_MOTION><H1 CLASS="APISYMBOL">MGMA_MOTION</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGMA_MOTION</B> - GL Mouse Action <I>Motion</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the GL mouse action that is reported 
to GL controls (via the GL mouse function) when the 
user moves the mouse pointer over the control 
with no mouse buttons pressed.  This is useful for 
simply tracking the mouse cursor within the GL control.</P></DD><DD><P>When this action is reported, the <I>callData</I> 
parameter passed to the GL mouse function will be a 
pointer to an object of type 
<A HREF=#mgglmousemotiondatarec>mgglmousemotiondatarec</A>.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGLSetMouseFunc>mgGLSetMouseFunc</A>, <A HREF=#mgglmousefunc>mgglmousefunc</A></DD></DL>
<HR>
<LEFT><A NAME=MGMA_WHEEL><H1 CLASS="APISYMBOL">MGMA_WHEEL</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGMA_WHEEL</B> - GL Mouse Action <I>Wheel</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the GL mouse action that is reported 
to GL controls (via the GL mouse function) when the 
user rotates the mouse wheel over the control.</P></DD><DD><P>When this action is reported, the <I>callData</I> 
parameter passed to the GL mouse function will be a 
pointer to an object of type 
<A HREF=#mgglmousewheeldatarec>mgglmousewheeldatarec</A>.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGLSetMouseFunc>mgGLSetMouseFunc</A>, <A HREF=#mgglmousefunc>mgglmousefunc</A></DD></DL>
<HR>
<LEFT><A NAME=MGP_IMAGEGEOINFO><H1 CLASS="APISYMBOL">MGP_IMAGEGEOINFO</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGP_IMAGEGEOINFO</B> - Image importer capability value<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A></DD></DL>
<HR>
<LEFT><A NAME=MGP_IMAGERESOLUTION><H1 CLASS="APISYMBOL">MGP_IMAGERESOLUTION</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGP_IMAGERESOLUTION</B> - Image importer capability value<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A></DD></DL>
<HR>
<LEFT><A NAME=MGP_IMAGEWHOLE><H1 CLASS="APISYMBOL">MGP_IMAGEWHOLE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGP_IMAGEWHOLE</B> - Image importer capability value<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A></DD></DL>
<HR>
<LEFT><A NAME=MGSP_DONOTCHANGE><H1 CLASS="APISYMBOL">MGSP_DONOTCHANGE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGSP_DONOTCHANGE</B> - Gui Size/Position <I>Do Not Change</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When you call <A HREF=#mgGuiSetSize>mgGuiSetSize</A> or <A HREF=#mgGuiSetPos>mgGuiSetPos</A>, 
you may specify MGSP_DONOTCHANGE for any of the 
position or dimension parameters to indicate that you do 
not want that position or dimension value for the gui item 
to change.</P></DD></DT></DL>
<HR>
<LEFT><A NAME=MGVD_FARCLIP><H1 CLASS="APISYMBOL">MGVD_FARCLIP</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVD_FARCLIP</B> - Graphics View Setting <I>Far Clip</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Far Clip". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetDouble>mgGraphicsViewSettingGetDouble</A>, <A HREF=#mgGraphicsViewSettingSetDouble>mgGraphicsViewSettingSetDouble</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVD_FOV><H1 CLASS="APISYMBOL">MGVD_FOV</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVD_FOV</B> - Graphics View Setting <I>Field of View</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Field of View". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetDouble>mgGraphicsViewSettingGetDouble</A>, <A HREF=#mgGraphicsViewSettingSetDouble>mgGraphicsViewSettingSetDouble</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVD_GRIDANGLE><H1 CLASS="APISYMBOL">MGVD_GRIDANGLE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVD_GRIDANGLE</B> - Graphics View Setting <I>Grid Angle</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Grid Angle". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetDouble>mgGraphicsViewSettingGetDouble</A>, <A HREF=#mgGraphicsViewSettingSetDouble>mgGraphicsViewSettingSetDouble</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVD_GRIDRADIUS><H1 CLASS="APISYMBOL">MGVD_GRIDRADIUS</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVD_GRIDRADIUS</B> - Graphics View Setting <I>Grid Radius</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Grid Radius". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetDouble>mgGraphicsViewSettingGetDouble</A>, <A HREF=#mgGraphicsViewSettingSetDouble>mgGraphicsViewSettingSetDouble</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVD_GRIDSPACEX><H1 CLASS="APISYMBOL">MGVD_GRIDSPACEX</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVD_GRIDSPACEX</B> - Graphics View Setting <I>Grid Space X</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Grid Space X". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetDouble>mgGraphicsViewSettingGetDouble</A>, <A HREF=#mgGraphicsViewSettingSetDouble>mgGraphicsViewSettingSetDouble</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVD_GRIDSPACEY><H1 CLASS="APISYMBOL">MGVD_GRIDSPACEY</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVD_GRIDSPACEY</B> - Graphics View Setting <I>Grid Space Y</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Grid Space Y". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetDouble>mgGraphicsViewSettingGetDouble</A>, <A HREF=#mgGraphicsViewSettingSetDouble>mgGraphicsViewSettingSetDouble</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVD_NEARCLIP><H1 CLASS="APISYMBOL">MGVD_NEARCLIP</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVD_NEARCLIP</B> - Graphics View Setting <I>Near Clip</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Near Clip". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetDouble>mgGraphicsViewSettingGetDouble</A>, <A HREF=#mgGraphicsViewSettingSetDouble>mgGraphicsViewSettingSetDouble</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVD_SCALE><H1 CLASS="APISYMBOL">MGVD_SCALE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVD_SCALE</B> - Graphics View Setting <I>Scale</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Scale". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetDouble>mgGraphicsViewSettingGetDouble</A>, <A HREF=#mgGraphicsViewSettingSetDouble>mgGraphicsViewSettingSetDouble</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVD_TARGETFOV><H1 CLASS="APISYMBOL">MGVD_TARGETFOV</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVD_TARGETFOV</B> - Graphics View Setting <I>Target Field of View</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Target Field of View". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetDouble>mgGraphicsViewSettingGetDouble</A>, <A HREF=#mgGraphicsViewSettingSetDouble>mgGraphicsViewSettingSetDouble</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_ANTIALIASLINES><H1 CLASS="APISYMBOL">MGVI_ANTIALIASLINES</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_ANTIALIASLINES</B> - Graphics View Setting <I>Antialias Lines</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Antialias Lines". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_AUTOFOV><H1 CLASS="APISYMBOL">MGVI_AUTOFOV</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_AUTOFOV</B> - Graphics View Setting <I>Auto Field of View</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Auto Field of View". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_AUTOLOD><H1 CLASS="APISYMBOL">MGVI_AUTOLOD</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_AUTOLOD</B> - Graphics View Setting <I>Auto LOD</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Auto LOD". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_AUTONEARFAR><H1 CLASS="APISYMBOL">MGVI_AUTONEARFAR</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_AUTONEARFAR</B> - Graphics View Setting <I>Auto Near/Far</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Auto Near/Far". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_CHANNELHEIGHT><H1 CLASS="APISYMBOL">MGVI_CHANNELHEIGHT</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_CHANNELHEIGHT</B> - Graphics View Setting <I>Channel Height</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Channel Height". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_DRAWBOUNDINGBOXES><H1 CLASS="APISYMBOL">MGVI_DRAWBOUNDINGBOXES</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_DRAWBOUNDINGBOXES</B> - Graphics View Setting <I>Draw Bounding Boxes</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Draw Bounding Boxes". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_DRAWCONSTRUCTIONS><H1 CLASS="APISYMBOL">MGVI_DRAWCONSTRUCTIONS</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_DRAWCONSTRUCTIONS</B> - Graphics View Setting <I>Draw Constructions</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Draw Constructions". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_DRAWCONTROLPOINTS><H1 CLASS="APISYMBOL">MGVI_DRAWCONTROLPOINTS</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_DRAWCONTROLPOINTS</B> - Graphics View Setting <I>Draw Control Points</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Draw Control Points". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_DRAWDOFAXES><H1 CLASS="APISYMBOL">MGVI_DRAWDOFAXES</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_DRAWDOFAXES</B> - Graphics View Setting <I>Draw Degree of Freedom Axes</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Draw Degree of Freedom Axes". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_DRAWEXTENDEDMATALPHA><H1 CLASS="APISYMBOL">MGVI_DRAWEXTENDEDMATALPHA</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_DRAWEXTENDEDMATALPHA</B> - Graphics View Setting <I>Draw Extended Material Alpha</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Draw Extended Material Alpha". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_DRAWEXTENDEDMATAMBIENT><H1 CLASS="APISYMBOL">MGVI_DRAWEXTENDEDMATAMBIENT</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_DRAWEXTENDEDMATAMBIENT</B> - Graphics View Setting <I>Draw Extended Material Ambient</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Draw Extended Material Ambient". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_DRAWEXTENDEDMATBUMPMAP><H1 CLASS="APISYMBOL">MGVI_DRAWEXTENDEDMATBUMPMAP</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_DRAWEXTENDEDMATBUMPMAP</B> - Graphics View Setting <I>Draw Extended Materail Bump Map</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Draw Extended Materail Bump Map". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_DRAWEXTENDEDMATDIFFUSE><H1 CLASS="APISYMBOL">MGVI_DRAWEXTENDEDMATDIFFUSE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_DRAWEXTENDEDMATDIFFUSE</B> - Graphics View Setting <I>Draw Extended Material Diffuse</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Draw Extended Material Diffuse". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_DRAWEXTENDEDMATEMISSIVE><H1 CLASS="APISYMBOL">MGVI_DRAWEXTENDEDMATEMISSIVE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_DRAWEXTENDEDMATEMISSIVE</B> - Graphics View Setting <I>Draw Extended Material Emissive</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Draw Extended Material Emissive". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_DRAWEXTENDEDMATLIGHTMAP><H1 CLASS="APISYMBOL">MGVI_DRAWEXTENDEDMATLIGHTMAP</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_DRAWEXTENDEDMATLIGHTMAP</B> - Graphics View Setting <I>Draw Extended Material Light Map</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Draw Extended Material Light Map". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_DRAWEXTENDEDMATREFLECTION><H1 CLASS="APISYMBOL">MGVI_DRAWEXTENDEDMATREFLECTION</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_DRAWEXTENDEDMATREFLECTION</B> - Graphics View Setting <I>Draw Extended Material Reflection</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Draw Extended Material Reflection". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_DRAWEXTENDEDMATSHADOWMAP><H1 CLASS="APISYMBOL">MGVI_DRAWEXTENDEDMATSHADOWMAP</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_DRAWEXTENDEDMATSHADOWMAP</B> - Graphics View Setting <I>Draw Extended Material Shadow Map</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Draw Extended Material Shadow Map". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_DRAWEXTENDEDMATSPECULAR><H1 CLASS="APISYMBOL">MGVI_DRAWEXTENDEDMATSPECULAR</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_DRAWEXTENDEDMATSPECULAR</B> - Graphics View Setting <I>Draw Extended Material Specular</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Draw Extended Material Specular". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_DRAWFOG><H1 CLASS="APISYMBOL">MGVI_DRAWFOG</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_DRAWFOG</B> - Graphics View Setting <I>Draw Fog</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Draw Fog". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_DRAWGRID><H1 CLASS="APISYMBOL">MGVI_DRAWGRID</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_DRAWGRID</B> - Graphics View Setting <I>Draw Grid</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Draw Grid". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_DRAWLIGHTS><H1 CLASS="APISYMBOL">MGVI_DRAWLIGHTS</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_DRAWLIGHTS</B> - Graphics View Setting <I>Draw Lights</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Draw Lights". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_DRAWLIGHTSLARGE><H1 CLASS="APISYMBOL">MGVI_DRAWLIGHTSLARGE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_DRAWLIGHTSLARGE</B> - Graphics View Setting <I>Draw Lights Large</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Draw Lights Large". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_DRAWMODE><H1 CLASS="APISYMBOL">MGVI_DRAWMODE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_DRAWMODE</B> - Graphics View Setting <I>Draw Mode</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Draw Mode". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_DRAWORDER><H1 CLASS="APISYMBOL">MGVI_DRAWORDER</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_DRAWORDER</B> - Graphics View Setting <I>Draw Order</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Draw Order". 
0 for fixed list, 1 for Z Buffer, 2 for BSP. 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetDouble>mgGraphicsViewSettingGetDouble</A>, <A HREF=#mgGraphicsViewSettingSetDouble>mgGraphicsViewSettingSetDouble</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_DRAWSELECTOUTLINE><H1 CLASS="APISYMBOL">MGVI_DRAWSELECTOUTLINE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_DRAWSELECTOUTLINE</B> - Graphics View Setting <I>Draw Select Outline</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Draw Select Outline". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_DRAWSHADERS><H1 CLASS="APISYMBOL">MGVI_DRAWSHADERS</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_DRAWSHADERS</B> - Graphics View Setting <I>Draw Shaders</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Draw Shaders". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_DRAWTEXTURE><H1 CLASS="APISYMBOL">MGVI_DRAWTEXTURE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_DRAWTEXTURE</B> - Graphics View Setting <I>Draw Texture</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Draw Texture". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_DRAWVERTEXLARGE><H1 CLASS="APISYMBOL">MGVI_DRAWVERTEXLARGE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_DRAWVERTEXLARGE</B> - Graphics View Setting <I>Draw Vertex Large</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Draw Vertex Large". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_DRAWVERTEXNORMALS><H1 CLASS="APISYMBOL">MGVI_DRAWVERTEXNORMALS</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_DRAWVERTEXNORMALS</B> - Graphics View Setting <I>Draw Vertex Normals</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Draw Vertex Normals". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_DRAWVERTEXNUMBERS><H1 CLASS="APISYMBOL">MGVI_DRAWVERTEXNUMBERS</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_DRAWVERTEXNUMBERS</B> - Graphics View Setting <I>Draw Vertex Numbers</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Draw Vertex Numbers". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_DYNAMICBILLBOARDS><H1 CLASS="APISYMBOL">MGVI_DYNAMICBILLBOARDS</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_DYNAMICBILLBOARDS</B> - Graphics View Setting <I>Dynamic Billboards</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Dynamic Billboards". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_DYNAMICTEXTURE><H1 CLASS="APISYMBOL">MGVI_DYNAMICTEXTURE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_DYNAMICTEXTURE</B> - Graphics View Setting <I>Dynamic Texture</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Dynamic Texture". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_DYNAMICWIREFRAME><H1 CLASS="APISYMBOL">MGVI_DYNAMICWIREFRAME</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_DYNAMICWIREFRAME</B> - Graphics View Setting <I>Dynamic Wireframe</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Dynamic Wireframe". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_FREEZEX><H1 CLASS="APISYMBOL">MGVI_FREEZEX</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_FREEZEX</B> - Graphics View Setting <I>Freeze X</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Freeze X". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_FREEZEY><H1 CLASS="APISYMBOL">MGVI_FREEZEY</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_FREEZEY</B> - Graphics View Setting <I>Freeze Y</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Freeze Y". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_FREEZEZ><H1 CLASS="APISYMBOL">MGVI_FREEZEZ</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_FREEZEZ</B> - Graphics View Setting <I>Freeze Z</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Freeze Z". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_GRIDTYPE><H1 CLASS="APISYMBOL">MGVI_GRIDTYPE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_GRIDTYPE</B> - Graphics View Setting <I>Grid Type</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Grid Type". 
0 for rectangular, 1 for radial. 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetDouble>mgGraphicsViewSettingGetDouble</A>, <A HREF=#mgGraphicsViewSettingSetDouble>mgGraphicsViewSettingSetDouble</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_INFRAREDVIEW><H1 CLASS="APISYMBOL">MGVI_INFRAREDVIEW</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_INFRAREDVIEW</B> - Graphics View Setting <I>Infrared View</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Infrared View". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_ORTHO><H1 CLASS="APISYMBOL">MGVI_ORTHO</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_ORTHO</B> - Graphics View Setting <I>Ortho</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Ortho". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_SHRINK><H1 CLASS="APISYMBOL">MGVI_SHRINK</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_SHRINK</B> - Graphics View Setting <I>Shrink</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Shrink". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_SKYCOLOR><H1 CLASS="APISYMBOL">MGVI_SKYCOLOR</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_SKYCOLOR</B> - Graphics View Setting <I>Sky Color</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Sky Color". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_SNAPTOGRID><H1 CLASS="APISYMBOL">MGVI_SNAPTOGRID</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_SNAPTOGRID</B> - Graphics View Setting <I>Snap to Grid</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Snap to Grid". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_TEXTURELAYER><H1 CLASS="APISYMBOL">MGVI_TEXTURELAYER</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_TEXTURELAYER</B> - Graphics View Setting <I>Texture Layer</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Texture Layer". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_VIEWHEIGHT><H1 CLASS="APISYMBOL">MGVI_VIEWHEIGHT</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_VIEWHEIGHT</B> - Graphics View Setting <I>View Height</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "View Height". 
This is the height dimension (in screen pixels) of the graphics view. 
This setting cannot be set, only read.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#MGVI_VIEWWIDTH>MGVI_VIEWWIDTH</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_VIEWWIDTH><H1 CLASS="APISYMBOL">MGVI_VIEWWIDTH</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_VIEWWIDTH</B> - Graphics View Setting <I>View Width</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "View Width". 
This is the width dimension (in screen pixels) of the graphics view. 
This setting cannot be set, only read.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#MGVI_VIEWHEIGHT>MGVI_VIEWHEIGHT</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_WINDOWVIEW><H1 CLASS="APISYMBOL">MGVI_WINDOWVIEW</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_WINDOWVIEW</B> - Graphics View Setting <I>Window View</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Window View". 
You can use this setting to change the pane layout of the database window. 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD><DD><P>The list of accessible window view values include:<BR> 
0 - Zoom View<BR> 
1 - Standard View<BR> 
2 - CAD View<BR> 
3 - Two View</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVI_XRAYMODE><H1 CLASS="APISYMBOL">MGVI_XRAYMODE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVI_XRAYMODE</B> - Graphics View Setting <I>X-Ray Mode</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "X-Ray Mode". 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVM_MODELVIEW><H1 CLASS="APISYMBOL">MGVM_MODELVIEW</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVM_MODELVIEW</B> - Graphics View Setting <I>Model View Matrix</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Model View Matrix".</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetMatrix>mgGraphicsViewSettingGetMatrix</A>, <A HREF=#mgGraphicsViewSettingSetMatrix>mgGraphicsViewSettingSetMatrix</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVM_MODELVIEWPROJECTION><H1 CLASS="APISYMBOL">MGVM_MODELVIEWPROJECTION</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVM_MODELVIEWPROJECTION</B> - Graphics View Setting <I>Model View Projection Matrix</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Model View Projection Matrix".</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetMatrix>mgGraphicsViewSettingGetMatrix</A>, <A HREF=#mgGraphicsViewSettingSetMatrix>mgGraphicsViewSettingSetMatrix</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVM_PROJECTION><H1 CLASS="APISYMBOL">MGVM_PROJECTION</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVM_PROJECTION</B> - Graphics View Setting <I>Projection Matrix</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This name specifies the Graphics View Setting "Projection Matrix".</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetMatrix>mgGraphicsViewSettingGetMatrix</A>, <A HREF=#mgGraphicsViewSettingSetMatrix>mgGraphicsViewSettingSetMatrix</A>, 
<A HREF=#mgsettingname>mgsettingname</A></DD></DL>
<HR>
<LEFT><A NAME=MGVSM_SETALL><H1 CLASS="APISYMBOL">MGVSM_SETALL</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVSM_SETALL</B> - Graphics View Set Mask <I>Set All Views</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Setting this mask causes <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A> and 
<A HREF=#mgGraphicsViewSettingSetDouble>mgGraphicsViewSettingSetDouble</A> to set the graphics view setting for 
all the graphics views of the related database window. 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, <A HREF=#mgGraphicsViewSettingSetDouble>mgGraphicsViewSettingSetDouble</A>, 
<A HREF=#MGVSM_SETCURRENT>MGVSM_SETCURRENT</A></DD></DL>
<HR>
<LEFT><A NAME=MGVSM_SETCURRENT><H1 CLASS="APISYMBOL">MGVSM_SETCURRENT</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MGVSM_SETCURRENT</B> - Graphics View Set Mask <I>Set Current View</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Setting this mask causes <A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A> and 
<A HREF=#mgGraphicsViewSettingSetDouble>mgGraphicsViewSettingSetDouble</A> to set the graphics view setting for 
the current graphics view in Creator only. 
See the Creator documentation for more information on graphics views 
and graphics view settings.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, <A HREF=#mgGraphicsViewSettingSetDouble>mgGraphicsViewSettingSetDouble</A> 
<A HREF=#MGVSM_SETALL>MGVSM_SETALL</A></DD></DL>
<HR>
<LEFT><A NAME=MIMG_BAD_DATA><H1 CLASS="APISYMBOL">MIMG_BAD_DATA</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MIMG_BAD_DATA</B> - (-8) Texture return status indicating error<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD>[0] <A HREF=#MIMG_NO_ERROR>MIMG_NO_ERROR</A> <BR> 
[-1] <A HREF=#MIMG_MALLOC_ERR>MIMG_MALLOC_ERR</A> <BR> 
[-2] <A HREF=#MIMG_OPEN_ERR>MIMG_OPEN_ERR</A> <BR> 
[-3] <A HREF=#MIMG_READ_ERR>MIMG_READ_ERR</A> <BR> 
[-4] <A HREF=#MIMG_WRITE_ERR>MIMG_WRITE_ERR</A> <BR> 
[-5] <A HREF=#MIMG_SEEK_ERR>MIMG_SEEK_ERR</A> <BR> 
[-6] <A HREF=#MIMG_BAD_FILE_TYPE>MIMG_BAD_FILE_TYPE</A> <BR> 
[-7] <A HREF=#MIMG_IMAGE_TOO_BIG>MIMG_IMAGE_TOO_BIG</A> <BR> 
[-9] <A HREF=#MIMG_NO_TILE>MIMG_NO_TILE</A> <BR> 
[-10] <A HREF=#MIMG_TILE_READ_ERR>MIMG_TILE_READ_ERR</A> <BR> 
[-11] <A HREF=#MIMG_TILE_WRITE_ERR>MIMG_TILE_WRITE_ERR</A></DD></DL>
<HR>
<LEFT><A NAME=MIMG_BAD_FILE_TYPE><H1 CLASS="APISYMBOL">MIMG_BAD_FILE_TYPE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MIMG_BAD_FILE_TYPE</B> - (-6) Texture return status indicating bad file error<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD>[0] <A HREF=#MIMG_NO_ERROR>MIMG_NO_ERROR</A> <BR> 
[-1] <A HREF=#MIMG_MALLOC_ERR>MIMG_MALLOC_ERR</A> <BR> 
[-2] <A HREF=#MIMG_OPEN_ERR>MIMG_OPEN_ERR</A> <BR> 
[-3] <A HREF=#MIMG_READ_ERR>MIMG_READ_ERR</A> <BR> 
[-4] <A HREF=#MIMG_WRITE_ERR>MIMG_WRITE_ERR</A> <BR> 
[-5] <A HREF=#MIMG_SEEK_ERR>MIMG_SEEK_ERR</A> <BR> 
[-7] <A HREF=#MIMG_IMAGE_TOO_BIG>MIMG_IMAGE_TOO_BIG</A> <BR> 
[-8] <A HREF=#MIMG_BAD_DATA>MIMG_BAD_DATA</A> <BR> 
[-9] <A HREF=#MIMG_NO_TILE>MIMG_NO_TILE</A> <BR> 
[-10] <A HREF=#MIMG_TILE_READ_ERR>MIMG_TILE_READ_ERR</A> <BR> 
[-11] <A HREF=#MIMG_TILE_WRITE_ERR>MIMG_TILE_WRITE_ERR</A></DD></DL>
<HR>
<LEFT><A NAME=MIMG_GEOEARTH_BESSEL><H1 CLASS="APISYMBOL">MIMG_GEOEARTH_BESSEL</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MIMG_GEOEARTH_BESSEL</B> - Texture Geographic Earth Model <I>Bessel</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for the image geographic Earth model attribute.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetTextureGeoEarthModel>mgGetTextureGeoEarthModel</A>, <A HREF=#mgSetTextureGeoEarthModel>mgSetTextureGeoEarthModel</A></DD></DL>
<HR>
<LEFT><A NAME=MIMG_GEOEARTH_CLARK1866><H1 CLASS="APISYMBOL">MIMG_GEOEARTH_CLARK1866</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MIMG_GEOEARTH_CLARK1866</B> - Texture Geographic Earth Model <I>Clark 1866</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for the image geographic Earth model attribute.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetTextureGeoEarthModel>mgGetTextureGeoEarthModel</A>, <A HREF=#mgSetTextureGeoEarthModel>mgSetTextureGeoEarthModel</A></DD></DL>
<HR>
<LEFT><A NAME=MIMG_GEOEARTH_WGS72><H1 CLASS="APISYMBOL">MIMG_GEOEARTH_WGS72</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MIMG_GEOEARTH_WGS72</B> - Texture Geographic Earth Model <I>WGS72</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for the image geographic Earth model attribute.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetTextureGeoEarthModel>mgGetTextureGeoEarthModel</A>, <A HREF=#mgSetTextureGeoEarthModel>mgSetTextureGeoEarthModel</A></DD></DL>
<HR>
<LEFT><A NAME=MIMG_GEOEARTH_WGS84><H1 CLASS="APISYMBOL">MIMG_GEOEARTH_WGS84</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MIMG_GEOEARTH_WGS84</B> - Texture Geographic Earth Model <I>WGS84</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for the image geographic Earth model attribute.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetTextureGeoEarthModel>mgGetTextureGeoEarthModel</A>, <A HREF=#mgSetTextureGeoEarthModel>mgSetTextureGeoEarthModel</A></DD></DL>
<HR>
<LEFT><A NAME=MIMG_GEOHEMISPHERE_NORTH><H1 CLASS="APISYMBOL">MIMG_GEOHEMISPHERE_NORTH</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MIMG_GEOHEMISPHERE_NORTH</B> - Texture Geographic Hemisphere <I>Northern</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid vMMBX_ERRORalue for the image geographic hemisphere attribute.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetTextureGeoUTMHemisphere>mgGetTextureGeoUTMHemisphere</A>, <A HREF=#mgSetTextureGeoUTMHemisphere>mgSetTextureGeoUTMHemisphere</A></DD></DL>
<HR>
<LEFT><A NAME=MIMG_GEOHEMISPHERE_SOUTH><H1 CLASS="APISYMBOL">MIMG_GEOHEMISPHERE_SOUTH</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MIMG_GEOHEMISPHERE_SOUTH</B> - Texture Geographic Hemisphere <I>Southern</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for the image geographic hemisphere attribute.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetTextureGeoUTMHemisphere>mgGetTextureGeoUTMHemisphere</A>, <A HREF=#mgSetTextureGeoUTMHemisphere>mgSetTextureGeoUTMHemisphere</A></DD></DL>
<HR>
<LEFT><A NAME=MIMG_GEOIMAGEORIGIN_LL><H1 CLASS="APISYMBOL">MIMG_GEOIMAGEORIGIN_LL</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MIMG_GEOIMAGEORIGIN_LL</B> - Texture Image Origin <I>Upper Left</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for the image origin attribute for geographic control.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetTextureGeoImageOrigin>mgGetTextureGeoImageOrigin</A>, <A HREF=#mgSetTextureGeoImageOrigin>mgSetTextureGeoImageOrigin</A></DD></DL>
<HR>
<LEFT><A NAME=MIMG_GEOIMAGEORIGIN_UL><H1 CLASS="APISYMBOL">MIMG_GEOIMAGEORIGIN_UL</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MIMG_GEOIMAGEORIGIN_UL</B> - Texture Image Origin <I>Lower Right</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for the image origin attribute for geographic control.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetTextureGeoImageOrigin>mgGetTextureGeoImageOrigin</A>, <A HREF=#mgSetTextureGeoImageOrigin>mgSetTextureGeoImageOrigin</A></DD></DL>
<HR>
<LEFT><A NAME=MIMG_GEOPROJ_GEODETIC><H1 CLASS="APISYMBOL">MIMG_GEOPROJ_GEODETIC</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MIMG_GEOPROJ_GEODETIC</B> - Texture Geographic Projection <I>Geodetic</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for the image geographic projection attribute.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetTextureGeoProjection>mgGetTextureGeoProjection</A>, <A HREF=#mgSetTextureGeoProjection>mgSetTextureGeoProjection</A></DD></DL>
<HR>
<LEFT><A NAME=MIMG_GEOPROJ_UTM><H1 CLASS="APISYMBOL">MIMG_GEOPROJ_UTM</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MIMG_GEOPROJ_UTM</B> - Texture Geographic Projection <I>UTM</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for the image geographic projection attribute.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetTextureGeoProjection>mgGetTextureGeoProjection</A>, <A HREF=#mgSetTextureGeoProjection>mgSetTextureGeoProjection</A></DD></DL>
<HR>
<LEFT><A NAME=MIMG_GEOTYPE_CTRLPT><H1 CLASS="APISYMBOL">MIMG_GEOTYPE_CTRLPT</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MIMG_GEOTYPE_CTRLPT</B> - Texture Geographic Control type <I>Control Point</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for the image geographic control type attribute.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetTextureGeoType>mgGetTextureGeoType</A>, <A HREF=#mgSetTextureGeoType>mgSetTextureGeoType</A></DD></DL>
<HR>
<LEFT><A NAME=MIMG_IMAGE_TOO_BIG><H1 CLASS="APISYMBOL">MIMG_IMAGE_TOO_BIG</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MIMG_IMAGE_TOO_BIG</B> - (-7) Texture return status indicating error<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD>[0] <A HREF=#MIMG_NO_ERROR>MIMG_NO_ERROR</A> <BR> 
[-1] <A HREF=#MIMG_MALLOC_ERR>MIMG_MALLOC_ERR</A> <BR> 
[-2] <A HREF=#MIMG_OPEN_ERR>MIMG_OPEN_ERR</A> <BR> 
[-3] <A HREF=#MIMG_READ_ERR>MIMG_READ_ERR</A> <BR> 
[-4] <A HREF=#MIMG_WRITE_ERR>MIMG_WRITE_ERR</A> <BR> 
[-5] <A HREF=#MIMG_SEEK_ERR>MIMG_SEEK_ERR</A> <BR> 
[-6] <A HREF=#MIMG_BAD_FILE_TYPE>MIMG_BAD_FILE_TYPE</A> <BR> 
[-8] <A HREF=#MIMG_BAD_DATA>MIMG_BAD_DATA</A> <BR> 
[-9] <A HREF=#MIMG_NO_TILE>MIMG_NO_TILE</A> <BR> 
[-10] <A HREF=#MIMG_TILE_READ_ERR>MIMG_TILE_READ_ERR</A> <BR> 
[-11] <A HREF=#MIMG_TILE_WRITE_ERR>MIMG_TILE_WRITE_ERR</A></DD></DL>
<HR>
<LEFT><A NAME=MIMG_INT><H1 CLASS="APISYMBOL">MIMG_INT</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MIMG_INT</B> - Texture Image type <I>Intensity</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for the image type attribute.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgSetTextureType>mgSetTextureType</A>, 
<A HREF=#mgGetTextureType>mgGetTextureType</A></DD></DL>
<HR>
<LEFT><A NAME=MIMG_INTA><H1 CLASS="APISYMBOL">MIMG_INTA</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MIMG_INTA</B> - Texture Image type <I>Intensity/Alpha</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for the image type attribute.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgSetTextureType>mgSetTextureType</A>, 
<A HREF=#mgGetTextureType>mgGetTextureType</A></DD></DL>
<HR>
<LEFT><A NAME=MIMG_MALLOC_ERR><H1 CLASS="APISYMBOL">MIMG_MALLOC_ERR</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MIMG_MALLOC_ERR</B> - (-1) Texture return status indicating allocation error<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD>[0] <A HREF=#MIMG_NO_ERROR>MIMG_NO_ERROR</A> <BR> 
[-2] <A HREF=#MIMG_OPEN_ERR>MIMG_OPEN_ERR</A> <BR> 
[-3] <A HREF=#MIMG_READ_ERR>MIMG_READ_ERR</A> <BR> 
[-4] <A HREF=#MIMG_WRITE_ERR>MIMG_WRITE_ERR</A> <BR> 
[-5] <A HREF=#MIMG_SEEK_ERR>MIMG_SEEK_ERR</A> <BR> 
[-6] <A HREF=#MIMG_BAD_FILE_TYPE>MIMG_BAD_FILE_TYPE</A> <BR> 
[-7] <A HREF=#MIMG_IMAGE_TOO_BIG>MIMG_IMAGE_TOO_BIG</A> <BR> 
[-8] <A HREF=#MIMG_BAD_DATA>MIMG_BAD_DATA</A> <BR> 
[-9] <A HREF=#MIMG_NO_TILE>MIMG_NO_TILE</A> <BR> 
[-10] <A HREF=#MIMG_TILE_READ_ERR>MIMG_TILE_READ_ERR</A> <BR> 
[-11] <A HREF=#MIMG_TILE_WRITE_ERR>MIMG_TILE_WRITE_ERR</A></DD></DL>
<HR>
<LEFT><A NAME=MIMG_MAXNAMELEN><H1 CLASS="APISYMBOL">MIMG_MAXNAMELEN</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MIMG_MAXNAMELEN</B> - Maximum Subtexture Name Length<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the maximum number of characters allowed 
for a subtexture name.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgsubtexturedata>mgsubtexturedata</A>, <A HREF=#mgSubTextureGet>mgSubTextureGet</A>,  <A HREF=#mgSubTextureAdd>mgSubTextureAdd</A></DD></DL>
<HR>
<LEFT><A NAME=MIMG_NO_ERROR><H1 CLASS="APISYMBOL">MIMG_NO_ERROR</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MIMG_NO_ERROR</B> - [0] Texture return status indicating success<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD>[-1] <A HREF=#MIMG_MALLOC_ERR>MIMG_MALLOC_ERR</A> <BR> 
[-2] <A HREF=#MIMG_OPEN_ERR>MIMG_OPEN_ERR</A> <BR> 
[-3] <A HREF=#MIMG_READ_ERR>MIMG_READ_ERR</A> <BR> 
[-4] <A HREF=#MIMG_WRITE_ERR>MIMG_WRITE_ERR</A> <BR> 
[-5] <A HREF=#MIMG_SEEK_ERR>MIMG_SEEK_ERR</A> <BR> 
[-6] <A HREF=#MIMG_BAD_FILE_TYPE>MIMG_BAD_FILE_TYPE</A> <BR> 
[-7] <A HREF=#MIMG_IMAGE_TOO_BIG>MIMG_IMAGE_TOO_BIG</A> <BR> 
[-8] <A HREF=#MIMG_BAD_DATA>MIMG_BAD_DATA</A> <BR> 
[-9] <A HREF=#MIMG_NO_TILE>MIMG_NO_TILE</A> <BR> 
[-10] <A HREF=#MIMG_TILE_READ_ERR>MIMG_TILE_READ_ERR</A> <BR> 
[-11] <A HREF=#MIMG_TILE_WRITE_ERR>MIMG_TILE_WRITE_ERR</A></DD></DL>
<HR>
<LEFT><A NAME=MIMG_NO_TILE><H1 CLASS="APISYMBOL">MIMG_NO_TILE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MIMG_NO_TILE</B> - (-9) Texture return status indicating error<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD>[0] <A HREF=#MIMG_NO_ERROR>MIMG_NO_ERROR</A> <BR> 
[-1] <A HREF=#MIMG_MALLOC_ERR>MIMG_MALLOC_ERR</A> <BR> 
[-2] <A HREF=#MIMG_OPEN_ERR>MIMG_OPEN_ERR</A> <BR> 
[-3] <A HREF=#MIMG_READ_ERR>MIMG_READ_ERR</A> <BR> 
[-4] <A HREF=#MIMG_WRITE_ERR>MIMG_WRITE_ERR</A> <BR> 
[-5] <A HREF=#MIMG_SEEK_ERR>MIMG_SEEK_ERR</A> <BR> 
[-6] <A HREF=#MIMG_BAD_FILE_TYPE>MIMG_BAD_FILE_TYPE</A> <BR> 
[-7] <A HREF=#MIMG_IMAGE_TOO_BIG>MIMG_IMAGE_TOO_BIG</A> <BR> 
[-8] <A HREF=#MIMG_BAD_DATA>MIMG_BAD_DATA</A> <BR> 
[-10] <A HREF=#MIMG_TILE_READ_ERR>MIMG_TILE_READ_ERR</A> <BR> 
[-11] <A HREF=#MIMG_TILE_WRITE_ERR>MIMG_TILE_WRITE_ERR</A></DD></DL>
<HR>
<LEFT><A NAME=MIMG_OPEN_ERR><H1 CLASS="APISYMBOL">MIMG_OPEN_ERR</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MIMG_OPEN_ERR</B> - (-2) Texture return status indicating open error<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD>[0] <A HREF=#MIMG_NO_ERROR>MIMG_NO_ERROR</A> <BR> 
[-1] <A HREF=#MIMG_MALLOC_ERR>MIMG_MALLOC_ERR</A> <BR> 
[-3] <A HREF=#MIMG_READ_ERR>MIMG_READ_ERR</A> <BR> 
[-4] <A HREF=#MIMG_WRITE_ERR>MIMG_WRITE_ERR</A> <BR> 
[-5] <A HREF=#MIMG_SEEK_ERR>MIMG_SEEK_ERR</A> <BR> 
[-6] <A HREF=#MIMG_BAD_FILE_TYPE>MIMG_BAD_FILE_TYPE</A> <BR> 
[-7] <A HREF=#MIMG_IMAGE_TOO_BIG>MIMG_IMAGE_TOO_BIG</A> <BR> 
[-8] <A HREF=#MIMG_BAD_DATA>MIMG_BAD_DATA</A> <BR> 
[-9] <A HREF=#MIMG_NO_TILE>MIMG_NO_TILE</A> <BR> 
[-10] <A HREF=#MIMG_TILE_READ_ERR>MIMG_TILE_READ_ERR</A> <BR> 
[-11] <A HREF=#MIMG_TILE_WRITE_ERR>MIMG_TILE_WRITE_ERR</A></DD></DL>
<HR>
<LEFT><A NAME=MIMG_READ_ERR><H1 CLASS="APISYMBOL">MIMG_READ_ERR</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MIMG_READ_ERR</B> - (-3) Texture return status indicating read error<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD>[0] <A HREF=#MIMG_NO_ERROR>MIMG_NO_ERROR</A> <BR> 
[-1] <A HREF=#MIMG_MALLOC_ERR>MIMG_MALLOC_ERR</A> <BR> 
[-2] <A HREF=#MIMG_OPEN_ERR>MIMG_OPEN_ERR</A> <BR> 
[-4] <A HREF=#MIMG_WRITE_ERR>MIMG_WRITE_ERR</A> <BR> 
[-5] <A HREF=#MIMG_SEEK_ERR>MIMG_SEEK_ERR</A> <BR> 
[-6] <A HREF=#MIMG_BAD_FILE_TYPE>MIMG_BAD_FILE_TYPE</A> <BR> 
[-7] <A HREF=#MIMG_IMAGE_TOO_BIG>MIMG_IMAGE_TOO_BIG</A> <BR> 
[-8] <A HREF=#MIMG_BAD_DATA>MIMG_BAD_DATA</A> <BR> 
[-9] <A HREF=#MIMG_NO_TILE>MIMG_NO_TILE</A> <BR> 
[-10] <A HREF=#MIMG_TILE_READ_ERR>MIMG_TILE_READ_ERR</A> <BR> 
[-11] <A HREF=#MIMG_TILE_WRITE_ERR>MIMG_TILE_WRITE_ERR</A></DD></DL>
<HR>
<LEFT><A NAME=MIMG_RGB><H1 CLASS="APISYMBOL">MIMG_RGB</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MIMG_RGB</B> - Texture Image type <I>RGB</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for the image type attribute.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgSetTextureType>mgSetTextureType</A>, 
<A HREF=#mgGetTextureType>mgGetTextureType</A></DD></DL>
<HR>
<LEFT><A NAME=MIMG_RGBA><H1 CLASS="APISYMBOL">MIMG_RGBA</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MIMG_RGBA</B> - Texture Image type <I>RGBA</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for the image type attribute.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgSetTextureType>mgSetTextureType</A>, 
<A HREF=#mgGetTextureType>mgGetTextureType</A></DD></DL>
<HR>
<LEFT><A NAME=MIMG_SEEK_ERR><H1 CLASS="APISYMBOL">MIMG_SEEK_ERR</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MIMG_SEEK_ERR</B> - (-5) Texture return status indicating seek error<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD>[0] <A HREF=#MIMG_NO_ERROR>MIMG_NO_ERROR</A> <BR> 
[-1] <A HREF=#MIMG_MALLOC_ERR>MIMG_MALLOC_ERR</A> <BR> 
[-2] <A HREF=#MIMG_OPEN_ERR>MIMG_OPEN_ERR</A> <BR> 
[-3] <A HREF=#MIMG_READ_ERR>MIMG_READ_ERR</A> <BR> 
[-4] <A HREF=#MIMG_WRITE_ERR>MIMG_WRITE_ERR</A> <BR> 
[-6] <A HREF=#MIMG_BAD_FILE_TYPE>MIMG_BAD_FILE_TYPE</A> <BR> 
[-7] <A HREF=#MIMG_IMAGE_TOO_BIG>MIMG_IMAGE_TOO_BIG</A> <BR> 
[-8] <A HREF=#MIMG_BAD_DATA>MIMG_BAD_DATA</A> <BR> 
[-9] <A HREF=#MIMG_NO_TILE>MIMG_NO_TILE</A> <BR> 
[-10] <A HREF=#MIMG_TILE_READ_ERR>MIMG_TILE_READ_ERR</A> <BR> 
[-11] <A HREF=#MIMG_TILE_WRITE_ERR>MIMG_TILE_WRITE_ERR</A></DD></DL>
<HR>
<LEFT><A NAME=MIMG_TILE_READ_ERR><H1 CLASS="APISYMBOL">MIMG_TILE_READ_ERR</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MIMG_TILE_READ_ERR</B> - (-10) Texture return status indicating error<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD>[0] <A HREF=#MIMG_NO_ERROR>MIMG_NO_ERROR</A> <BR> 
[-1] <A HREF=#MIMG_MALLOC_ERR>MIMG_MALLOC_ERR</A> <BR> 
[-2] <A HREF=#MIMG_OPEN_ERR>MIMG_OPEN_ERR</A> <BR> 
[-3] <A HREF=#MIMG_READ_ERR>MIMG_READ_ERR</A> <BR> 
[-4] <A HREF=#MIMG_WRITE_ERR>MIMG_WRITE_ERR</A> <BR> 
[-5] <A HREF=#MIMG_SEEK_ERR>MIMG_SEEK_ERR</A> <BR> 
[-6] <A HREF=#MIMG_BAD_FILE_TYPE>MIMG_BAD_FILE_TYPE</A> <BR> 
[-7] <A HREF=#MIMG_IMAGE_TOO_BIG>MIMG_IMAGE_TOO_BIG</A> <BR> 
[-8] <A HREF=#MIMG_BAD_DATA>MIMG_BAD_DATA</A> <BR> 
[-9] <A HREF=#MIMG_NO_TILE>MIMG_NO_TILE</A> <BR> 
[-11] <A HREF=#MIMG_TILE_WRITE_ERR>MIMG_TILE_WRITE_ERR</A></DD></DL>
<HR>
<LEFT><A NAME=MIMG_TILE_WRITE_ERR><H1 CLASS="APISYMBOL">MIMG_TILE_WRITE_ERR</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MIMG_TILE_WRITE_ERR</B> - (-11) Texture return status indicating error<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD>[0] <A HREF=#MIMG_NO_ERROR>MIMG_NO_ERROR</A> <BR> 
[-1] <A HREF=#MIMG_MALLOC_ERR>MIMG_MALLOC_ERR</A> <BR> 
[-2] <A HREF=#MIMG_OPEN_ERR>MIMG_OPEN_ERR</A> <BR> 
[-3] <A HREF=#MIMG_READ_ERR>MIMG_READ_ERR</A> <BR> 
[-4] <A HREF=#MIMG_WRITE_ERR>MIMG_WRITE_ERR</A> <BR> 
[-5] <A HREF=#MIMG_SEEK_ERR>MIMG_SEEK_ERR</A> <BR> 
[-6] <A HREF=#MIMG_BAD_FILE_TYPE>MIMG_BAD_FILE_TYPE</A> <BR> 
[-7] <A HREF=#MIMG_IMAGE_TOO_BIG>MIMG_IMAGE_TOO_BIG</A> <BR> 
[-8] <A HREF=#MIMG_BAD_DATA>MIMG_BAD_DATA</A> <BR> 
[-9] <A HREF=#MIMG_NO_TILE>MIMG_NO_TILE</A> <BR> 
[-10] <A HREF=#MIMG_TILE_READ_ERR>MIMG_TILE_READ_ERR</A></DD></DL>
<HR>
<LEFT><A NAME=MIMG_WRITE_ERR><H1 CLASS="APISYMBOL">MIMG_WRITE_ERR</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MIMG_WRITE_ERR</B> - (-4) Texture return status indicating write error<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD>[0] <A HREF=#MIMG_NO_ERROR>MIMG_NO_ERROR</A> <BR> 
[-1] <A HREF=#MIMG_MALLOC_ERR>MIMG_MALLOC_ERR</A> <BR> 
[-2] <A HREF=#MIMG_OPEN_ERR>MIMG_OPEN_ERR</A> <BR> 
[-3] <A HREF=#MIMG_READ_ERR>MIMG_READ_ERR</A> <BR> 
[-5] <A HREF=#MIMG_SEEK_ERR>MIMG_SEEK_ERR</A> <BR> 
[-6] <A HREF=#MIMG_BAD_FILE_TYPE>MIMG_BAD_FILE_TYPE</A> <BR> 
[-7] <A HREF=#MIMG_IMAGE_TOO_BIG>MIMG_IMAGE_TOO_BIG</A> <BR> 
[-8] <A HREF=#MIMG_BAD_DATA>MIMG_BAD_DATA</A> <BR> 
[-9] <A HREF=#MIMG_NO_TILE>MIMG_NO_TILE</A> <BR> 
[-10] <A HREF=#MIMG_TILE_READ_ERR>MIMG_TILE_READ_ERR</A> <BR> 
[-11] <A HREF=#MIMG_TILE_WRITE_ERR>MIMG_TILE_WRITE_ERR</A></DD></DL>
<HR>
<LEFT><A NAME=MKB_ALTKEY><H1 CLASS="APISYMBOL">MKB_ALTKEY</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MKB_ALTKEY</B> - Keyboard flag <I>Alt Key Down</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When the appropriate mouse input function is 
called to report mouse input activity to an 
editor tool or to a GL control, this keyboard 
flag mask will be set if the <I>Alt Key</I> is down 
when the input was reported.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSetVertexFunc>mgEditorSetVertexFunc</A>, 
<A HREF=#mgEditorSetPointFunc>mgEditorSetPointFunc</A>, <A HREF=#mgEditorSetPickFunc>mgEditorSetPickFunc</A>, 
<A HREF=#mgGLSetMouseFunc>mgGLSetMouseFunc</A></DD></DL>
<HR>
<LEFT><A NAME=MKB_CTRLKEY><H1 CLASS="APISYMBOL">MKB_CTRLKEY</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MKB_CTRLKEY</B> - Keyboard flag <I>Ctrl Key Down</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When the appropriate mouse input function is 
called to report mouse input activity to an 
editor tool or to a GL control, this keyboard 
flag mask will be set if the <I>Ctrl Key</I> is down 
when the input was reported.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSetVertexFunc>mgEditorSetVertexFunc</A>, 
<A HREF=#mgEditorSetPointFunc>mgEditorSetPointFunc</A>, <A HREF=#mgEditorSetPickFunc>mgEditorSetPickFunc</A>, 
<A HREF=#mgGLSetMouseFunc>mgGLSetMouseFunc</A></DD></DL>
<HR>
<LEFT><A NAME=MKB_SHIFTKEY><H1 CLASS="APISYMBOL">MKB_SHIFTKEY</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MKB_SHIFTKEY</B> - Keyboard flag <I>Shift Key Down</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When the appropriate mouse input function is 
called to report mouse input activity to an 
editor tool or to a GL control, this keyboard flag 
mask will be set if either <I>Shift Key</I> is down when 
the input was reported.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSetVertexFunc>mgEditorSetVertexFunc</A>, 
<A HREF=#mgEditorSetPointFunc>mgEditorSetPointFunc</A>, <A HREF=#mgEditorSetPickFunc>mgEditorSetPickFunc</A>, 
<A HREF=#mgGLSetMouseFunc>mgGLSetMouseFunc</A></DD></DL>
<HR>
<LEFT><A NAME=MMB_LEFTMOUSE><H1 CLASS="APISYMBOL">MMB_LEFTMOUSE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMB_LEFTMOUSE</B> - Mouse Button flag <I>Left Mouse Down</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When the appropriate mouse input function is 
called to report mouse input activity to an 
editor tool or to a GL control, this mouse button 
flag mask will be set if the <I>Left Mouse</I> is down 
when the input was reported.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSetVertexFunc>mgEditorSetVertexFunc</A>, 
<A HREF=#mgEditorSetPointFunc>mgEditorSetPointFunc</A>, <A HREF=#mgEditorSetPickFunc>mgEditorSetPickFunc</A>, 
<A HREF=#mgGLSetMouseFunc>mgGLSetMouseFunc</A></DD></DL>
<HR>
<LEFT><A NAME=MMB_MIDDLEMOUSE><H1 CLASS="APISYMBOL">MMB_MIDDLEMOUSE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMB_MIDDLEMOUSE</B> - Mouse Button flag <I>Middle Mouse Down</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When the appropriate mouse input function is 
called to report mouse input activity to an 
editor tool or to a GL control, this mouse button 
flag mask will be set if the <I>Middle Mouse</I> is down 
when the input was reported.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSetVertexFunc>mgEditorSetVertexFunc</A>, 
<A HREF=#mgEditorSetPointFunc>mgEditorSetPointFunc</A>, <A HREF=#mgEditorSetPickFunc>mgEditorSetPickFunc</A>, 
<A HREF=#mgGLSetMouseFunc>mgGLSetMouseFunc</A></DD></DL>
<HR>
<LEFT><A NAME=MMB_RIGHTMOUSE><H1 CLASS="APISYMBOL">MMB_RIGHTMOUSE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMB_RIGHTMOUSE</B> - Mouse Button flag <I>Right Mouse Down</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When the appropriate mouse input function is 
called to report mouse input activity to an 
editor tool or to a GL control, this mouse button 
flag mask will be set if the <I>Right Mouse</I> is down 
when the input was reported.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSetVertexFunc>mgEditorSetVertexFunc</A>, 
<A HREF=#mgEditorSetPointFunc>mgEditorSetPointFunc</A>, <A HREF=#mgEditorSetPickFunc>mgEditorSetPickFunc</A>, 
<A HREF=#mgGLSetMouseFunc>mgGLSetMouseFunc</A></DD></DL>
<HR>
<LEFT><A NAME=MMBX_ERROR><H1 CLASS="APISYMBOL">MMBX_ERROR</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMBX_ERROR</B> - <A HREF=#mgMessageDialog>mgMessageDialog</A> flag indicating that 
the error icon (stop sign) be displayed in the dialog<P></DD>
</DL>
<HR>
<LEFT><A NAME=MMBX_OK><H1 CLASS="APISYMBOL">MMBX_OK</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMBX_OK</B> - <A HREF=#mgMessageDialog>mgMessageDialog</A> flag indicating that 
a single push button "OK" be displayed in the dialog<P></DD>
</DL>
<HR>
<LEFT><A NAME=MMBX_OKCANCEL><H1 CLASS="APISYMBOL">MMBX_OKCANCEL</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMBX_OKCANCEL</B> - <A HREF=#mgMessageDialog>mgMessageDialog</A> flag indicating that 
two push buttons, "OK" and "Cancel" be displayed in the dialog<P></DD>
</DL>
<HR>
<LEFT><A NAME=MMBX_QUESTION><H1 CLASS="APISYMBOL">MMBX_QUESTION</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMBX_QUESTION</B> - <A HREF=#mgMessageDialog>mgMessageDialog</A> flag indicating that 
the question icon (question mark) be displayed in the dialog<P></DD>
</DL>
<HR>
<LEFT><A NAME=MMBX_STATUS><H1 CLASS="APISYMBOL">MMBX_STATUS</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMBX_STATUS</B> - <A HREF=#mgMessageDialog>mgMessageDialog</A> flag indicating that 
the status icon (lower case i) be displayed in the dialog<P></DD>
</DL>
<HR>
<LEFT><A NAME=MMBX_WARNING><H1 CLASS="APISYMBOL">MMBX_WARNING</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMBX_WARNING</B> - <A HREF=#mgMessageDialog>mgMessageDialog</A> flag indicating that 
the warning icon (exclamation point ) be displayed in the dialog<P></DD>
</DL>
<HR>
<LEFT><A NAME=MMBX_YESNO><H1 CLASS="APISYMBOL">MMBX_YESNO</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMBX_YESNO</B> - <A HREF=#mgMessageDialog>mgMessageDialog</A> flag indicating that 
two push buttons, "Yes" and "No" be displayed in the dialog<P></DD>
</DL>
<HR>
<LEFT><A NAME=MMBX_YESNOCANCEL><H1 CLASS="APISYMBOL">MMBX_YESNOCANCEL</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMBX_YESNOCANCEL</B> - <A HREF=#mgMessageDialog>mgMessageDialog</A> flag indicating that 
three push buttons, "Yes", "No" and "Cancel" be displayed 
in the dialog<P></DD>
</DL>
<HR>
<LEFT><A NAME=MMENU_ATTRIBUTES><H1 CLASS="APISYMBOL">MMENU_ATTRIBUTES</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMENU_ATTRIBUTES</B> - Menu Location <I>Attributes</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Menu Location</I> 
<A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A> when 
you register an editor or viewer tool, the menu item for your 
tool is placed in the <I>Attributes</I> menu.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MMENU_BSP><H1 CLASS="APISYMBOL">MMENU_BSP</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMENU_BSP</B> - Menu Location <I>BSP</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Menu Location</I> 
<A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A> when 
you register an editor or viewer tool, the menu item for your 
tool is placed in the <I>BSP</I> menu.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MMENU_EDIT><H1 CLASS="APISYMBOL">MMENU_EDIT</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMENU_EDIT</B> - Menu Location <I>Edit</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Menu Location</I> 
<A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A> when 
you register an editor or viewer tool, the menu item for your 
tool is placed in the <I>Edit</I> menu.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MMENU_EXTENSIONS><H1 CLASS="APISYMBOL">MMENU_EXTENSIONS</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMENU_EXTENSIONS</B> - Menu Location <I>Extensions</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Menu Location</I> 
<A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A> when 
you register an editor or viewer tool, the menu item for your 
tool is placed in the <I>Extensions</I> menu.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MMENU_FILE><H1 CLASS="APISYMBOL">MMENU_FILE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMENU_FILE</B> - Menu Location <I>File</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Menu Location</I> 
<A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A> when 
you register an editor or viewer tool, the menu item for your 
tool is placed in the <I>File</I> menu.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MMENU_GEOFEATURE><H1 CLASS="APISYMBOL">MMENU_GEOFEATURE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMENU_GEOFEATURE</B> - Menu Location <I>GeoFeature</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Menu Location</I> 
<A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A> when 
you register an editor or viewer tool, the menu item for your 
tool is placed in the <I>GeoFeature</I> menu.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MMENU_HELP><H1 CLASS="APISYMBOL">MMENU_HELP</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMENU_HELP</B> - Menu Location <I>Help</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Menu Location</I> 
<A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A> when 
you register an editor or viewer tool, the menu item for your 
tool is placed in the <I>Help</I> menu.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MMENU_INFO><H1 CLASS="APISYMBOL">MMENU_INFO</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMENU_INFO</B> - Menu Location <I>Info</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Menu Location</I> 
<A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A> when 
you register an editor or viewer tool, the menu item for your 
tool is placed in the <I>Info</I> menu.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MMENU_INSTRUMENTS><H1 CLASS="APISYMBOL">MMENU_INSTRUMENTS</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMENU_INSTRUMENTS</B> - Menu Location <I>Instruments</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Menu Location</I> 
<A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A> when 
you register an editor or viewer tool, the menu item for your 
tool is placed in the <I>Instruments</I> menu.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MMENU_LOCALDOF><H1 CLASS="APISYMBOL">MMENU_LOCALDOF</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMENU_LOCALDOF</B> - Menu Location <I>Local-DOF</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Menu Location</I> 
<A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A> when 
you register an editor or viewer tool, the menu item for your 
tool is placed in the <I>Local-DOF</I> menu.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MMENU_LOD><H1 CLASS="APISYMBOL">MMENU_LOD</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMENU_LOD</B> - Menu Location <I>LOD</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Menu Location</I> 
<A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A> when 
you register an editor or viewer tool, the menu item for your 
tool is placed in the <I>LOD</I> menu.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MMENU_PALETTES><H1 CLASS="APISYMBOL">MMENU_PALETTES</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMENU_PALETTES</B> - Menu Location <I>Palettes</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Menu Location</I> 
<A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A> when 
you register an editor or viewer tool, the menu item for your 
tool is placed in the <I>Palettes</I> menu.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MMENU_ROAD><H1 CLASS="APISYMBOL">MMENU_ROAD</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMENU_ROAD</B> - Menu Location <I>Road</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Menu Location</I> 
<A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A> when 
you register an editor or viewer tool, the menu item for your 
tool is placed in the <I>Road</I> menu.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MMENU_SCRIPTS><H1 CLASS="APISYMBOL">MMENU_SCRIPTS</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMENU_SCRIPTS</B> - Menu Location <I>Scripts</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Menu Location</I> 
<A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A> when 
you register an editor or viewer tool, the menu item for your 
tool is placed in the <I>Scripts</I> menu.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MMENU_SELECT><H1 CLASS="APISYMBOL">MMENU_SELECT</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMENU_SELECT</B> - Menu Location <I>Select</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Menu Location</I> 
<A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A> when 
you register an editor or viewer tool, the menu item for your 
tool is placed in the <I>Select</I> menu.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MMENU_SOUND><H1 CLASS="APISYMBOL">MMENU_SOUND</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMENU_SOUND</B> - Menu Location <I>Sound</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Menu Location</I> 
<A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A> when 
you register an editor or viewer tool, the menu item for your 
tool is placed in the <I>Sound</I> menu.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MMENU_TERRAIN><H1 CLASS="APISYMBOL">MMENU_TERRAIN</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMENU_TERRAIN</B> - Menu Location <I>Terrain</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Menu Location</I> 
<A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A> when 
you register an editor or viewer tool, the menu item for your 
tool is placed in the <I>Terrain</I> menu.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MMENU_VIEW><H1 CLASS="APISYMBOL">MMENU_VIEW</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMENU_VIEW</B> - Menu Location <I>View</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Menu Location</I> 
<A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A> when 
you register an editor or viewer tool, the menu item for your 
tool is placed in the <I>View</I> menu.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MMESH_VTXCOLOR><H1 CLASS="APISYMBOL">MMESH_VTXCOLOR</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMESH_VTXCOLOR</B> - Mesh Vertex Mask Bit for 
Vertex Color Index<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Mesh vertex mask bit indicating that the 
vertices in a mesh contain 
color index (index, intensity) data.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshSetVtxMask>mgMeshSetVtxMask</A>, 
<A HREF=#mgMeshCreateVtxPool>mgMeshCreateVtxPool</A>, <A HREF=#mgMeshGetVtxOffset>mgMeshGetVtxOffset</A></DD></DL>
<HR>
<LEFT><A NAME=MMESH_VTXCOLORRGB><H1 CLASS="APISYMBOL">MMESH_VTXCOLORRGB</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMESH_VTXCOLORRGB</B> - Mesh Vertex Mask Bit for 
Vertex Color RGB<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Mesh vertex mask bit indicating that the 
vertices in a mesh contain color RGB data.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshSetVtxMask>mgMeshSetVtxMask</A>, 
<A HREF=#mgMeshCreateVtxPool>mgMeshCreateVtxPool</A>, <A HREF=#mgMeshGetVtxOffset>mgMeshGetVtxOffset</A></DD></DL>
<HR>
<LEFT><A NAME=MMESH_VTXCOORD><H1 CLASS="APISYMBOL">MMESH_VTXCOORD</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMESH_VTXCOORD</B> - Mesh Vertex Mask Bit for 
Vertex Coordinates<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Mesh vertex mask bit indicating that the 
vertices in a mesh contain 
coordinate position (x,y,z) data.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshSetVtxMask>mgMeshSetVtxMask</A>, 
<A HREF=#mgMeshCreateVtxPool>mgMeshCreateVtxPool</A>, <A HREF=#mgMeshGetVtxOffset>mgMeshGetVtxOffset</A></DD></DL>
<HR>
<LEFT><A NAME=MMESH_VTXNORMAL><H1 CLASS="APISYMBOL">MMESH_VTXNORMAL</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMESH_VTXNORMAL</B> - Mesh Vertex Mask Bit for 
Vertex Normal<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Mesh vertex mask bit indicating that the 
vertices in a mesh contain normals.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshSetVtxMask>mgMeshSetVtxMask</A>, 
<A HREF=#mgMeshCreateVtxPool>mgMeshCreateVtxPool</A>, <A HREF=#mgMeshGetVtxOffset>mgMeshGetVtxOffset</A></DD></DL>
<HR>
<LEFT><A NAME=MMESH_VTXUV0><H1 CLASS="APISYMBOL">MMESH_VTXUV0</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMESH_VTXUV0</B> - Mesh Vertex Mask Bit for 
Texture Coordinates Layer 0<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Mesh vertex mask bit indicating that the 
vertices in a mesh contain 
texture coordinates for layer 0 (base layer).</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshSetVtxMask>mgMeshSetVtxMask</A>, 
<A HREF=#mgMeshCreateVtxPool>mgMeshCreateVtxPool</A>, <A HREF=#mgMeshGetVtxOffset>mgMeshGetVtxOffset</A></DD></DL>
<HR>
<LEFT><A NAME=MMESH_VTXUV1><H1 CLASS="APISYMBOL">MMESH_VTXUV1</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMESH_VTXUV1</B> - Mesh Vertex Mask Bit for 
Texture Coordinates Layer 1<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Mesh vertex mask bit indicating that the 
vertices in a mesh contain 
texture coordinates for layer 1.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshSetVtxMask>mgMeshSetVtxMask</A>, 
<A HREF=#mgMeshCreateVtxPool>mgMeshCreateVtxPool</A>, <A HREF=#mgMeshGetVtxOffset>mgMeshGetVtxOffset</A></DD></DL>
<HR>
<LEFT><A NAME=MMESH_VTXUV2><H1 CLASS="APISYMBOL">MMESH_VTXUV2</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMESH_VTXUV2</B> - Mesh Vertex Mask Bit for 
Texture Coordinates Layer 2<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Mesh vertex mask bit indicating that the 
vertices in a mesh contain 
texture coordinates for layer 2.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshSetVtxMask>mgMeshSetVtxMask</A>, 
<A HREF=#mgMeshCreateVtxPool>mgMeshCreateVtxPool</A>, <A HREF=#mgMeshGetVtxOffset>mgMeshGetVtxOffset</A></DD></DL>
<HR>
<LEFT><A NAME=MMESH_VTXUV3><H1 CLASS="APISYMBOL">MMESH_VTXUV3</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMESH_VTXUV3</B> - Mesh Vertex Mask Bit for 
Texture Coordinates Layer 3<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Mesh vertex mask bit indicating that the 
vertices in a mesh contain 
texture coordinates for layer 3.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshSetVtxMask>mgMeshSetVtxMask</A>, 
<A HREF=#mgMeshCreateVtxPool>mgMeshCreateVtxPool</A>, <A HREF=#mgMeshGetVtxOffset>mgMeshGetVtxOffset</A></DD></DL>
<HR>
<LEFT><A NAME=MMESH_VTXUV4><H1 CLASS="APISYMBOL">MMESH_VTXUV4</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMESH_VTXUV4</B> - Mesh Vertex Mask Bit for 
Texture Coordinates Layer 4<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Mesh vertex mask bit indicating that the 
vertices in a mesh contain 
texture coordinates for layer 4.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshSetVtxMask>mgMeshSetVtxMask</A>, 
<A HREF=#mgMeshCreateVtxPool>mgMeshCreateVtxPool</A>, <A HREF=#mgMeshGetVtxOffset>mgMeshGetVtxOffset</A></DD></DL>
<HR>
<LEFT><A NAME=MMESH_VTXUV5><H1 CLASS="APISYMBOL">MMESH_VTXUV5</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMESH_VTXUV5</B> - Mesh Vertex Mask Bit for 
Texture Coordinates Layer 5<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Mesh vertex mask bit indicating that the 
vertices in a mesh contain 
texture coordinates for layer 5.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshSetVtxMask>mgMeshSetVtxMask</A>, 
<A HREF=#mgMeshCreateVtxPool>mgMeshCreateVtxPool</A>, <A HREF=#mgMeshGetVtxOffset>mgMeshGetVtxOffset</A></DD></DL>
<HR>
<LEFT><A NAME=MMESH_VTXUV6><H1 CLASS="APISYMBOL">MMESH_VTXUV6</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMESH_VTXUV6</B> - Mesh Vertex Mask Bit for 
Texture Coordinates Layer 6<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Mesh vertex mask bit indicating that the 
vertices in a mesh contain 
texture coordinates for layer 6.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshSetVtxMask>mgMeshSetVtxMask</A>, 
<A HREF=#mgMeshCreateVtxPool>mgMeshCreateVtxPool</A>, <A HREF=#mgMeshGetVtxOffset>mgMeshGetVtxOffset</A></DD></DL>
<HR>
<LEFT><A NAME=MMESH_VTXUV7><H1 CLASS="APISYMBOL">MMESH_VTXUV7</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MMESH_VTXUV7</B> - Mesh Vertex Mask Bit for 
Texture Coordinates Layer 7<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Mesh vertex mask bit indicating that the 
vertices in a mesh contain 
texture coordinates for layer 7.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshGetVtxMask>mgMeshGetVtxMask</A>, <A HREF=#mgMeshSetVtxMask>mgMeshSetVtxMask</A>, 
<A HREF=#mgMeshCreateVtxPool>mgMeshCreateVtxPool</A>, <A HREF=#mgMeshGetVtxOffset>mgMeshGetVtxOffset</A></DD></DL>
<HR>
<LEFT><A NAME=MPAL_BOOLEANTOOLS><H1 CLASS="APISYMBOL">MPAL_BOOLEANTOOLS</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPAL_BOOLEANTOOLS</B> - Palette Location <I>Boolean</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Palette Location</I> 
<A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A> when 
you register an editor or viewer tool, the palette icon for your 
tool is placed in the <I>Boolean</I> Tool palette.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MPAL_CONSTRUCTIONTOOLS><H1 CLASS="APISYMBOL">MPAL_CONSTRUCTIONTOOLS</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPAL_CONSTRUCTIONTOOLS</B> - Palette Location <I>Construction</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Palette Location</I> 
<A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A> when 
you register an editor or viewer tool, the palette icon for your 
tool is placed in the <I>Construction</I> Tool palette.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MPAL_CREATETOOLS><H1 CLASS="APISYMBOL">MPAL_CREATETOOLS</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPAL_CREATETOOLS</B> - Palette Location <I>Create</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Palette Location</I> 
<A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A> when 
you register an editor or viewer tool, the palette icon for your 
tool is placed in the <I>Create</I> Tool palette.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MPAL_DEFORMTOOLS><H1 CLASS="APISYMBOL">MPAL_DEFORMTOOLS</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPAL_DEFORMTOOLS</B> - Palette Location <I>Deform</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Palette Location</I> 
<A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A> when 
you register an editor or viewer tool, the palette icon for your 
tool is placed in the <I>Deform</I> Tool palette.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MPAL_DUPLICATE><H1 CLASS="APISYMBOL">MPAL_DUPLICATE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPAL_DUPLICATE</B> - Palette Location <I>Duplicate</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Palette Location</I> 
<A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A> when 
you register an editor or viewer tool, the palette icon for your 
tool is placed in the <I>Duplicate</I> Tool palette.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MPAL_FACETOOLS><H1 CLASS="APISYMBOL">MPAL_FACETOOLS</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPAL_FACETOOLS</B> - Palette Location <I>Face</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Palette Location</I> 
<A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A> when 
you register an editor or viewer tool, the palette icon for your 
tool is placed in the <I>Face</I> Tool palette.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MPAL_GEOMETRYTOOLS><H1 CLASS="APISYMBOL">MPAL_GEOMETRYTOOLS</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPAL_GEOMETRYTOOLS</B> - Palette Location <I>Geometry</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Palette Location</I> 
<A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A> when 
you register an editor or viewer tool, the palette icon for your 
tool is placed in the <I>Geometry</I> Tool palette.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MPAL_HIERARCHYTOOLS><H1 CLASS="APISYMBOL">MPAL_HIERARCHYTOOLS</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPAL_HIERARCHYTOOLS</B> - Palette Location <I>Hierarchy</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Palette Location</I> 
<A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A> when 
you register an editor or viewer tool, the palette icon for your 
tool is placed in the <I>Hierarchy</I> Tool palette.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MPAL_MANEUVERTOOLS><H1 CLASS="APISYMBOL">MPAL_MANEUVERTOOLS</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPAL_MANEUVERTOOLS</B> - Palette Location <I>Maneuver</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Palette Location</I> 
<A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A> when 
you register an editor or viewer tool, the palette icon for your 
tool is placed in the <I>Maneuver</I> Tool palette.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MPAL_MAPTEXTURE><H1 CLASS="APISYMBOL">MPAL_MAPTEXTURE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPAL_MAPTEXTURE</B> - Palette Location <I>Map Texture</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Palette Location</I> 
<A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A> when 
you register an editor or viewer tool, the palette icon for your 
tool is placed in the <I>Texture</I> Tool palette.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MPAL_MODIFYFACE><H1 CLASS="APISYMBOL">MPAL_MODIFYFACE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPAL_MODIFYFACE</B> - Palette Location <I>Modify Face</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Palette Location</I> 
<A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A> when 
you register an editor or viewer tool, the palette icon for your 
tool is placed in the <I>ModFace</I> Tool palette.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MPAL_MODIFYGEOMETRY><H1 CLASS="APISYMBOL">MPAL_MODIFYGEOMETRY</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPAL_MODIFYGEOMETRY</B> - Palette Location <I>Modify Geometry</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Palette Location</I> 
<A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A> when 
you register an editor or viewer tool, the palette icon for your 
tool is placed in the <I>ModGeom</I> Tool palette.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MPAL_MODIFYTEXTURE><H1 CLASS="APISYMBOL">MPAL_MODIFYTEXTURE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPAL_MODIFYTEXTURE</B> - Palette Location <I>Modify Texture</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Palette Location</I> 
<A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A> when 
you register an editor or viewer tool, the palette icon for your 
tool is placed in the <I>ModTexture</I> Tool palette.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MPAL_MODIFYVERTEX><H1 CLASS="APISYMBOL">MPAL_MODIFYVERTEX</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPAL_MODIFYVERTEX</B> - Palette Location <I>Modify Vertex</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Palette Location</I> 
<A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A> when 
you register an editor or viewer tool, the palette icon for your 
tool is placed in the <I>ModVertex</I> Tool palette.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MPAL_PROPERTIES><H1 CLASS="APISYMBOL">MPAL_PROPERTIES</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPAL_PROPERTIES</B> - Palette Location <I>Properties</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Palette Location</I> 
<A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A> when 
you register an editor or viewer tool, the palette icon for your 
tool is placed in the <I>Properties</I> Tool palette.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MPAL_WIZARDTOOLS><H1 CLASS="APISYMBOL">MPAL_WIZARDTOOLS</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPAL_WIZARDTOOLS</B> - Palette Location <I>Wizard</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is a valid value for Tool Attribute <I>Palette Location</I> 
<A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A></P></DD><DD><P>If you specify this value for <A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A> when 
you register an editor or viewer tool, the palette icon for your 
tool is placed in the <I>Wizards</I> Tool palette.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MPFA_CALLBACKMASK><H1 CLASS="APISYMBOL">MPFA_CALLBACKMASK</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPFA_CALLBACKMASK</B> - File Browser parameter for specifying the 
callback mask for your dialog function of your file browser<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Specify this as a parameter for <A HREF=#mgPromptDialogFile>mgPromptDialogFile</A> followed 
by an unsigned integer value representing the bitwise combination of 
dialog events selected for the dialog function of your file browser.</P></DD><DD><P>Typically you specify this parameter as well as <A HREF=#MPFA_RESOURCE>MPFA_RESOURCE</A>, 
<A HREF=#MPFA_DIALOGID>MPFA_DIALOGID</A>, <A HREF=#MPFA_DIALOGFUNC>MPFA_DIALOGFUNC</A>, and <A HREF=#MPFA_USERDATA>MPFA_USERDATA</A> together.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This parameter is not supported in Python OpenFlight Script.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPromptDialogFile>mgPromptDialogFile</A>, <A HREF=#mgResourceGetDialog>mgResourceGetDialog</A>, <A HREF=#mgResourceModalDialog>mgResourceModalDialog</A></DD></DL>
<HR>
<LEFT><A NAME=MPFA_DIALOGFUNC><H1 CLASS="APISYMBOL">MPFA_DIALOGFUNC</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPFA_DIALOGFUNC</B> - File Browser parameter for specifying a 
dialog function for your file browser<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Specify this as a parameter for <A HREF=#mgPromptDialogFile>mgPromptDialogFile</A> followed 
by the <A HREF=#mgdialogfunc>mgdialogfunc</A> you want to be called as the dialog function 
of your file browser.</P></DD><DD><P>Typically you specify this parameter as well as <A HREF=#MPFA_RESOURCE>MPFA_RESOURCE</A>, 
<A HREF=#MPFA_DIALOGID>MPFA_DIALOGID</A>, <A HREF=#MPFA_CALLBACKMASK>MPFA_CALLBACKMASK</A> and <A HREF=#MPFA_USERDATA>MPFA_USERDATA</A> together.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This parameter is not supported in Python OpenFlight Script.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPromptDialogFile>mgPromptDialogFile</A>, <A HREF=#mgResourceGetDialog>mgResourceGetDialog</A>, <A HREF=#mgResourceModalDialog>mgResourceModalDialog</A></DD></DL>
<HR>
<LEFT><A NAME=MPFA_DIALOGID><H1 CLASS="APISYMBOL">MPFA_DIALOGID</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPFA_DIALOGID</B> - File Browser parameter for specifying a custom 
dialog template to be used to create the file browser<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Specify this as a parameter for <A HREF=#mgPromptDialogFile>mgPromptDialogFile</A> followed 
by the identifier of your custom dialog template in your resource file.</P></DD><DD><P>Typically you specify this parameter as well as <A HREF=#MPFA_RESOURCE>MPFA_RESOURCE</A>, 
<A HREF=#MPFA_DIALOGFUNC>MPFA_DIALOGFUNC</A>, <A HREF=#MPFA_CALLBACKMASK>MPFA_CALLBACKMASK</A> and <A HREF=#MPFA_USERDATA>MPFA_USERDATA</A> together.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This parameter is not supported in Python OpenFlight Script.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPromptDialogFile>mgPromptDialogFile</A>, <A HREF=#mgResourceGetDialog>mgResourceGetDialog</A>, <A HREF=#mgResourceModalDialog>mgResourceModalDialog</A></DD></DL>
<HR>
<LEFT><A NAME=MPFA_DIRECTORY><H1 CLASS="APISYMBOL">MPFA_DIRECTORY</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPFA_DIRECTORY</B> - File Browser parameter for specifying initial<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Specify this as a parameter for <A HREF=#mgPromptDialogFile>mgPromptDialogFile</A> followed 
by a string indicating the initial directory for the file browser.</P></DD><DD><P>If no value is specified for this attribute the initial directory 
will be the last directory visited or the desktop directory.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPromptDialogFile>mgPromptDialogFile</A></DD></DL>
<HR>
<LEFT><A NAME=MPFA_EXITDIRECTORY><H1 CLASS="APISYMBOL">MPFA_EXITDIRECTORY</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPFA_EXITDIRECTORY</B> - File Browser parameter for receiving the 
name of the "exit" directory at the time the user closes the file browser<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>The exit directory is the last directory selected by the user in the 
file browser while it is open.</P></DD><DD><P>Specify this as a parameter for <A HREF=#mgPromptDialogFile>mgPromptDialogFile</A> followed 
by the address of the character string to receive the active directory 
name. If the user cancels the selection in the file browser, the directory 
returned is not defined.</P></DD></DT></DL>
<DL><DT><H3>C NOTES</H3><DD><P>The exit directory string returned is dynamically allocated 
by <A HREF=#mgPromptDialogFile>mgPromptDialogFile</A>.  When you are done accessing this string, you 
should dispose of it using <A HREF=#mgFree>mgFree</A>.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This parameter is not supported in Python OpenFlight Script.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPromptDialogFile>mgPromptDialogFile</A></DD></DL>
<HR>
<LEFT><A NAME=MPFA_FILENAME><H1 CLASS="APISYMBOL">MPFA_FILENAME</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPFA_FILENAME</B> - File Browser parameter for specifying the initial file<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Specify this as a parameter for <A HREF=#mgPromptDialogFile>mgPromptDialogFile</A> followed 
by a string specifying the file to be selected as the initial file.</P></DD><DD><P>If no value is specified for this attribute no initial file is 
selected.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPromptDialogFile>mgPromptDialogFile</A></DD></DL>
<HR>
<LEFT><A NAME=MPFA_FLAGS><H1 CLASS="APISYMBOL">MPFA_FLAGS</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPFA_FLAGS</B> - File Browser parameter for specifying Flags<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Specify this as a parameter followed by a integer for the 
<A HREF=#mgPromptDialogFile>mgPromptDialogFile</A> indicating the flags for the file browser.</P></DD><DD><P>If no value is specified for this attribute none of the flags 
are set.</P></DD><DD><P>Valid values for MPFA_FLAGS include</P></DD><DD><P><A HREF=#MPFF_OVERWRITEPROMPT>MPFF_OVERWRITEPROMPT</A> - Specify whether the user should be prompted 
with a warning if he tries to overwrite an existing file, only valid for 
<A HREF=#MPFM_SAVE>MPFM_SAVE</A></P></DD><DD><P><A HREF=#MPFF_FILEMUSTEXIST>MPFF_FILEMUSTEXIST</A> - Specify whether the user should be prompted 
with a warning if he tries to open a non-existent file</P></DD><DD><P><A HREF=#MPFF_MULTISELECT>MPFF_MULTISELECT</A> - Specify if the user is allowed to select multiple 
files from the file browser</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPromptDialogFile>mgPromptDialogFile</A></DD></DL>
<HR>
<LEFT><A NAME=MPFA_FULLFILENAME><H1 CLASS="APISYMBOL">MPFA_FULLFILENAME</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPFA_FULLFILENAME</B> - File Browser parameter for specifying the complete 
file name including the path<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Specify this as a parameter for <A HREF=#mgPromptDialogFile>mgPromptDialogFile</A> followed 
by a string specifying the initial file with the path.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPromptDialogFile>mgPromptDialogFile</A></DD></DL>
<HR>
<LEFT><A NAME=MPFA_PATTERN><H1 CLASS="APISYMBOL">MPFA_PATTERN</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPFA_PATTERN</B> - File Browser parameter for specifying the filters<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Specify this as a parameter for <A HREF=#mgPromptDialogFile>mgPromptDialogFile</A> followed 
by a string which specifies one or more description-extension pairs. 
Each description-extension pair is separated using the '|' character 
as shown below:</P></DD><DD><P>OpenFlight Files | *.flt</P></DD><DD><P>Successive pairs are delimited using the "||" character sequence 
as shown below:</P></DD><DD><P>OpenFlight Files | *.flt || Text Files | *.txt</P></DD><DD><P>If no value is specified for this attribute the default pattern 
will be used:</P></DD><DD><P>All Files | *.*</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPromptDialogFile>mgPromptDialogFile</A></DD></DL>
<HR>
<LEFT><A NAME=MPFA_PATTERNINDEX><H1 CLASS="APISYMBOL">MPFA_PATTERNINDEX</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPFA_PATTERNINDEX</B> - File Browser parameter for receiving the 
index of the selected pattern at the time the user closes the file browser<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Specify this as a parameter for <A HREF=#mgPromptDialogFile>mgPromptDialogFile</A> followed 
by the address of the integer value to receive the selected pattern 
index.</P></DD><DD><P>The index returned will be '1' if the user selected the first 
pattern specified by the attribute <A HREF=#MPFA_PATTERN>MPFA_PATTERN</A>, '2' if they selected 
the second, and so on.  Since the default "All Files" pattern is always 
added after the patterns you specify with <A HREF=#MPFA_PATTERN>MPFA_PATTERN</A>, the index 
returned will one greater than the number of patterns you specified if 
the user selected the "All Files" pattern.  If the user cancels the 
selection in the file browser, the index returned is not defined.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This parameter is not supported in Python OpenFlight Script.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPromptDialogFile>mgPromptDialogFile</A>, <A HREF=#MPFA_PATTERN>MPFA_PATTERN</A></DD></DL>
<HR>
<LEFT><A NAME=MPFA_RESOURCE><H1 CLASS="APISYMBOL">MPFA_RESOURCE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPFA_RESOURCE</B> - File Browser parameter for specifying your 
resource when using a custom dialog template for your file browser<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Specify this as a parameter for <A HREF=#mgPromptDialogFile>mgPromptDialogFile</A> followed 
by the <A HREF=#mgresource>mgresource</A> of your plug-in containing your dialog template.</P></DD><DD><P>Typically you specify this parameter as well as <A HREF=#MPFA_DIALOGID>MPFA_DIALOGID</A>, 
<A HREF=#MPFA_DIALOGFUNC>MPFA_DIALOGFUNC</A>, <A HREF=#MPFA_CALLBACKMASK>MPFA_CALLBACKMASK</A> and <A HREF=#MPFA_USERDATA>MPFA_USERDATA</A> together.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This parameter is not supported in Python OpenFlight Script.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPromptDialogFile>mgPromptDialogFile</A>, <A HREF=#mgResourceGetDialog>mgResourceGetDialog</A>, <A HREF=#mgResourceModalDialog>mgResourceModalDialog</A></DD></DL>
<HR>
<LEFT><A NAME=MPFA_TITLE><H1 CLASS="APISYMBOL">MPFA_TITLE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPFA_TITLE</B> - File Browser parameter for specifying Title<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Specify this as a parameter followed by a string for the 
<A HREF=#mgPromptDialogFile>mgPromptDialogFile</A> if you want a title for the file browser.</P></DD><DD><P>If no value is specified for this attribute, the default 
title of Open/Save As will be used.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPromptDialogFile>mgPromptDialogFile</A></DD></DL>
<HR>
<LEFT><A NAME=MPFA_USERDATA><H1 CLASS="APISYMBOL">MPFA_USERDATA</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPFA_USERDATA</B> - File Browser parameter for specifying 
the user data passed in to you dialog function<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Specify this as a parameter for <A HREF=#mgPromptDialogFile>mgPromptDialogFile</A> followed 
by the user data you want to pass to your dialog function.</P></DD><DD><P>Typically you specify this parameter as well as <A HREF=#MPFA_RESOURCE>MPFA_RESOURCE</A>, 
<A HREF=#MPFA_DIALOGID>MPFA_DIALOGID</A>, <A HREF=#MPFA_DIALOGFUNC>MPFA_DIALOGFUNC</A>, and <A HREF=#MPFA_CALLBACKMASK>MPFA_CALLBACKMASK</A> together.</P></DD></DT></DL>
<DL><DT><H3>PYTHON NOTES</H3><DD><P>This parameter is not supported in Python OpenFlight Script.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPromptDialogFile>mgPromptDialogFile</A>, <A HREF=#mgResourceGetDialog>mgResourceGetDialog</A>, <A HREF=#mgResourceModalDialog>mgResourceModalDialog</A></DD></DL>
<HR>
<LEFT><A NAME=MPFF_FILEMUSTEXIST><H1 CLASS="APISYMBOL">MPFF_FILEMUSTEXIST</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPFF_FILEMUSTEXIST</B> - File Browser flag<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This may follow the <I>MPFA_FLAGS</I>. Specifies that the user can type 
only names of existing files in the File Name entry field. If this flag is 
specified and the user enters an invalid name, the dialog box procedure displays a 
warning in a message box</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPromptDialogFile>mgPromptDialogFile</A></DD></DL>
<HR>
<LEFT><A NAME=MPFF_MULTISELECT><H1 CLASS="APISYMBOL">MPFF_MULTISELECT</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPFF_MULTISELECT</B> - File Browser flag<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Specifies that the File browser list box allows multiple selections</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPromptDialogFile>mgPromptDialogFile</A></DD></DL>
<HR>
<LEFT><A NAME=MPFF_OVERWRITEPROMPT><H1 CLASS="APISYMBOL">MPFF_OVERWRITEPROMPT</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPFF_OVERWRITEPROMPT</B> - File Browser flag for overwrite prompting<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This may follow the <I>MPFA_FLAGS</I> and specifies that the file browser 
should prompt the user if he tries to overwrite an existing file. This flag 
is valid for <A HREF=#MPFM_SAVE>MPFM_SAVE</A>.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPromptDialogFile>mgPromptDialogFile</A></DD></DL>
<HR>
<LEFT><A NAME=MPFM_OPEN><H1 CLASS="APISYMBOL">MPFM_OPEN</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPFM_OPEN</B> - File Browser flag for specifying the type of browser<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Specifies that the File browser default type is Open</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPromptDialogFile>mgPromptDialogFile</A></DD></DL>
<HR>
<LEFT><A NAME=MPFM_SAVE><H1 CLASS="APISYMBOL">MPFM_SAVE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPFM_SAVE</B> - File Browser flag for specifying the type of browser<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Specifies that the File browser default type is Save</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPromptDialogFile>mgPromptDialogFile</A></DD></DL>
<HR>
<LEFT><A NAME=MPIXMAP_ARROW><H1 CLASS="APISYMBOL">MPIXMAP_ARROW</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPIXMAP_ARROW</B> - Arrow Pixmap Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
arrow pixmap.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetPixmap>mgResourceGetPixmap</A>, <A HREF=#mgSetPixmap>mgSetPixmap</A></DD></DL>
<HR>
<LEFT><A NAME=MPIXMAP_COPY><H1 CLASS="APISYMBOL">MPIXMAP_COPY</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPIXMAP_COPY</B> - Copy Pixmap Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
copy pixmap.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetPixmap>mgResourceGetPixmap</A>, <A HREF=#mgSetPixmap>mgSetPixmap</A></DD></DL>
<HR>
<LEFT><A NAME=MPIXMAP_CUT><H1 CLASS="APISYMBOL">MPIXMAP_CUT</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPIXMAP_CUT</B> - Cut Pixmap Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
cut pixmap.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetPixmap>mgResourceGetPixmap</A>, <A HREF=#mgSetPixmap>mgSetPixmap</A></DD></DL>
<HR>
<LEFT><A NAME=MPIXMAP_DELETE><H1 CLASS="APISYMBOL">MPIXMAP_DELETE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPIXMAP_DELETE</B> - Delete Pixmap Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
delete pixmap.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetPixmap>mgResourceGetPixmap</A>, <A HREF=#mgSetPixmap>mgSetPixmap</A></DD></DL>
<HR>
<LEFT><A NAME=MPIXMAP_EDIT><H1 CLASS="APISYMBOL">MPIXMAP_EDIT</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPIXMAP_EDIT</B> - Edit Pixmap Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
edit pixmap.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetPixmap>mgResourceGetPixmap</A>, <A HREF=#mgSetPixmap>mgSetPixmap</A></DD></DL>
<HR>
<LEFT><A NAME=MPIXMAP_FENCE><H1 CLASS="APISYMBOL">MPIXMAP_FENCE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPIXMAP_FENCE</B> - Fence Pixmap Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
fence pixmap.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetPixmap>mgResourceGetPixmap</A>, <A HREF=#mgSetPixmap>mgSetPixmap</A></DD></DL>
<HR>
<LEFT><A NAME=MPIXMAP_FITONFENCE><H1 CLASS="APISYMBOL">MPIXMAP_FITONFENCE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPIXMAP_FITONFENCE</B> - Fit on Fence Pixmap Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
fit on fence pixmap.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetPixmap>mgResourceGetPixmap</A>, <A HREF=#mgSetPixmap>mgSetPixmap</A></DD></DL>
<HR>
<LEFT><A NAME=MPIXMAP_LASSO><H1 CLASS="APISYMBOL">MPIXMAP_LASSO</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPIXMAP_LASSO</B> - Lasso Pixmap Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
lasso pixmap.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetPixmap>mgResourceGetPixmap</A>, <A HREF=#mgSetPixmap>mgSetPixmap</A></DD></DL>
<HR>
<LEFT><A NAME=MPIXMAP_NEWFILE><H1 CLASS="APISYMBOL">MPIXMAP_NEWFILE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPIXMAP_NEWFILE</B> - New File Pixmap Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
new file pixmap.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetPixmap>mgResourceGetPixmap</A>, <A HREF=#mgSetPixmap>mgSetPixmap</A></DD></DL>
<HR>
<LEFT><A NAME=MPIXMAP_OPENFILE><H1 CLASS="APISYMBOL">MPIXMAP_OPENFILE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPIXMAP_OPENFILE</B> - Open File Pixmap Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
open file pixmap.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetPixmap>mgResourceGetPixmap</A>, <A HREF=#mgSetPixmap>mgSetPixmap</A></DD></DL>
<HR>
<LEFT><A NAME=MPIXMAP_PANVIEW><H1 CLASS="APISYMBOL">MPIXMAP_PANVIEW</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPIXMAP_PANVIEW</B> - Pan View Pixmap Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
pan view pixmap.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetPixmap>mgResourceGetPixmap</A>, <A HREF=#mgSetPixmap>mgSetPixmap</A></DD></DL>
<HR>
<LEFT><A NAME=MPIXMAP_PASTE><H1 CLASS="APISYMBOL">MPIXMAP_PASTE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPIXMAP_PASTE</B> - Paste Pixmap Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
paste pixmap.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetPixmap>mgResourceGetPixmap</A>, <A HREF=#mgSetPixmap>mgSetPixmap</A></DD></DL>
<HR>
<LEFT><A NAME=MPIXMAP_REDO><H1 CLASS="APISYMBOL">MPIXMAP_REDO</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPIXMAP_REDO</B> - Redo Pixmap Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
redo pixmap.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetPixmap>mgResourceGetPixmap</A>, <A HREF=#mgSetPixmap>mgSetPixmap</A></DD></DL>
<HR>
<LEFT><A NAME=MPIXMAP_ROTATEVIEW><H1 CLASS="APISYMBOL">MPIXMAP_ROTATEVIEW</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPIXMAP_ROTATEVIEW</B> - Rotate View Pixmap Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
rotate view pixmap.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetPixmap>mgResourceGetPixmap</A>, <A HREF=#mgSetPixmap>mgSetPixmap</A></DD></DL>
<HR>
<LEFT><A NAME=MPIXMAP_SAVEFILE><H1 CLASS="APISYMBOL">MPIXMAP_SAVEFILE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPIXMAP_SAVEFILE</B> - Save File Pixmap Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
save file pixmap.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetPixmap>mgResourceGetPixmap</A>, <A HREF=#mgSetPixmap>mgSetPixmap</A></DD></DL>
<HR>
<LEFT><A NAME=MPIXMAP_TEST><H1 CLASS="APISYMBOL">MPIXMAP_TEST</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPIXMAP_TEST</B> - Test Pixmap Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
test pixmap.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetPixmap>mgResourceGetPixmap</A>, <A HREF=#mgSetPixmap>mgSetPixmap</A></DD></DL>
<HR>
<LEFT><A NAME=MPIXMAP_UNDO><H1 CLASS="APISYMBOL">MPIXMAP_UNDO</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPIXMAP_UNDO</B> - Undo Pixmap Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
undo pixmap.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetPixmap>mgResourceGetPixmap</A>, <A HREF=#mgSetPixmap>mgSetPixmap</A></DD></DL>
<HR>
<LEFT><A NAME=MPIXMAP_ZOOMVIEW><H1 CLASS="APISYMBOL">MPIXMAP_ZOOMVIEW</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPIXMAP_ZOOMVIEW</B> - Zoom View Pixmap Identifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the identifier of the predefined 
zoom view pixmap.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetPixmap>mgResourceGetPixmap</A>, <A HREF=#mgSetPixmap>mgSetPixmap</A></DD></DL>
<HR>
<LEFT><A NAME=MPREFD_COALIGNEDVERTEXTOLERANCE><H1 CLASS="APISYMBOL">MPREFD_COALIGNEDVERTEXTOLERANCE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPREFD_COALIGNEDVERTEXTOLERANCE</B> - Modeling Preference Key <I>Coaligned Vertex Tolerance</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This key specifies the Creator Modeling Preference "Coaligned Vertex Tolerance". 
See the Creator documentation for a description of this value.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgModelingPrefGetDouble>mgModelingPrefGetDouble</A>, <A HREF=#mgmodelingprefname>mgmodelingprefname</A></DD></DL>
<HR>
<LEFT><A NAME=MPREFD_COPLANARTOLERANCE><H1 CLASS="APISYMBOL">MPREFD_COPLANARTOLERANCE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPREFD_COPLANARTOLERANCE</B> - Modeling Preference Key <I>Coplanar Tolerance</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This key specifies the Creator Modeling Preference "Coplanar Tolerance". 
See the Creator documentation for a description of this value.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgModelingPrefGetDouble>mgModelingPrefGetDouble</A>, <A HREF=#mgmodelingprefname>mgmodelingprefname</A></DD></DL>
<HR>
<LEFT><A NAME=MPREFD_MATCHVERTEXTOLERANCE><H1 CLASS="APISYMBOL">MPREFD_MATCHVERTEXTOLERANCE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPREFD_MATCHVERTEXTOLERANCE</B> - Modeling Preference Key <I>Match Vertex Tolerance</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This key specifies the Creator Modeling Preference "Match Vertex Tolerance". 
See the Creator documentation for a description of this value.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgModelingPrefGetDouble>mgModelingPrefGetDouble</A>, <A HREF=#mgmodelingprefname>mgmodelingprefname</A></DD></DL>
<HR>
<LEFT><A NAME=MPREFD_SNAPTOANGLE><H1 CLASS="APISYMBOL">MPREFD_SNAPTOANGLE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPREFD_SNAPTOANGLE</B> - Modeling Preference Key <I>Snap To Angle</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This key specifies the Creator Modeling Preference "Snap To Angle". 
See the Creator documentation for a description of this value.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgModelingPrefGetDouble>mgModelingPrefGetDouble</A>, <A HREF=#mgmodelingprefname>mgmodelingprefname</A>, 
<A HREF=#MPREFI_SNAPROTATION>MPREFI_SNAPROTATION</A></DD></DL>
<HR>
<LEFT><A NAME=MPREFI_AUTOAPPLYALTCOLOR><H1 CLASS="APISYMBOL">MPREFI_AUTOAPPLYALTCOLOR</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPREFI_AUTOAPPLYALTCOLOR</B> - Modeling Preference Key <I>Auto Apply Alternate Color</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This key specifies the Creator Modeling Preference "Auto Apply Alternate Color". 
See the Creator documentation for a description of this value.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A>, <A HREF=#mgmodelingprefname>mgmodelingprefname</A></DD></DL>
<HR>
<LEFT><A NAME=MPREFI_AUTOAPPLYIRCODE><H1 CLASS="APISYMBOL">MPREFI_AUTOAPPLYIRCODE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPREFI_AUTOAPPLYIRCODE</B> - Modeling Preference Key <I>Auto Apply IR Code</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This key specifies the Creator Modeling Preference "Auto Apply IR Code". 
See the Creator documentation for a description of this value.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A>, <A HREF=#mgmodelingprefname>mgmodelingprefname</A></DD></DL>
<HR>
<LEFT><A NAME=MPREFI_AUTOAPPLYMATERIAL><H1 CLASS="APISYMBOL">MPREFI_AUTOAPPLYMATERIAL</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPREFI_AUTOAPPLYMATERIAL</B> - Modeling Preference Key <I>Auto Apply Material</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This key specifies the Creator Modeling Preference "Auto Apply Material". 
See the Creator documentation for a description of this value.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A>, <A HREF=#mgmodelingprefname>mgmodelingprefname</A></DD></DL>
<HR>
<LEFT><A NAME=MPREFI_AUTOAPPLYSHADELIT2D><H1 CLASS="APISYMBOL">MPREFI_AUTOAPPLYSHADELIT2D</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPREFI_AUTOAPPLYSHADELIT2D</B> - Modeling Preference Key <I>Auto Apply Shade Lit 2D</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This key specifies the Creator Modeling Preference "Auto Apply Shade Lit 2D". 
See the Creator documentation for a description of this value.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A>, <A HREF=#mgmodelingprefname>mgmodelingprefname</A></DD></DL>
<HR>
<LEFT><A NAME=MPREFI_AUTOAPPLYSHADELIT3D><H1 CLASS="APISYMBOL">MPREFI_AUTOAPPLYSHADELIT3D</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPREFI_AUTOAPPLYSHADELIT3D</B> - Modeling Preference Key <I>Auto Apply Shade Lit 3D</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This key specifies the Creator Modeling Preference "Auto Apply Shade Lit 3D". 
See the Creator documentation for a description of this value.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A>, <A HREF=#mgmodelingprefname>mgmodelingprefname</A></DD></DL>
<HR>
<LEFT><A NAME=MPREFI_DRAWHANDLESONTOP><H1 CLASS="APISYMBOL">MPREFI_DRAWHANDLESONTOP</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPREFI_DRAWHANDLESONTOP</B> - Modeling Preference Key <I>Draw Handles on Top</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This key specifies the Creator Modeling Preference "Draw Handles on Top". 
See the Creator documentation for a description of this value.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A>, <A HREF=#mgmodelingprefname>mgmodelingprefname</A></DD></DL>
<HR>
<LEFT><A NAME=MPREFI_FLIPDDSIMAGES><H1 CLASS="APISYMBOL">MPREFI_FLIPDDSIMAGES</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPREFI_FLIPDDSIMAGES</B> - Modeling Preference Key <I>Flip DDS Images</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This key specifies the Creator Modeling Preference "Flip DDS Images". 
See the Creator documentation for a description of this value.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A>, <A HREF=#mgmodelingprefname>mgmodelingprefname</A></DD></DL>
<HR>
<LEFT><A NAME=MPREFI_HANDLETHICKNESS><H1 CLASS="APISYMBOL">MPREFI_HANDLETHICKNESS</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPREFI_HANDLETHICKNESS</B> - Modeling Preference Key <I>Handle Thickness</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This key specifies the Creator Modeling Preference "Handle Thickness". 
See the Creator documentation for a description of this value.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A>, <A HREF=#mgmodelingprefname>mgmodelingprefname</A></DD></DL>
<HR>
<LEFT><A NAME=MPREFI_MOUSEUPZOOMOUT><H1 CLASS="APISYMBOL">MPREFI_MOUSEUPZOOMOUT</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPREFI_MOUSEUPZOOMOUT</B> - Modeling Preference Key <I>Mouse Up Zoom Out</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This key specifies the Creator Modeling Preference "Mouse Up Zoom Out". 
See the Creator documentation for a description of this value.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A>, <A HREF=#mgmodelingprefname>mgmodelingprefname</A></DD></DL>
<HR>
<LEFT><A NAME=MPREFI_SCALEHANDLES><H1 CLASS="APISYMBOL">MPREFI_SCALEHANDLES</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPREFI_SCALEHANDLES</B> - Modeling Preference Key <I>Scale Handles</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This key specifies the Creator Modeling Preference "Scale Handles". 
When <A HREF=#MPREFI_SIZEHANDLES>MPREFI_SIZEHANDLES</A> is 1, 0..100% to change scale of handles in screen. 
See the Creator documentation for a description of this value.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A>, <A HREF=#mgmodelingprefname>mgmodelingprefname</A></DD></DL>
<HR>
<LEFT><A NAME=MPREFI_SHADEWIRE><H1 CLASS="APISYMBOL">MPREFI_SHADEWIRE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPREFI_SHADEWIRE</B> - Modeling Preference Key <I>Shade Wire</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This key specifies the Creator Modeling Preference "Shade Wire". 
See the Creator documentation for a description of this value.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A>, <A HREF=#mgmodelingprefname>mgmodelingprefname</A></DD></DL>
<HR>
<LEFT><A NAME=MPREFI_SIZEHANDLES><H1 CLASS="APISYMBOL">MPREFI_SIZEHANDLES</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPREFI_SIZEHANDLES</B> - Modeling Preference Key <I>Size Handles</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This key specifies the Creator Modeling Preference "Size Handles". 
0 for To Geometry, 1 for To Screen. 
See the Creator documentation for a description of this value.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A>, <A HREF=#mgmodelingprefname>mgmodelingprefname</A></DD></DL>
<HR>
<LEFT><A NAME=MPREFI_SNAPHANDLES><H1 CLASS="APISYMBOL">MPREFI_SNAPHANDLES</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPREFI_SNAPHANDLES</B> - Modeling Preference Key <I>Snap Handles</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This key specifies the Creator Modeling Preference "Snap Handles". 
0 for Off, 1 for On, 2 for On When Grid Snap On. 
See the Creator documentation for a description of this value.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A>, <A HREF=#mgmodelingprefname>mgmodelingprefname</A></DD></DL>
<HR>
<LEFT><A NAME=MPREFI_SNAPROTATION><H1 CLASS="APISYMBOL">MPREFI_SNAPROTATION</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPREFI_SNAPROTATION</B> - Modeling Preference Key <I>Snap Rotation</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This key specifies the Creator Modeling Preference "Snap Rotation". 
See the Creator documentation for a description of this value.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A>, <A HREF=#mgmodelingprefname>mgmodelingprefname</A>, 
<A HREF=#MPREFD_SNAPTOANGLE>MPREFD_SNAPTOANGLE</A></DD></DL>
<HR>
<LEFT><A NAME=MPREFI_TEXTUREPALETTEDIMENSION><H1 CLASS="APISYMBOL">MPREFI_TEXTUREPALETTEDIMENSION</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPREFI_TEXTUREPALETTEDIMENSION</B> - Modeling Preference Key <I>Texture Palette Dimension</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This key specifies the Creator Modeling Preference "Texture Palette Dimension". 
See the Creator documentation for a description of this value.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A>, <A HREF=#mgmodelingprefname>mgmodelingprefname</A></DD></DL>
<HR>
<LEFT><A NAME=MPRIM_INDEXED_POLY><H1 CLASS="APISYMBOL">MPRIM_INDEXED_POLY</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPRIM_INDEXED_POLY</B> - Mesh Primitive Type Indexed Poly<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the mesh primitive type defining an indexed 
polygon. An indexed polygon represents a single N-sided 
polygon defined by the vertices of the mesh primitive.</P></DD><DD><P>One polygon is defined per indexed polygon mesh 
primitive. If an indexed polygon mesh primitive has N vertices, 
1 N-sided closed polygon or 1 (N-1)-sided unclosed polygon 
is defined.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshPrimitiveGetType>mgMeshPrimitiveGetType</A>, <A HREF=#mgMeshPrimitiveGetNumVtx>mgMeshPrimitiveGetNumVtx</A>, 
<A HREF=#mgMeshPrimitiveGetVtxIndexArray>mgMeshPrimitiveGetVtxIndexArray</A>, 
<A HREF=#MPRIM_TRI_STRIP>MPRIM_TRI_STRIP</A>, 
<A HREF=#MPRIM_TRI_FAN>MPRIM_TRI_FAN</A>, 
<A HREF=#MPRIM_QUAD_STRIP>MPRIM_QUAD_STRIP</A></DD></DL>
<HR>
<LEFT><A NAME=MPRIM_QUAD_STRIP><H1 CLASS="APISYMBOL">MPRIM_QUAD_STRIP</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPRIM_QUAD_STRIP</B> - Mesh Primitive Type Quadrilateral Strip<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the mesh primitive type defining a quadrilateral 
strip.  A quadrilateral strip represents a series of 4-sided 
polygons (quadrilaterals) defined by the vertices of the mesh 
primitive.</P></DD><DD><P>One quadrilateral is defined for each pair of vertices 
after the first pair. For any n (starting at 0), the nth 
quadrilateral is defined by vertices 2n, 2n+1, 2n+3 and 2n+2.</P></DD><DD><P>If a quadrilateral strip mesh primitive has N vertices, 
(N/2)-1 quadrilaterals are defined.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshPrimitiveGetType>mgMeshPrimitiveGetType</A>, <A HREF=#mgMeshPrimitiveGetNumVtx>mgMeshPrimitiveGetNumVtx</A>, 
<A HREF=#mgMeshPrimitiveGetVtxIndexArray>mgMeshPrimitiveGetVtxIndexArray</A>, 
<A HREF=#MPRIM_TRI_STRIP>MPRIM_TRI_STRIP</A>, 
<A HREF=#MPRIM_TRI_FAN>MPRIM_TRI_FAN</A>, 
<A HREF=#MPRIM_INDEXED_POLY>MPRIM_INDEXED_POLY</A></DD></DL>
<HR>
<LEFT><A NAME=MPRIM_TRI_FAN><H1 CLASS="APISYMBOL">MPRIM_TRI_FAN</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPRIM_TRI_FAN</B> - Mesh Primitive Type Triangle Fan<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the mesh primitive type defining a triangle 
fan.  A triangle fan represents a series of 3-sided 
polygons (triangles) defined by the vertices of the mesh 
primitive.</P></DD><DD><P>One triangle is defined for each vertex of the 
primitive after the first two. For any n (starting at 0), 
the nth triangle is defined by vertices 0, n+1 and n+2.</P></DD><DD><P>If a triangle fan mesh primitive has N vertices, 
N-2 triangles are defined.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshPrimitiveGetType>mgMeshPrimitiveGetType</A>, <A HREF=#mgMeshPrimitiveGetNumVtx>mgMeshPrimitiveGetNumVtx</A>, 
<A HREF=#mgMeshPrimitiveGetVtxIndexArray>mgMeshPrimitiveGetVtxIndexArray</A>, 
<A HREF=#MPRIM_TRI_STRIP>MPRIM_TRI_STRIP</A>, 
<A HREF=#MPRIM_QUAD_STRIP>MPRIM_QUAD_STRIP</A>, 
<A HREF=#MPRIM_INDEXED_POLY>MPRIM_INDEXED_POLY</A></DD></DL>
<HR>
<LEFT><A NAME=MPRIM_TRI_STRIP><H1 CLASS="APISYMBOL">MPRIM_TRI_STRIP</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MPRIM_TRI_STRIP</B> - Mesh Primitive Type Triangle Strip<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the mesh primitive type defining a triangle 
strip.  A triangle strip represents a series of 3-sided 
polygons (triangles) defined by the vertices of the mesh 
primitive.</P></DD><DD><P>One triangle is defined for each vertex of the 
primitive after the first two. For n (starting at 0), 
the nth triangle is defined as follows. For even n 
(0, 2, 4, etc), the nth triangle is defined by vertices 
n, n+1 and n+2. For odd n (1, 3, 5, etc), the nth triangle 
is defined by vertices n+1, n and n+2.</P></DD><DD><P>If a triangle strip mesh primitive has N vertices, 
N-2 triangles are defined.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMeshPrimitiveGetType>mgMeshPrimitiveGetType</A>, <A HREF=#mgMeshPrimitiveGetNumVtx>mgMeshPrimitiveGetNumVtx</A>, 
<A HREF=#mgMeshPrimitiveGetVtxIndexArray>mgMeshPrimitiveGetVtxIndexArray</A>, 
<A HREF=#MPRIM_TRI_FAN>MPRIM_TRI_FAN</A>, 
<A HREF=#MPRIM_QUAD_STRIP>MPRIM_QUAD_STRIP</A>, 
<A HREF=#MPRIM_INDEXED_POLY>MPRIM_INDEXED_POLY</A></DD></DL>
<HR>
<LEFT><A NAME=MRCB_DESTROY><H1 CLASS="APISYMBOL">MRCB_DESTROY</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MRCB_DESTROY</B> - Renderer event <I>Destroy</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the renderer event that is sent 
to a renderer plug-in tool instance 
(via the renderer callback function) when it 
is destroyed.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterRenderer>mgRegisterRenderer</A>, <A HREF=#mgrendererfunc>mgrendererfunc</A></DD></DL>
<HR>
<LEFT><A NAME=MRCB_DRAW><H1 CLASS="APISYMBOL">MRCB_DRAW</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MRCB_DRAW</B> - Renderer event <I>Draw</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the renderer event that is sent 
to a renderer plug-in tool instance 
(via the renderer callback function) when it 
needs to be drawn.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterRenderer>mgRegisterRenderer</A>, <A HREF=#mgrendererfunc>mgrendererfunc</A></DD></DL>
<HR>
<LEFT><A NAME=MRCB_HIDE><H1 CLASS="APISYMBOL">MRCB_HIDE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MRCB_HIDE</B> - Renderer event <I>Hide</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the renderer event that is sent 
to a renderer plug-in tool instance 
(via the renderer callback function) when it 
changes from displayed to hidden.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterRenderer>mgRegisterRenderer</A>, <A HREF=#mgrendererfunc>mgrendererfunc</A></DD></DL>
<HR>
<LEFT><A NAME=MRCB_INIT><H1 CLASS="APISYMBOL">MRCB_INIT</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MRCB_INIT</B> - Renderer event <I>Initialize</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the renderer event that is sent 
to a renderer plug-in tool instance 
(via the renderer callback function) when it 
is initialized.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterRenderer>mgRegisterRenderer</A>, <A HREF=#mgrendererfunc>mgrendererfunc</A></DD></DL>
<HR>
<LEFT><A NAME=MRCB_SHOW><H1 CLASS="APISYMBOL">MRCB_SHOW</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MRCB_SHOW</B> - Renderer event <I>Show</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the renderer event that is sent 
to a renderer plug-in tool instance 
(via the renderer callback function) when it 
changes from hidden to displayed.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterRenderer>mgRegisterRenderer</A>, <A HREF=#mgrendererfunc>mgrendererfunc</A></DD></DL>
<HR>
<LEFT><A NAME=MRCB_SIZE><H1 CLASS="APISYMBOL">MRCB_SIZE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MRCB_SIZE</B> - Renderer event <I>Size</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the renderer event that is sent 
to a renderer plug-in tool instance 
(via the renderer callback function) when the 
user changes its size.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterRenderer>mgRegisterRenderer</A>, <A HREF=#mgrendererfunc>mgrendererfunc</A></DD></DL>
<HR>
<LEFT><A NAME=MRCB_SYNC><H1 CLASS="APISYMBOL">MRCB_SYNC</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MRCB_SYNC</B> - Renderer event <I>Synchronize</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This is the renderer event that is sent 
to a renderer plug-in tool instance 
(via the renderer callback function) when the 
user wants to synchronize the view.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterRenderer>mgRegisterRenderer</A>, <A HREF=#mgrendererfunc>mgrendererfunc</A></DD></DL>
<HR>
<LEFT><A NAME=MSEL_ALLOWRECURSIVE><H1 CLASS="APISYMBOL">MSEL_ALLOWRECURSIVE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MSEL_ALLOWRECURSIVE</B> - Select Allow Recursive Selection<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Setting this mask causes <A HREF=#mgSelectOneEx>mgSelectOneEx</A> 
to allow selection of nodes whose ancestors or decendents are 
already selected.</P></DD><DD><P>By default, recursive selection is not allowed.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSelectOneEx>mgSelectOneEx</A></DD></DL>
<HR>
<LEFT><A NAME=MSTAT_OK><H1 CLASS="APISYMBOL">MSTAT_OK</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MSTAT_OK</B> - denotes a successful return value for return values of type <A HREF=#mgstatus>mgstatus</A><P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#MSTAT_ISOK>MSTAT_ISOK</A></DD></DL>
<HR>
<LEFT><A NAME=MTA_DESCRIPTION><H1 CLASS="APISYMBOL">MTA_DESCRIPTION</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MTA_DESCRIPTION</B> - Tool Attribute <I>Description</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This string attribute specifies the description text for this tool.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><B>mgRegisterValidator</B></DD></DL>
<HR>
<LEFT><A NAME=MTA_FILETYPE><H1 CLASS="APISYMBOL">MTA_FILETYPE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MTA_FILETYPE</B> - Tool Attribute <I>File Type String</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This string attribute specifies the description text that 
is used in the appropriate File Selection Dialog to describe 
the applicable files for database and image importer and 
database exporter tools.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImporter>mgRegisterImporter</A>, <A HREF=#mgRegisterExporter>mgRegisterExporter</A> 
<A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A></DD></DL>
<HR>
<LEFT><A NAME=MTA_FILTER><H1 CLASS="APISYMBOL">MTA_FILTER</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MTA_FILTER</B> - Tool Attribute <I>Filter String</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This string attribute specifies the pattern string that 
is used in the appropriate File Selection Dialog 
to match files for database and image importer and 
database exporter tools.</P></DD><DD><P>This attribute is typically of the form "*.xyz" where 
xyz is the suffix used to identify applicable files for the 
importer or exporter tool.  To include multiple filters, separate 
each using a semi-colon as in "*.xyz;*.abc;*.ijk";</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImporter>mgRegisterImporter</A>, <A HREF=#mgRegisterExporter>mgRegisterExporter</A> 
<A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A></DD></DL>
<HR>
<LEFT><A NAME=MTA_HELPCONTEXT><H1 CLASS="APISYMBOL">MTA_HELPCONTEXT</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MTA_HELPCONTEXT</B> - Tool Attribute <I>Help Context</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This string attribute specifies the help topic for 
context sensitive help for your plug-in tool.  The help 
context identifies the location in your help file where 
the plug-in tool context sensitive help is found.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImporter>mgRegisterImporter</A>, <A HREF=#mgRegisterExporter>mgRegisterExporter</A>, 
<A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgRegisterViewer>mgRegisterViewer</A>, 
<A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgRegisterInputDevice>mgRegisterInputDevice</A></DD></DL>
<HR>
<LEFT><A NAME=MTA_MENULABEL><H1 CLASS="APISYMBOL">MTA_MENULABEL</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MTA_MENULABEL</B> - Tool Attribute <I>Menu Label</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This string attribute specifies the menu label that 
is placed in the corresponding menu <A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A> 
for a tool.  When the user selects this menu item, the plug-in 
tool is launched.</P></DD><DD><P>You must specify both <A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A> and 
MTA_MENULABEL if you want your tool to be launched from 
a menu.</P></DD><DD><P>To put a horizontal separator before or after your new 
menu item prepend or append, respectively, your menu label 
with the "-" character. 
See the examples that follow.</P></DD></DT></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>Specify the following values for this attribute to put 
a horizontal separator before/after your new menu item:</DT><DT><PRE CLASS="EXAMPLE">-Launch My Tool : Horizontal separator added before your menu item.

Launch My Tool- : Horizontal separator added after your menu item.</PRE></DT></DL></DD></DL>

<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MTA_MENULOCATION><H1 CLASS="APISYMBOL">MTA_MENULOCATION</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MTA_MENULOCATION</B> - Tool Attribute <I>Menu Location</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Specify this tool attribute if you want your 
viewer or editor tool to be launched from a menu.</P></DD><DD><P>This string attribute specifies the menu where 
the corresponding menu label <A HREF=#MTA_MENULABEL>MTA_MENULABEL</A> is 
placed for a tool.</P></DD><DD><P>You must specify both MTA_MENULOCATION and 
<A HREF=#MTA_MENULABEL>MTA_MENULABEL</A> if you want your tool to be launched from 
a menu.</P></DD><DD><P>Possible values for this tool attribute are: <BR> 
<A HREF=#MMENU_FILE>MMENU_FILE</A> - File menu <BR> 
<A HREF=#MMENU_EDIT>MMENU_EDIT</A> - Edit menu <BR> 
<A HREF=#MMENU_VIEW>MMENU_VIEW</A> - View menu <BR> 
<A HREF=#MMENU_INFO>MMENU_INFO</A> - Info menu <BR> 
<A HREF=#MMENU_SELECT>MMENU_SELECT</A> - Select menu <BR> 
<A HREF=#MMENU_ATTRIBUTES>MMENU_ATTRIBUTES</A> - Attributes menu <BR> 
<A HREF=#MMENU_LOD>MMENU_LOD</A> - LOD menu <BR> 
<A HREF=#MMENU_LOCALDOF>MMENU_LOCALDOF</A> - Local-DOF menu <BR> 
<A HREF=#MMENU_PALETTES>MMENU_PALETTES</A> - Palette menu <BR> 
<A HREF=#MMENU_SCRIPTS>MMENU_SCRIPTS</A> - Palette menu <BR> 
<A HREF=#MMENU_TERRAIN>MMENU_TERRAIN</A> - Terrain menu <BR> 
<A HREF=#MMENU_ROAD>MMENU_ROAD</A> - Road menu&#32<BR> 
<A HREF=#MMENU_GEOFEATURE>MMENU_GEOFEATURE</A> - GeoFeature menu&#32<BR> 
<A HREF=#MMENU_SOUND>MMENU_SOUND</A> - Sound menu&#32<BR> 
<A HREF=#MMENU_INSTRUMENTS>MMENU_INSTRUMENTS</A> - Instruments menu&#32<BR> 
<A HREF=#MMENU_BSP>MMENU_BSP</A> - BSP menu <BR></P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MTA_MENUPOSITION><H1 CLASS="APISYMBOL">MTA_MENUPOSITION</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MTA_MENUPOSITION</B> - Tool Attribute <I>Menu Position</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When you want your viewer or editor tool to be 
launched from a menu, you can select another item in the 
menu before or after which your new menu item is to be located.</P></DD><DD><P>This string attribute specifies an existing item in the 
menu you specify by <A HREF=#MTA_MENULOCATION>MTA_MENULOCATION</A>. 
To place your new menu item after the item specified by this 
attribute, precede the menu item with the "&gt" character. 
To place your new menu item before the specified item, use the 
"&lt" character.  If you do not specify "&gt" or "&lt", your 
new menu item will be placed after the specified item. 
See the examples that follow.</P></DD></DT></DL>
<DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT>Specify the following values for this attribute to add 
your new menu item before/after the "Open" menu item:</DT><DT><PRE CLASS="EXAMPLE">&lt Open    : Add new menu item before the "Open" menu item.

&gt Open... : Add new menu item after the "Open" menu item.
Note: The "..." are not required and if included are ignored.

Open      : Add new menu item after the "Open" menu item.
Note: In the absence of "&gt" and "&lt", "&gt" is the default.</PRE></DT></DL></DD></DL>

<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MTA_MENUSUBMENU><H1 CLASS="APISYMBOL">MTA_MENUSUBMENU</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MTA_MENUSUBMENU</B> - Tool Attribute <I>Menu Submenu</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When you specify that your viewer or editor tool is to 
be launched from a menu, you can specify the submenu that will 
contain your new menu item.  If the submenu already exists, your 
new menu item is simply added to that submenu.  If the submenu 
does not exist, it will be created for you.</P></DD><DD><P>This string attribute specifies the submenu where your 
new menu item will be placed.  If you are specifying an existing 
submenu, specify the label string of the existing submenu (just 
as it appears in the menu) as the value of this attribute. 
If you are specifying a new submenu to create, specify the 
label text you want to appear on the submenu.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MTA_NODIALOGPOSITIONPREFERENCE><H1 CLASS="APISYMBOL">MTA_NODIALOGPOSITIONPREFERENCE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MTA_NODIALOGPOSITIONPREFERENCE</B> - Tool Attribute <I>No Dialog 
Position Preference</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This boolean attribute specifies whether or not the position 
of the tool dialog created by this editor tool should be remembered 
and applied to the position of the next editor tool that is launched 
in Creator. Typically when a user repositions an editor tool dialog 
in Creator, its position is used to position the dialog of the next 
editor tool that is launched. Use this attribute to disable that 
behavior for your editor tool dialog.</P></DD><DD><P>By default, this attribute is <A HREF=#mgbool>MG_FALSE</A> indicating that 
the position of this editor tool dialog should be used to position the 
dialog of the next editor tool that is run in Creator.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MTA_NOHIDESELECTOUTLINE><H1 CLASS="APISYMBOL">MTA_NOHIDESELECTOUTLINE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MTA_NOHIDESELECTOUTLINE</B> - Tool Attribute <I>No Hide Select Outline</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This boolean attribute specifies whether or not the select outline 
can be hidden while your editor tool is active.  In Creator, the user 
can choose to Hide Select Outlines while Tool is Active.  When this 
tool attribute is set, the select outline is drawn regardless of the 
user setting.</P></DD><DD><P>By default, this attribute is <A HREF=#mgbool>MG_FALSE</A> indicating that 
the user setting should be honored.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MTA_PALETTEICON><H1 CLASS="APISYMBOL">MTA_PALETTEICON</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MTA_PALETTEICON</B> - Tool Attribute <I>Palette Icon</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This <A HREF=#mgpixmap>mgpixmap</A> attribute specifies the tool icon that 
is placed in the corresponding tool palette <A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A> 
for a tool. When the user clicks on this icon, the plug-in tool 
is launched.</P></DD><DD><P>You must specify both <A HREF=#MTA_PALETTELOCATION>MTA_PALETTELOCATION</A> and 
MTA_PALETTEICON if you want your tool to be launched from 
a tool palette.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MTA_PALETTELOCATION><H1 CLASS="APISYMBOL">MTA_PALETTELOCATION</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MTA_PALETTELOCATION</B> - Tool Attribute <I>Palette Location</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Specify this tool attribute if you want your 
viewer or editor tool to be launched from a tool palette.</P></DD><DD><P>This string attribute specifies the tool palette where 
the corresponding palette icon <A HREF=#MTA_PALETTEICON>MTA_PALETTEICON</A> is 
placed for a tool.</P></DD><DD><P>You must specify both MTA_PALETTELOCATION and 
<A HREF=#MTA_PALETTEICON>MTA_PALETTEICON</A> if you want your tool to be launched from 
a tool palette.</P></DD><DD><P>Possible values for this tool attribute are: <BR> 
<A HREF=#MPAL_FACETOOLS>MPAL_FACETOOLS</A> - Face Tools palette <BR> 
<A HREF=#MPAL_GEOMETRYTOOLS>MPAL_GEOMETRYTOOLS</A> - Geometry Tools palette <BR> 
<A HREF=#MPAL_MANEUVERTOOLS>MPAL_MANEUVERTOOLS</A> - Maneuver Tools palette <BR> 
<A HREF=#MPAL_DUPLICATE>MPAL_DUPLICATE</A> - Duplicate palette <BR> 
<A HREF=#MPAL_DEFORMTOOLS>MPAL_DEFORMTOOLS</A> - Deform Tools palette <BR> 
<A HREF=#MPAL_BOOLEANTOOLS>MPAL_BOOLEANTOOLS</A> - Boolean Tools palette <BR> 
<A HREF=#MPAL_MODIFYGEOMETRY>MPAL_MODIFYGEOMETRY</A> - Modify Geometry palette <BR> 
<A HREF=#MPAL_MODIFYFACE>MPAL_MODIFYFACE</A> - Modify Face palette <BR> 
<A HREF=#MPAL_MODIFYVERTEX>MPAL_MODIFYVERTEX</A> - Modify Vertex palette <BR> 
<A HREF=#MPAL_PROPERTIES>MPAL_PROPERTIES</A> - Properties palette <BR> 
<A HREF=#MPAL_MAPTEXTURE>MPAL_MAPTEXTURE</A> - Map Texture palette <BR> 
<A HREF=#MPAL_MODIFYTEXTURE>MPAL_MODIFYTEXTURE</A> - Modify Texture palette <BR> 
<A HREF=#MPAL_CONSTRUCTIONTOOLS>MPAL_CONSTRUCTIONTOOLS</A> - Construction Tools palette <BR> 
<A HREF=#MPAL_CREATETOOLS>MPAL_CREATETOOLS</A> - Create Tools palette <BR> 
<A HREF=#MPAL_HIERARCHYTOOLS>MPAL_HIERARCHYTOOLS</A> - Hierarchy Tools palette</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MTA_REPEATABLE><H1 CLASS="APISYMBOL">MTA_REPEATABLE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MTA_REPEATABLE</B> - Tool Attribute <I>Repeatable</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This boolean attribute specifies whether or not 
your editor tool is repeatable.  A repeatable tool, 
after being invoked by the user, is added to the 
Repeat History in the <I>Edit</I> menu. 
By default, editor tools are repeatable.  To make 
your editor tool non-repeatable, set this value to 
<A HREF=#mgbool>MG_FALSE</A>.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MTA_SCRIPTABLE><H1 CLASS="APISYMBOL">MTA_SCRIPTABLE</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MTA_SCRIPTABLE</B> - Tool Attribute <I>Scriptable</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This boolean attribute specifies whether or not 
your editor tool is scriptable.  A scriptable tool 
may be invoked by the user via Creator Script. 
By default, editor tools are not scriptable.  To make 
your editor tool scriptable, set this value to 
<A HREF=#mgbool>MG_TRUE</A>.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MTA_TOOLTIP><H1 CLASS="APISYMBOL">MTA_TOOLTIP</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MTA_TOOLTIP</B> - Tool Attribute <I>Tool Tip</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This string attribute specifies the tool tip text that 
is displayed when the user positions the mouse over the 
the palette icon <A HREF=#MTA_PALETTEICON>MTA_PALETTEICON</A> associated with this tool.</P></DD><DD><P>The default tool tip for editor and viewer tools launched 
from a tool palette is the tool name.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterViewer>mgRegisterViewer</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=MTA_VERSION><H1 CLASS="APISYMBOL">MTA_VERSION</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MTA_VERSION</B> - Tool Attribute <I>Version</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This string attribute is displayed in the 
Help on Plugins dialog and may be used by a 
plug-in tool to identify a version or other 
vendor-specific information applicable to the tool.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImporter>mgRegisterImporter</A>, <A HREF=#mgRegisterExporter>mgRegisterExporter</A>, 
<A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgRegisterViewer>mgRegisterViewer</A>, 
<A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgRegisterInputDevice>mgRegisterInputDevice</A></DD></DL>
<HR>
<LEFT><A NAME=MTRUL_HORIZONTAL><H1 CLASS="APISYMBOL">MTRUL_HORIZONTAL</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MTRUL_HORIZONTAL</B> - The <B>MTRUL_ORIENTATION</B> parameter that specifies the direction for a tab ruler control.<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Use this value with the <B>MTRUL_ORIENTATION</B> key in the variable arguments in the <A HREF=#mgNewTabRuler>mgNewTabRuler</A> function.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewTabRuler>mgNewTabRuler</A>, <A HREF=#mgtabruleroption>mgtabruleroption</A></DD></DL>
<HR>
<LEFT><A NAME=MTRUL_VERTICAL><H1 CLASS="APISYMBOL">MTRUL_VERTICAL</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MTRUL_VERTICAL</B> - The <B>MTRUL_ORIENTATION</B> parameter that specifies the direction for a tab ruler control.<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Use this value with the <B>MTRUL_ORIENTATION</B> key in the variable arguments in the <A HREF=#mgNewTabRuler>mgNewTabRuler</A> function.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewTabRuler>mgNewTabRuler</A>, <A HREF=#mgtabruleroption>mgtabruleroption</A></DD></DL>
<HR>
<LEFT><A NAME=MUML_USETOOLNAME><H1 CLASS="APISYMBOL">MUML_USETOOLNAME</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MUML_USETOOLNAME</B> - Undo menu label <I>Use Tool Name</I><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When an editor tool instance registers an undo-able 
action, MUML_USETOOLNAME can be specified for the menu 
label parameter.  If this value is specified as the 
menu label, the name of the editor tool is displayed 
on the undo menu item in the Edit->Undo menu.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorAddUndo>mgEditorAddUndo</A>, 
<A HREF=#mgEditorAddUndoForCreate>mgEditorAddUndoForCreate</A>, <A HREF=#mgEditorAddUndoForDelete>mgEditorAddUndoForDelete</A>, 
<A HREF=#mgEditorAddUndoForMove>mgEditorAddUndoForMove</A></DD></DL>
<HR>
<LEFT><A NAME=MVERSION_API><H1 CLASS="APISYMBOL">MVERSION_API</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MVERSION_API</B> - OpenFlight API Version number<P></DD>
</DL>
<HR>
<LEFT><A NAME=MVERSION_OPENFLIGHT><H1 CLASS="APISYMBOL">MVERSION_OPENFLIGHT</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MVERSION_OPENFLIGHT</B> - OpenFlight Format Version number<P></DD>
</DL>
<HR>
<LEFT><A NAME=MWALK_ATTR><H1 CLASS="APISYMBOL">MWALK_ATTR</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MWALK_ATTR</B> - mgWalk flag Walk Attributes<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Setting this mask causes <A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, 
<A HREF=#mgFind>mgFind</A>, and <A HREF=#mgFindEx>mgFindEx</A> 
to visit attribute nodes.</P></DD><DD><P>By default, attribute nodes are not visited.</P></DD><DD><P>This flag is not yet implemented.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, <A HREF=#mgFind>mgFind</A>, <A HREF=#mgFindEx>mgFindEx</A><BR> 
<A HREF=#MWALK_NEXT>MWALK_NEXT</A><BR> 
<A HREF=#MWALK_VERTEX>MWALK_VERTEX</A><BR> 
<A HREF=#MWALK_MASTER>MWALK_MASTER</A><BR> 
<A HREF=#MWALK_MASTERALL>MWALK_MASTERALL</A><BR> 
<A HREF=#MWALK_ON>MWALK_ON</A><BR> 
<A HREF=#MWALK_NOREADONLY>MWALK_NOREADONLY</A><BR> 
<A HREF=#MWALK_NONESTED>MWALK_NONESTED</A><BR> 
<A HREF=#MWALK_MATRIXSTACK>MWALK_MATRIXSTACK</A></DD></DL>
<HR>
<LEFT><A NAME=MWALK_MASTER><H1 CLASS="APISYMBOL">MWALK_MASTER</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MWALK_MASTER</B> - mgWalk flag Walk Master<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Setting this mask causes <A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, 
<A HREF=#mgFind>mgFind</A>, and <A HREF=#mgFindEx>mgFindEx</A> 
to visit referenced nodes.  If you set this mask without 
setting <A HREF=#MWALK_MASTERALL>MWALK_MASTERALL</A>, referenced nodes will 
only be visited one time no matter how many times 
they are referenced in the database. 
If you set this mask when using <A HREF=#mgWalkRecList>mgWalkRecList</A>, it is 
only used when traversing the children of the nodes in the 
record list.</P></DD><DD><P>Set <A HREF=#MWALK_MASTERALL>MWALK_MASTERALL</A> to visit referenced 
nodes once each time they are referenced.</P></DD><DD><P>By default, referenced nodes are not visited.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, <A HREF=#mgFind>mgFind</A>, <A HREF=#mgFindEx>mgFindEx</A><BR> 
<A HREF=#MWALK_NEXT>MWALK_NEXT</A><BR> 
<A HREF=#MWALK_VERTEX>MWALK_VERTEX</A><BR> 
<A HREF=#MWALK_MASTERALL>MWALK_MASTERALL</A><BR> 
<A HREF=#MWALK_ON>MWALK_ON</A><BR> 
<A HREF=#MWALK_NOREADONLY>MWALK_NOREADONLY</A><BR> 
<A HREF=#MWALK_NONESTED>MWALK_NONESTED</A><BR> 
<A HREF=#MWALK_MATRIXSTACK>MWALK_MATRIXSTACK</A></DD></DL>
<HR>
<LEFT><A NAME=MWALK_MASTERALL><H1 CLASS="APISYMBOL">MWALK_MASTERALL</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MWALK_MASTERALL</B> - mgWalk flag Walk Master All<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Setting this mask causes <A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, 
<A HREF=#mgFind>mgFind</A>, and <A HREF=#mgFindEx>mgFindEx</A> 
to visit referenced nodes once each time they are referenced. 
If you set this mask when using <A HREF=#mgWalkRecList>mgWalkRecList</A>, it is 
only used when traversing the children of the nodes in the 
record list.</P></DD><DD><P>By default, referenced nodes are not visited.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, <A HREF=#mgFind>mgFind</A>, <A HREF=#mgFindEx>mgFindEx</A><BR> 
<A HREF=#MWALK_NEXT>MWALK_NEXT</A><BR> 
<A HREF=#MWALK_VERTEX>MWALK_VERTEX</A><BR> 
<A HREF=#MWALK_MASTER>MWALK_MASTER</A><BR> 
<A HREF=#MWALK_ON>MWALK_ON</A><BR> 
<A HREF=#MWALK_NOREADONLY>MWALK_NOREADONLY</A><BR> 
<A HREF=#MWALK_NONESTED>MWALK_NONESTED</A><BR> 
<A HREF=#MWALK_MATRIXSTACK>MWALK_MATRIXSTACK</A></DD></DL>
<HR>
<LEFT><A NAME=MWALK_MATRIXSTACK><H1 CLASS="APISYMBOL">MWALK_MATRIXSTACK</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MWALK_MATRIXSTACK</B> - mgWalk flag Walk Matrix Stack<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Setting this mask causes <A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, 
<A HREF=#mgFind>mgFind</A>, and <A HREF=#mgFindEx>mgFindEx</A> 
to accumulate a matrix stack while visiting the nodes. 
If you set this mask when using <A HREF=#mgWalkRecList>mgWalkRecList</A>, it is 
only used when traversing the children of the nodes in the 
record list. 
This matrix stack can be accessed during either of the 
walk action functions using the function <A HREF=#mgWalkGetMatrix>mgWalkGetMatrix</A>.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, <A HREF=#mgFind>mgFind</A>, <A HREF=#mgFindEx>mgFindEx</A><BR> 
<A HREF=#MWALK_NEXT>MWALK_NEXT</A><BR> 
<A HREF=#MWALK_VERTEX>MWALK_VERTEX</A><BR> 
<A HREF=#MWALK_MASTER>MWALK_MASTER</A><BR> 
<A HREF=#MWALK_MASTERALL>MWALK_MASTERALL</A><BR> 
<A HREF=#MWALK_ON>MWALK_ON</A><BR> 
<A HREF=#MWALK_NOREADONLY>MWALK_NOREADONLY</A><BR> 
<A HREF=#MWALK_NONESTED>MWALK_NONESTED</A><BR></DD></DL>
<HR>
<LEFT><A NAME=MWALK_NEXT><H1 CLASS="APISYMBOL">MWALK_NEXT</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MWALK_NEXT</B> - mgWalk flag Walk Next<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Setting this mask causes <A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, 
<A HREF=#mgFind>mgFind</A>, and <A HREF=#mgFindEx>mgFindEx</A> 
to visit siblings of the top node being walked as well as the 
children of these siblings.</P></DD><DD><P>By default, siblings are not visited.</P></DD><DD><P>Note: This mask has no effect if used with <A HREF=#mgWalkRecList>mgWalkRecList</A>.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, <A HREF=#mgFind>mgFind</A>, <A HREF=#mgFindEx>mgFindEx</A><BR> 
<A HREF=#MWALK_VERTEX>MWALK_VERTEX</A><BR> 
<A HREF=#MWALK_MASTER>MWALK_MASTER</A><BR> 
<A HREF=#MWALK_MASTERALL>MWALK_MASTERALL</A><BR> 
<A HREF=#MWALK_ON>MWALK_ON</A><BR> 
<A HREF=#MWALK_NOREADONLY>MWALK_NOREADONLY</A><BR> 
<A HREF=#MWALK_NONESTED>MWALK_NONESTED</A><BR> 
<A HREF=#MWALK_MATRIXSTACK>MWALK_MATRIXSTACK</A></DD></DL>
<HR>
<LEFT><A NAME=MWALK_NONESTED><H1 CLASS="APISYMBOL">MWALK_NONESTED</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MWALK_NONESTED</B> - mgWalk flag Walk No Nested<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Setting this mask causes <A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, 
<A HREF=#mgFind>mgFind</A>, and <A HREF=#mgFindEx>mgFindEx</A> 
to not visit nested nodes (subfaces, for example). 
If you set this mask when using <A HREF=#mgWalkRecList>mgWalkRecList</A>, it is 
only used when traversing the children of the nodes in the 
record list.</P></DD><DD><P>By default, nested nodes are visited.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, <A HREF=#mgFind>mgFind</A>, <A HREF=#mgFindEx>mgFindEx</A><BR> 
<A HREF=#MWALK_NEXT>MWALK_NEXT</A><BR> 
<A HREF=#MWALK_VERTEX>MWALK_VERTEX</A><BR> 
<A HREF=#MWALK_MASTER>MWALK_MASTER</A><BR> 
<A HREF=#MWALK_MASTERALL>MWALK_MASTERALL</A><BR> 
<A HREF=#MWALK_ON>MWALK_ON</A><BR> 
<A HREF=#MWALK_NOREADONLY>MWALK_NOREADONLY</A><BR> 
<A HREF=#MWALK_MATRIXSTACK>MWALK_MATRIXSTACK</A></DD></DL>
<HR>
<LEFT><A NAME=MWALK_NOREADONLY><H1 CLASS="APISYMBOL">MWALK_NOREADONLY</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MWALK_NOREADONLY</B> - mgWalk flag Walk No Read Only<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Setting this mask causes <A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, 
<A HREF=#mgFind>mgFind</A>, and <A HREF=#mgFindEx>mgFindEx</A> 
to not visit read-only nodes (external nodes, for example). 
If you set this mask when using <A HREF=#mgWalkRecList>mgWalkRecList</A>, it is 
only used when traversing the children of the nodes in the 
record list.</P></DD><DD><P>By default, read-only nodes are visited.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, <A HREF=#mgFind>mgFind</A>, <A HREF=#mgFindEx>mgFindEx</A><BR> 
<A HREF=#MWALK_NEXT>MWALK_NEXT</A><BR> 
<A HREF=#MWALK_VERTEX>MWALK_VERTEX</A><BR> 
<A HREF=#MWALK_MASTER>MWALK_MASTER</A><BR> 
<A HREF=#MWALK_MASTERALL>MWALK_MASTERALL</A><BR> 
<A HREF=#MWALK_ON>MWALK_ON</A><BR> 
<A HREF=#MWALK_NONESTED>MWALK_NONESTED</A><BR> 
<A HREF=#MWALK_MATRIXSTACK>MWALK_MATRIXSTACK</A></DD></DL>
<HR>
<LEFT><A NAME=MWALK_ON><H1 CLASS="APISYMBOL">MWALK_ON</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MWALK_ON</B> - mgWalk flag Walk On<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Setting this mask causes <A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, 
<A HREF=#mgFind>mgFind</A>, and <A HREF=#mgFindEx>mgFindEx</A> 
to visit only nodes that are currently <B>On</B>. 
If you set this mask when using <A HREF=#mgWalkRecList>mgWalkRecList</A>, it is 
only used when traversing the children of the nodes in the 
record list. 
Nodes are <B>Off</B> if they are not part of the current 
level of detail or if they have been explicitly 
"toggled off" by the modeler.</P></DD><DD><P>By default, all nodes are visited whether 
they are <B>On</B> or <B>Off</B>.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, <A HREF=#mgFind>mgFind</A>, <A HREF=#mgFindEx>mgFindEx</A><BR> 
<A HREF=#MWALK_NEXT>MWALK_NEXT</A><BR> 
<A HREF=#MWALK_VERTEX>MWALK_VERTEX</A><BR> 
<A HREF=#MWALK_MASTER>MWALK_MASTER</A><BR> 
<A HREF=#MWALK_MASTERALL>MWALK_MASTERALL</A><BR> 
<A HREF=#MWALK_NOREADONLY>MWALK_NOREADONLY</A><BR> 
<A HREF=#MWALK_NONESTED>MWALK_NONESTED</A><BR> 
<A HREF=#MWALK_MATRIXSTACK>MWALK_MATRIXSTACK</A></DD></DL>
<HR>
<LEFT><A NAME=MWALK_VERTEX><H1 CLASS="APISYMBOL">MWALK_VERTEX</H1></A></LEFT>
<DL>
<DT><H3>NAME</H3></DT>
<DD><B>MWALK_VERTEX</B> - mgWalk flag Walk Vertices<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Setting this mask causes <A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, 
<A HREF=#mgFind>mgFind</A>, and <A HREF=#mgFindEx>mgFindEx</A> 
to visit vertex nodes. Note that the mask <A HREF=#MWALK_ON>MWALK_ON</A> does not affect whether 
a vertex node is visited because vertex nodes are always <B>On</B>. 
If you set this mask when using <A HREF=#mgWalkRecList>mgWalkRecList</A>, it is 
only used when traversing the children of the nodes in the 
record list.</P></DD><DD><P>By default, vertex nodes are not visited.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A>, <A HREF=#mgFind>mgFind</A>, <A HREF=#mgFindEx>mgFindEx</A><BR> 
<A HREF=#MWALK_NEXT>MWALK_NEXT</A><BR> 
<A HREF=#MWALK_MASTER>MWALK_MASTER</A><BR> 
<A HREF=#MWALK_MASTERALL>MWALK_MASTERALL</A><BR> 
<A HREF=#MWALK_ON>MWALK_ON</A><BR> 
<A HREF=#MWALK_NOREADONLY>MWALK_NOREADONLY</A><BR> 
<A HREF=#MWALK_NONESTED>MWALK_NONESTED</A><BR> 
<A HREF=#MWALK_MATRIXSTACK>MWALK_MATRIXSTACK</A></DD></DL>
<HR>
<LEFT><A NAME=mgbool><H1 CLASS="APISYMBOL">mgbool</H1></A></LEFT>
<DL>
<DT><H3>ENUM NAME</H3></DT>
<DD><B>mgbool</B> - A simple true or false data type<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef enum mgbool {
&#32;&#32;&#32;MG_FALSE,
&#32;&#32;&#32;MG_TRUE,
} mgbool;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>MG_FALSE</B><DD>Represents the boolean value false<DT><B>MG_TRUE</B><DD>Represents the boolean value true</DL></DT></DL>
<HR>
<LEFT><A NAME=mgboxd><H1 CLASS="APISYMBOL">mgboxd</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgboxd</B> - Double precision box record<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct mgboxd {
&#32;&#32;&#32;mgcoord3d min;
&#32;&#32;&#32;mgcoord3d max;
} mgboxd;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>min</B><DD><A HREF=#mgcoord3d>mgcoord3d</A> - lower left front point of box</DD></DT><DT><B>max</B><DD><A HREF=#mgcoord3d>mgcoord3d</A> - upper right back point of box</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This record contains 2 3-D coordinates that define an axis aligned box.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgplaned>mgplaned</A>, <A HREF=#mglined>mglined</A>, <A HREF=#mgMakeBox>mgMakeBox</A>, <A HREF=#mgGetBounds>mgGetBounds</A></DD></DL>
<HR>
<LEFT><A NAME=mgclosedialogcallbackrec><H1 CLASS="APISYMBOL">mgclosedialogcallbackrec</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgclosedialogcallbackrec</B> - callback structure for editor close dialog functions<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct  {
&#32;&#32;&#32;int buttonEvent;
} mgclosedialogcallbackrec;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>buttonEvent</B><DD>int - if your editor close dialog function 
returns <A HREF=#mgbool>MG_TRUE</A>, this is the button 
event you want sent to the dialog button function 
for your editor tool</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>If you have assigned a close dialog function for you editor tool 
and the user clicks the Close Box, the close dialog function is called. 
The close dialog function is passed a pointer to a record of this type 
in the <I>callData</I> parameter.</P></DD><DD><P>This record contains a field that your tool fills in and returns 
if a dialog is required by your tool.  If your 
editor tool needs to display a dialog to continue its work, it must 
set the <I>dialogRequired</I> field to <A HREF=#mgbool>MG_TRUE</A>.  Additionally, 
you can fill in the <I>toolData</I> field with tool defined data that 
is passed to subsequent editor interactions while your tool 
is active on the desktop.</P></DD><DD><P>If you do not need to display a dialog, set the 
<I>dialogRequired</I> field to <A HREF=#mgbool>MG_FALSE</A>.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSetCloseDialogFunc>mgEditorSetCloseDialogFunc</A>, <A HREF=#mgeditorclosedialogfunc>mgeditorclosedialogfunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgcode><H1 CLASS="APISYMBOL">mgcode</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgcode</B> - An integer code used to specify a record's type<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Each record type has a unique <A HREF=#mgcode>mgcode</A></P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCode>mgGetCode</A>, <A HREF=#mgNewRec>mgNewRec</A></DD></DL>
<HR>
<LEFT><A NAME=mgconstructcolor><H1 CLASS="APISYMBOL">mgconstructcolor</H1></A></LEFT>
<DL>
<DT><H3>ENUM NAME</H3></DT>
<DD><B>mgconstructcolor</B> - Construction Vertex/Edge Color<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef enum mgconstructcolor {
&#32;&#32;&#32;MCCOLOR_RED,
&#32;&#32;&#32;MCCOLOR_GREEN,
&#32;&#32;&#32;MCCOLOR_YELLOW,
&#32;&#32;&#32;MCCOLOR_BLUE,
&#32;&#32;&#32;MCCOLOR_MAGENTA,
&#32;&#32;&#32;MCCOLOR_CYAN,
&#32;&#32;&#32;MCCOLOR_WHITE,
} mgconstructcolor;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>MCCOLOR_RED</B><DD>Construction color <I>red</I><DT><B>MCCOLOR_GREEN</B><DD>Construction color <I>green</I><DT><B>MCCOLOR_YELLOW</B><DD>Construction color <I>yellow</I><DT><B>MCCOLOR_BLUE</B><DD>Construction color <I>blue</I><DT><B>MCCOLOR_MAGENTA</B><DD>Construction color <I>magenta</I><DT><B>MCCOLOR_CYAN</B><DD>Construction color <I>cyan</I><DT><B>MCCOLOR_WHITE</B><DD>Construction color <I>white</I></DL></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetConstructVertexColor>mgSetConstructVertexColor</A>, <A HREF=#mgSetConstructEdgeColor>mgSetConstructEdgeColor</A></DD></DL>
<HR>
<LEFT><A NAME=mgcontrolattribute><H1 CLASS="APISYMBOL">mgcontrolattribute</H1></A></LEFT>
<DL>
<DT><H3>ENUM NAME</H3></DT>
<DD><B>mgcontrolattribute</B> - Control attribute name type<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef enum mgcontrolattribute {
&#32;&#32;&#32;MCA_GLBORDERSTYLE,
&#32;&#32;&#32;MCA_BOLDFONT,
&#32;&#32;&#32;MCA_ITALICFONT,
&#32;&#32;&#32;MCA_GLMOUSEWRAP,
&#32;&#32;&#32;MCA_SPINAUTOINCREMENT,
&#32;&#32;&#32;MCA_TEXTACTIVATEONCHANGED,
} mgcontrolattribute;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>MCA_GLBORDERSTYLE</B><DD>GL Control Border Style. 
This control attribute specifies what kind (if any) 
of border to draw around the GL control.<BR> 
The possible values for this attribute include:<BR> 
<A HREF=#MGLBS_NONE>MGLBS_NONE</A> (default)<BR> 
<A HREF=#MGLBS_SUNKEN>MGLBS_SUNKEN</A><BR> 
<A HREF=#MGLBS_RAISED>MGLBS_RAISED</A><BR> 
<A HREF=#MGLBS_SOLID>MGLBS_SOLID</A>.<DT><B>MCA_BOLDFONT</B><DD>Control Bold Font Style. 
This control attribute specifies whether or not 
a control's font is bold.<BR> 
The possible values for this attribute include:<BR> 
1 - bold<BR> 
0 - not bold (default)<DT><B>MCA_ITALICFONT</B><DD>Control Italic Font Style. 
This control attribute specifies whether or not 
a control's font is italic.<BR> 
The possible values for this attribute include:<BR> 
1 - italic<BR> 
0 - not italic (default)<DT><B>MCA_GLMOUSEWRAP</B><DD>GL Control Mouse Wrap. 
This control attribute specifies whether or not the 
<A HREF=#MGMA_BUTTON>MGMA_BUTTON</A> mouse action reported to a GL mouse 
function allows the mouse position to go outside the 
bounds of the physical screen display.  Specifically, 
when the user tries to drag the mouse past the "edge" 
of the screen (top, bottom, left or right), this 
attribute controls the mouse behavior as follows:<BR> 
If Mouse Wrap is not enabled, the mouse position is clamped 
to the bounds of the screen and the mouse is not allowed 
to move any further in that direction.<BR> 
If Mouse Wrap is enabled, the mouse position is automatically 
"wrapped" to the edge of the screen that is opposite the 
edge past which the user is trying to drag.<BR> 
For example, if the user drags the mouse past the 
right edge of the screen, the mouse is automatically 
moved to the left edge of the screen.  This allows for 
more continuous mouse motion in the GL control.<BR> 
Note: When Mouse Wrap is enabled, the coordinates 
contained in the <A HREF=#mgglmousebuttondatarec>mgglmousebuttondatarec</A> structure 
reported to the GL mouse function will be adjusted 
automatically to account for this "wrapping" behavior. 
Again, consider the example of the user dragging the 
mouse past the right edge of the screen.  If the X 
coordinate reported just before the mouse "wraps" is N, 
The X coordinate reported just after the mouse "wraps" 
will be N+1.<BR> 
The possible values for this attribute include:<BR> 
1 - Mouse Wrap enabled<BR> 
0 - Mouse Wrap not enabled (default)<DT><B>MCA_SPINAUTOINCREMENT</B><DD>Spin Control Auto Increment. 
This control attribute specifies whether or not the 
increment value of a spin buddy control attached to 
a text or scale control is automatically calculated 
by Creator based on the current value of the text or 
scale control.<BR> 
When setting this attribute you must call <A HREF=#mgControlSetAttribute>mgControlSetAttribute</A> 
after <A HREF=#mgSetGuiCallback>mgSetGuiCallback</A> and after you have assigned the spin 
buddy to the control.<BR> 
The possible values for this attribute include:<BR> 
1 - Auto Increment enabled<BR> 
0 - Auto Increment not enabled (default)<DT><B>MCA_TEXTACTIVATEONCHANGED</B><DD>Text Activate on Changed. 
Normally a text control receives the <A HREF=#MGCB_ACTIVATE>MGCB_ACTIVATE</A> 
event only when the control loses focus. This control 
attribute lets you specify that a text control is to 
receive this event as the user types.  This may be 
useful in certain situations.<BR> 
When setting this attribute you must call <A HREF=#mgControlSetAttribute>mgControlSetAttribute</A> 
after <A HREF=#mgSetGuiCallback>mgSetGuiCallback</A>.<BR> 
The possible values for this attribute include:<BR> 
1 - Text control receives <A HREF=#MGCB_ACTIVATE>MGCB_ACTIVATE</A> event 
as user types and when control loses focus.<BR> 
0 - Text control receives <A HREF=#MGCB_ACTIVATE>MGCB_ACTIVATE</A> event 
only when control loses focus. (default)</DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This type is used to enumerate the control attributes that can be set.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgControlSetAttribute>mgControlSetAttribute</A></DD></DL>
<HR>
<LEFT><A NAME=mgcontrolid><H1 CLASS="APISYMBOL">mgcontrolid</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgcontrolid</B> - Control identifier type used to identify and find 
controls within dialog instances<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgFindGuiById>mgFindGuiById</A>, <A HREF=#mgControlIdsMatch>mgControlIdsMatch</A></DD></DL>
<HR>
<LEFT><A NAME=mgconvexhull><H1 CLASS="APISYMBOL">mgconvexhull</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgconvexhull</B> - Abstract type used to represent a convex hull<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgconvexhulltriangle>mgconvexhulltriangle</A>, <A HREF=#mgGetConvexHull>mgGetConvexHull</A>, <A HREF=#mgconvexhullbuilder>mgconvexhullbuilder</A>, <A HREF=#mgNewConvexHullBuilder>mgNewConvexHullBuilder</A></DD></DL>
<HR>
<LEFT><A NAME=mgconvexhullbuilder><H1 CLASS="APISYMBOL">mgconvexhullbuilder</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgconvexhullbuilder</B> - Abstract type used to represent a convex hull builder<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewConvexHullBuilder>mgNewConvexHullBuilder</A>, <A HREF=#mgconvexhull>mgconvexhull</A></DD></DL>
<HR>
<LEFT><A NAME=mgconvexhulltriangle><H1 CLASS="APISYMBOL">mgconvexhulltriangle</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgconvexhulltriangle</B> - Convex Hull triangle structure used by <A HREF=#mgconvexhull>mgconvexhull</A><P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct  {
&#32;&#32;&#32;mgcoord3d p1;
&#32;&#32;&#32;mgcoord3d p2;
&#32;&#32;&#32;mgcoord3d p3;
} mgconvexhulltriangle;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>p1</B><DD><A HREF=#mgcoord3d>mgcoord3d</A> - the coordinate position of the first vertex of the convex hull triangle</DD></DT><DT><B>p2</B><DD><A HREF=#mgcoord3d>mgcoord3d</A> - the coordinate position of the second vertex of the convex hull triangle</DD></DT><DT><B>p3</B><DD><A HREF=#mgcoord3d>mgcoord3d</A> - the coordinate position of the third vertex of the convex hull triangle</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This structure represents a single triangle of a convex hull.  The vertices of the 
triangle are ordered counter-clockwise and the direction of the normal is based on the 
right hand rule.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgconvexhull>mgconvexhull</A>, <A HREF=#mgGetConvexHull>mgGetConvexHull</A>, <A HREF=#mgConvexHullGetTriangleCount>mgConvexHullGetTriangleCount</A>, <A HREF=#mgConvexHullGetTriangleNth>mgConvexHullGetTriangleNth</A>.</DD></DL>
<HR>
<LEFT><A NAME=mgcoord2d><H1 CLASS="APISYMBOL">mgcoord2d</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgcoord2d</B> - Double precision 2 dimensional coordinate record<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct mgcoord2d {
&#32;&#32;&#32;double x;
&#32;&#32;&#32;double y;
} mgcoord2d;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>x</B><DD>double - x component of coordinate</DD></DT><DT><B>y</B><DD>double - y component of coordinate</DD></DT></DL></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3f>mgcoord3f</A>, <A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgcoord2i>mgcoord2i</A></DD></DL>
<HR>
<LEFT><A NAME=mgcoord2i><H1 CLASS="APISYMBOL">mgcoord2i</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgcoord2i</B> - Integer 2 dimensional coordinate record<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct mgcoord2i {
&#32;&#32;&#32;int x;
&#32;&#32;&#32;int y;
} mgcoord2i;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>x</B><DD>int - x component of coordinate</DD></DT><DT><B>y</B><DD>int - y component of coordinate</DD></DT></DL></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgcoord3f>mgcoord3f</A>, <A HREF=#mgcoord2d>mgcoord2d</A></DD></DL>
<HR>
<LEFT><A NAME=mgcoord3d><H1 CLASS="APISYMBOL">mgcoord3d</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgcoord3d</B> - Double precision 3 dimensional coordinate record<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct mgcoord3d {
&#32;&#32;&#32;double x;
&#32;&#32;&#32;double y;
&#32;&#32;&#32;double z;
} mgcoord3d;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>x</B><DD>double - x component of coordinate</DD></DT><DT><B>y</B><DD>double - y component of coordinate</DD></DT><DT><B>z</B><DD>double - z component of coordinate</DD></DT></DL></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3f>mgcoord3f</A>, <A HREF=#mgcoord2i>mgcoord2i</A>, <A HREF=#mgcoord2d>mgcoord2d</A>, <A HREF=#mgMakeCoord3d>mgMakeCoord3d</A>, 
<A HREF=#mgCoord3dAdd>mgCoord3dAdd</A>, <A HREF=#mgCoord3dSubtract>mgCoord3dSubtract</A>, <A HREF=#mgCoord3dMultiply>mgCoord3dMultiply</A>, <A HREF=#mgCoord3dDivide>mgCoord3dDivide</A>, 
<A HREF=#mgCoord3dLerp>mgCoord3dLerp</A>, <A HREF=#mgCoord3dNegate>mgCoord3dNegate</A>, <A HREF=#mgCoord3dTransform>mgCoord3dTransform</A></DD></DL>
<HR>
<LEFT><A NAME=mgcoord3f><H1 CLASS="APISYMBOL">mgcoord3f</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgcoord3f</B> - Single precision 3 dimensional coordinate record<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct mgcoord3f {
&#32;&#32;&#32;float x;
&#32;&#32;&#32;float y;
&#32;&#32;&#32;float z;
} mgcoord3f;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>x</B><DD>float - x component of coordinate</DD></DT><DT><B>y</B><DD>float - y component of coordinate</DD></DT><DT><B>z</B><DD>float - z component of coordinate</DD></DT></DL></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgcoord2i>mgcoord2i</A>, <A HREF=#mgcoord3d>mgcoord3d</A></DD></DL>
<HR>
<LEFT><A NAME=mgcursor><H1 CLASS="APISYMBOL">mgcursor</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgcursor</B> - Abstract type used to represent a cursor object<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetCursor>mgResourceGetCursor</A>, <A HREF=#mgSetCursor>mgSetCursor</A></DD></DL>
<HR>
<LEFT><A NAME=mgcursorhandle><H1 CLASS="APISYMBOL">mgcursorhandle</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgcursorhandle</B> - Platform specific type to represent native cursor 
items<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>On Windows, this is type HCURSOR.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCursorHandle>mgGetCursorHandle</A></DD></DL>
<HR>
<LEFT><A NAME=mgcursorid><H1 CLASS="APISYMBOL">mgcursorid</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgcursorid</B> - Cursor identifier type used to identify and extract 
cursors from resources<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetCursor>mgResourceGetCursor</A>, <A HREF=#mgCursorIdsMatch>mgCursorIdsMatch</A></DD></DL>
<HR>
<LEFT><A NAME=mgdeviceinputdata><H1 CLASS="APISYMBOL">mgdeviceinputdata</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgdeviceinputdata</B> - Device specific Input data<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct  {
&#32;&#32;&#32;mginputdevice inputDevice;
&#32;&#32;&#32;void* deviceData;
&#32;&#32;&#32;int button;
&#32;&#32;&#32;mgmousestate mouseEvent;
&#32;&#32;&#32;const char* toolName;
} mgdeviceinputdata;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>inputDevice</B><DD><A HREF=#mginputdevice>mginputdevice</A> - the input device originating the event</DD></DT><DT><B>deviceData</B><DD>void* - pointer to device specific data</DD></DT><DT><B>button</B><DD>int - button on device that was pressed</DD></DT><DT><B>mouseEvent</B><DD><A HREF=#mgmousestate>mgmousestate</A> - state of the button</DD></DT><DT><B>toolName</B><DD>const char* - pointer to the name of the input device</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When device input is reported to an editor tool via 
the corresponding device input function, a pointer to a record 
of this type is passed to the device function that describes 
the device input.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSetDeviceInputFunc>mgEditorSetDeviceInputFunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgdialogattribute><H1 CLASS="APISYMBOL">mgdialogattribute</H1></A></LEFT>
<DL>
<DT><H3>ENUM NAME</H3></DT>
<DD><B>mgdialogattribute</B> - Dialog attribute name type<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef enum mgdialogattribute {
&#32;&#32;&#32;MDA_RESIZEWIDTH,
&#32;&#32;&#32;MDA_RESIZEHEIGHT,
&#32;&#32;&#32;MDA_MINWIDTH,
&#32;&#32;&#32;MDA_MAXWIDTH,
&#32;&#32;&#32;MDA_MINHEIGHT,
&#32;&#32;&#32;MDA_MAXHEIGHT,
} mgdialogattribute;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>MDA_RESIZEWIDTH</B><DD>Resize Width. 
This dialog attribute specifies whether or not a dialog's 
width is resizable.  A value of 1 indicates that the width 
is resizable, 0 it is not.  If your dialog 
can be minimized, you must set this attribute to 1. 
The default value of this attribute is 1 meaning that 
the width of a dialog may be resized (if allowed to do 
so in the dialog template).<DT><B>MDA_RESIZEHEIGHT</B><DD>Resize Height. 
This dialog attribute specifies whether or not a dialog's 
height is resizable.  A value of 1 indicates that the height 
is resizable, 0 it is not.  If your dialog 
can be minimized, you must set this attribute to 1. 
The default value of this attribute is 1 meaning that 
the height of a dialog may be resized (if allowed to do 
so in the dialog template).<DT><B>MDA_MINWIDTH</B><DD>Minimum Width. 
This dialog attribute specifies the minimum width 
(in pixels) the dialog is allowed to be resized. 
If the value of this attribute is -1, the dialog has no 
user defined minimum width.  In this case, the minimum 
width will be imposed by the window system.  Also, if 
a minimum width is specified that is less than the system 
imposed minimum width, the system may override this value. 
The default value of this attribute is -1 meaning that 
there is no user defined minimum dimension. 
This attribute is only applicable if the dialog width is 
resizable (i.e., <A HREF=#mgdialogattribute>MDA_RESIZEWIDTH</A> is 1).<DT><B>MDA_MAXWIDTH</B><DD>Maximum Width. 
This dialog attribute specifies the maximum width 
(in pixels) the dialog is allowed to be resized. 
If the value of this attribute is -1, the dialog has no 
user defined maximum width.  In this case, the maximum 
width will be imposed by the window system. 
The default value of this attribute is -1 meaning that 
there is no user defined maximum dimension.  Also, if 
a maximum width is specified that is greater than the system 
imposed maximum width, the system may override this value. 
This attribute is only applicable if the dialog width is 
resizable (i.e., <A HREF=#mgdialogattribute>MDA_RESIZEWIDTH</A> is 1).<DT><B>MDA_MINHEIGHT</B><DD>Minimum Height. 
This dialog attribute specifies the minimum height 
(in pixels) the dialog is allowed to be resized. 
If the value of this attribute is -1, the dialog has no 
user defined minimum height.  In this case, the minimum 
height will be imposed by the window system. 
The default value of this attribute is -1 meaning that 
there is no user defined minimum dimension.  Also, if 
a minimum height is specified that is less than the system 
imposed minimum height, the system may override this value. 
This attribute is only applicable if the dialog height is 
resizable (i.e., <A HREF=#mgdialogattribute>MDA_RESIZEHEIGHT</A> is 1).<DT><B>MDA_MAXHEIGHT</B><DD>Maximum Height. 
This dialog attribute specifies the maximum height 
(in pixels) the dialog is allowed to be resized. 
If the value of this attribute is -1, the dialog has no 
user defined maximum height.  In this case, the maximum 
height will be imposed by the window system.  Also, if 
a maximum height is specified that is greater than the system 
imposed maximum height, the system may override this value. 
The default value of this attribute is -1 meaning that 
there is no user defined maximum dimension. 
This attribute is only applicable if the dialog height is 
resizable (i.e., <A HREF=#mgdialogattribute>MDA_RESIZEHEIGHT</A> is 1).</DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This type is used to enumerate the dialog attributes that can be set.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetDialog>mgResourceGetDialog</A>, <A HREF=#mgResourceModalDialog>mgResourceModalDialog</A>, <A HREF=#mgDialogSetAttribute>mgDialogSetAttribute</A></DD></DL>
<HR>
<LEFT><A NAME=mgdialogid><H1 CLASS="APISYMBOL">mgdialogid</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgdialogid</B> - Dialog identifier type used to identify and extract 
dialog templates from resources<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetDialog>mgResourceGetDialog</A>, <A HREF=#mgResourceModalDialog>mgResourceModalDialog</A></DD></DL>
<HR>
<LEFT><A NAME=mgdialogsizecallbackrec><H1 CLASS="APISYMBOL">mgdialogsizecallbackrec</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgdialogsizecallbackrec</B> - callback structure for the size dialog 
event sent to dialogs<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct  {
&#32;&#32;&#32;mgguicalldatatype callDataType;
&#32;&#32;&#32;mgbool isMinimized;
} mgdialogsizecallbackrec;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>callDataType</B><DD><A HREF=#mgguicalldatatype>mgguicalldatatype</A> - call data type that indicates the type 
of call data this object really is - will always be 
<A HREF=#mgguicalldatatype>MGCD_DIALOGSIZE</A></DD></DT><DT><B>isMinimized</B><DD><A HREF=#mgbool>mgbool</A> - <A HREF=#mgbool>MG_TRUE</A> if 
dialog is being minimized, <A HREF=#mgbool>MG_FALSE</A> 
otherwise</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When the <A HREF=#MGCB_SIZE>MGCB_SIZE</A> dialog event is sent to a 
dialog via its <A HREF=#mgdialogfunc>mgdialogfunc</A>, the <I>calldata</I> parameter passed in will point 
to an object of this type.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgdialogfunc>mgdialogfunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgeditorcallbackrec><H1 CLASS="APISYMBOL">mgeditorcallbackrec</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgeditorcallbackrec</B> - callback structure for editor tool start functions<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct  {
&#32;&#32;&#32;mgtoolactivation toolActivation;
&#32;&#32;&#32;mgbool dialogRequired;
&#32;&#32;&#32;void* toolData;
&#32;&#32;&#32;mgeditorcontext editorContext;
} mgeditorcallbackrec;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>toolActivation</B><DD><A HREF=#mgtoolactivation>mgtoolactivation</A> - tool activation</DD></DT><DT><B>dialogRequired</B><DD><A HREF=#mgbool>mgbool</A> - <A HREF=#mgbool>MG_TRUE</A> to tell 
OpenFlight API to create your editor dialog for you</DD></DT><DT><B>toolData</B><DD>void* - tool instance data that will be 
passed to subsequent editor tool interactions</DD></DT><DT><B>editorContext</B><DD><A HREF=#mgeditorcontext>mgeditorcontext</A> - the editor context associated to this 
invocation of the editor tool</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When an editor tool is launched, the corresponding 
start function is called. The start function is passed a 
pointer to a record of this type in the <I>callData</I> parameter.</P></DD><DD><P>This record contains a tool activation object from which 
you can obtain the identity of the top (focus) database.</P></DD><DD><P>This record also contains two fields that your tool 
fills in and returns if a dialog is required by your tool.  If your 
editor tool needs to display a dialog to continue its work, it must 
set the <I>dialogRequired</I> field to <A HREF=#mgbool>MG_TRUE</A>.  Additionally, 
you can fill in the <I>toolData</I> field with tool defined data that 
is passed to subsequent editor interactions while your tool 
is active on the desktop.</P></DD><DD><P>If you do not need to display a dialog, set the 
<I>dialogRequired</I> field to <A HREF=#mgbool>MG_FALSE</A>.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgtoolstartfunc>mgtoolstartfunc</A>, <A HREF=#mgGetActivationDb>mgGetActivationDb</A></DD></DL>
<HR>
<LEFT><A NAME=mgeditorcontext><H1 CLASS="APISYMBOL">mgeditorcontext</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgeditorcontext</B> - Abstract type used to represent an active editor 
tool context<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>If, when an editor tool is launched, it requires additional user 
interaction to complete its processing, the OpenFlight API creates an 
editor tool context corresponding to that instance of the tool. The editor 
tool context is maintained while the editor tool instance is active on the 
desktop.  It is used to encapsulate and identify the state of 
the active editor tool instance.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgEditorGetDbRec>mgEditorGetDbRec</A>, <A HREF=#mgEditorGetDialog>mgEditorGetDialog</A>, <A HREF=#mgEditorGetPluginTool>mgEditorGetPluginTool</A>, 
<A HREF=#mgEditorGetToolActivation>mgEditorGetToolActivation</A>, <A HREF=#mgRegisterEditor>mgRegisterEditor</A></DD></DL>
<HR>
<LEFT><A NAME=mgexportercallbackrec><H1 CLASS="APISYMBOL">mgexportercallbackrec</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgexportercallbackrec</B> - callback structure for database exporter tool start functions<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct  {
&#32;&#32;&#32;mgtoolactivation toolActivation;
&#32;&#32;&#32;char* fileName;
} mgexportercallbackrec;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>toolActivation</B><DD><A HREF=#mgtoolactivation>mgtoolactivation</A> - tool activation</DD></DT><DT><B>fileName</B><DD>char* - name of file to export to</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When a database exporter tool is launched, the corresponding 
start function is this type in the <I>callData</I> parameter.</P></DD><DD><P>This record contains a tool activation object from which 
you can obtain the identity of the database to export.  Also in this 
record is the name of the file selected by the user in the Export 
File Dialog.  This is the name of the file into which your tool 
writes the exported file contents.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgtoolstartfunc>mgtoolstartfunc</A>, <A HREF=#mgGetActivationDb>mgGetActivationDb</A></DD></DL>
<HR>
<LEFT><A NAME=mggeocoorddata><H1 CLASS="APISYMBOL">mggeocoorddata</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mggeocoorddata</B> - Geospecific Coordinate data<P></DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>u</B><DD>double - x coordinate in image</DD></DT><DT><B>v</B><DD>double - y coordinate in image</DD></DT><DT><B>lat</B><DD>double - latitude position that maps to x coordinate</DD></DT><DT><B>lon</B><DD>double - longitude position that maps to y coordinate</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Use an array of <A HREF=#mggeocoorddata>mggeocoorddata</A> to add and get geospecific 
coordinates.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGeoCoordGet>mgGeoCoordGet</A>, <A HREF=#mgGeoCoordAdd>mgGeoCoordAdd</A></DD></DL>
<HR>
<LEFT><A NAME=mgglcontext><H1 CLASS="APISYMBOL">mgglcontext</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgglcontext</B> - Abstract type used to represent GL rendering context 
objects<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterGraphicDraw>mgRegisterGraphicDraw</A>, <A HREF=#mgRegisterHierarchyDraw>mgRegisterHierarchyDraw</A></DD></DL>
<HR>
<LEFT><A NAME=mggldrawcallbackrec><H1 CLASS="APISYMBOL">mggldrawcallbackrec</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mggldrawcallbackrec</B> - callback structure for the draw control 
event sent to GL controls<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct  {
&#32;&#32;&#32;mgguicalldatatype callDataType;
&#32;&#32;&#32;int width;
&#32;&#32;&#32;int height;
&#32;&#32;&#32;mgglcontext glContext;
} mggldrawcallbackrec;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>callDataType</B><DD><A HREF=#mgguicalldatatype>mgguicalldatatype</A> - call data type that 
indicates the type of call data this object really is - 
will always be <A HREF=#mgguicalldatatype>MGCD_GLDRAW</A></DD></DT><DT><B>width</B><DD>int - width, in pixels of the GL control</DD></DT><DT><B>height</B><DD>int - height, in pixels of the GL control</DD></DT><DT><B>glContext</B><DD><A HREF=#mgglcontext>mgglcontext</A> - rendering context associated with GL control</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When the <A HREF=#MGCB_DRAW>MGCB_DRAW</A> control event is sent to 
a GL control via its <A HREF=#mgguifunc>mgguifunc</A>, the <I>calldata</I> parameter passed in will point 
to an object of this type.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgguifunc>mgguifunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgglmouseaction><H1 CLASS="APISYMBOL">mgglmouseaction</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgglmouseaction</B> - GL mouse action<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When a GL mouse function is called, the <I>mouseAction</I> 
parameter passed in of this type will specify which action triggered the 
function being called.</P></DD><DD><P>The mouse actions that are sent to GL mouse functions are: <BR> 
<A HREF=#MGMA_BUTTON>MGMA_BUTTON</A> <BR> 
<A HREF=#MGMA_DOUBLECLICK>MGMA_DOUBLECLICK</A> <BR> 
<A HREF=#MGMA_MOTION>MGMA_MOTION</A> <BR> 
<A HREF=#MGMA_WHEEL>MGMA_WHEEL</A> <BR></P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGLSetMouseFunc>mgGLSetMouseFunc</A>, <A HREF=#mgglmousefunc>mgglmousefunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgglmousebuttondatarec><H1 CLASS="APISYMBOL">mgglmousebuttondatarec</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgglmousebuttondatarec</B> - callback structure for the GL mouse button 
action sent to GL controls<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct  {
&#32;&#32;&#32;mgglmousedatatype callDataType;
&#32;&#32;&#32;mgmousestate mouseEvent;
&#32;&#32;&#32;unsigned int keyboardFlags;
&#32;&#32;&#32;unsigned int buttonFlags;
&#32;&#32;&#32;mgcoord2i* thisPoint;
&#32;&#32;&#32;mgcoord2i* prevPoint;
&#32;&#32;&#32;mgcoord2i* firstPoint;
} mgglmousebuttondatarec;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>callDataType</B><DD><A HREF=#mgglmousedatatype>mgglmousedatatype</A> - call data type that indicates 
the type of call data this object really is - 
will always be <A HREF=#mgglmousedatatype>MGMCD_BUTTONDATA</A></DD></DT><DT><B>mouseEvent</B><DD><A HREF=#mgmousestate>mgmousestate</A> - the vertex input sequence state</DD></DT><DT><B>keyboardFlags</B><DD>unsigned int - the state of the <I>Alt</I>, <I>Ctrl</I>, and <I>Shift</I> keys - 
the value of this field will be a bitwise combination 
of <A HREF=#MKB_ALTKEY>MKB_ALTKEY</A>, <A HREF=#MKB_CTRLKEY>MKB_CTRLKEY</A> and <A HREF=#MKB_SHIFTKEY>MKB_SHIFTKEY</A></DD></DT><DT><B>buttonFlags</B><DD>unsigned int - the state of the <I>Left</I>, <I>Middle</I> and <I>Right</I> 
mouse buttons - the value of this field will be a bitwise 
combination of <A HREF=#MMB_LEFTMOUSE>MMB_LEFTMOUSE</A>, <A HREF=#MMB_MIDDLEMOUSE>MMB_MIDDLEMOUSE</A> and 
<A HREF=#MMB_RIGHTMOUSE>MMB_RIGHTMOUSE</A></DD></DT><DT><B>thisPoint</B><DD><A HREF=#mgcoord2i>mgcoord2i*</A> - address of 2D coordinate record for 
the current point being reported in this sequence</DD></DT><DT><B>prevPoint</B><DD><A HREF=#mgcoord2i>mgcoord2i*</A> - address of 2D coordinate record for 
the previous point being reported in this sequence</DD></DT><DT><B>firstPoint</B><DD><A HREF=#mgcoord2i>mgcoord2i*</A> - address of 2D coordinate record for 
the first point reported in this sequence</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When the <A HREF=#MGMA_BUTTON>MGMA_BUTTON</A> mouse action is reported to a GL control via its 
<A HREF=#mgglmousefunc>mgglmousefunc</A>, the <I>calldata</I> parameter passed in will point to an object 
of this type.</P></DD><DD><P>The coordinates of mouse button input are reported relative 
to the lower left corner of the GL control in which the input 
was received.  That is, if the point reported is at the lower left 
corner of the control, it will be reported as (0, 0).</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgglmousefunc>mgglmousefunc</A>, <A HREF=#mgGLSetMouseFunc>mgGLSetMouseFunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgglmousedatarec><H1 CLASS="APISYMBOL">mgglmousedatarec</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgglmousedatarec</B> - generic callback structure for <I>callData</I> 
parameter of <A HREF=#mgglmousefunc>mgglmousefunc</A><P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct  {
&#32;&#32;&#32;mgglmousedatatype callDataType;
} mgglmousedatarec;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>callDataType</B><DD><A HREF=#mgglmousedatatype>mgglmousedatatype</A> - call data type that indicates 
the type of call data this object really is</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When a GL mouse function is called, the <I>callData</I> 
parameter passed in will be a pointer to an object type that is dependent on the context 
of the mouse function.  The first field of each data structure is the same as this 
structure.  In this way, the <I>callData</I> parameter can always safely be cast to a pointer 
to an object of this type.  Doing so, you can then examine the <I>callDataType</I> field to 
determine which callback record structure has actually been passed.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgglmousedatatype>mgglmousedatatype</A>, <A HREF=#mgglmousefunc>mgglmousefunc</A>, <A HREF=#mgGLSetMouseFunc>mgGLSetMouseFunc</A>.</DD></DL>
<HR>
<LEFT><A NAME=mgglmousedatatype><H1 CLASS="APISYMBOL">mgglmousedatatype</H1></A></LEFT>
<DL>
<DT><H3>ENUM NAME</H3></DT>
<DD><B>mgglmousedatatype</B> - GL Mouse function callback data type<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef enum mgglmousedatatype {
&#32;&#32;&#32;MGMCD_COMMON,
&#32;&#32;&#32;MGMCD_BUTTONDATA,
&#32;&#32;&#32;MGMCD_DOUBLECLICKDATA,
&#32;&#32;&#32;MGMCD_MOTIONDATA,
&#32;&#32;&#32;MGMCD_WHEELDATA,
} mgglmousedatatype;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>MGMCD_COMMON</B><DD>GL Mouse Common Call Data.  This indicates that the 
<I>callData</I> parameter to a GL mouse function is a pointer 
to an object of type <A HREF=#mgglmousedatarec>mgglmousedatarec</A> and has no 
additional data.<DT><B>MGMCD_BUTTONDATA</B><DD>GL Mouse Button Call Data.  This indicates that the 
<I>callData</I> parameter to a GL mouse function is a pointer 
to an object of type <A HREF=#mgglmousebuttondatarec>mgglmousebuttondatarec</A>.<DT><B>MGMCD_DOUBLECLICKDATA</B><DD>GL Mouse Double Click Call Data.  This indicates that 
the <I>callData</I> parameter to a GL mouse function is a pointer 
to an object of type <A HREF=#mgglmousedoubleclickdatarec>mgglmousedoubleclickdatarec</A>.<DT><B>MGMCD_MOTIONDATA</B><DD>GL Mouse Motion Call Data.  This indicates that 
the <I>callData</I> parameter to a GL mouse function is a pointer 
to an object of type <A HREF=#mgglmousemotiondatarec>mgglmousemotiondatarec</A>.<DT><B>MGMCD_WHEELDATA</B><DD>GL Mouse Wheel Call Data.  This indicates that 
the <I>callData</I> parameter to a GL mouse function is a pointer 
to an object of type <A HREF=#mgglmousewheeldatarec>mgglmousewheeldatarec</A>.</DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This type is used to indicate the type of call data passed to GL mouse function. 
When a GL mouse function is called, the <I>callData</I> parameter passed in will be a pointer 
to an object type that is dependent on the context of the mouse function.</P></DD><DD><P>Each member of this type corresponds to a different GL mouse function call data 
structure.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGLSetMouseFunc>mgGLSetMouseFunc</A>, <A HREF=#mgglmousefunc>mgglmousefunc</A>, <A HREF=#mgglmouseaction>mgglmouseaction</A></DD></DL>
<HR>
<LEFT><A NAME=mgglmousedoubleclickdatarec><H1 CLASS="APISYMBOL">mgglmousedoubleclickdatarec</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgglmousedoubleclickdatarec</B> - callback structure for the GL mouse 
double click action sent to GL controls<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct  {
&#32;&#32;&#32;mgglmousedatatype callDataType;
&#32;&#32;&#32;unsigned int keyboardFlags;
&#32;&#32;&#32;unsigned int buttonFlags;
&#32;&#32;&#32;mgcoord2i* thisPoint;
} mgglmousedoubleclickdatarec;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>callDataType</B><DD><A HREF=#mgglmousedatatype>mgglmousedatatype</A> - call data type that indicates 
the type of call data this object really is - 
will always be <A HREF=#mgglmousedatatype>MGMCD_DOUBLECLICKDATA</A></DD></DT><DT><B>keyboardFlags</B><DD>unsigned int - the state of the <I>Alt</I>, <I>Ctrl</I>, and <I>Shift</I> keys - 
the value of this field will be a bitwise combination 
of <A HREF=#MKB_ALTKEY>MKB_ALTKEY</A>, <A HREF=#MKB_CTRLKEY>MKB_CTRLKEY</A> and <A HREF=#MKB_SHIFTKEY>MKB_SHIFTKEY</A></DD></DT><DT><B>buttonFlags</B><DD>unsigned int - the state of the <I>Left</I>, <I>Middle</I> and <I>Right</I> 
mouse buttons - the value of this field will be a bitwise 
combination of <A HREF=#MMB_LEFTMOUSE>MMB_LEFTMOUSE</A>, <A HREF=#MMB_MIDDLEMOUSE>MMB_MIDDLEMOUSE</A> and 
<A HREF=#MMB_RIGHTMOUSE>MMB_RIGHTMOUSE</A></DD></DT><DT><B>thisPoint</B><DD><A HREF=#mgcoord2i>mgcoord2i*</A> - address of 2D coordinate record for 
the double click reported</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When the <A HREF=#MGMA_DOUBLECLICK>MGMA_DOUBLECLICK</A> mouse action is reported to a GL control via its 
<A HREF=#mgglmousefunc>mgglmousefunc</A>, the <I>calldata</I> parameter passed in will point to an object 
of this type.</P></DD><DD><P>The coordinates of mouse button input are reported relative 
to the lower left corner of the GL control in which the input 
was received.  That is, if the point reported is at the lower left 
corner of the control, it will be reported as (0, 0).</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgglmousefunc>mgglmousefunc</A>, <A HREF=#mgGLSetMouseFunc>mgGLSetMouseFunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgglmousemotiondatarec><H1 CLASS="APISYMBOL">mgglmousemotiondatarec</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgglmousemotiondatarec</B> - callback structure for the GL mouse 
motion action sent to GL controls<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct  {
&#32;&#32;&#32;mgglmousedatatype callDataType;
&#32;&#32;&#32;unsigned int keyboardFlags;
&#32;&#32;&#32;mgcoord2i* thisPoint;
} mgglmousemotiondatarec;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>callDataType</B><DD><A HREF=#mgglmousedatatype>mgglmousedatatype</A> - call data type that indicates 
the type of call data this object really is - 
will always be <A HREF=#mgglmousedatatype>MGMCD_MOTIONDATA</A></DD></DT><DT><B>keyboardFlags</B><DD>unsigned int - the state of the <I>Alt</I>, <I>Ctrl</I>, and <I>Shift</I> keys - 
the value of this field will be a bitwise combination 
of <A HREF=#MKB_ALTKEY>MKB_ALTKEY</A>, <A HREF=#MKB_CTRLKEY>MKB_CTRLKEY</A> and <A HREF=#MKB_SHIFTKEY>MKB_SHIFTKEY</A></DD></DT><DT><B>thisPoint</B><DD><A HREF=#mgcoord2i>mgcoord2i*</A> - address of 2D coordinate record for motion 
reported</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When the <A HREF=#MGMA_MOTION>MGMA_MOTION</A> mouse action is reported to a GL control via its 
<A HREF=#mgglmousefunc>mgglmousefunc</A>, the <I>calldata</I> parameter passed in will point to an object 
of this type.</P></DD><DD><P>The coordinates of mouse button input are reported relative 
to the lower left corner of the GL control in which the input 
was received.  That is, if the point reported is at the lower left 
corner of the control, it will be reported as (0, 0).</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgglmousefunc>mgglmousefunc</A>, <A HREF=#mgGLSetMouseFunc>mgGLSetMouseFunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgglmousewheeldatarec><H1 CLASS="APISYMBOL">mgglmousewheeldatarec</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgglmousewheeldatarec</B> - callback structure for the GL mouse 
wheel action sent to GL controls<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct  {
&#32;&#32;&#32;mgglmousedatatype callDataType;
&#32;&#32;&#32;unsigned int keyboardFlags;
&#32;&#32;&#32;unsigned int buttonFlags;
&#32;&#32;&#32;mgcoord2i* thisPoint;
&#32;&#32;&#32;int zDelta;
} mgglmousewheeldatarec;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>callDataType</B><DD><A HREF=#mgglmousedatatype>mgglmousedatatype</A> - call data type that indicates 
the type of call data this object really is - 
will always be <A HREF=#mgglmousedatatype>MGMCD_WHEELDATA</A></DD></DT><DT><B>keyboardFlags</B><DD>unsigned int - the state of the <I>Alt</I>, <I>Ctrl</I>, and <I>Shift</I> keys - 
the value of this field will be a bitwise combination 
of <A HREF=#MKB_ALTKEY>MKB_ALTKEY</A>, <A HREF=#MKB_CTRLKEY>MKB_CTRLKEY</A> and <A HREF=#MKB_SHIFTKEY>MKB_SHIFTKEY</A></DD></DT><DT><B>buttonFlags</B><DD>unsigned int - the state of the <I>Left</I>, <I>Middle</I> and <I>Right</I> 
mouse buttons - the value of this field will be a bitwise 
combination of <A HREF=#MMB_LEFTMOUSE>MMB_LEFTMOUSE</A>, <A HREF=#MMB_MIDDLEMOUSE>MMB_MIDDLEMOUSE</A> and 
<A HREF=#MMB_RIGHTMOUSE>MMB_RIGHTMOUSE</A></DD></DT><DT><B>thisPoint</B><DD><A HREF=#mgcoord2i>mgcoord2i*</A> - address of 2D coordinate record for motion 
reported</DD></DT><DT><B>zDelta</B><DD>int - the distance that the wheel is rotated. 
A positive value indicates that the wheel was rotated 
forward, away from the user; a negative value indicates 
that the wheel was rotated backward, toward the user.</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When the <A HREF=#MGMA_WHEEL>MGMA_WHEEL</A> mouse action is reported to a GL control via its 
<A HREF=#mgglmousefunc>mgglmousefunc</A>, the <I>calldata</I> parameter passed in will point to an object 
of this type.</P></DD><DD><P>The coordinates of mouse button input are reported relative 
to the lower left corner of the GL control in which the input 
was received.  That is, if the point reported is at the lower left 
corner of the control, it will be reported as (0, 0).</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgglmousefunc>mgglmousefunc</A>, <A HREF=#mgGLSetMouseFunc>mgGLSetMouseFunc</A></DD></DL>
<HR>
<LEFT><A NAME=mggraphicdrawmode><H1 CLASS="APISYMBOL">mggraphicdrawmode</H1></A></LEFT>
<DL>
<DT><H3>ENUM NAME</H3></DT>
<DD><B>mggraphicdrawmode</B> - Graphic View Draw Mode type<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef enum mggraphicdrawmode {
&#32;&#32;&#32;MGDM_WIREFRAME,
&#32;&#32;&#32;MGDM_SOLID,
&#32;&#32;&#32;MGDM_WIRESOLID,
&#32;&#32;&#32;MGDM_SELECT,
} mggraphicdrawmode;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>MGDM_WIREFRAME</B><DD>Graphic View Draw Mode is Wireframe<DT><B>MGDM_SOLID</B><DD>Graphic View Draw Mode is Solid<DT><B>MGDM_WIRESOLID</B><DD>Graphic View Draw Mode is Wireframe over Solid<DT><B>MGDM_SELECT</B><DD>Graphic View Draw Mode is Select</DL></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterGraphicDraw>mgRegisterGraphicDraw</A>, <A HREF=#mggraphicdrawfunc>mggraphicdrawfunc</A>, <A HREF=#mggraphicviewdata>mggraphicviewdata</A></DD></DL>
<HR>
<LEFT><A NAME=mggraphicdrawreason><H1 CLASS="APISYMBOL">mggraphicdrawreason</H1></A></LEFT>
<DL>
<DT><H3>ENUM NAME</H3></DT>
<DD><B>mggraphicdrawreason</B> - Graphic View Draw Reason type<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef enum mggraphicdrawreason {
&#32;&#32;&#32;MGDR_PREDRAW,
&#32;&#32;&#32;MGDR_POSTDRAW,
&#32;&#32;&#32;MGDR_DRAW,
} mggraphicdrawreason;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>MGDR_PREDRAW</B><DD>Graphic View Draw Reason is Pre-Draw<DT><B>MGDR_POSTDRAW</B><DD>Graphic View Draw Reason is Pre-Draw<DT><B>MGDR_DRAW</B><DD>Graphic View Draw Reason is Draw</DL></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterGraphicDraw>mgRegisterGraphicDraw</A>, 
<A HREF=#mggraphicdrawfunc>mggraphicdrawfunc</A>, <A HREF=#mggraphicviewdata>mggraphicviewdata</A></DD></DL>
<HR>
<LEFT><A NAME=mggraphicviewdata><H1 CLASS="APISYMBOL">mggraphicviewdata</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mggraphicviewdata</B> - Graphic View data<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct  {
&#32;&#32;&#32;mgglcontext glContext;
&#32;&#32;&#32;mggraphicdrawmode drawMode;
&#32;&#32;&#32;mgbool lightingEnabled;
&#32;&#32;&#32;mgbool textureEnabled;
&#32;&#32;&#32;mggraphicdrawreason drawReason;
&#32;&#32;&#32;void* userData;
&#32;&#32;&#32;mggraphicview graphicView;
} mggraphicviewdata;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>glContext</B><DD><A HREF=#mgglcontext>mgglcontext</A> - Gl rendering context associated to this 
graphics view</DD></DT><DT><B>drawMode</B><DD><A HREF=#mggraphicdrawmode>mggraphicdrawmode</A> - draw mode for the graphics view</DD></DT><DT><B>lightingEnabled</B><DD><A HREF=#mgbool>mgbool</A> - <A HREF=#mgbool>MG_TRUE</A> if lighting mode is enabled</DD></DT><DT><B>textureEnabled</B><DD><A HREF=#mgbool>mgbool</A> - <A HREF=#mgbool>MG_TRUE</A> if texture drawing is enabled</DD></DT><DT><B>drawReason</B><DD><A HREF=#mggraphicdrawreason>mggraphicdrawreason</A> - draw reason for the graphics view</DD></DT><DT><B>userData</B><DD>void* - user data supplied by <B>mgRegisterNodeDrawGraphic</B></DD></DT><DT><B>graphicView</B><DD><A HREF=#mggraphicview>mggraphicview</A> - graphic view</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>The graphic draw function for an extension node will be passed a pointer 
to an object of this type.  This record contains a GL rendering context object 
and other objects that indicate the draw state of the graphics view in which 
the extension node is to be drawn.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterGraphicDraw>mgRegisterGraphicDraw</A>, <A HREF=#mggraphicdrawfunc>mggraphicdrawfunc</A></DD></DL>
<HR>
<LEFT><A NAME=mggui><H1 CLASS="APISYMBOL">mggui</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mggui</B> - Abstract type used to represent Dialog and Control GUI items<P></DD>
</DL>
<HR>
<LEFT><A NAME=mgguicallbackreason><H1 CLASS="APISYMBOL">mgguicallbackreason</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgguicallbackreason</B> - Callback reason type used to specify dialog 
and control events<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When a control callback or dialog function is called, the <I>callbackReason</I> 
parameter passed in of this type will specify which event triggered the callback.</P></DD><DD><P>Dialog and control callback functions are called to report these events.</P></DD><DD><P>The events that are sent to dialog functions are: <BR> 
<A HREF=#MGCB_INIT>MGCB_INIT</A> <BR> 
<A HREF=#MGCB_SHOW>MGCB_SHOW</A> <BR> 
<A HREF=#MGCB_SIZE>MGCB_SIZE</A> <BR> 
<A HREF=#MGCB_REFRESH>MGCB_REFRESH</A> <BR> 
<A HREF=#MGCB_HIDE>MGCB_HIDE</A> <BR> 
<A HREF=#MGCB_DESTROY>MGCB_DESTROY</A> <BR></P></DD><DD><P>The events that are sent to control callback functions are: <BR> 
<A HREF=#MGCB_ACTIVATE>MGCB_ACTIVATE</A> <BR> 
<A HREF=#MGCB_REFRESH>MGCB_REFRESH</A> <BR> 
<A HREF=#MGCB_DRAW>MGCB_DRAW</A> <BR></P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetGuiCallback>mgSetGuiCallback</A>, <A HREF=#mgResourceGetDialog>mgResourceGetDialog</A>, <A HREF=#mgResourceModalDialog>mgResourceModalDialog</A>, 
<A HREF=#mgguifunc>mgguifunc</A>, <A HREF=#mgdialogfunc>mgdialogfunc</A>, <A HREF=#mgguicalldatatype>mgguicalldatatype</A></DD></DL>
<HR>
<LEFT><A NAME=mgguicallbackrec><H1 CLASS="APISYMBOL">mgguicallbackrec</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgguicallbackrec</B> - generic callback structure for <I>callData</I> 
parameter of <A HREF=#mgguifunc>mgguifunc</A> and <A HREF=#mgdialogfunc>mgdialogfunc</A><P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct  {
&#32;&#32;&#32;mgguicalldatatype callDataType;
} mgguicallbackrec;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>callDataType</B><DD><A HREF=#mgguicalldatatype>mgguicalldatatype</A> - call data type that indicates 
the type of call data this object really is</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When a control callback or dialog 
function is called, the <I>callData</I> parameter passed in will be a pointer to an 
object type that is dependent on the context of the callback function.  The first 
field of each data structure is the same as this structure.  In this way, the 
<I>callData</I> parameter can always safely be cast to a pointer to an object of this 
type.  Doing so, you can then examine the <I>callDataType</I> field to determine which 
callback record structure has actually been passed.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgguicalldatatype>mgguicalldatatype</A>, <A HREF=#mgguifunc>mgguifunc</A>, <A HREF=#mgdialogfunc>mgdialogfunc</A>.</DD></DL>
<HR>
<LEFT><A NAME=mgguicalldatatype><H1 CLASS="APISYMBOL">mgguicalldatatype</H1></A></LEFT>
<DL>
<DT><H3>ENUM NAME</H3></DT>
<DD><B>mgguicalldatatype</B> - GUI callback data type<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef enum mgguicalldatatype {
&#32;&#32;&#32;MGCD_COMMON,
&#32;&#32;&#32;MGCD_TEXTACTIVATE,
&#32;&#32;&#32;MGCD_SCALEACTIVATE,
&#32;&#32;&#32;MGCD_GLDRAW,
&#32;&#32;&#32;MGCD_DIALOGSIZE,
&#32;&#32;&#32;MGCD_TABRULERACTIVATE,
&#32;&#32;&#32;MGCD_LISTACTIVATE,
} mgguicalldatatype;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>MGCD_COMMON</B><DD>Common Call Data.  This indicates that the 
<I>callData</I> parameter to a control callback or dialog 
function is a pointer to an object of type 
<A HREF=#mgguicallbackrec>mgguicallbackrec</A> and has no additional data.<DT><B>MGCD_TEXTACTIVATE</B><DD>Text Activate Call Data.  This indicates that the 
<I>callData</I> parameter to a control callback is a pointer 
to an object of type <A HREF=#mgtextactivatecallbackrec>mgtextactivatecallbackrec</A>.<DT><B>MGCD_SCALEACTIVATE</B><DD>Scale Activate Call Data.  This indicates that the 
<I>callData</I> parameter to a control callback is a pointer 
to an object of type <A HREF=#mgscaleactivatecallbackrec>mgscaleactivatecallbackrec</A>.<DT><B>MGCD_GLDRAW</B><DD>GL Draw Call Data.  This indicates that the 
<I>callData</I> parameter to a control callback is a pointer 
to an object of type <A HREF=#mggldrawcallbackrec>mggldrawcallbackrec</A>.<DT><B>MGCD_DIALOGSIZE</B><DD>Dialog Size Call Data.  This indicates that the 
<I>callData</I> parameter to a dialog function is a pointer 
to an object of type <A HREF=#mgdialogsizecallbackrec>mgdialogsizecallbackrec</A>.<DT><B>MGCD_TABRULERACTIVATE</B><DD>Tab ruler Activate Call Data.  This indicates that the 
<I>callData</I> parameter to a control callback is a pointer 
to an object of type <A HREF=#mgtabruleractivatecallbackrec>mgtabruleractivatecallbackrec</A>.<DT><B>MGCD_LISTACTIVATE</B><DD>List Activate Call Data.  This indicates that the 
<I>callData</I> parameter to a control callback is a pointer 
to an object of type <A HREF=#mglistactivatecallbackrec>mglistactivatecallbackrec</A>.</DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This type is used to indicate the type of call data passed to control callback 
and dialog functions. When a control callback or dialog function is called, the <I>callData</I> 
parameter passed in will be a pointer to an object type that is dependent on the context of 
the callback function.</P></DD><DD><P>Each member of this type corresponds to a different callback data structure.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetGuiCallback>mgSetGuiCallback</A>, <A HREF=#mgResourceGetDialog>mgResourceGetDialog</A>, <A HREF=#mgResourceModalDialog>mgResourceModalDialog</A>, 
<A HREF=#mgguifunc>mgguifunc</A>, <A HREF=#mgdialogfunc>mgdialogfunc</A>, <A HREF=#mgguicallbackreason>mgguicallbackreason</A></DD></DL>
<HR>
<LEFT><A NAME=mgguihandle><H1 CLASS="APISYMBOL">mgguihandle</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgguihandle</B> - Platform-specific type used to represent native Dialog 
and Control GUI items<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>On Windows, this is type HWND</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetGuiHandle>mgGetGuiHandle</A></DD></DL>
<HR>
<LEFT><A NAME=mghelpcontext><H1 CLASS="APISYMBOL">mghelpcontext</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mghelpcontext</B> - A string type used to identify help context 
topics or keys in plug-in help files<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>If your help file format 
supports integer keys, you can express such a key using the string 
representation of the desired integer.  For example the string value 
"234" would be converted automatically to the integer value 234 and 
used to lookup the topic in your plug-in help file.</P></DD><DD><P>Note: Currently, help contexts are only supported for Windows 
Help Files.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterHelpFile>mgRegisterHelpFile</A>, <A HREF=#mgGuiSetHelpContext>mgGuiSetHelpContext</A>, 
<A HREF=#mgShowHelpContext>mgShowHelpContext</A>, <A HREF=#MTA_HELPCONTEXT>MTA_HELPCONTEXT</A></DD></DL>
<HR>
<LEFT><A NAME=mghierarchyviewdata><H1 CLASS="APISYMBOL">mghierarchyviewdata</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mghierarchyviewdata</B> - Hierarchy View data<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct  {
&#32;&#32;&#32;mgglcontext glContext;
&#32;&#32;&#32;unsigned int left;
&#32;&#32;&#32;unsigned int bottom;
&#32;&#32;&#32;unsigned int right;
&#32;&#32;&#32;unsigned int top;
} mghierarchyviewdata;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>glContext</B><DD><A HREF=#mgglcontext>mgglcontext</A> - Gl rendering context associated to this 
hierarchy view</DD></DT><DT><B>left</B><DD>unsigned int - left position of extension node rectangle</DD></DT><DT><B>bottom</B><DD>unsigned int - bottom position of extension node rectangle</DD></DT><DT><B>right</B><DD>unsigned int - right position of extension node rectangle</DD></DT><DT><B>top</B><DD>unsigned int - top position of extension node rectangle</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>The hierarchy draw function for an extension node will be passed a pointer 
to an object of this type.  This record contains a GL rendering context object and 
the extents of the rectangle in which the extension node is to be drawn.  The draw 
function should not draw outside the bounds of this rectangle.  The coordinates 
of this rectangle are measured relative to the lower left corner (0,0) of the 
enclosing hierarchy view.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterHierarchyDraw>mgRegisterHierarchyDraw</A>, <A HREF=#mghierarchydrawfunc>mghierarchydrawfunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgimagegeoinfo><H1 CLASS="APISYMBOL">mgimagegeoinfo</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgimagegeoinfo</B> - Abstract type used to represent a georeference 
info object for an image object<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>A geoimage object is used to describe a geographic control of 
a georeference info and contains fields such as type, projection, 
earth model, UTM info, origin and geo control points.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgReadImageGeoInfo>mgReadImageGeoInfo</A></DD></DL>
<HR>
<LEFT><A NAME=mgimageinfo><H1 CLASS="APISYMBOL">mgimageinfo</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgimageinfo</B> - Abstract type used to represent an image object<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>An image object is used to describe an image and contains fields 
such as width, height, type, sample size and other flags.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A>, <A HREF=#mgReadImageInfo>mgReadImageInfo</A></DD></DL>
<HR>
<LEFT><A NAME=mgimportercallbackrec><H1 CLASS="APISYMBOL">mgimportercallbackrec</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgimportercallbackrec</B> - callback structure for database importer tool start functions<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct  {
&#32;&#32;&#32;mgtoolactivation toolActivation;
&#32;&#32;&#32;char* fileName;
} mgimportercallbackrec;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>toolActivation</B><DD><A HREF=#mgtoolactivation>mgtoolactivation</A> - tool activation</DD></DT><DT><B>fileName</B><DD>char* - name of file to import</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When a database importer tool is launched, the corresponding 
start function is called.  The start function is passed a 
pointer to a record of this type in the <I>callData</I> parameter.</P></DD><DD><P>This record contains the name of the file selected by the 
user in the Import File Dialog.  This is the file whose contents 
your tool is to import.  Also in this record is tool activation object 
from which you can obtain the identity of the database to which 
the imported database items are to be attached.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgtoolstartfunc>mgtoolstartfunc</A>, <A HREF=#mgGetActivationDb>mgGetActivationDb</A></DD></DL>
<HR>
<LEFT><A NAME=mginputdevice><H1 CLASS="APISYMBOL">mginputdevice</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mginputdevice</B> - Abstract type used to represent an input device<P></DD>
</DL>
<HR>
<LEFT><A NAME=mgkeysequence><H1 CLASS="APISYMBOL">mgkeysequence</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgkeysequence</B> - Keyboard key sequence used by shortcuts.<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct  {
&#32;&#32;&#32;unsigned int keyboardFlags;
&#32;&#32;&#32;mgkeytype key;
} mgkeysequence;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>keyboardFlags</B><DD>unsigned int - the state of the <I>Alt</I>, <I>Ctrl</I>, and <I>Shift</I> keys 
for the key sequence - the value of this field will be a bitwise 
combination of <A HREF=#MKB_ALTKEY>MKB_ALTKEY</A>, <A HREF=#MKB_CTRLKEY>MKB_CTRLKEY</A> and <A HREF=#MKB_SHIFTKEY>MKB_SHIFTKEY</A></DD></DT><DT><B>key</B><DD><A HREF=#mgkeytype>mgkeytype</A> - the key code for the key sequence</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This structure represents the state of the keyboard when a shortcut 
is entered by the user.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgkeytype>mgkeytype</A>, <A HREF=#mgtoolaction>mgtoolaction</A>, <A HREF=#mgToolActionSetShortCut>mgToolActionSetShortCut</A>, <A HREF=#mgToolActionGetShortCut>mgToolActionGetShortCut</A>.</DD></DL>
<HR>
<LEFT><A NAME=mgkeytype><H1 CLASS="APISYMBOL">mgkeytype</H1></A></LEFT>
<DL>
<DT><H3>ENUM NAME</H3></DT>
<DD><B>mgkeytype</B> - Keyboard Key names<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef enum mgkeytype {
&#32;&#32;&#32;MKEY_NOKEY,
&#32;&#32;&#32;MKEY_ESCAPE,
&#32;&#32;&#32;MKEY_BACK,
&#32;&#32;&#32;MKEY_TAB,
&#32;&#32;&#32;MKEY_RETURN,
&#32;&#32;&#32;MKEY_F1,
&#32;&#32;&#32;MKEY_F2,
&#32;&#32;&#32;MKEY_F3,
&#32;&#32;&#32;MKEY_F4,
&#32;&#32;&#32;MKEY_F5,
&#32;&#32;&#32;MKEY_F6,
&#32;&#32;&#32;MKEY_F7,
&#32;&#32;&#32;MKEY_F8,
&#32;&#32;&#32;MKEY_F9,
&#32;&#32;&#32;MKEY_F10,
&#32;&#32;&#32;MKEY_F11,
&#32;&#32;&#32;MKEY_F12,
&#32;&#32;&#32;MKEY_F13,
&#32;&#32;&#32;MKEY_F14,
&#32;&#32;&#32;MKEY_F15,
&#32;&#32;&#32;MKEY_F16,
&#32;&#32;&#32;MKEY_KEYPAD0,
&#32;&#32;&#32;MKEY_KEYPAD1,
&#32;&#32;&#32;MKEY_KEYPAD2,
&#32;&#32;&#32;MKEY_KEYPAD3,
&#32;&#32;&#32;MKEY_KEYPAD4,
&#32;&#32;&#32;MKEY_KEYPAD5,
&#32;&#32;&#32;MKEY_KEYPAD6,
&#32;&#32;&#32;MKEY_KEYPAD7,
&#32;&#32;&#32;MKEY_KEYPAD8,
&#32;&#32;&#32;MKEY_KEYPAD9,
&#32;&#32;&#32;MKEY_APOSTROPHE,
&#32;&#32;&#32;MKEY_COMMA,
&#32;&#32;&#32;MKEY_MINUS,
&#32;&#32;&#32;MKEY_PERIOD,
&#32;&#32;&#32;MKEY_SLASH,
&#32;&#32;&#32;MKEY_SEMICOLON,
&#32;&#32;&#32;MKEY_EQUAL,
&#32;&#32;&#32;MKEY_0,
&#32;&#32;&#32;MKEY_1,
&#32;&#32;&#32;MKEY_2,
&#32;&#32;&#32;MKEY_3,
&#32;&#32;&#32;MKEY_4,
&#32;&#32;&#32;MKEY_5,
&#32;&#32;&#32;MKEY_6,
&#32;&#32;&#32;MKEY_7,
&#32;&#32;&#32;MKEY_8,
&#32;&#32;&#32;MKEY_9,
&#32;&#32;&#32;MKEY_A,
&#32;&#32;&#32;MKEY_B,
&#32;&#32;&#32;MKEY_C,
&#32;&#32;&#32;MKEY_D,
&#32;&#32;&#32;MKEY_E,
&#32;&#32;&#32;MKEY_F,
&#32;&#32;&#32;MKEY_G,
&#32;&#32;&#32;MKEY_H,
&#32;&#32;&#32;MKEY_I,
&#32;&#32;&#32;MKEY_J,
&#32;&#32;&#32;MKEY_K,
&#32;&#32;&#32;MKEY_L,
&#32;&#32;&#32;MKEY_M,
&#32;&#32;&#32;MKEY_N,
&#32;&#32;&#32;MKEY_O,
&#32;&#32;&#32;MKEY_P,
&#32;&#32;&#32;MKEY_Q,
&#32;&#32;&#32;MKEY_R,
&#32;&#32;&#32;MKEY_S,
&#32;&#32;&#32;MKEY_T,
&#32;&#32;&#32;MKEY_U,
&#32;&#32;&#32;MKEY_V,
&#32;&#32;&#32;MKEY_W,
&#32;&#32;&#32;MKEY_X,
&#32;&#32;&#32;MKEY_Y,
&#32;&#32;&#32;MKEY_Z,
&#32;&#32;&#32;MKEY_LEFTBRACKET,
&#32;&#32;&#32;MKEY_BACKSLASH,
&#32;&#32;&#32;MKEY_RIGHTBRACKET,
&#32;&#32;&#32;MKEY_PAGEUP,
&#32;&#32;&#32;MKEY_QUOTELEFT,
&#32;&#32;&#32;MKEY_PAGEDOWN,
&#32;&#32;&#32;MKEY_CLEAR,
&#32;&#32;&#32;MKEY_UP,
&#32;&#32;&#32;MKEY_DOWN,
&#32;&#32;&#32;MKEY_LEFT,
&#32;&#32;&#32;MKEY_RIGHT,
&#32;&#32;&#32;MKEY_INSERT,
&#32;&#32;&#32;MKEY_DELETE,
&#32;&#32;&#32;MKEY_HOME,
&#32;&#32;&#32;MKEY_END,
&#32;&#32;&#32;MKEY_DIVIDE,
&#32;&#32;&#32;MKEY_MULTIPLY,
&#32;&#32;&#32;MKEY_SUBTRACT,
&#32;&#32;&#32;MKEY_ADD,
&#32;&#32;&#32;MKEY_DECIMAL,
&#32;&#32;&#32;MKEY_SPACE,
} mgkeytype;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>MKEY_NOKEY</B><DD>No key<DT><B>MKEY_ESCAPE</B><DD>Escape key<DT><B>MKEY_BACK</B><DD>Backspace key<DT><B>MKEY_TAB</B><DD>Tab key<DT><B>MKEY_RETURN</B><DD>Return key<DT><B>MKEY_F1</B><DD>Function key F1<DT><B>MKEY_F2</B><DD>Function key F2<DT><B>MKEY_F3</B><DD>Function key F3<DT><B>MKEY_F4</B><DD>Function key F4<DT><B>MKEY_F5</B><DD>Function key F5<DT><B>MKEY_F6</B><DD>Function key F6<DT><B>MKEY_F7</B><DD>Function key F7<DT><B>MKEY_F8</B><DD>Function key F8<DT><B>MKEY_F9</B><DD>Function key F9<DT><B>MKEY_F10</B><DD>Function key F10<DT><B>MKEY_F11</B><DD>Function key F11<DT><B>MKEY_F12</B><DD>Function key F12<DT><B>MKEY_F13</B><DD>Function key F13<DT><B>MKEY_F14</B><DD>Function key F14<DT><B>MKEY_F15</B><DD>Function key F15<DT><B>MKEY_F16</B><DD>Function key F16<DT><B>MKEY_KEYPAD0</B><DD>Keypad key 0<DT><B>MKEY_KEYPAD1</B><DD>Keypad key 1<DT><B>MKEY_KEYPAD2</B><DD>Keypad key 2<DT><B>MKEY_KEYPAD3</B><DD>Keypad key 3<DT><B>MKEY_KEYPAD4</B><DD>Keypad key 4<DT><B>MKEY_KEYPAD5</B><DD>Keypad key 5<DT><B>MKEY_KEYPAD6</B><DD>Keypad key 6<DT><B>MKEY_KEYPAD7</B><DD>Keypad key 7<DT><B>MKEY_KEYPAD8</B><DD>Keypad key 8<DT><B>MKEY_KEYPAD9</B><DD>Keypad key 9<DT><B>MKEY_APOSTROPHE</B><DD>Apostrophe key<DT><B>MKEY_COMMA</B><DD>Comma key<DT><B>MKEY_MINUS</B><DD>Minus key<DT><B>MKEY_PERIOD</B><DD>Period key<DT><B>MKEY_SLASH</B><DD>Forward Slash key<DT><B>MKEY_SEMICOLON</B><DD>Semicolon key<DT><B>MKEY_EQUAL</B><DD>Equals key<DT><B>MKEY_0</B><DD>0 key<DT><B>MKEY_1</B><DD>1 key<DT><B>MKEY_2</B><DD>2 key<DT><B>MKEY_3</B><DD>3 key<DT><B>MKEY_4</B><DD>4 key<DT><B>MKEY_5</B><DD>5 key<DT><B>MKEY_6</B><DD>6 key<DT><B>MKEY_7</B><DD>7 key<DT><B>MKEY_8</B><DD>8 key<DT><B>MKEY_9</B><DD>9 key<DT><B>MKEY_A</B><DD>A key<DT><B>MKEY_B</B><DD>B key<DT><B>MKEY_C</B><DD>C key<DT><B>MKEY_D</B><DD>D key<DT><B>MKEY_E</B><DD>E key<DT><B>MKEY_F</B><DD>F key<DT><B>MKEY_G</B><DD>G key<DT><B>MKEY_H</B><DD>H key<DT><B>MKEY_I</B><DD>I key<DT><B>MKEY_J</B><DD>J key<DT><B>MKEY_K</B><DD>K key<DT><B>MKEY_L</B><DD>L key<DT><B>MKEY_M</B><DD>M key<DT><B>MKEY_N</B><DD>N key<DT><B>MKEY_O</B><DD>O key<DT><B>MKEY_P</B><DD>P key<DT><B>MKEY_Q</B><DD>Q key<DT><B>MKEY_R</B><DD>R key<DT><B>MKEY_S</B><DD>S key<DT><B>MKEY_T</B><DD>T key<DT><B>MKEY_U</B><DD>U key<DT><B>MKEY_V</B><DD>V key<DT><B>MKEY_W</B><DD>W key<DT><B>MKEY_X</B><DD>X key<DT><B>MKEY_Y</B><DD>Y key<DT><B>MKEY_Z</B><DD>Z key<DT><B>MKEY_LEFTBRACKET</B><DD>Left Bracket key<DT><B>MKEY_BACKSLASH</B><DD>Backward Slash key<DT><B>MKEY_RIGHTBRACKET</B><DD>Right Bracket key<DT><B>MKEY_PAGEUP</B><DD>Page Up key<DT><B>MKEY_QUOTELEFT</B><DD>Left Quote key<DT><B>MKEY_PAGEDOWN</B><DD>Page Down key<DT><B>MKEY_CLEAR</B><DD>C Up key<DT><B>MKEY_UP</B><DD>Up Arrow key<DT><B>MKEY_DOWN</B><DD>Down Arrow key<DT><B>MKEY_LEFT</B><DD>Left Arrow key<DT><B>MKEY_RIGHT</B><DD>Right Arrow key<DT><B>MKEY_INSERT</B><DD>Insert key<DT><B>MKEY_DELETE</B><DD>Delete key<DT><B>MKEY_HOME</B><DD>Home key<DT><B>MKEY_END</B><DD>End key<DT><B>MKEY_DIVIDE</B><DD>Keypad Divide key<DT><B>MKEY_MULTIPLY</B><DD>Keypad Multiply key<DT><B>MKEY_SUBTRACT</B><DD>Keypad Subtract key<DT><B>MKEY_ADD</B><DD>Keypad Add key<DT><B>MKEY_DECIMAL</B><DD>Keypad Decimal key<DT><B>MKEY_SPACE</B><DD>Space Key</DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This enumerated type is used to identify keyboard keys. 
See <A HREF=#mgkeysequence>mgkeysequence</A>.</P></DD></DT></DL>
<HR>
<LEFT><A NAME=mglicense><H1 CLASS="APISYMBOL">mglicense</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mglicense</B> - Abstract type used to represent a license<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewLicense>mgNewLicense</A>, <A HREF=#mgCheckoutLicense>mgCheckoutLicense</A></DD></DL>
<HR>
<LEFT><A NAME=mglightpointanimationsequencedata><H1 CLASS="APISYMBOL">mglightpointanimationsequencedata</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mglightpointanimationsequencedata</B> - Light Point Animation Sequence data<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct  {
&#32;&#32;&#32;unsigned int state;
&#32;&#32;&#32;float duration;
&#32;&#32;&#32;unsigned int colorIndex;
&#32;&#32;&#32;float colorIntensity;
} mglightpointanimationsequencedata;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>state</B><DD>unsigned int - state of this item in the sequence - 
On = 0, Off = 1, Color Change = 2</DD></DT><DT><B>duration</B><DD>float - time (in seconds) for this item in the sequence</DD></DT><DT><B>colorIndex</B><DD>unsigned int - index of color for this item in the sequence if 
state is On or Color Change, ignored when state is Off</DD></DT><DT><B>colorIntensity</B><DD>float - intensity of color for this item in the sequence if 
state is On or Color Change, ignored when state is Off</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Use an array of <A HREF=#mglightpointanimationsequencedata>mglightpointanimationsequencedata</A> to add and get 
light point animation sequence records.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mglightpointanimationsequencedata>mglightpointanimationsequencedata</A>, 
<A HREF=#mgLightPointAnimationSequenceGet>mgLightPointAnimationSequenceGet</A>, 
<A HREF=#mgLightPointAnimationSequenceSet>mgLightPointAnimationSequenceSet</A></DD></DL>
<HR>
<LEFT><A NAME=mglined><H1 CLASS="APISYMBOL">mglined</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mglined</B> - Double precision line record<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct mglined {
&#32;&#32;&#32;mgcoord3d p1;
&#32;&#32;&#32;mgcoord3d p2;
} mglined;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>p1</B><DD><A HREF=#mgcoord3d>mgcoord3d</A> - point 1 of line</DD></DT><DT><B>p2</B><DD><A HREF=#mgcoord3d>mgcoord3d</A> - point 2 of line</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This record contains 2 3-D coordinates that define a line.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mgplaned>mgplaned</A>, <A HREF=#mgboxd>mgboxd</A>, <A HREF=#mgMakeLine>mgMakeLine</A>, <A HREF=#mgVectordFromLine>mgVectordFromLine</A></DD></DL>
<HR>
<LEFT><A NAME=mglistactivatecallbackrec><H1 CLASS="APISYMBOL">mglistactivatecallbackrec</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mglistactivatecallbackrec</B> - callback structure for the activate control 
event sent to list controls<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct  {
&#32;&#32;&#32;mgguicalldatatype callDataType;
&#32;&#32;&#32;mglistactivatereason activateReason;
} mglistactivatecallbackrec;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>callDataType</B><DD><A HREF=#mgguicalldatatype>mgguicalldatatype</A> - call data type that indicates the 
type of call data this object really is - 
will always be <A HREF=#mgguicalldatatype>MGCD_LISTACTIVATE</A></DD></DT><DT><B>activateReason</B><DD><A HREF=#mglistactivatereason>mglistactivatereason</A> - reason the activate control event was sent to the list control - 
possible values are: <BR> 
<A HREF=#mglistactivatereason>MLIST_SELECT</A> - The user selected an item in the list. 
<BR> 
<A HREF=#mglistactivatereason>MLIST_DESELECT</A> - The user deselected an item in the list. 
<BR> 
<A HREF=#mglistactivatereason>MLIST_DOUBLECLICK</A> - The user double clicked an item in the list. 
<BR></DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When the <A HREF=#MGCB_ACTIVATE>MGCB_ACTIVATE</A> control event is sent to 
a list control via its <A HREF=#mgguifunc>mgguifunc</A>, the <I>calldata</I> parameter passed in will point 
to an object of this type.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgguifunc>mgguifunc</A></DD></DL>
<HR>
<LEFT><A NAME=mglistactivatereason><H1 CLASS="APISYMBOL">mglistactivatereason</H1></A></LEFT>
<DL>
<DT><H3>ENUM NAME</H3></DT>
<DD><B>mglistactivatereason</B> - List activate reason type<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef enum mglistactivatereason {
&#32;&#32;&#32;MLIST_SELECT,
&#32;&#32;&#32;MLIST_DESELECT,
&#32;&#32;&#32;MLIST_DOUBLECLICK,
} mglistactivatereason;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>MLIST_SELECT</B><DD>List item selected.  This indicates that the user selected 
an item in the list.<DT><B>MLIST_DESELECT</B><DD>List item deselected.  This indicates that the user deselected 
an item in the list.<DT><B>MLIST_DOUBLECLICK</B><DD>List item double clicked.  This indicates that the user double clicked 
an item in the list.</DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This enumerated type is used when the activate control event is sent to list controls.</P></DD></DT></DL>
<HR>
<LEFT><A NAME=mgmatrix><H1 CLASS="APISYMBOL">mgmatrix</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgmatrix</B> - a double precision 4 x 4 matrix used for transformations<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Elements are stored in row major order (i.e., m[0], m[1], m[2] and m[3] are 
the elements in the first row of matrix m).</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrixstack>mgmatrixstack</A>, <A HREF=#mgGetMatrix>mgGetMatrix</A>, 
<A HREF=#mgMatrixFormTranslate>mgMatrixFormTranslate</A>, <A HREF=#mgMatrixFormRotate>mgMatrixFormRotate</A>, <A HREF=#mgMatrixFormScale>mgMatrixFormScale</A>, 
<A HREF=#mgMatrixFormRotateX>mgMatrixFormRotateX</A>, <A HREF=#mgMatrixFormRotateY>mgMatrixFormRotateY</A>, <A HREF=#mgMatrixFormRotateZ>mgMatrixFormRotateZ</A>, 
<A HREF=#mgMatrixFormQuadToQuad>mgMatrixFormQuadToQuad</A>,</DD></DL>
<HR>
<LEFT><A NAME=mgmatrixstack><H1 CLASS="APISYMBOL">mgmatrixstack</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgmatrixstack</B> - An opaque pointer type used to represent a matrix stack<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgmatrix>mgmatrix</A>, <A HREF=#mgFreeMatrixStack>mgFreeMatrixStack</A>, 
<A HREF=#mgMatrixStackPush>mgMatrixStackPush</A>, <A HREF=#mgMatrixStackPop>mgMatrixStackPop</A>, 
<A HREF=#mgMatrixStackLoadIdentity>mgMatrixStackLoadIdentity</A>, <A HREF=#mgMatrixStackIsIdentity>mgMatrixStackIsIdentity</A>, 
<A HREF=#mgMatrixStackLoadMatrix>mgMatrixStackLoadMatrix</A>, <A HREF=#mgMatrixStackGetMatrix>mgMatrixStackGetMatrix</A>, 
<A HREF=#mgMatrixStackMultiply>mgMatrixStackMultiply</A>, <A HREF=#mgMatrixStackTranslate>mgMatrixStackTranslate</A>, <A HREF=#mgMatrixStackScale>mgMatrixStackScale</A>, 
<A HREF=#mgMatrixStackRotate>mgMatrixStackRotate</A>, <A HREF=#mgMatrixStackRotateX>mgMatrixStackRotateX</A>, 
<A HREF=#mgMatrixStackRotateY>mgMatrixStackRotateY</A>, <A HREF=#mgMatrixStackRotateZ>mgMatrixStackRotateZ</A></DD></DL>
<HR>
<LEFT><A NAME=mgmessageseverityenum><H1 CLASS="APISYMBOL">mgmessageseverityenum</H1></A></LEFT>
<DL>
<DT><H3>ENUM NAME</H3></DT>
<DD><B>mgmessageseverityenum</B> - Severity level for 
system messages<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef enum mgmessageseverityenum {
&#32;&#32;&#32;MMSG_STATUS,
&#32;&#32;&#32;MMSG_WARNING,
&#32;&#32;&#32;MMSG_ERROR,
&#32;&#32;&#32;MMSG_TIP,
} mgmessageseverityenum;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>MMSG_STATUS</B><DD>Severity level of <I>status</I><DT><B>MMSG_WARNING</B><DD>Severity level of <I>warning</I><DT><B>MMSG_ERROR</B><DD>Severity level of <I>error</I><DT><B>MMSG_TIP</B><DD>Severity level of <I>tip</I></DL></DT></DL>
<HR>
<LEFT><A NAME=mgmodelingprefname><H1 CLASS="APISYMBOL">mgmodelingprefname</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgmodelingprefname</B> - A string type used to reference Modeling Preferences 
when using <A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A> or <A HREF=#mgModelingPrefGetDouble>mgModelingPrefGetDouble</A><P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>The list of accessible modeling preferences include:<BR> 
<A HREF=#MPREFD_MATCHVERTEXTOLERANCE>MPREFD_MATCHVERTEXTOLERANCE</A><BR> 
<A HREF=#MPREFD_COPLANARTOLERANCE>MPREFD_COPLANARTOLERANCE</A><BR> 
<A HREF=#MPREFD_COALIGNEDVERTEXTOLERANCE>MPREFD_COALIGNEDVERTEXTOLERANCE</A><BR> 
<A HREF=#MPREFD_SNAPTOANGLE>MPREFD_SNAPTOANGLE</A><BR> 
<A HREF=#MPREFI_AUTOAPPLYMATERIAL>MPREFI_AUTOAPPLYMATERIAL</A><BR> 
<A HREF=#MPREFI_AUTOAPPLYALTCOLOR>MPREFI_AUTOAPPLYALTCOLOR</A><BR> 
<A HREF=#MPREFI_AUTOAPPLYIRCODE>MPREFI_AUTOAPPLYIRCODE</A><BR> 
<A HREF=#MPREFI_AUTOAPPLYSHADELIT2D>MPREFI_AUTOAPPLYSHADELIT2D</A><BR> 
<A HREF=#MPREFI_AUTOAPPLYSHADELIT3D>MPREFI_AUTOAPPLYSHADELIT3D</A><BR> 
<A HREF=#MPREFI_FLIPDDSIMAGES>MPREFI_FLIPDDSIMAGES</A><BR> 
<A HREF=#MPREFI_SNAPROTATION>MPREFI_SNAPROTATION</A><BR> 
<A HREF=#MPREFI_SNAPHANDLES>MPREFI_SNAPHANDLES</A><BR> 
<A HREF=#MPREFI_SIZEHANDLES>MPREFI_SIZEHANDLES</A><BR> 
<A HREF=#MPREFI_SCALEHANDLES>MPREFI_SCALEHANDLES</A><BR> 
<A HREF=#MPREFI_HANDLETHICKNESS>MPREFI_HANDLETHICKNESS</A><BR> 
<A HREF=#MPREFI_DRAWHANDLESONTOP>MPREFI_DRAWHANDLESONTOP</A><BR> 
<A HREF=#MPREFI_SHADEWIRE>MPREFI_SHADEWIRE</A><BR> 
<A HREF=#MPREFI_MOUSEUPZOOMOUT>MPREFI_MOUSEUPZOOMOUT</A><BR> 
<A HREF=#MPREFI_TEXTUREPALETTEDIMENSION>MPREFI_TEXTUREPALETTEDIMENSION</A><BR></P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgModelingPrefGetInteger>mgModelingPrefGetInteger</A>, <A HREF=#mgModelingPrefGetDouble>mgModelingPrefGetDouble</A></DD></DL>
<HR>
<LEFT><A NAME=mgmodulehandle><H1 CLASS="APISYMBOL">mgmodulehandle</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgmodulehandle</B> - Platform-specific type used to represent a plug-in module 
library object<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Use this to load a resource.</P></DD><DD><P>On Windows, this is type HINSTANCE.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetModuleHandle>mgGetModuleHandle</A>, <A HREF=#mgLoadResource>mgLoadResource</A></DD></DL>
<HR>
<LEFT><A NAME=mgmouseinputtype><H1 CLASS="APISYMBOL">mgmouseinputtype</H1></A></LEFT>
<DL>
<DT><H3>ENUM NAME</H3></DT>
<DD><B>mgmouseinputtype</B> - Mouse Input Selector type<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef enum mgmouseinputtype {
&#32;&#32;&#32;MMSI_NOINPUT,
&#32;&#32;&#32;MMSI_VERTEXINPUT,
&#32;&#32;&#32;MMSI_POINTINPUT,
&#32;&#32;&#32;MMSI_PICKINPUT,
&#32;&#32;&#32;MMSI_DEVICEINPUT,
} mgmouseinputtype;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>MMSI_NOINPUT</B><DD>No mouse input selected<DT><B>MMSI_VERTEXINPUT</B><DD>Select 3D vertex mouse input<DT><B>MMSI_POINTINPUT</B><DD>Select 2D point mouse input<DT><B>MMSI_PICKINPUT</B><DD>Select geometry pick mouse input<DT><B>MMSI_DEVICEINPUT</B><DD>Select device specific input</DL></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSelectMouseInput>mgEditorSelectMouseInput</A></DD></DL>
<HR>
<LEFT><A NAME=mgmousestate><H1 CLASS="APISYMBOL">mgmousestate</H1></A></LEFT>
<DL>
<DT><H3>ENUM NAME</H3></DT>
<DD><B>mgmousestate</B> - Mouse State type<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef enum mgmousestate {
&#32;&#32;&#32;MMSS_START,
&#32;&#32;&#32;MMSS_CONTINUE,
&#32;&#32;&#32;MMSS_STOP,
&#32;&#32;&#32;MMSS_NONE,
} mgmousestate;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>MMSS_START</B><DD>The mouse-start state.  This indicates that the 
associated event was the first (down) event in a sequence 
of mouse down/drag/release events.  The event sequence will 
have at most, one <A HREF=#mgmousestate>MMSS_START</A> event which 
will always be the first event sent.<DT><B>MMSS_CONTINUE</B><DD>The drag-mouse state.  This indicates that the 
associated event was a drag event in a sequence of mouse 
down/drag/release events.  The event sequence will 
have 0-n <A HREF=#mgmousestate>MMSS_CONTINUE</A> events, the first of 
which will always follow the <A HREF=#mgmousestate>MMSS_START</A> event, 
and the last of which will always precede the 
<A HREF=#mgmousestate>MMSS_STOP</A> event.<DT><B>MMSS_STOP</B><DD>The mouse-stop state.  This indicates that the 
associated event was the last (release) event in a sequence 
of mouse down/drag/release events.  The event sequence will 
have at most, one <A HREF=#mgmousestate>MMSS_STOP</A> event which will 
always be the last event sent.<DT><B>MMSS_NONE</B><DD>The mouse-none state.  This indicates that the 
mouse was not involved with the associated event.</DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This enumerated type is used in the following contexts:</P></DD><DD><P>When reporting mouse input events to editor tools.  See 
<A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSetVertexFunc>mgEditorSetVertexFunc</A>, 
<A HREF=#mgEditorSetPointFunc>mgEditorSetPointFunc</A>, <A HREF=#mgEditorSetPickFunc>mgEditorSetPickFunc</A> for more 
information.</P></DD><DD><P>When reporting the <A HREF=#MGCB_ACTIVATE>MGCB_ACTIVATE</A> control event to scale controls. 
See <A HREF=#mgscaleactivatecallbackrec>mgscaleactivatecallbackrec</A> for more information.</P></DD><DD><P>When reporting the <A HREF=#MGCB_ACTIVATE>MGCB_ACTIVATE</A> control event to text controls 
that have an associated spin buddy control. 
See <A HREF=#mgtextactivatecallbackrec>mgtextactivatecallbackrec</A> for more information.</P></DD></DT></DL>
<HR>
<LEFT><A NAME=mgnodeexpression><H1 CLASS="APISYMBOL">mgnodeexpression</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgnodeexpression</B> - Generic type used to embody a node in an expression tree.<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>OpenFlight API users do not need to manipulate the internal fields of this structure directly; 
simply pass the structure into API functions instead.</P></DD></DT></DL>
<HR>
<LEFT><A NAME=mgnodeexpressionoperator><H1 CLASS="APISYMBOL">mgnodeexpressionoperator</H1></A></LEFT>
<DL>
<DT><H3>ENUM NAME</H3></DT>
<DD><B>mgnodeexpressionoperator</B> - Node expression type<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef enum mgnodeexpressionoperator {
&#32;&#32;&#32;MEOP_EQ,
&#32;&#32;&#32;MEOP_NE,
&#32;&#32;&#32;MEOP_LT,
&#32;&#32;&#32;MEOP_LE,
&#32;&#32;&#32;MEOP_GT,
&#32;&#32;&#32;MEOP_GE,
&#32;&#32;&#32;MEOP_LOGAND,
&#32;&#32;&#32;MEOP_LOGOR,
&#32;&#32;&#32;MEOP_ADD,
&#32;&#32;&#32;MEOP_SUB,
&#32;&#32;&#32;MEOP_MUL,
&#32;&#32;&#32;MEOP_DIV,
&#32;&#32;&#32;MEOP_FUNC,
&#32;&#32;&#32;MEOP_LIT,
&#32;&#32;&#32;MEOP_GETATT,
&#32;&#32;&#32;MEOP_GETVAR,
} mgnodeexpressionoperator;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>MEOP_EQ</B><DD>The equal to operator.<DT><B>MEOP_NE</B><DD>The not equal to operator.<DT><B>MEOP_LT</B><DD>The less than operator.<DT><B>MEOP_LE</B><DD>The less than or equal to operator.<DT><B>MEOP_GT</B><DD>The greater than operator.<DT><B>MEOP_GE</B><DD>The greater than or equal to operator.<DT><B>MEOP_LOGAND</B><DD>The logical and operator.<DT><B>MEOP_LOGOR</B><DD>The logical or operator.<DT><B>MEOP_ADD</B><DD>The addition operator.<DT><B>MEOP_SUB</B><DD>The subtraction operator.<DT><B>MEOP_MUL</B><DD>The multiplication operator.<DT><B>MEOP_DIV</B><DD>The division operator.<DT><B>MEOP_FUNC</B><DD>The indication to use a function as the operator.<DT><B>MEOP_LIT</B><DD>The indication of a literal (no operation performed).<DT><B>MEOP_GETATT</B><DD>The indication to use the mgGetAttList function.<DT><B>MEOP_GETVAR</B><DD>The indication of a variable.</DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This enumerated type is used to indicate the operator to be embodied by the 
the expression returned from the <A HREF=#mgNewNodeExpressionOperator>mgNewNodeExpressionOperator</A> call</P></DD></DT></DL>
<HR>
<LEFT><A NAME=mgnotifier><H1 CLASS="APISYMBOL">mgnotifier</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgnotifier</B> - Abstract type used to represent a model-time event notifier<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>You can register a notifier that triggers notification callbacks when 
pre-defined model time events occur.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterNotifier>mgRegisterNotifier</A>.</DD></DL>
<HR>
<LEFT><A NAME=mgnotifierevent><H1 CLASS="APISYMBOL">mgnotifierevent</H1></A></LEFT>
<DL>
<DT><H3>ENUM NAME</H3></DT>
<DD><B>mgnotifierevent</B> - Notifier Event types<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef enum mgnotifierevent {
&#32;&#32;&#32;MNOTIFY_SELECTLISTCHANGED,
&#32;&#32;&#32;MNOTIFY_NEWTOPDATABASE,
&#32;&#32;&#32;MNOTIFY_DATABASECLOSED,
&#32;&#32;&#32;MNOTIFY_CURRENTPRIMARYCOLORCHANGED,
&#32;&#32;&#32;MNOTIFY_CURRENTALTCOLORCHANGED,
&#32;&#32;&#32;MNOTIFY_CURRENTTEXTURECHANGED,
&#32;&#32;&#32;MNOTIFY_CURRENTMATERIALCHANGED,
&#32;&#32;&#32;MNOTIFY_CURRENTTEXTUREMAPPINGCHANGED,
&#32;&#32;&#32;MNOTIFY_CURRENTLIGHTPOINTAPPEARANCECHANGED,
&#32;&#32;&#32;MNOTIFY_CURRENTLIGHTPOINTANIMATIONCHANGED,
&#32;&#32;&#32;MNOTIFY_CURRENTSHADERCHANGED,
&#32;&#32;&#32;MNOTIFY_CURRENTSOUNDCHANGED,
&#32;&#32;&#32;MNOTIFY_CURRENTLIGHTSOURCECHANGED,
&#32;&#32;&#32;MNOTIFY_LIGHTPOINTPALETTEIZED,
&#32;&#32;&#32;MNOTIFY_DESKTOPINIT,
&#32;&#32;&#32;MNOTIFY_DESKTOPEXIT,
&#32;&#32;&#32;MNOTIFY_DATABASEOPENED,
&#32;&#32;&#32;MNOTIFY_DATABASESAVED,
&#32;&#32;&#32;MNOTIFY_NODECHANGED,
&#32;&#32;&#32;MNOTIFY_NODEDELETED,
&#32;&#32;&#32;MNOTIFY_NODECREATED,
&#32;&#32;&#32;MNOTIFY_NODEREPARENTED,
&#32;&#32;&#32;MNOTIFY_COLORPALETTECHANGED,
&#32;&#32;&#32;MNOTIFY_TEXTUREPALETTECHANGED,
&#32;&#32;&#32;MNOTIFY_MATERIALPALETTECHANGED,
&#32;&#32;&#32;MNOTIFY_TEXTUREMAPPINGPALETTECHANGED,
&#32;&#32;&#32;MNOTIFY_LIGHTPOINTAPPEARANCEPALETTECHANGED,
&#32;&#32;&#32;MNOTIFY_LIGHTPOINTANIMATIONPALETTECHANGED,
&#32;&#32;&#32;MNOTIFY_SHADERPALETTECHANGED,
&#32;&#32;&#32;MNOTIFY_SOUNDPALETTECHANGED,
&#32;&#32;&#32;MNOTIFY_LIGHTSOURCEPALETTECHANGED,
&#32;&#32;&#32;MNOTIFY_SWITCHDISTANCECHANGED,
&#32;&#32;&#32;MNOTIFY_TIMEOFDAYCHANGED,
&#32;&#32;&#32;MNOTIFY_TEXTURESELECTCHANGED,
&#32;&#32;&#32;MNOTIFY_EXTENSIONCHANGED,
&#32;&#32;&#32;MNOTIFY_DATABASEPRESAVE,
&#32;&#32;&#32;MNOTIFY_EYEPOINTCHANGED,
} mgnotifierevent;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>MNOTIFY_SELECTLISTCHANGED</B><DD>Select List Change notifier event. This 
is sent whenever the select list contents change.<BR> 
Applicable to viewer tools only.<DT><B>MNOTIFY_NEWTOPDATABASE</B><DD>New Top Database notifier event. This is 
sent whenever a new database is selected to be 
the top (focus) database in Creator.<BR> 
Applicable to viewer and editor tools only.<DT><B>MNOTIFY_DATABASECLOSED</B><DD>Database Close notifier event. This is 
sent whenever a database is closed in Creator.<BR> 
Applicable to viewer and editor tools only.<DT><B>MNOTIFY_CURRENTPRIMARYCOLORCHANGED</B><DD>Current Primary Color Change notifier event. 
This is sent whenever the modeler selects a new 
primary modeling color.<BR> 
Applicable to viewer and editor tools only.<DT><B>MNOTIFY_CURRENTALTCOLORCHANGED</B><DD>Current Alternate Color Change notifier event. 
This is sent whenever the modeler selects a new 
alternate modeling color.<BR> 
Applicable to viewer and editor tools only.<DT><B>MNOTIFY_CURRENTTEXTURECHANGED</B><DD>Current Texture Change notifier event. 
This is sent whenever the modeler selects a new 
modeling texture.<BR> 
Applicable to viewer and editor tools only.<DT><B>MNOTIFY_CURRENTMATERIALCHANGED</B><DD>Current Material Change notifier event. 
This is sent whenever the modeler selects a new 
modeling material.<BR> 
Applicable to viewer and editor tools only.<DT><B>MNOTIFY_CURRENTTEXTUREMAPPINGCHANGED</B><DD>Current Texture Mapping Change notifier event. 
This is sent whenever the modeler selects a new 
modeling texture mapping.<BR> 
Applicable to viewer and editor tools only.<DT><B>MNOTIFY_CURRENTLIGHTPOINTAPPEARANCECHANGED</B><DD>Current Light Point Appearance Change notifier event. 
This is sent whenever the modeler selects a new 
modeling light point appearance.<BR> 
Applicable to viewer and editor tools only.<DT><B>MNOTIFY_CURRENTLIGHTPOINTANIMATIONCHANGED</B><DD>Current Light Point Animation Change notifier event. 
This is sent whenever the modeler selects a new 
modeling light point animation.<BR> 
Applicable to viewer and editor tools only.<DT><B>MNOTIFY_CURRENTSHADERCHANGED</B><DD>Current Shader Change notifier event. 
This is sent whenever the modeler selects a new 
modeling shader.<BR> 
Applicable to viewer and editor tools only.<DT><B>MNOTIFY_CURRENTSOUNDCHANGED</B><DD>Current Sound Change notifier event. 
This is sent whenever the modeler selects a new 
modeling sound.<BR> 
Applicable to viewer and editor tools only.<DT><B>MNOTIFY_CURRENTLIGHTSOURCECHANGED</B><DD>Current Light Source Change notifier event. 
This is sent whenever the modeler selects a new 
modeling light source.<BR> 
Applicable to viewer and editor tools only.<DT><B>MNOTIFY_LIGHTPOINTPALETTEIZED</B><DD>Light Point Paletteized notifier event. 
This is sent whenever an inline light point is read and converted 
to be a paletteized light point.<BR> 
Applicable to viewer tools only.<DT><B>MNOTIFY_DESKTOPINIT</B><DD>Desktop Initialized notifier event. This is 
sent when the Creator desktop starts after all plug-ins are 
initialized. <BR> 
Applicable to all tools.<DT><B>MNOTIFY_DESKTOPEXIT</B><DD>Desktop Exit notifier event. This is 
sent when the Creator desktop exits.<BR> 
Applicable to all tools.<DT><B>MNOTIFY_DATABASEOPENED</B><DD>Database Opened notifier event. This is 
sent whenever a database is opened in Creator.<BR> 
Applicable to viewer and editor tools only.<DT><B>MNOTIFY_DATABASESAVED</B><DD>Database Saved notifier event. This is 
sent whenever a database is saved in Creator.<BR> 
Applicable to viewer and editor tools only.<DT><B>MNOTIFY_NODECHANGED</B><DD>Node Changed notifier event. This is 
sent whenever a node attribute is changed in Creator.<BR> 
Applicable to viewer tools only.<DT><B>MNOTIFY_NODEDELETED</B><DD>Node Deleted notifier event. This is 
sent whenever a node is deleted in Creator.<BR> 
Applicable to viewer tools only.<DT><B>MNOTIFY_NODECREATED</B><DD>Node Created notifier event. This is 
sent whenever a new node is created in Creator.<BR> 
Applicable to viewer tools only.<DT><B>MNOTIFY_NODEREPARENTED</B><DD>Node Re-Parented notifier event. This is 
sent whenever a new node is re-parented in Creator.<BR> 
Applicable to viewer tools only.<DT><B>MNOTIFY_COLORPALETTECHANGED</B><DD>Color Palette Changed notifier event. This is 
sent whenever a color palette entry is changed in Creator.<BR> 
Applicable to viewer and editor tools only.<DT><B>MNOTIFY_TEXTUREPALETTECHANGED</B><DD>Texture Palette Changed notifier event. This is 
sent whenever a texture palette entry is changed in Creator.<BR> 
Applicable to viewer and editor tools only.<DT><B>MNOTIFY_MATERIALPALETTECHANGED</B><DD>Material Palette Changed notifier event. This is 
sent whenever a material palette entry is changed in Creator.<BR> 
Applicable to viewer and editor tools only.<DT><B>MNOTIFY_TEXTUREMAPPINGPALETTECHANGED</B><DD>Texture Mapping Palette Changed notifier event. This is 
sent whenever a texture mapping palette entry is changed in Creator.<BR> 
Applicable to viewer and editor tools only.<DT><B>MNOTIFY_LIGHTPOINTAPPEARANCEPALETTECHANGED</B><DD>Light Point Appearance Palette Changed notifier event. This is 
sent whenever a light point appearance palette entry is changed in Creator.<BR> 
Applicable to viewer and editor tools only.<DT><B>MNOTIFY_LIGHTPOINTANIMATIONPALETTECHANGED</B><DD>Light Point Animation Palette Changed notifier event. This is 
sent whenever a light point animation palette entry is changed in Creator.<BR> 
Applicable to viewer and editor tools only.<DT><B>MNOTIFY_SHADERPALETTECHANGED</B><DD>Shader Palette Changed notifier event. This is 
sent whenever a shader palette entry is changed in Creator.<BR> 
Applicable to viewer and editor tools only.<DT><B>MNOTIFY_SOUNDPALETTECHANGED</B><DD>Sound Palette Changed notifier event. This is 
sent whenever a sound palette entry is changed in Creator.<BR> 
Applicable to viewer and editor tools only.<DT><B>MNOTIFY_LIGHTSOURCEPALETTECHANGED</B><DD>Light Source Palette Changed notifier event. This is 
sent whenever a light source palette entry is changed in Creator.<BR> 
Applicable to viewer and editor tools only.<DT><B>MNOTIFY_SWITCHDISTANCECHANGED</B><DD>Switch Distance Changed notifier event. This is 
sent whenever the switch distance is changed in Creator, 
usually via the More Detail or Less Detail commands.<BR> 
Applicable to viewer and editor tools only.<DT><B>MNOTIFY_TIMEOFDAYCHANGED</B><DD>Time of Day Changed notifier event. This is 
sent whenever the sky color changes in Creator.<BR> 
Applicable to viewer and editor tools only.<DT><B>MNOTIFY_TEXTURESELECTCHANGED</B><DD>Texture Select Change notifier event. This 
is sent whenever the textures selected in the 
palette change in Creator.<BR> 
Applicable to viewer and editor tools only.<DT><B>MNOTIFY_EXTENSIONCHANGED</B><DD>Extension Changed notifier event. This 
is sent whenever the definition of an OpenFlight 
extension is changed.<BR> 
Applicable to all tools.<DT><B>MNOTIFY_DATABASEPRESAVE</B><DD>Database Pre-Save notifier event. This is 
sent just before a database is saved in Creator.<BR> 
Applicable to viewer and editor tools only.<DT><B>MNOTIFY_EYEPOINTCHANGED</B><DD>Eye Point Changed notifier event. This is 
sent whenever the current eye point changes in Creator.<BR> 
Applicable to viewer and editor tools only.</DL></DT></DL>
<HR>
<LEFT><A NAME=mgpaletteid><H1 CLASS="APISYMBOL">mgpaletteid</H1></A></LEFT>
<DL>
<DT><H3>ENUM NAME</H3></DT>
<DD><B>mgpaletteid</B> - Palette Id type<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef enum mgpaletteid {
&#32;&#32;&#32;MPID_COLORPALETTE,
&#32;&#32;&#32;MPID_ALTCOLORPALETTE,
&#32;&#32;&#32;MPID_IRCOLORPALETTE,
&#32;&#32;&#32;MPID_MATERIALPALETTE,
&#32;&#32;&#32;MPID_LIGHTSOURCEPALETTE,
&#32;&#32;&#32;MPID_TEXTUREPALETTE,
&#32;&#32;&#32;MPID_TEXTUREMAPPINGPALETTE,
&#32;&#32;&#32;MPID_SOUNDPALETTE,
&#32;&#32;&#32;MPID_LINESTYLEPALETTE,
&#32;&#32;&#32;MPID_LIGHTPOINTPALETTE,
&#32;&#32;&#32;MPID_SHADERPALETTE,
} mgpaletteid;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>MPID_COLORPALETTE</B><DD>Primary Color Palette Id. 
This palette id specifies the Primary Color Palette.<DT><B>MPID_ALTCOLORPALETTE</B><DD>Alternate Color Palette Id. 
This palette id specifies the Alternate Color Palette.<DT><B>MPID_IRCOLORPALETTE</B><DD>Infrared Color Palette Id. 
This palette id specifies the Infrared Color Palette.<DT><B>MPID_MATERIALPALETTE</B><DD>Material Palette Id. 
This palette id specifies the Material Palette.<DT><B>MPID_LIGHTSOURCEPALETTE</B><DD>Light Source Palette Id. 
This palette id specifies the Light Source Palette.<DT><B>MPID_TEXTUREPALETTE</B><DD>Texture Palette Id. 
This palette id specifies the Texture Palette.<DT><B>MPID_TEXTUREMAPPINGPALETTE</B><DD>Texture Mapping Palette Id. 
This palette id specifies the Texture Mapping Palette.<DT><B>MPID_SOUNDPALETTE</B><DD>Sound Palette Id. 
This palette id specifies the Sound Palette.<DT><B>MPID_LINESTYLEPALETTE</B><DD>Line Style Palette Id. 
This palette id specifies the Line Style Palette.<DT><B>MPID_LIGHTPOINTPALETTE</B><DD>Light Point Palette Id. 
This palette id specifies the Light Point Palette.<DT><B>MPID_SHADERPALETTE</B><DD>Shader Palette Id. 
This palette id specifies the Shader Palette.</DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This type is used to enumerate the database palettes that can be displayed 
using the <A HREF=#mgShowPalette>mgShowPalette</A> function.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgShowPalette>mgShowPalette</A></DD></DL>
<HR>
<LEFT><A NAME=mgpanelayout><H1 CLASS="APISYMBOL">mgpanelayout</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgpanelayout</B> - Abstract type used to represent a pane layout (splitter locations and view types).<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewPaneLayout>mgNewPaneLayout</A>, <A HREF=#mgFreePaneLayout>mgFreePaneLayout</A>, <A HREF=#mgGetPaneLayout>mgGetPaneLayout</A>, <A HREF=#mgSetPaneLayout>mgSetPaneLayout</A></DD></DL>
<HR>
<LEFT><A NAME=mgparam><H1 CLASS="APISYMBOL">mgparam</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgparam</B> - Abstract type used to represent a generic (tool) parameter. 
One or more  <A HREF=#mgparam>mgparam</A> objects can be collected in a <A HREF=#mgparamblock>mgparamblock</A> object.<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgparamblock>mgparamblock</A>, 
<A HREF=#mgParamAddInteger>mgParamAddInteger</A>, <A HREF=#mgParamAddDouble>mgParamAddDouble</A>, <A HREF=#mgParamAddFloat>mgParamAddFloat</A>, <A HREF=#mgParamAddBool>mgParamAddBool</A>, 
<A HREF=#mgParamAddString>mgParamAddString</A>, <A HREF=#mgParamAddDouble2>mgParamAddDouble2</A>, <A HREF=#mgParamAddDouble3>mgParamAddDouble3</A></DD></DL>
<HR>
<LEFT><A NAME=mgparamblock><H1 CLASS="APISYMBOL">mgparamblock</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgparamblock</B> - Abstract type used to represent a generic (tool) parameter block. 
A <A HREF=#mgparamblock>mgparamblock</A> object is composed of one or more <A HREF=#mgparam>mgparam</A> objects.<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgparam>mgparam</A>, <A HREF=#mgNewParamBlock>mgNewParamBlock</A>, <A HREF=#mgGetParamBlock>mgGetParamBlock</A></DD></DL>
<HR>
<LEFT><A NAME=mgpickinputdata><H1 CLASS="APISYMBOL">mgpickinputdata</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgpickinputdata</B> - Pick Mouse Input data<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct  {
&#32;&#32;&#32;unsigned int keyboardFlags;
&#32;&#32;&#32;unsigned int buttonFlags;
&#32;&#32;&#32;mgreclist pickList;
} mgpickinputdata;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>keyboardFlags</B><DD>unsigned int - the state of the <I>Alt</I>, <I>Ctrl</I>, and <I>Shift</I> keys - 
the value of this field will be a bitwise combination 
of <A HREF=#MKB_ALTKEY>MKB_ALTKEY</A>, <A HREF=#MKB_CTRLKEY>MKB_CTRLKEY</A> and <A HREF=#MKB_SHIFTKEY>MKB_SHIFTKEY</A></DD></DT><DT><B>buttonFlags</B><DD>unsigned int - the state of the <I>Left</I>, <I>Middle</I> and <I>Right</I> 
mouse buttons - the value of this field will be a bitwise 
combination of <A HREF=#MMB_LEFTMOUSE>MMB_LEFTMOUSE</A>, <A HREF=#MMB_MIDDLEMOUSE>MMB_MIDDLEMOUSE</A> and 
<A HREF=#MMB_RIGHTMOUSE>MMB_RIGHTMOUSE</A></DD></DT><DT><B>pickList</B><DD><A HREF=#mgreclist>mgreclist</A> - the select list containing the nodes that were selected</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When pick mouse input is reported to an editor tool via 
the corresponding pick input function, a pointer to a record 
of this type is passed to the pick function that describes 
the pick input.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSetPickFunc>mgEditorSetPickFunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgpixmap><H1 CLASS="APISYMBOL">mgpixmap</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgpixmap</B> - Abstract type used to represent a pixmap object<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetPixmap>mgResourceGetPixmap</A></DD></DL>
<HR>
<LEFT><A NAME=mgpixmaphandle><H1 CLASS="APISYMBOL">mgpixmaphandle</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgpixmaphandle</B> - Platform specific type to represent native pixmap 
items<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>On Windows, this is type HBITMAP or HICON depending on the 
format of the image contained in the resource file.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetPixmapHandle>mgGetPixmapHandle</A></DD></DL>
<HR>
<LEFT><A NAME=mgpixmapid><H1 CLASS="APISYMBOL">mgpixmapid</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgpixmapid</B> - Pixmap identifier type used to identify and extract 
pixmaps from resources<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetPixmap>mgResourceGetPixmap</A></DD></DL>
<HR>
<LEFT><A NAME=mgplaned><H1 CLASS="APISYMBOL">mgplaned</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgplaned</B> - Double precision plane record<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct mgplaned {
&#32;&#32;&#32;double a;
&#32;&#32;&#32;double b;
&#32;&#32;&#32;double c;
&#32;&#32;&#32;double d;
} mgplaned;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>a</B><DD>double - a coefficient of plane equation</DD></DT><DT><B>b</B><DD>double - b coefficient of plane equation</DD></DT><DT><B>c</B><DD>double - c coefficient of plane equation</DD></DT><DT><B>d</B><DD>double - d coefficient of plane equation</DD></DT></DL></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgcoord3d>mgcoord3d</A>, <A HREF=#mglined>mglined</A>, <A HREF=#mgMakePlaned>mgMakePlaned</A></DD></DL>
<HR>
<LEFT><A NAME=mgplugin><H1 CLASS="APISYMBOL">mgplugin</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgplugin</B> - Abstract type used to represent a plug-in module<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgpInit>mgpInit</A>, <A HREF=#mgpExit>mgpExit</A></DD></DL>
<HR>
<LEFT><A NAME=mgpluginsite><H1 CLASS="APISYMBOL">mgpluginsite</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgpluginsite</B> - Abstract type used to represent a plug-in data extension<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterSite>mgRegisterSite</A></DD></DL>
<HR>
<LEFT><A NAME=mgplugintool><H1 CLASS="APISYMBOL">mgplugintool</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgplugintool</B> - Abstract type used to represent a plug-in tool<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterImporter>mgRegisterImporter</A>, <A HREF=#mgRegisterExporter>mgRegisterExporter</A>, 
<A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgRegisterViewer>mgRegisterViewer</A>, 
<A HREF=#mgRegisterImageImporter>mgRegisterImageImporter</A></DD></DL>
<HR>
<LEFT><A NAME=mgpointinputdata><H1 CLASS="APISYMBOL">mgpointinputdata</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgpointinputdata</B> - 2D Point Mouse Input data<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct  {
&#32;&#32;&#32;mgmousestate mouseEvent;
&#32;&#32;&#32;unsigned int keyboardFlags;
&#32;&#32;&#32;unsigned int buttonFlags;
&#32;&#32;&#32;mgcoord2i* thisPoint;
&#32;&#32;&#32;mgcoord2i* firstPoint;
} mgpointinputdata;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>mouseEvent</B><DD><A HREF=#mgmousestate>mgmousestate</A> - the point input sequence state</DD></DT><DT><B>keyboardFlags</B><DD>unsigned int - the state of the <I>Alt</I>, <I>Ctrl</I>, and <I>Shift</I> keys - 
the value of this field will be a bitwise combination 
of <A HREF=#MKB_ALTKEY>MKB_ALTKEY</A>, <A HREF=#MKB_CTRLKEY>MKB_CTRLKEY</A> and <A HREF=#MKB_SHIFTKEY>MKB_SHIFTKEY</A></DD></DT><DT><B>buttonFlags</B><DD>unsigned int - the state of the <I>Left</I>, <I>Middle</I> and <I>Right</I> 
mouse buttons - the value of this field will be a bitwise 
combination of <A HREF=#MMB_LEFTMOUSE>MMB_LEFTMOUSE</A>, <A HREF=#MMB_MIDDLEMOUSE>MMB_MIDDLEMOUSE</A> and 
<A HREF=#MMB_RIGHTMOUSE>MMB_RIGHTMOUSE</A></DD></DT><DT><B>thisPoint</B><DD><A HREF=#mgcoord2i>mgcoord2i*</A> - address of 2D coordinate for 
the current point being reported in this sequence</DD></DT><DT><B>firstPoint</B><DD><A HREF=#mgcoord2i>mgcoord2i*</A> - address of 2D coordinate for 
the first point reported in this sequence</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When 2D point mouse input is reported to an editor tool via 
the corresponding 2D point input function, a pointer to a record 
of this type is passed to the point function that describes 
the point input.</P></DD><DD><P>The coordinates of 2D point mouse input are reported relative 
to the lower left corner of the graphics view in which the input 
was received.  That is, if the point reported is at the lower left 
corner of the graphics view, it will be reported as (0, 0).</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSetPointFunc>mgEditorSetPointFunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgprojcoord><H1 CLASS="APISYMBOL">mgprojcoord</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgprojcoord</B> - A projection coordinate expressed in latitude, longitude and height<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct mgprojcoord {
&#32;&#32;&#32;double lat;
&#32;&#32;&#32;double lon;
&#32;&#32;&#32;double height;
} mgprojcoord;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>lat</B><DD>double - the latitude in degrees, positive is north</DD></DT><DT><B>lon</B><DD>double - the longitude in degrees, positive is east</DD></DT><DT><B>height</B><DD>double - the elevation above mean sea level in meters</DD></DT></DL></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgProject>mgProject</A>, <A HREF=#mgUnproject>mgUnproject</A>, 
<A HREF=#mgProjectionConvertLLEtoXYZ>mgProjectionConvertLLEtoXYZ</A>, <A HREF=#mgProjectionConvertXYZtoLLE>mgProjectionConvertXYZtoLLE</A></DD></DL>
<HR>
<LEFT><A NAME=mgprojection><H1 CLASS="APISYMBOL">mgprojection</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgprojection</B> - Abstract type used to represent projection objects<P></DD>
</DL>
<HR>
<LEFT><A NAME=mgpropertyname><H1 CLASS="APISYMBOL">mgpropertyname</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgpropertyname</B> - A string type used to name user defined data<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Each user defined data item has a unique <A HREF=#mgpropertyname>mgpropertyname</A>.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgpropertyvalue>mgpropertyvalue</A>, 
<A HREF=#mgPluginPutProperty>mgPluginPutProperty</A>, <A HREF=#mgPluginToolPutProperty>mgPluginToolPutProperty</A>, <A HREF=#mgRecPutProperty>mgRecPutProperty</A>, 
<A HREF=#mgEditorPutProperty>mgEditorPutProperty</A>, <A HREF=#mgGuiPutProperty>mgGuiPutProperty</A></DD></DL>
<HR>
<LEFT><A NAME=mgpropertyvalue><H1 CLASS="APISYMBOL">mgpropertyvalue</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgpropertyvalue</B> - An opaque pointer type used to hold user defined data<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Each user defined data item should be cast to type <A HREF=#mgpropertyvalue>mgpropertyvalue</A>.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgpropertyname>mgpropertyname</A>, 
<A HREF=#mgPluginPutProperty>mgPluginPutProperty</A>, <A HREF=#mgPluginToolPutProperty>mgPluginToolPutProperty</A>, <A HREF=#mgRecPutProperty>mgRecPutProperty</A>, 
<A HREF=#mgEditorPutProperty>mgEditorPutProperty</A>, <A HREF=#mgGuiPutProperty>mgGuiPutProperty</A></DD></DL>
<HR>
<LEFT><A NAME=mgptrarray><H1 CLASS="APISYMBOL">mgptrarray</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgptrarray</B> - Abstract type used to represent a pointer array<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgptrstack>mgptrstack</A>, 
<A HREF=#mgNewPtrArray>mgNewPtrArray</A>, 
<A HREF=#mgPtrArrayAppend>mgPtrArrayAppend</A>, <A HREF=#mgPtrArrayInsert>mgPtrArrayInsert</A>, 
<A HREF=#mgPtrArrayReplace>mgPtrArrayReplace</A>, <A HREF=#mgPtrArrayGet>mgPtrArrayGet</A>, <A HREF=#mgPtrArrayRemove>mgPtrArrayRemove</A>, 
<A HREF=#mgPtrArrayClear>mgPtrArrayClear</A>, <A HREF=#mgPtrArrayLength>mgPtrArrayLength</A>, <A HREF=#mgPtrArraySort>mgPtrArraySort</A>, 
<A HREF=#mgPtrArraySearch>mgPtrArraySearch</A>, <A HREF=#mgPtrArrayBSearch>mgPtrArrayBSearch</A></DD></DL>
<HR>
<LEFT><A NAME=mgptrstack><H1 CLASS="APISYMBOL">mgptrstack</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgptrstack</B> - Abstract type used to represent a pointer stack<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgptrarray>mgptrarray</A>, 
<A HREF=#mgNewPtrStack>mgNewPtrStack</A>, <A HREF=#mgPtrStackPush>mgPtrStackPush</A>, <A HREF=#mgPtrStackPop>mgPtrStackPop</A>, <A HREF=#mgPtrStackClear>mgPtrStackClear</A>, 
<A HREF=#mgPtrStackTop>mgPtrStackTop</A>, <A HREF=#mgPtrStackLength>mgPtrStackLength</A></DD></DL>
<HR>
<LEFT><A NAME=mgrec><H1 CLASS="APISYMBOL">mgrec</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgrec</B> - Generic type used to access any type of record accessible by the OpenFlight API<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>OpenFlight API users do not need to manipulate the internal fields of this structure directly; 
simply pass the structure into API functions instead.  Variables of type <A HREF=#mgrec>mgrec</A> are referred to as records.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewRec>mgNewRec</A>, <A HREF=#mgNewRecDb>mgNewRecDb</A>, 
<A HREF=#mgDuplicate>mgDuplicate</A>, <A HREF=#mgDuplicateToDb>mgDuplicateToDb</A>, <A HREF=#mgDelete>mgDelete</A>, <A HREF=#mgAttach>mgAttach</A>, 
<A HREF=#mgAppend>mgAppend</A>, <A HREF=#mgInsert>mgInsert</A>, <A HREF=#mgReference>mgReference</A></DD></DL>
<HR>
<LEFT><A NAME=mgreclist><H1 CLASS="APISYMBOL">mgreclist</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgreclist</B> - Abstract type used to represent a general record list<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This node list is used for select lists and construct lists.</P></DD><DD><P>The node list maintains a list of node records and a traversal pointer 
to keep track of which node in the list is next to be traversed by 
<A HREF=#mgGetNextRecInList>mgGetNextRecInList</A>.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewRecList>mgNewRecList</A>, <A HREF=#mgFreeRecList>mgFreeRecList</A>, <A HREF=#mgGetSelectList>mgGetSelectList</A>, 
<A HREF=#mgGetConstructList>mgGetConstructList</A>, <A HREF=#mgGetTriangleList>mgGetTriangleList</A></DD></DL>
<HR>
<LEFT><A NAME=mgrenderercallbackreason><H1 CLASS="APISYMBOL">mgrenderercallbackreason</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgrenderercallbackreason</B> - Callback reason type used to renderer events<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When a renderer callback function function is called, the <I>callbackReason</I> 
parameter passed in of this type will specify which event triggered the callback.</P></DD><DD><P>Renderer callback functions are called to report these events.</P></DD><DD><P>The events that are sent to renderer callback functions are: <BR> 
<A HREF=#MRCB_INIT>MRCB_INIT</A> <BR> 
<A HREF=#MRCB_SHOW>MRCB_SHOW</A> <BR> 
<A HREF=#MRCB_SIZE>MRCB_SIZE</A> <BR> 
<A HREF=#MRCB_DRAW>MRCB_DRAW</A> <BR> 
<A HREF=#MRCB_HIDE>MRCB_HIDE</A> <BR> 
<A HREF=#MRCB_DESTROY>MRCB_DESTROY</A> <BR></P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterRenderer>mgRegisterRenderer</A>, <A HREF=#mgrendererfunc>mgrendererfunc</A>, <A HREF=#mgrenderercalldatatype>mgrenderercalldatatype</A></DD></DL>
<HR>
<LEFT><A NAME=mgrenderercallbackrec><H1 CLASS="APISYMBOL">mgrenderercallbackrec</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgrenderercallbackrec</B> - callback structure for renderer tool start functions<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct  {
&#32;&#32;&#32;mgtoolactivation toolActivation;
&#32;&#32;&#32;mgrenderercontext rendererContext;
&#32;&#32;&#32;mgbool startRenderer;
&#32;&#32;&#32;void* toolData;
} mgrenderercallbackrec;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>toolActivation</B><DD><A HREF=#mgtoolactivation>mgtoolactivation</A> - tool activation</DD></DT><DT><B>rendererContext</B><DD><A HREF=#mgrenderercontext>mgrenderercontext</A> - the renderer context associated to this 
invocation of the renderer tool</DD></DT><DT><B>startRenderer</B><DD><A HREF=#mgbool>mgbool</A> - <A HREF=#mgbool>MG_TRUE</A> to tell 
API whether or not to start your renderer</DD></DT><DT><B>toolData</B><DD>void* - tool instance data that will be 
passed to subsequent renderer tool interactions</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When a renderer tool is launched, the corresponding 
start function is called.  The start function is passed a 
pointer to a record of this type in the <I>callData</I> parameter.</P></DD><DD><P>This record contains a tool activation object from which 
you can obtain the identity of the top (focus) database.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgtoolstartfunc>mgtoolstartfunc</A>, <A HREF=#mgGetActivationDb>mgGetActivationDb</A></DD></DL>
<HR>
<LEFT><A NAME=mgrenderercalldatatype><H1 CLASS="APISYMBOL">mgrenderercalldatatype</H1></A></LEFT>
<DL>
<DT><H3>ENUM NAME</H3></DT>
<DD><B>mgrenderercalldatatype</B> - Renderer callback data type<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef enum mgrenderercalldatatype {
&#32;&#32;&#32;MRCD_COMMON,
&#32;&#32;&#32;MRCD_TEXTACTIVATE,
&#32;&#32;&#32;MRCD_SCALEACTIVATE,
&#32;&#32;&#32;MRCD_GLDRAW,
&#32;&#32;&#32;MRCD_DIALOGSIZE,
} mgrenderercalldatatype;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>MRCD_COMMON</B><DD>Common Call Data.  This indicates that the 
<I>callData</I> parameter to a renderer callback function 
is a pointer to an object of type 
<A HREF=#mgguicallbackrec>mgguicallbackrec</A> and has no additional data.<DT><B>MRCD_TEXTACTIVATE</B><DD>Text Activate Call Data.  This indicates that the 
<I>callData</I> parameter to a control callback is a pointer 
to an object of type <A HREF=#mgtextactivatecallbackrec>mgtextactivatecallbackrec</A>.<DT><B>MRCD_SCALEACTIVATE</B><DD>Scale Activate Call Data.  This indicates that the 
<I>callData</I> parameter to a control callback is a pointer 
to an object of type <A HREF=#mgscaleactivatecallbackrec>mgscaleactivatecallbackrec</A>.<DT><B>MRCD_GLDRAW</B><DD>GL Draw Call Data.  This indicates that the 
<I>callData</I> parameter to a control callback is a pointer 
to an object of type <A HREF=#mggldrawcallbackrec>mggldrawcallbackrec</A>.<DT><B>MRCD_DIALOGSIZE</B><DD>Dialog Size Call Data.  This indicates that the 
<I>callData</I> parameter to a dialog function is a pointer 
to an object of type <A HREF=#mgdialogsizecallbackrec>mgdialogsizecallbackrec</A>.</DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This type is used to indicate the type of call data passed to a renderer callback 
functions. When a renderer callback function is called, the <I>callData</I> 
parameter passed in will be a pointer to an object type that is dependent on the context of 
the callback function.</P></DD><DD><P>Each member of this type corresponds to a different callback data structure.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterRenderer>mgRegisterRenderer</A>, <A HREF=#mgrendererfunc>mgrendererfunc</A>, <A HREF=#mgrenderercallbackreason>mgrenderercallbackreason</A></DD></DL>
<HR>
<LEFT><A NAME=mgrenderercontext><H1 CLASS="APISYMBOL">mgrenderercontext</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgrenderercontext</B> - Abstract type used to represent an active renderer 
tool context<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When a renderer tool is launched, the OpenFlight API creates a renderer 
tool context corresponding to that instance of the tool.  The renderer tool 
context is maintained while the renderer tool instance is active on the 
desktop.  It is used to encapsulate and identify the state of 
the active renderer tool instance.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgrenderercallbackrec>mgrenderercallbackrec</A></DD></DL>
<HR>
<LEFT><A NAME=mgresource><H1 CLASS="APISYMBOL">mgresource</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgresource</B> - Abstract type used to represent a plug-in resource<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgLoadResource>mgLoadResource</A>, <A HREF=#mgResourceGetDialog>mgResourceGetDialog</A>, <A HREF=#mgResourceModalDialog>mgResourceModalDialog</A>, 
<A HREF=#mgResourceGetPixmap>mgResourceGetPixmap</A>, <A HREF=#mgResourceGetString>mgResourceGetString</A>, <A HREF=#mgGetModuleFilename>mgGetModuleFilename</A></DD></DL>
<HR>
<LEFT><A NAME=mgsavepathtype><H1 CLASS="APISYMBOL">mgsavepathtype</H1></A></LEFT>
<DL>
<DT><H3>ENUM NAME</H3></DT>
<DD><B>mgsavepathtype</B> - Save path type for 
external files associated with a database file (textures and shaders)<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef enum mgsavepathtype {
&#32;&#32;&#32;MSPT_ABSOLUTE,
&#32;&#32;&#32;MSPT_RELATIVE,
&#32;&#32;&#32;MSPT_NOPATH,
&#32;&#32;&#32;MSPT_UNKNOWN,
} mgsavepathtype;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>MSPT_ABSOLUTE</B><DD>Save absolute file paths<DT><B>MSPT_RELATIVE</B><DD>Save relative file paths<DT><B>MSPT_NOPATH</B><DD>Save no path information with file names<DT><B>MSPT_UNKNOWN</B><DD>Unknown save path type</DL></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgTextureGetSavePathType>mgTextureGetSavePathType</A>, <A HREF=#mgTextureSetSavePathType>mgTextureSetSavePathType</A>, 
<A HREF=#mgShaderGetSavePathType>mgShaderGetSavePathType</A>, <A HREF=#mgShaderSetSavePathType>mgShaderSetSavePathType</A></DD></DL>
<HR>
<LEFT><A NAME=mgscaleactivatecallbackrec><H1 CLASS="APISYMBOL">mgscaleactivatecallbackrec</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgscaleactivatecallbackrec</B> - callback structure for the activate control 
event sent to scale controls<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct  {
&#32;&#32;&#32;mgguicalldatatype callDataType;
&#32;&#32;&#32;mgmousestate mouseState;
} mgscaleactivatecallbackrec;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>callDataType</B><DD><A HREF=#mgguicalldatatype>mgguicalldatatype</A> - call data type that indicates the 
type of call data this object really is - 
will always be <A HREF=#mgguicalldatatype>MGCD_SCALEACTIVATE</A></DD></DT><DT><B>mouseState</B><DD><A HREF=#mgmousestate>mgmousestate</A> - state of mouse when event was triggered - 
possible values are: <BR> 
<A HREF=#mgmousestate>MMSS_START</A> - The mouse state will be set to this 
value under either of the following conditons: <BR> 
When the user first presses the left mouse button on the thumb or 
the trough of the scale control. -- or -- <BR> 
When the user first presses (and then holds) the left mouse button 
on either arrow button of the spin buddy control associated to the 
scale control.  Note: If the user clicks the left mouse button on the 
spin buddy control (without holding it down), the event will be treated 
like a single event and <A HREF=#mgmousestate>MMSS_NONE</A> will be used. 
<BR> 
<A HREF=#mgmousestate>MMSS_CONTINUE</A> - The mouse state is set to this value 
as long as the user continues to hold the left mouse button down on the 
thumb or the trough of the scale control, or on either arrow of an 
associated spin buddy control. 
<BR> 
<A HREF=#mgmousestate>MMSS_STOP</A> - The mouse state is set to this value when 
the user releases the left mouse button after dragging the mouse on the 
thumb or the trough of the scale control, or after holding down either 
arrow of an associated spin buddy control. 
<BR> 
<A HREF=#mgmousestate>MMSS_NONE</A> - The mouse state will be set to this value 
under either of the following conditons: <BR> 
When the user enters a numeric value into the text buddy control 
of the associated scale control. -- or -- <BR> 
When the user clicks (but does not hold) the left mouse button on 
either arrow of the spin buddy control associated to the scale control.</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When the <A HREF=#MGCB_ACTIVATE>MGCB_ACTIVATE</A> control event is sent to 
a scale control via its <A HREF=#mgguifunc>mgguifunc</A>, the <I>calldata</I> parameter passed in will point 
to an object of this type.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgguifunc>mgguifunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgsettingname><H1 CLASS="APISYMBOL">mgsettingname</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgsettingname</B> - A string type used to reference Graphics View Settings<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Use these values when calling <A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, 
<A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, <A HREF=#mgGraphicsViewSettingGetDouble>mgGraphicsViewSettingGetDouble</A> or 
<A HREF=#mgGraphicsViewSettingSetDouble>mgGraphicsViewSettingSetDouble</A>.</P></DD><DD><P>The list of accessible graphics view settings include:<BR> 
<A HREF=#MGVM_PROJECTION>MGVM_PROJECTION</A><BR> 
<A HREF=#MGVM_MODELVIEW>MGVM_MODELVIEW</A><BR> 
<A HREF=#MGVM_MODELVIEWPROJECTION>MGVM_MODELVIEWPROJECTION</A><BR> 
<A HREF=#MGVD_FOV>MGVD_FOV</A><BR> 
<A HREF=#MGVD_TARGETFOV>MGVD_TARGETFOV</A><BR> 
<A HREF=#MGVD_SCALE>MGVD_SCALE</A><BR> 
<A HREF=#MGVD_NEARCLIP>MGVD_NEARCLIP</A><BR> 
<A HREF=#MGVD_FARCLIP>MGVD_FARCLIP</A><BR> 
<A HREF=#MGVD_GRIDSPACEX>MGVD_GRIDSPACEX</A><BR> 
<A HREF=#MGVD_GRIDSPACEY>MGVD_GRIDSPACEY</A><BR> 
<A HREF=#MGVD_GRIDANGLE>MGVD_GRIDANGLE</A><BR> 
<A HREF=#MGVD_GRIDRADIUS>MGVD_GRIDRADIUS</A><BR> 
<A HREF=#MGVI_DRAWORDER>MGVI_DRAWORDER</A><BR> 
<A HREF=#MGVI_GRIDTYPE>MGVI_GRIDTYPE</A><BR> 
<A HREF=#MGVI_AUTOFOV>MGVI_AUTOFOV</A><BR> 
<A HREF=#MGVI_AUTOLOD>MGVI_AUTOLOD</A><BR> 
<A HREF=#MGVI_AUTONEARFAR>MGVI_AUTONEARFAR</A><BR> 
<A HREF=#MGVI_VIEWHEIGHT>MGVI_VIEWHEIGHT</A><BR> 
<A HREF=#MGVI_VIEWWIDTH>MGVI_VIEWWIDTH</A><BR> 
<A HREF=#MGVI_CHANNELHEIGHT>MGVI_CHANNELHEIGHT</A><BR> 
<A HREF=#MGVI_DRAWMODE>MGVI_DRAWMODE</A><BR> 
<A HREF=#MGVI_DRAWCONSTRUCTIONS>MGVI_DRAWCONSTRUCTIONS</A><BR> 
<A HREF=#MGVI_DRAWSHADERS>MGVI_DRAWSHADERS</A><BR> 
<A HREF=#MGVI_DRAWFOG>MGVI_DRAWFOG</A><BR> 
<A HREF=#MGVI_DRAWSELECTOUTLINE>MGVI_DRAWSELECTOUTLINE</A><BR> 
<A HREF=#MGVI_DRAWGRID>MGVI_DRAWGRID</A><BR> 
<A HREF=#MGVI_DRAWTEXTURE>MGVI_DRAWTEXTURE</A><BR> 
<A HREF=#MGVI_DRAWVERTEXNORMALS>MGVI_DRAWVERTEXNORMALS</A><BR> 
<A HREF=#MGVI_DRAWVERTEXNUMBERS>MGVI_DRAWVERTEXNUMBERS</A><BR> 
<A HREF=#MGVI_DRAWVERTEXLARGE>MGVI_DRAWVERTEXLARGE</A><BR> 
<A HREF=#MGVI_DRAWLIGHTSLARGE>MGVI_DRAWLIGHTSLARGE</A><BR> 
<A HREF=#MGVI_DRAWDOFAXES>MGVI_DRAWDOFAXES</A><BR> 
<A HREF=#MGVI_DRAWCONTROLPOINTS>MGVI_DRAWCONTROLPOINTS</A><BR> 
<A HREF=#MGVI_DRAWBOUNDINGBOXES>MGVI_DRAWBOUNDINGBOXES</A><BR> 
<A HREF=#MGVI_ORTHO>MGVI_ORTHO</A><BR> 
<A HREF=#MGVI_SNAPTOGRID>MGVI_SNAPTOGRID</A><BR> 
<A HREF=#MGVI_SHRINK>MGVI_SHRINK</A><BR> 
<A HREF=#MGVI_ANTIALIASLINES>MGVI_ANTIALIASLINES</A><BR> 
<A HREF=#MGVI_INFRAREDVIEW>MGVI_INFRAREDVIEW</A><BR> 
<A HREF=#MGVI_WINDOWVIEW>MGVI_WINDOWVIEW</A><BR> 
<A HREF=#MGVI_TEXTURELAYER>MGVI_TEXTURELAYER</A><BR> 
<A HREF=#MGVI_FREEZEX>MGVI_FREEZEX</A><BR> 
<A HREF=#MGVI_FREEZEY>MGVI_FREEZEY</A><BR> 
<A HREF=#MGVI_FREEZEZ>MGVI_FREEZEZ</A><BR> 
<A HREF=#MGVI_XRAYMODE>MGVI_XRAYMODE</A><BR> 
<A HREF=#MGVI_DYNAMICBILLBOARDS>MGVI_DYNAMICBILLBOARDS</A><BR> 
<A HREF=#MGVI_DYNAMICTEXTURE>MGVI_DYNAMICTEXTURE</A><BR> 
<A HREF=#MGVI_DYNAMICWIREFRAME>MGVI_DYNAMICWIREFRAME</A><BR> 
<A HREF=#MGVI_SKYCOLOR>MGVI_SKYCOLOR</A><BR></P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGraphicsViewSettingGetInteger>mgGraphicsViewSettingGetInteger</A>, 
<A HREF=#mgGraphicsViewSettingSetInteger>mgGraphicsViewSettingSetInteger</A>, <A HREF=#mgGraphicsViewSettingGetDouble>mgGraphicsViewSettingGetDouble</A>, 
<A HREF=#mgGraphicsViewSettingSetDouble>mgGraphicsViewSettingSetDouble</A>.</DD></DL>
<HR>
<LEFT><A NAME=mgsize_t><H1 CLASS="APISYMBOL">mgsize_t</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgsize_t</B> - A numeric type used to represent the size of an object similar 
to the predefined type <B>size_t</B>. The <A HREF=#mgsize_t>mgsize_t</A> type is used in function 
<A HREF=#mgMalloc>mgMalloc</A> to specify the size of the memory you want to allocate. 
For 32 bit versions of the OpenFlight API, this type is unsigned 32 bit integer. 
For 64 bit versions of the OpenFlight API, this type is unsigned 64 bit integer.<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgMalloc>mgMalloc</A></DD></DL>
<HR>
<LEFT><A NAME=mgstatus><H1 CLASS="APISYMBOL">mgstatus</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgstatus</B> - return value used by certain OpenFlight API functions<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>The return value must be checked for success using the macro <A HREF=#MSTAT_ISOK>MSTAT_ISOK</A> 
or tested for equality with <A HREF=#MSTAT_OK>MSTAT_OK</A>.</P></DD></DT></DL>
<HR>
<LEFT><A NAME=mgstringid><H1 CLASS="APISYMBOL">mgstringid</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgstringid</B> - String Definition identifier type used to identify 
and extract string definitions from resources<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgResourceGetString>mgResourceGetString</A></DD></DL>
<HR>
<LEFT><A NAME=mgstringlist><H1 CLASS="APISYMBOL">mgstringlist</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgstringlist</B> - String list identifier type used to store list of 
strings as in an array<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgPromptDialogFile>mgPromptDialogFile</A>, <A HREF=#mgListGetStrings>mgListGetStrings</A>, <A HREF=#mgStringListCount>mgStringListCount</A>, 
<A HREF=#mgListGetSelectedStrings>mgListGetSelectedStrings</A>, <A HREF=#mgGetColorNameList>mgGetColorNameList</A>, <A HREF=#mgFreeStringList>mgFreeStringList</A></DD></DL>
<HR>
<LEFT><A NAME=mgsubtexturedata><H1 CLASS="APISYMBOL">mgsubtexturedata</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgsubtexturedata</B> - Subtexture Definition data<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct  {
&#32;&#32;&#32;char name[MIMG_MAXNAMELEN];
&#32;&#32;&#32;int l;
&#32;&#32;&#32;int b;
&#32;&#32;&#32;int r;
&#32;&#32;&#32;int t;
} mgsubtexturedata;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>name[MIMG_MAXNAMELEN]</B><DD>char - name of subtexture in image</DD></DT><DT><B>l</B><DD>int - lower left x coordinate of subtexture in image</DD></DT><DT><B>b</B><DD>int - lower left y coordinate of subtexture in image</DD></DT><DT><B>r</B><DD>int - upper right x coordinate of subtexture in image</DD></DT><DT><B>t</B><DD>int - upper right y coordinate of subtexture in image</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>Use an array of <A HREF=#mgsubtexturedata>mgsubtexturedata</A> to add and get subtexture 
records.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSubTextureGet>mgSubTextureGet</A>, <A HREF=#mgSubTextureAdd>mgSubTextureAdd</A></DD></DL>
<HR>
<LEFT><A NAME=mgtabruleractivatecallbackrec><H1 CLASS="APISYMBOL">mgtabruleractivatecallbackrec</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgtabruleractivatecallbackrec</B> - callback structure for the control 
events sent to tab ruler controls<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct  {
&#32;&#32;&#32;mgguicalldatatype callDataType;
&#32;&#32;&#32;int tabIndex;
&#32;&#32;&#32;int tabIndex;
&#32;&#32;&#32;int tabPosition;
} mgtabruleractivatecallbackrec;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>callDataType</B><DD><A HREF=#mgguicalldatatype>mgguicalldatatype</A> - call data type that indicates 
the type of call data this object really is - 
will always be <A HREF=#mgguicalldatatype>MGCD_TABRULERACTIVATE</A></DD></DT><DT><B>tabIndex</B><DD>int - state of tab ruler when event was triggered - 
possible values are: <BR> 
<A HREF=#mgtabrulercallbackreason>MTRUL_TAB_SELECTED</A> - The mouse state will be set to this 
value when the user selects a tab in a tab ruler control. 
<BR> 
<A HREF=#mgtabrulercallbackreason>MTRUL_TAB_DESELECTED</A> - The mouse state will be set to this 
value when the user deselects a tab in a tab ruler control. 
<BR> 
<A HREF=#mgtabrulercallbackreason>MTRUL_TAB_DRAGGED</A> - The mouse state will be set to this 
value when the user has dragged a selected tab tab ruler control. A tab can be dragged by 
depressing the left mouse button over the tab and without releasing the mouse button, moving 
the mouse parallel with the tab ruler control. 
<BR> 
<A HREF=#mgtabrulercallbackreason>MTRUL_TAB_BUMPED</A> - The mouse state will be set to this 
value when the user bumps into a tab in a tab ruler control, while dragging another tab. 
<BR> 
<A HREF=#mgtabrulercallbackreason>MTRUL_TAB_CHANGED</A> - The mouse state will be set to this 
value when the user enters a new value for a tab in a tab ruler control, using the 
tab's text box. A tab's text box can be displayed by clicking on the tab's position label. 
<BR> 
<A HREF=#mgtabrulercallbackreason>MTRUL_TAB_CREATED</A> - The mouse state will be set to this 
value when the user creates a new tab in a tab ruler control. 
<BR> 
<A HREF=#mgtabrulercallbackreason>MTRUL_TAB_DELETED</A> - The mouse state will be set to this 
value when the user deletes a tab in a tab ruler control. 
<BR> 
<A HREF=#mgtabrulercallbackreason>MTRUL_TAB_RELEASED</A> - The mouse state will be set to this 
value when the user releases the mouse button on a tab in a tab ruler control.</DD></DT><DT><B>tabIndex</B><DD>int - the index of the tab that caused the event (the first 
tab is at index 1)</DD></DT><DT><B>tabPosition</B><DD>int - the position of the tab that caused the event</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When the control event is sent to a tab ruler control via its <B>mgtabrulerguifunc</B>, 
the <I>calldata</I> parameter passed in will point to an object of this type.</P></DD></DT></DL>
<HR>
<LEFT><A NAME=mgtabrulercallbackreason><H1 CLASS="APISYMBOL">mgtabrulercallbackreason</H1></A></LEFT>
<DL>
<DT><H3>ENUM NAME</H3></DT>
<DD><B>mgtabrulercallbackreason</B> - Tab ruler callback reason type<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef enum mgtabrulercallbackreason {
&#32;&#32;&#32;MTRUL_TAB_SELECTED,
&#32;&#32;&#32;MTRUL_TAB_DESELECTED,
&#32;&#32;&#32;MTRUL_TAB_DRAGGED,
&#32;&#32;&#32;MTRUL_TAB_BUMPED,
&#32;&#32;&#32;MTRUL_TAB_CHANGED,
&#32;&#32;&#32;MTRUL_TAB_CREATED,
&#32;&#32;&#32;MTRUL_TAB_DELETED,
&#32;&#32;&#32;MTRUL_TAB_RELEASED,
} mgtabrulercallbackreason;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>MTRUL_TAB_SELECTED</B><DD>The tab selected state.  This indicates that the 
associated event was due to a tab getting selected.<DT><B>MTRUL_TAB_DESELECTED</B><DD>The tab deselected state.  This indicates that the 
associated event was due to a tab getting deselected.<DT><B>MTRUL_TAB_DRAGGED</B><DD>The tab moved state.  This indicates that the 
associated event was due to a tab getting moved. Specifically the tab 
was dragged.<DT><B>MTRUL_TAB_BUMPED</B><DD>The tab selected state.  This indicates that the 
associated event was due to a tab getting moved. Specifically the tab 
was bumped by dragging another tab.<DT><B>MTRUL_TAB_CHANGED</B><DD>The tab selected state.  This indicates that the 
associated event was due to a tab getting moved. Specifically the tab's 
value was changed by entering a new value in the tab's text box.<DT><B>MTRUL_TAB_CREATED</B><DD>The tab created state.  This indicates that a new tab was created.<DT><B>MTRUL_TAB_DELETED</B><DD>The tab deleted state.  This indicates that a tab was deleted.<DT><B>MTRUL_TAB_RELEASED</B><DD>The tab released state.  This indicates the mouse up event occurred.</DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This enumerated type is used when calling the tab ruler control callback function.</P></DD></DT></DL>
<HR>
<LEFT><A NAME=mgtabruleroption><H1 CLASS="APISYMBOL">mgtabruleroption</H1></A></LEFT>
<DL>
<DT><H3>ENUM NAME</H3></DT>
<DD><B>mgtabruleroption</B> - tab ruler control Options<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef enum mgtabruleroption {
&#32;&#32;&#32;MTRUL_ORIENTATION,
&#32;&#32;&#32;MTRUL_TABBAROFFSET,
&#32;&#32;&#32;MTRUL_LABELOFFSET,
&#32;&#32;&#32;MTRUL_SCALEBAROFFSET,
&#32;&#32;&#32;MTRUL_MARGINWIDTH,
&#32;&#32;&#32;MTRUL_TICHEIGHT,
&#32;&#32;&#32;MTRUL_AUTOTICS,
&#32;&#32;&#32;MTRUL_LABELEDTICSEVERY,
&#32;&#32;&#32;MTRUL_TICSEVERY,
&#32;&#32;&#32;MTRUL_SCALEMIN,
&#32;&#32;&#32;MTRUL_SCALEMAX,
&#32;&#32;&#32;MTRUL_ELASTICMIN,
&#32;&#32;&#32;MTRUL_ELASTICMAX,
} mgtabruleroption;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>MTRUL_ORIENTATION</B><DD>Tab Orientation, either <A HREF=#MTRUL_HORIZONTAL>MTRUL_HORIZONTAL</A> or <A HREF=#MTRUL_VERTICAL>MTRUL_VERTICAL</A>. 
The Default is horizontal.<DT><B>MTRUL_TABBAROFFSET</B><DD>Tab Bar Offset in pixels 
The Default is 0.<DT><B>MTRUL_LABELOFFSET</B><DD>Tab Label Offset in pixels 
The Default is 0.<DT><B>MTRUL_SCALEBAROFFSET</B><DD>Scale Bar Offset in pixels 
The Default is 0.<DT><B>MTRUL_MARGINWIDTH</B><DD>Margin Width in pixels 
The Default is 0.<DT><B>MTRUL_TICHEIGHT</B><DD>Tic Height specifies the height in pixels of the largest tic-marks on the 
tab ruler control.  The tab ruler automatically decrements for finer level tics. 
The default is 10.<DT><B>MTRUL_AUTOTICS</B><DD>Auto Calculate Tics uses an algorithm to automatically generate tic marks 
for the tab ruler control. 
This parameter cannot be used in conjunction with <B>MTRUL_TICKSEVERY</B><DT><B>MTRUL_LABELEDTICSEVERY</B><DD>Labeled Tics Every specifies the labeled tic frequency for the tab ruler control. 
Setting this value turns off <B>MTRUL_AUTOTICS</B><DT><B>MTRUL_TICSEVERY</B><DD>Tics Every specifies the unlabeled tic frequency for the tab ruler control. 
Setting this value turns off <B>MTRUL_AUTOTICS</B><DT><B>MTRUL_SCALEMIN</B><DD>Scale Min specifies the minimum value of the scale extents of the tab ruler control. 
The default is 0.<DT><B>MTRUL_SCALEMAX</B><DD>Scale Max specifies the maximum value of the scale extents of the tab ruler control. 
The default is 100.<DT><B>MTRUL_ELASTICMIN</B><DD>Elastic Minimum specifies whether the scale extents of the tab ruler control should 
grow when a tab is dragged outside the current scale minimum. 
Default is to assign the same value as <B>MTRUL_SCALEMIN</B>.<DT><B>MTRUL_ELASTICMAX</B><DD>Elastic Maximum specifies whether the scale extents of the tab ruler control should 
grow when a tab is dragged outside the current scale maximum. 
Default is to assign the same values as <B>MTRUL_SCALEMAX</B>.</DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This type is used to set the options for a new tab ruler control created 
using the <A HREF=#mgNewTabRuler>mgNewTabRuler</A> function.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgTabRulerSetOptions>mgTabRulerSetOptions</A></DD></DL>
<HR>
<LEFT><A NAME=mgtagtype><H1 CLASS="APISYMBOL">mgtagtype</H1></A></LEFT>
<DL>
<DT><H3>ENUM NAME</H3></DT>
<DD><B>mgtagtype</B> - Tag types<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef enum tagtype {
&#32;&#32;&#32;MTYPE_NULL,
&#32;&#32;&#32;MTYPE_CHAR,
&#32;&#32;&#32;MTYPE_UCHAR,
&#32;&#32;&#32;MTYPE_SHORT,
&#32;&#32;&#32;MTYPE_USHORT,
&#32;&#32;&#32;MTYPE_INT,
&#32;&#32;&#32;MTYPE_UINT,
&#32;&#32;&#32;MTYPE_FLOAT,
&#32;&#32;&#32;MTYPE_DOUBLE,
&#32;&#32;&#32;MTYPE_FLAG,
&#32;&#32;&#32;MTYPE_ENUM,
&#32;&#32;&#32;MTYPE_TEXT,
&#32;&#32;&#32;MTYPE_ROOT,
&#32;&#32;&#32;MTYPE_BEAD,
&#32;&#32;&#32;MTYPE_REC,
&#32;&#32;&#32;MTYPE_DATA,
&#32;&#32;&#32;MTYPE_XML,
&#32;&#32;&#32;MTYPE_DOUBLE2,
&#32;&#32;&#32;MTYPE_DOUBLE3,
} mgtagtype;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>MTYPE_NULL</B><DD>undefined<DT><B>MTYPE_CHAR</B><DD>signed character<DT><B>MTYPE_UCHAR</B><DD>unsigned character<DT><B>MTYPE_SHORT</B><DD>signed short<DT><B>MTYPE_USHORT</B><DD>unsigned short<DT><B>MTYPE_INT</B><DD>signed int<DT><B>MTYPE_UINT</B><DD>unsigned int<DT><B>MTYPE_FLOAT</B><DD>float<DT><B>MTYPE_DOUBLE</B><DD>double<DT><B>MTYPE_FLAG</B><DD>flag<DT><B>MTYPE_ENUM</B><DD>bit integer<DT><B>MTYPE_TEXT</B><DD>text string<DT><B>MTYPE_ROOT</B><DD>db header<DT><B>MTYPE_BEAD</B><DD>has ifmt bead<DT><B>MTYPE_REC</B><DD>generic record<DT><B>MTYPE_DATA</B><DD>data buffer<DT><B>MTYPE_XML</B><DD>XML text string<DT><B>MTYPE_DOUBLE2</B><DD>double 2<DT><B>MTYPE_DOUBLE3</B><DD>double 3</DL></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#ddGetTagType>ddGetTagType</A>, <A HREF=#mgExtensionFieldGetType>mgExtensionFieldGetType</A></DD></DL>
<HR>
<LEFT><A NAME=mgtextactivatecallbackrec><H1 CLASS="APISYMBOL">mgtextactivatecallbackrec</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgtextactivatecallbackrec</B> - callback structure for the activate control 
event sent to text controls<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct  {
&#32;&#32;&#32;mgguicalldatatype callDataType;
&#32;&#32;&#32;mgmousestate mouseState;
&#32;&#32;&#32;mgtextactivatereason activateReason;
} mgtextactivatecallbackrec;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>callDataType</B><DD><A HREF=#mgguicalldatatype>mgguicalldatatype</A> - call data type that indicates 
the type of call data this object really is - 
will always be <A HREF=#mgguicalldatatype>MGCD_TEXTACTIVATE</A></DD></DT><DT><B>mouseState</B><DD><A HREF=#mgmousestate>mgmousestate</A> - state of mouse when event was triggered - 
possible values are: <BR> 
<A HREF=#mgmousestate>MMSS_START</A> - The mouse state will be set to this 
value when the user first presses (and then holds) the left mouse button 
on either arrow button of the spin buddy control associated to the 
text control.  Note: If the user clicks the left mouse button on the 
spin buddy control (without holding it down), the event will be treated 
like a single event and <A HREF=#mgmousestate>MMSS_NONE</A> will be used. 
<BR> 
<A HREF=#mgmousestate>MMSS_CONTINUE</A> - The mouse state is set to this value 
as long as the user continues to hold the left mouse button down on 
either arrow of an associated spin buddy control. 
<BR> 
<A HREF=#mgmousestate>MMSS_STOP</A> - The mouse state is set to this value when 
the user releases the left mouse button after holding down either 
arrow of an associated spin buddy control. 
<BR> 
<A HREF=#mgmousestate>MMSS_NONE</A> - The mouse state will be set to this value 
under either of the following conditons: <BR> 
When the user enters a numeric value into the text control. -- or -- <BR> 
When the user clicks (but does not hold) the left mouse button on 
either arrow of the spin buddy control associated to the text control.</DD></DT><DT><B>activateReason</B><DD><A HREF=#mgtextactivatereason>mgtextactivatereason</A> - reason the activate control event was sent to the text control - 
possible values are: <BR> 
<A HREF=#mgtextactivatereason>MTEXT_LOSTFOCUS</A> - The control lost focus. 
<BR> 
<A HREF=#mgtextactivatereason>MTEXT_TEXTCHANGED</A> - The user typed in the text control.</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When the <A HREF=#MGCB_ACTIVATE>MGCB_ACTIVATE</A> control event is sent to 
a text control via its <A HREF=#mgguifunc>mgguifunc</A>, the <I>calldata</I> parameter passed in will point 
to an object of this type.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgguifunc>mgguifunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgtextactivatereason><H1 CLASS="APISYMBOL">mgtextactivatereason</H1></A></LEFT>
<DL>
<DT><H3>ENUM NAME</H3></DT>
<DD><B>mgtextactivatereason</B> - Text activate reason type<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef enum mgtextactivatereason {
&#32;&#32;&#32;MTEXT_LOSTFOCUS,
&#32;&#32;&#32;MTEXT_TEXTCHANGED,
} mgtextactivatereason;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>MTEXT_LOSTFOCUS</B><DD>Text control lost focus. This indicates that the event was sent 
because the text control lost focus. By default, this is the only reason 
the activate control event is sent to a text control.<DT><B>MTEXT_TEXTCHANGED</B><DD>Text control text changed. This indicates that the event was sent 
because the user typed in the text control. Note that the user may not 
have finished typing when this event is sent. By default, the activate 
control event is not sent for this reason. To enable this for a specific 
text control, use <A HREF=#mgControlSetAttribute>mgControlSetAttribute</A> to set the <B>MCA_TEXTACTIVATEONCHANGED</B> 
attribute on the text control.</DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This enumerated type is used when the activate control event is sent to text controls.</P></DD></DT></DL>
<HR>
<LEFT><A NAME=mgtimer><H1 CLASS="APISYMBOL">mgtimer</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgtimer</B> - Abstract type used to represent timer objects<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterTimer>mgRegisterTimer</A></DD></DL>
<HR>
<LEFT><A NAME=mgtoolaction><H1 CLASS="APISYMBOL">mgtoolaction</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgtoolaction</B> - Abstract type used to represent Plug-in Tool actions<P></DD>
</DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgkeytype>mgkeytype</A>, <A HREF=#mgPluginToolNewAction>mgPluginToolNewAction</A>, <A HREF=#mgSetGuiToolAction>mgSetGuiToolAction</A>, <A HREF=#mgToolActionGetShortCut>mgToolActionGetShortCut</A>.</DD></DL>
<HR>
<LEFT><A NAME=mgtoolactivation><H1 CLASS="APISYMBOL">mgtoolactivation</H1></A></LEFT>
<DL>
<DT><H3>TYPE NAME</H3></DT>
<DD><B>mgtoolactivation</B> - Abstract type used to represent a tool activation object.<P></DD>
</DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When the user launches a plug-in tool you have registered, an object of this 
type is created and passed to your tool's start function. You can query this 
object to obtain useful information about the context in which your tool is 
running.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetActivationDb>mgGetActivationDb</A>, <A HREF=#mgGetActivationType>mgGetActivationType</A>, <A HREF=#mgGetActivationParamBlock>mgGetActivationParamBlock</A> 
<A HREF=#mgeditorcallbackrec>mgeditorcallbackrec</A>, <A HREF=#mgviewercallbackrec>mgviewercallbackrec</A>, 
<A HREF=#mgimportercallbackrec>mgimportercallbackrec</A>, <A HREF=#mgexportercallbackrec>mgexportercallbackrec</A>, <A HREF=#mgrenderercallbackrec>mgrenderercallbackrec</A></DD></DL>
<HR>
<LEFT><A NAME=mgtoolactivationtype><H1 CLASS="APISYMBOL">mgtoolactivationtype</H1></A></LEFT>
<DL>
<DT><H3>ENUM NAME</H3></DT>
<DD><B>mgtoolactivationtype</B> - Tool Activation Type<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef enum mgtoolactivationtype {
&#32;&#32;&#32;MTAT_UNKNOWN,
&#32;&#32;&#32;MTAT_NORMAL,
&#32;&#32;&#32;MTAT_REPEAT,
&#32;&#32;&#32;MTAT_SCRIPT,
&#32;&#32;&#32;MTAT_PROCESS,
} mgtoolactivationtype;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>MTAT_UNKNOWN</B><DD>Tool Activation Unknown.  Unknown tool activation type. 
This typically indicates an error condition.<DT><B>MTAT_NORMAL</B><DD>Tool Activation Normal.  This indicates that the tool 
was launched normally by the user from within the interactive 
Creator modeling environment.<DT><B>MTAT_REPEAT</B><DD>Tool Activation Repeat.  This indicates that the 
tool was launched by the user from the interactive 
Creator modeling environment using the Repeat Last command.<DT><B>MTAT_SCRIPT</B><DD>Tool Activation Script.  This indicates that the 
tool was launched from a Creator script.  When this is the 
case, the tool should perform its actions "silently" without 
displaying a dialog.<DT><B>MTAT_PROCESS</B><DD>Tool Activation Process.  This indicates that the 
tool was launched by an external process (normally Terra Vista). 
When this is the case, the tool should perform its actions 
accordingly.  Internal use only by Presagis.</DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>This enumerated type is used to indicate the activation type for a 
tool activation object.  A plug-in tool may use this activation type to 
alter its behavior depending on how it was launched.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetActivationType>mgGetActivationType</A></DD></DL>
<HR>
<LEFT><A NAME=mgtoolterminationreason><H1 CLASS="APISYMBOL">mgtoolterminationreason</H1></A></LEFT>
<DL>
<DT><H3>ENUM NAME</H3></DT>
<DD><B>mgtoolterminationreason</B> - Editor Tool Termination Reason type<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef enum mgtoolterminationreason {
&#32;&#32;&#32;MTRM_DONE,
&#32;&#32;&#32;MTRM_CANCEL,
&#32;&#32;&#32;MTRM_SELF,
&#32;&#32;&#32;MTRM_SYSTEM,
} mgtoolterminationreason;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>MTRM_DONE</B><DD>Tool terminated because user pressed <I>Done</I> button (<A HREF=#MBT_DONE>MBT_DONE</A>).<DT><B>MTRM_CANCEL</B><DD>Tool terminated because user pressed <I>Cancel</I> button (<A HREF=#MBT_CANCEL>MBT_CANCEL</A>) 
or tool terminated itself by calling <A HREF=#mgEditorCancelTool>mgEditorCancelTool</A>.<DT><B>MTRM_SELF</B><DD>Tool terminated itself by calling <A HREF=#mgEditorTerminateTool>mgEditorTerminateTool</A>.<DT><B>MTRM_SYSTEM</B><DD>Tool terminated by modeling system (window closed, tool chain, etc)</DL></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSetTerminateFunc>mgEditorSetTerminateFunc</A>, <A HREF=#mgEditorTerminateTool>mgEditorTerminateTool</A>, <A HREF=#mgEditorCancelTool>mgEditorCancelTool</A></DD></DL>
<HR>
<LEFT><A NAME=mgundocleanupreason><H1 CLASS="APISYMBOL">mgundocleanupreason</H1></A></LEFT>
<DL>
<DT><H3>ENUM NAME</H3></DT>
<DD><B>mgundocleanupreason</B> - Editor Tool Undo Cleanup Reason type<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef enum mgundocleanupreason {
&#32;&#32;&#32;MUCR_AFTERUNDO,
&#32;&#32;&#32;MUCR_NOUNDO,
} mgundocleanupreason;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>MUCR_AFTERUNDO</B><DD>Undo cleanup function called after undo function called<DT><B>MUCR_NOUNDO</B><DD>Undo cleanup function called without calling undo function</DL></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgEditorAddUndo>mgEditorAddUndo</A>, <A HREF=#mgEditorAppendUndo>mgEditorAppendUndo</A>, 
<A HREF=#mgEditorAddRedo>mgEditorAddRedo</A>, <A HREF=#mgEditorAddUndoForRedo>mgEditorAddUndoForRedo</A>, 
<A HREF=#mgEditorAddUndoForCreate>mgEditorAddUndoForCreate</A>, <A HREF=#mgEditorAppendUndoForCreate>mgEditorAppendUndoForCreate</A>, 
<A HREF=#mgEditorAddUndoForDelete>mgEditorAddUndoForDelete</A>, <A HREF=#mgEditorAppendUndoForDelete>mgEditorAppendUndoForDelete</A>, 
<A HREF=#mgEditorAddUndoForMove>mgEditorAddUndoForMove</A>, <A HREF=#mgEditorAppendUndoForMove>mgEditorAppendUndoForMove</A></DD></DL>
<HR>
<LEFT><A NAME=mgvectord><H1 CLASS="APISYMBOL">mgvectord</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgvectord</B> - Double precision vector record<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct mgvectord {
&#32;&#32;&#32;double i;
&#32;&#32;&#32;double j;
&#32;&#32;&#32;double k;
} mgvectord;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>i</B><DD>double - i component of vector</DD></DT><DT><B>j</B><DD>double - j component of vector</DD></DT><DT><B>k</B><DD>double - k component of vector</DD></DT></DL></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectorf>mgvectorf</A>, <A HREF=#mgMakeVectord>mgMakeVectord</A></DD></DL>
<HR>
<LEFT><A NAME=mgvectorf><H1 CLASS="APISYMBOL">mgvectorf</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgvectorf</B> - Single precision vector record<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct mgvectorf {
&#32;&#32;&#32;float i;
&#32;&#32;&#32;float j;
&#32;&#32;&#32;float k;
} mgvectorf;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>i</B><DD>float - i component of vector</DD></DT><DT><B>j</B><DD>float - j component of vector</DD></DT><DT><B>k</B><DD>float - k component of vector</DD></DT></DL></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgvectord>mgvectord</A>, <A HREF=#mgVectordToVectorf>mgVectordToVectorf</A></DD></DL>
<HR>
<LEFT><A NAME=mgvertexinputdata><H1 CLASS="APISYMBOL">mgvertexinputdata</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgvertexinputdata</B> - 3D Vertex Mouse Input data<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct  {
&#32;&#32;&#32;mgmousestate mouseEvent;
&#32;&#32;&#32;unsigned&#32int keyboardFlags;
&#32;&#32;&#32;unsigned int buttonFlags;
&#32;&#32;&#32;mgvertexreftype refType;
&#32;&#32;&#32;mgcoord3d* thisPoint;
&#32;&#32;&#32;mgcoord3d* firstPoint;
&#32;&#32;&#32;mgvertexrefdata refData;
&#32;&#32;&#32;mginputdevice inputDevice;
&#32;&#32;&#32;mgmatrix refXform;
} mgvertexinputdata;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>mouseEvent</B><DD><A HREF=#mgmousestate>mgmousestate</A> - the vertex input sequence state</DD></DT><DT><B>keyboardFlags</B><DD><A HREF=#unsigned&#32int>unsigned&#32int</A> - the state of the <I>Alt</I>, <I>Ctrl</I>, and <I>Shift</I> keys - 
the value of this field will be a bitwise combination 
of <A HREF=#MKB_ALTKEY>MKB_ALTKEY</A>, <A HREF=#MKB_CTRLKEY>MKB_CTRLKEY</A> and <A HREF=#MKB_SHIFTKEY>MKB_SHIFTKEY</A></DD></DT><DT><B>buttonFlags</B><DD>unsigned int - the state of the <I>Left</I>, <I>Middle</I> and <I>Right</I> 
mouse buttons - the value of this field will be a bitwise 
combination of <A HREF=#MMB_LEFTMOUSE>MMB_LEFTMOUSE</A>, <A HREF=#MMB_MIDDLEMOUSE>MMB_MIDDLEMOUSE</A> and 
<A HREF=#MMB_RIGHTMOUSE>MMB_RIGHTMOUSE</A></DD></DT><DT><B>refType</B><DD><A HREF=#mgvertexreftype>mgvertexreftype</A> - vertex Input reference type</DD></DT><DT><B>thisPoint</B><DD><A HREF=#mgcoord3d>mgcoord3d*</A> - address of 3D coordinate for the current 
vertex being reported in this sequence</DD></DT><DT><B>firstPoint</B><DD><A HREF=#mgcoord3d>mgcoord3d*</A> - address of 3D coordinate for the first 
vertex reported in this sequence</DD></DT><DT><B>refData</B><DD><A HREF=#mgvertexrefdata>mgvertexrefdata</A> - vertex Input reference data</DD></DT><DT><B>inputDevice</B><DD><A HREF=#mginputdevice>mginputdevice</A> - input device that generated this input</DD></DT><DT><B>refXform</B><DD><A HREF=#mgmatrix>mgmatrix</A> - cumulative transform above the referenced Face</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When 3D vertex mouse input is reported to an editor tool via 
the corresponding 3D vertex input function, a pointer to a record 
of this type is passed to the vertex function that describes 
the vertex input.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSetVertexFunc>mgEditorSetVertexFunc</A></DD></DL>
<HR>
<LEFT><A NAME=mgvertexrefdata><H1 CLASS="APISYMBOL">mgvertexrefdata</H1></A></LEFT>
<DL>
<DT><H3>UNION NAME</H3></DT>
<DD><B>mgvertexrefdata</B> - 3D Vertex Mouse Input Reference data<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef union  {
&#32;&#32;&#32;mgrec* vertex;
&#32;&#32;&#32;mgrec* edge[2];
&#32;&#32;&#32;mgrec* curve;
&#32;&#32;&#32;mgrec* face;
&#32;&#32;&#32;mgplaned* trackPlane;
} mgvertexrefdata;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>vertex</B><DD><A HREF=#mgrec>mgrec*</A> - the existing vertex referenced for <A HREF=#mgvertexreftype>MVRF_VERTEX</A></DD></DT><DT><B>edge[2]</B><DD><A HREF=#mgrec>mgrec*</A> - the existing edge referenced for <A HREF=#mgvertexreftype>MVRF_EDGE</A></DD></DT><DT><B>curve</B><DD><A HREF=#mgrec>mgrec*</A> - the existing curve referenced for <A HREF=#mgvertexreftype>MVRF_CURVE</A></DD></DT><DT><B>face</B><DD><A HREF=#mgrec>mgrec*</A> - the existing face referenced for <A HREF=#mgvertexreftype>MVRF_FACE</A></DD></DT><DT><B>trackPlane</B><DD><A HREF=#mgplaned>mgplaned*</A> - the trackplane referenced for <A HREF=#mgvertexreftype>MVRF_TRACKPLANE</A></DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When 3D vertex mouse input is reported to an editor tool via 
the corresponding 3D vertex input function, reference data may be 
included that specifies how the user entered the 3D vertex input. 
This record is used to specify this 3D vertex input reference data.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSetVertexFunc>mgEditorSetVertexFunc</A>, <A HREF=#mgvertexreftype>mgvertexreftype</A></DD></DL>
<HR>
<LEFT><A NAME=mgvertexreftype><H1 CLASS="APISYMBOL">mgvertexreftype</H1></A></LEFT>
<DL>
<DT><H3>ENUM NAME</H3></DT>
<DD><B>mgvertexreftype</B> - 3D Vertex Mouse Input Reference type<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef enum mgvertexreftype {
&#32;&#32;&#32;MVRF_VERTEX,
&#32;&#32;&#32;MVRF_EDGE,
&#32;&#32;&#32;MVRF_CURVE,
&#32;&#32;&#32;MVRF_TRACKPLANE,
&#32;&#32;&#32;MVRF_UNKNOWN,
&#32;&#32;&#32;MVRF_FACE,
} mgvertexreftype;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>MVRF_VERTEX</B><DD>Vertex input references existing vertex node<DT><B>MVRF_EDGE</B><DD>Vertex input references existing edge<DT><B>MVRF_CURVE</B><DD>Vertex input references existing curve node<DT><B>MVRF_TRACKPLANE</B><DD>Vertex input references trackplane<DT><B>MVRF_UNKNOWN</B><DD>Unknown vertex input reference<DT><B>MVRF_FACE</B><DD>Vertex input references existing face node</DL></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgRegisterEditor>mgRegisterEditor</A>, <A HREF=#mgEditorSetVertexFunc>mgEditorSetVertexFunc</A>, <A HREF=#mgvertexrefdata>mgvertexrefdata</A></DD></DL>
<HR>
<LEFT><A NAME=mgviewercallbackrec><H1 CLASS="APISYMBOL">mgviewercallbackrec</H1></A></LEFT>
<DL>
<DT><H3>STRUCT NAME</H3></DT>
<DD><B>mgviewercallbackrec</B> - callback structure for viewer tool start functions<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef struct  {
&#32;&#32;&#32;mgtoolactivation toolActivation;
} mgviewercallbackrec;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>toolActivation</B><DD><A HREF=#mgtoolactivation>mgtoolactivation</A> - tool activation</DD></DT></DL></DT></DL>
<DL><DT><H3>DESCRIPTION</H3><DD><P>When a viewer tool is launched, the corresponding 
start function is called.  The start function is passed a 
pointer to a record of this type in the <I>callData</I> parameter.</P></DD><DD><P>This record contains a tool activation object from which 
you can obtain the identity of the top (focus) database.</P></DD></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgtoolstartfunc>mgtoolstartfunc</A>, <A HREF=#mgGetActivationDb>mgGetActivationDb</A></DD></DL>
<HR>
<LEFT><A NAME=mgxfllcode><H1 CLASS="APISYMBOL">mgxfllcode</H1></A></LEFT>
<DL>
<DT><H3>ENUM NAME</H3></DT>
<DD><B>mgxfllcode</B> - The set of possible transformation 
matrix types for <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXmHeader>fltXmHeader</A>
 records<P></DD>
<DT><H3>SYNOPSIS</H3></DT>
<DD><PRE CLASS="EXAMPLE">typedef enum mgxfllcode {
&#32;&#32;&#32;MXLL_TRANSLATE,
&#32;&#32;&#32;MXLL_SCALE,
&#32;&#32;&#32;MXLL_ROTEDGE,
&#32;&#32;&#32;MXLL_ROTPT,
&#32;&#32;&#32;MXLL_PUT,
&#32;&#32;&#32;MXLL_TOPOINT,
&#32;&#32;&#32;MXLL_GENERAL,
} mgxfllcode;
</PRE>
</DD>
</DL>
<DL><DT><H3>MEMBERS</H3><DL><DT><B>MXLL_TRANSLATE</B><DD>a translation matrix<DT><B>MXLL_SCALE</B><DD>a scale matrix<DT><B>MXLL_ROTEDGE</B><DD>a rotation about an edge<DT><B>MXLL_ROTPT</B><DD>a rotation about a point<DT><B>MXLL_PUT</B><DD>a simultaneous translation, rotation and scale matrix<DT><B>MXLL_TOPOINT</B><DD>a simultaneous scale and rotation matrix<DT><B>MXLL_GENERAL</B><DD>a matrix of one or more undefined transformations</DL></DT></DL>
<DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetXformType>mgGetXformType</A></DD></DL>
<HR>
<LEFT><A NAME=action_get><H1 CLASS="APISYMBOL">action_get</H1></A></LEFT>
<DL><DT></DT>
<DD><B>action_get</B> is deprecated. Do not use<P></DD>
</DL>
<HR>
<LEFT><A NAME=action_print><H1 CLASS="APISYMBOL">action_print</H1></A></LEFT>
<DL><DT></DT>
<DD><B>action_print</B> is deprecated. Do not use<P></DD>
</DL>
<HR>
<LEFT><A NAME=action_set><H1 CLASS="APISYMBOL">action_set</H1></A></LEFT>
<DL><DT></DT>
<DD><B>action_set</B> is deprecated. Do not use<P></DD>
</DL>
<HR>
<LEFT><A NAME=action_type><H1 CLASS="APISYMBOL">action_type</H1></A></LEFT>
<DL><DT></DT>
<DD><B>action_type</B> is deprecated. Do not use<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltCatTexture1><H1 CLASS="APISYMBOL">fltCatTexture1</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltCatTexture1</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCat>fltCatDetailTexture</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltDofCurAzim><H1 CLASS="APISYMBOL">fltDofCurAzim</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltDofCurAzim</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDofCurXRot</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltDofCurIncl><H1 CLASS="APISYMBOL">fltDofCurIncl</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltDofCurIncl</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDofCurYRot</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltDofCurTwist><H1 CLASS="APISYMBOL">fltDofCurTwist</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltDofCurTwist</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDofCurZRot</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltDofFlagAzimLimited><H1 CLASS="APISYMBOL">fltDofFlagAzimLimited</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltDofFlagAzimLimited</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDofLimitXRot</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltDofFlagInclLimited><H1 CLASS="APISYMBOL">fltDofFlagInclLimited</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltDofFlagInclLimited</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDofLimitYRot</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltDofFlagMembrane><H1 CLASS="APISYMBOL">fltDofFlagMembrane</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltDofFlagMembrane</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDofMembrane</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltDofFlagTwistLimited><H1 CLASS="APISYMBOL">fltDofFlagTwistLimited</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltDofFlagTwistLimited</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDofLimitZRot</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltDofFlagTxtRepeat><H1 CLASS="APISYMBOL">fltDofFlagTxtRepeat</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltDofFlagTxtRepeat</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDofTxtRepeat</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltDofFlagXLimited><H1 CLASS="APISYMBOL">fltDofFlagXLimited</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltDofFlagXLimited</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDofLimitX</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltDofFlagXScaleLimited><H1 CLASS="APISYMBOL">fltDofFlagXScaleLimited</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltDofFlagXScaleLimited</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDofLimitXScale</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltDofFlagYLimited><H1 CLASS="APISYMBOL">fltDofFlagYLimited</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltDofFlagYLimited</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDofLimitY</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltDofFlagYScaleLimited><H1 CLASS="APISYMBOL">fltDofFlagYScaleLimited</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltDofFlagYScaleLimited</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDofLimitYScale</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltDofFlagZLimited><H1 CLASS="APISYMBOL">fltDofFlagZLimited</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltDofFlagZLimited</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDofLimitZ</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltDofFlagZScaleLimited><H1 CLASS="APISYMBOL">fltDofFlagZScaleLimited</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltDofFlagZScaleLimited</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDofLimitZScale</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltDofIncrementAzim><H1 CLASS="APISYMBOL">fltDofIncrementAzim</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltDofIncrementAzim</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDofIncXRot</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltDofIncrementIncl><H1 CLASS="APISYMBOL">fltDofIncrementIncl</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltDofIncrementIncl</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDofIncYRot</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltDofIncrementTwist><H1 CLASS="APISYMBOL">fltDofIncrementTwist</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltDofIncrementTwist</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDofIncZRot</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltDofIncrementX><H1 CLASS="APISYMBOL">fltDofIncrementX</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltDofIncrementX</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDofIncX</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltDofIncrementXScale><H1 CLASS="APISYMBOL">fltDofIncrementXScale</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltDofIncrementXScale</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDofIncXScale</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltDofIncrementY><H1 CLASS="APISYMBOL">fltDofIncrementY</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltDofIncrementY</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDofIncY</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltDofIncrementYScale><H1 CLASS="APISYMBOL">fltDofIncrementYScale</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltDofIncrementYScale</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDofIncYScale</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltDofIncrementZ><H1 CLASS="APISYMBOL">fltDofIncrementZ</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltDofIncrementZ</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDofIncZ</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltDofIncrementZScale><H1 CLASS="APISYMBOL">fltDofIncrementZScale</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltDofIncrementZScale</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDofIncZScale</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltDofMaxAzim><H1 CLASS="APISYMBOL">fltDofMaxAzim</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltDofMaxAzim</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDofMaxXRot</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltDofMaxIncl><H1 CLASS="APISYMBOL">fltDofMaxIncl</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltDofMaxIncl</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDofMaxYRot</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltDofMaxTwist><H1 CLASS="APISYMBOL">fltDofMaxTwist</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltDofMaxTwist</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDofMaxZRot</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltDofMinAzim><H1 CLASS="APISYMBOL">fltDofMinAzim</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltDofMinAzim</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDofMinXRot</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltDofMinIncl><H1 CLASS="APISYMBOL">fltDofMinIncl</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltDofMinIncl</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDofMinYRot</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltDofMinTwist><H1 CLASS="APISYMBOL">fltDofMinTwist</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltDofMinTwist</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDofMinZRot</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltFCoord><H1 CLASS="APISYMBOL">fltFCoord</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltFCoord</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3f>fltCoord3f</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltFCoordX><H1 CLASS="APISYMBOL">fltFCoordX</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltFCoordX</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3f>fltCoord3fX</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltFCoordY><H1 CLASS="APISYMBOL">fltFCoordY</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltFCoordY</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3f>fltCoord3fY</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltFCoordZ><H1 CLASS="APISYMBOL">fltFCoordZ</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltFCoordZ</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3f>fltCoord3fZ</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltGrpFlagAnimation><H1 CLASS="APISYMBOL">fltGrpFlagAnimation</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltGrpFlagAnimation</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltGroup>fltGrpAnimation</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltGrpFlagAnimationFB><H1 CLASS="APISYMBOL">fltGrpFlagAnimationFB</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltGrpFlagAnimationFB</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltGroup>fltGrpAnimationFB</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltGrpFlagBoxed><H1 CLASS="APISYMBOL">fltGrpFlagBoxed</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltGrpFlagBoxed</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltGroup>fltGrpBoxed</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltGrpFlagFreezeBox><H1 CLASS="APISYMBOL">fltGrpFlagFreezeBox</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltGrpFlagFreezeBox</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltGroup>fltGrpFreezeBox</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltHdrFlagVtxNorms><H1 CLASS="APISYMBOL">fltHdrFlagVtxNorms</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltHdrFlagVtxNorms</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHdrSaveVtxNorms</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltIcoord><H1 CLASS="APISYMBOL">fltIcoord</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltIcoord</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3d</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltIcoordX><H1 CLASS="APISYMBOL">fltIcoordX</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltIcoordX</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3dX</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltIcoordY><H1 CLASS="APISYMBOL">fltIcoordY</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltIcoordY</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3dY</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltIcoordZ><H1 CLASS="APISYMBOL">fltIcoordZ</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltIcoordZ</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3dZ</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltIPoint><H1 CLASS="APISYMBOL">fltIPoint</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltIPoint</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord2i>fltCoord2i</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltIPointX><H1 CLASS="APISYMBOL">fltIPointX</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltIPointX</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord2i>fltCoord2iX</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltIPointY><H1 CLASS="APISYMBOL">fltIPointY</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltIPointY</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord2i>fltCoord2iY</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltLodFlagAdditive><H1 CLASS="APISYMBOL">fltLodFlagAdditive</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltLodFlagAdditive</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLod>fltLodAdditive</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltLodFlagFreezeCenter><H1 CLASS="APISYMBOL">fltLodFlagFreezeCenter</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltLodFlagFreezeCenter</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLod>fltLodFreezeCenter</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltLodFlagRange><H1 CLASS="APISYMBOL">fltLodFlagRange</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltLodFlagRange</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLod>fltLodUsePrevRange</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltLodFloat><H1 CLASS="APISYMBOL">fltLodFloat</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltLodFloat</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLod>fltLod</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltLpAttr><H1 CLASS="APISYMBOL">fltLpAttr</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltLpAttr</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLpAppearancePalette>fltLpAppearancePalette</A>
 and <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLpAnimationPalette>fltLpAnimationPalette</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltObjFlagDay><H1 CLASS="APISYMBOL">fltObjFlagDay</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltObjFlagDay</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltObject>fltObjDay</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltObjFlagDusk><H1 CLASS="APISYMBOL">fltObjFlagDusk</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltObjFlagDusk</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltObject>fltObjDusk</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltObjFlagNight><H1 CLASS="APISYMBOL">fltObjFlagNight</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltObjFlagNight</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltObject>fltObjNight</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltObjFlagNoillum><H1 CLASS="APISYMBOL">fltObjFlagNoillum</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltObjFlagNoillum</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltObject>fltObjNoillum</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltObjFlagNoshade><H1 CLASS="APISYMBOL">fltObjFlagNoshade</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltObjFlagNoshade</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltObject>fltObjNoshade</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltObjFlagShadow><H1 CLASS="APISYMBOL">fltObjFlagShadow</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltObjFlagShadow</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltObject>fltObjShadow</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltPolyFlagFootprint><H1 CLASS="APISYMBOL">fltPolyFlagFootprint</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltPolyFlagFootprint</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyFootprint</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltPolyFlagHidden><H1 CLASS="APISYMBOL">fltPolyFlagHidden</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltPolyFlagHidden</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyHidden</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltPolyFlagNocolor><H1 CLASS="APISYMBOL">fltPolyFlagNocolor</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltPolyFlagNocolor</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyNoPrimeColor</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltPolyFlagNocolor2><H1 CLASS="APISYMBOL">fltPolyFlagNocolor2</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltPolyFlagNocolor2</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyNoAltColor</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltPolyFlagRgbMode><H1 CLASS="APISYMBOL">fltPolyFlagRgbMode</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltPolyFlagRgbMode</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyRgbMode</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltPolyFlagTerrain><H1 CLASS="APISYMBOL">fltPolyFlagTerrain</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltPolyFlagTerrain</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyTerrain</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltPolyMgTemplate><H1 CLASS="APISYMBOL">fltPolyMgTemplate</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltPolyMgTemplate</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyTemplate</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltPolyTexmap1><H1 CLASS="APISYMBOL">fltPolyTexmap1</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltPolyTexmap1</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyDetailTexmap</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltPolyTexture1><H1 CLASS="APISYMBOL">fltPolyTexture1</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltPolyTexture1</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyDetailTexture</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=fltVbead><H1 CLASS="APISYMBOL">fltVbead</H1></A></LEFT>
<DL><DT></DT>
<DD><B>fltVbead</B> is deprecated. Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=GetHeaderCodeFunc><H1 CLASS="APISYMBOL">GetHeaderCodeFunc</H1></A></LEFT>
<DL><DT></DT>
<DD><B>GetHeaderCodeFunc</B> is deprecated. Use <A HREF=#mggetheadercodefunc>mggetheadercodefunc</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=GetMaxIdFunc><H1 CLASS="APISYMBOL">GetMaxIdFunc</H1></A></LEFT>
<DL><DT></DT>
<DD><B>GetMaxIdFunc</B> is deprecated. Use <A HREF=#mggetmaxidfunc>mggetmaxidfunc</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=ILATTR><H1 CLASS="APISYMBOL">ILATTR</H1></A></LEFT>
<DL><DT></DT>
<DD><B>ILATTR</B> is deprecated. Use <A HREF=#MWALK_ATTR>MWALK_ATTR</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=ILMASTER><H1 CLASS="APISYMBOL">ILMASTER</H1></A></LEFT>
<DL><DT></DT>
<DD><B>ILMASTER</B> is deprecated. Use <A HREF=#MWALK_MASTER>MWALK_MASTER</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=ILMASTERALL><H1 CLASS="APISYMBOL">ILMASTERALL</H1></A></LEFT>
<DL><DT></DT>
<DD><B>ILMASTERALL</B> is deprecated. Use <A HREF=#MWALK_MASTERALL>MWALK_MASTERALL</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=ILNEXT><H1 CLASS="APISYMBOL">ILNEXT</H1></A></LEFT>
<DL><DT></DT>
<DD><B>ILNEXT</B> is deprecated. Use <A HREF=#MWALK_NEXT>MWALK_NEXT</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=ILNORDONLY><H1 CLASS="APISYMBOL">ILNORDONLY</H1></A></LEFT>
<DL><DT></DT>
<DD><B>ILNORDONLY</B> is deprecated. Use <A HREF=#MWALK_NORDONLY>MWALK_NORDONLY</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=ILON><H1 CLASS="APISYMBOL">ILON</H1></A></LEFT>
<DL><DT></DT>
<DD><B>ILON</B> is deprecated. Use <A HREF=#MWALK_ON>MWALK_ON</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=ILVERTEX><H1 CLASS="APISYMBOL">ILVERTEX</H1></A></LEFT>
<DL><DT></DT>
<DD><B>ILVERTEX</B> is deprecated. Use <A HREF=#MWALK_VERTEX>MWALK_VERTEX</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=ILXFORM><H1 CLASS="APISYMBOL">ILXFORM</H1></A></LEFT>
<DL><DT></DT>
<DD><B>ILXFORM</B> is deprecated. Do not use<P></DD>
</DL>
<HR>
<LEFT><A NAME=mgAddCoord><H1 CLASS="APISYMBOL">mgAddCoord</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgAddCoord</B> is deprecated. Use <A HREF=#mgCoord3dAdd>mgCoord3dAdd</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgAddLightSourceTableEntry><H1 CLASS="APISYMBOL">mgAddLightSourceTableEntry</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgAddLightSourceTableEntry</B> is obsolete. Replaced by&#32&#32&#32<A HREF=#mgNewLightSource>mgNewLightSource</A>&#32(different params)<P></DD>
</DL>
<HR>
<LEFT><A NAME=mgAddMatrix><H1 CLASS="APISYMBOL">mgAddMatrix</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgAddMatrix</B> is deprecated. Do not use<P></DD>
</DL>
<HR>
<LEFT><A NAME=mgCheckVal><H1 CLASS="APISYMBOL">mgCheckVal</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgCheckVal</B> is obsolete. No longer supported<P></DD>
</DL>
<HR>
<LEFT><A NAME=mgCode2Buf><H1 CLASS="APISYMBOL">mgCode2Buf</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgCode2Buf</B> is deprecated. Do not use<P></DD>
</DL>
<HR>
<LEFT><A NAME=mgCoord3dTof><H1 CLASS="APISYMBOL">mgCoord3dTof</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgCoord3dTof</B> is deprecated. Use <A HREF=#mgCoord3dToCoord3f>mgCoord3dToCoord3f</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgCoordDif><H1 CLASS="APISYMBOL">mgCoordDif</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgCoordDif</B> is deprecated. Use <A HREF=#mgCoord3dSubtract>mgCoord3dSubtract</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgCoordsEqual><H1 CLASS="APISYMBOL">mgCoordsEqual</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgCoordsEqual</B> is deprecated. Use <A HREF=#mgCoord3dAlmostEqual>mgCoord3dAlmostEqual</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgCrossProdVector><H1 CLASS="APISYMBOL">mgCrossProdVector</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgCrossProdVector</B> is deprecated. Use <A HREF=#mgVectordCross>mgVectordCross</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgDelLightSource><H1 CLASS="APISYMBOL">mgDelLightSource</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgDelLightSource</B> is deprecated. Use <A HREF=#mgDeleteLightSource>mgDeleteLightSource</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgDelMaterial><H1 CLASS="APISYMBOL">mgDelMaterial</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgDelMaterial</B> is deprecated. Use <A HREF=#mgDeleteMaterial>mgDeleteMaterial</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgDelMaterialByName><H1 CLASS="APISYMBOL">mgDelMaterialByName</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgDelMaterialByName</B> is deprecated. Use <A HREF=#mgDeleteMaterialByName>mgDeleteMaterialByName</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgDelMaterialTableEntry><H1 CLASS="APISYMBOL">mgDelMaterialTableEntry</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgDelMaterialTableEntry</B> is obsolete. Replaced by&#32&#32&#32<A HREF=#mgDelMaterial>mgDelMaterial</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgDelMaterialTableEntryByName><H1 CLASS="APISYMBOL">mgDelMaterialTableEntryByName</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgDelMaterialTableEntryByName</B> is obsolete. Replaced by&#32&#32&#32<A HREF=#mgDelMaterialByName>mgDelMaterialByName</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgDelSound><H1 CLASS="APISYMBOL">mgDelSound</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgDelSound</B> is deprecated. Use <A HREF=#mgDeleteSound>mgDeleteSound</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgDelTextureMapping><H1 CLASS="APISYMBOL">mgDelTextureMapping</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgDelTextureMapping</B> is deprecated. Use <A HREF=#mgDeleteTextureMapping>mgDeleteTextureMapping</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgDelTextureMappingByName><H1 CLASS="APISYMBOL">mgDelTextureMappingByName</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgDelTextureMappingByName</B> is deprecated. Use <A HREF=#mgDeleteTextureMappingByName>mgDeleteTextureMappingByName</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgDistance><H1 CLASS="APISYMBOL">mgDistance</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgDistance</B> is deprecated. Use <A HREF=#mgCoord3dDistance>mgCoord3dDistance</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgFALSE><H1 CLASS="APISYMBOL">mgFALSE</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgFALSE</B> is deprecated. Use <A HREF=#mgbool>MG_FALSE</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgFreeSelectList><H1 CLASS="APISYMBOL">mgFreeSelectList</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgFreeSelectList</B> is deprecated. Use <A HREF=#mgFreeRecList>mgFreeRecList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetAtt><H1 CLASS="APISYMBOL">mgGetAtt</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetAtt</B> is obsolete. Use <A HREF=#mgGetAttList>mgGetAttList</A><P></DD>
</DL>

<HR>
<LEFT><A NAME=mgGetAttAddress><H1 CLASS="APISYMBOL">mgGetAttAddress</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetAttAddress</B> is obsolete. No longer supported<P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetAttBits><H1 CLASS="APISYMBOL">mgGetAttBits</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetAttBits</B> is obsolete. Use <A HREF=#mgGetAttList>mgGetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetAttFlag><H1 CLASS="APISYMBOL">mgGetAttFlag</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetAttFlag</B> is obsolete. Use <A HREF=#mgGetAttList>mgGetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetAttNth><H1 CLASS="APISYMBOL">mgGetAttNth</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetAttNth</B> is deprecated. Use <A HREF=#ddGetFieldNth>ddGetFieldNth</A> and <A HREF=#mgGetAttList>mgGetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetAttText><H1 CLASS="APISYMBOL">mgGetAttText</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetAttText</B> is obsolete. Use <A HREF=#mgGetAttList>mgGetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetAttValC><H1 CLASS="APISYMBOL">mgGetAttValC</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetAttValC</B> is obsolete. Use <A HREF=#mgGetAttList>mgGetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetAttValD><H1 CLASS="APISYMBOL">mgGetAttValD</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetAttValD</B> is obsolete. Use <A HREF=#mgGetAttList>mgGetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetAttValF><H1 CLASS="APISYMBOL">mgGetAttValF</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetAttValF</B> is obsolete. Use <A HREF=#mgGetAttList>mgGetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetAttValI><H1 CLASS="APISYMBOL">mgGetAttValI</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetAttValI</B> is obsolete. Use <A HREF=#mgGetAttList>mgGetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetAttValP><H1 CLASS="APISYMBOL">mgGetAttValP</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetAttValP</B> is obsolete. Use <A HREF=#mgGetAttList>mgGetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetAttValS><H1 CLASS="APISYMBOL">mgGetAttValS</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetAttValS</B> is obsolete. Use <A HREF=#mgGetAttList>mgGetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetAttValUC><H1 CLASS="APISYMBOL">mgGetAttValUC</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetAttValUC</B> is obsolete. Use <A HREF=#mgGetAttList>mgGetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetAttValUI><H1 CLASS="APISYMBOL">mgGetAttValUI</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetAttValUI</B> is obsolete. Use <A HREF=#mgGetAttList>mgGetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetAttValUS><H1 CLASS="APISYMBOL">mgGetAttValUS</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetAttValUS</B> is obsolete. Use <A HREF=#mgGetAttList>mgGetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetAttXmBuf><H1 CLASS="APISYMBOL">mgGetAttXmBuf</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetAttXmBuf</B> is deprecated. Do not use<P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetChar><H1 CLASS="APISYMBOL">mgGetChar</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetChar</B> is deprecated. Use <A HREF=#mgGetAttList>mgGetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetFCoord><H1 CLASS="APISYMBOL">mgGetFCoord</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetFCoord</B> is deprecated. Use <A HREF=#mgGetCoord3f>mgGetCoord3f</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetFirstTextureInPalette><H1 CLASS="APISYMBOL">mgGetFirstTextureInPalette</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetFirstTextureInPalette</B> is obsolete. Replaced by&#32&#32&#32<A HREF=#mgGetFirstTexture>mgGetFirstTexture</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetFlag><H1 CLASS="APISYMBOL">mgGetFlag</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetFlag</B> is deprecated. Use <A HREF=#mgGetAttList>mgGetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetIcoord><H1 CLASS="APISYMBOL">mgGetIcoord</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetIcoord</B> is deprecated. Use <A HREF=#mgGetCoord3d>mgGetCoord3d</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetIPoint><H1 CLASS="APISYMBOL">mgGetIPoint</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetIPoint</B> is deprecated. Use <A HREF=#mgGetCoord2i>mgGetCoord2i</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetLtsCount><H1 CLASS="APISYMBOL">mgGetLtsCount</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetLtsCount</B> is obsolete. Replaced by&#32&#32&#32<A HREF=#mgGetLightSourceCount>mgGetLightSourceCount</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetNextSelected><H1 CLASS="APISYMBOL">mgGetNextSelected</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetNextSelected</B> is deprecated. Use <A HREF=#mgGetNextRecInList>mgGetNextRecInList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetNextTextureInPalette><H1 CLASS="APISYMBOL">mgGetNextTextureInPalette</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetNextTextureInPalette</B> is obsolete. Replaced by&#32&#32&#32<A HREF=#mgGetNextTexture>mgGetNextTexture</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetNthSelected><H1 CLASS="APISYMBOL">mgGetNthSelected</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetNthSelected</B> is deprecated. Use <A HREF=#mgGetNthRecInList>mgGetNthRecInList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetPackedColor><H1 CLASS="APISYMBOL">mgGetPackedColor</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetPackedColor</B> is deprecated. Do not use<P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetPolyRGBA><H1 CLASS="APISYMBOL">mgGetPolyRGBA</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetPolyRGBA</B> is obsolete. Replaced by&#32&#32&#32<A HREF=#mgGetPolyColorRGB>mgGetPolyColorRGB</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetRepCount><H1 CLASS="APISYMBOL">mgGetRepCount</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetRepCount</B> is deprecated. Use <A HREF=#mgGetAttList>mgGetAttList</A> with <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltGroup>fltRepCnt</A>
<P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetSelectListCount><H1 CLASS="APISYMBOL">mgGetSelectListCount</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetSelectListCount</B> is deprecated. Use <A HREF=#mgGetRecListCount>mgGetRecListCount</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetSelectListLevel><H1 CLASS="APISYMBOL">mgGetSelectListLevel</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetSelectListLevel</B> is deprecated. Use <A HREF=#mgGetRecListLevel>mgGetRecListLevel</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetText><H1 CLASS="APISYMBOL">mgGetText</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetText</B> is deprecated. Use <A HREF=#mgGetAttList>mgGetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetType><H1 CLASS="APISYMBOL">mgGetType</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetType</B> is deprecated. Use <A HREF=#ddGetTagType>ddGetTagType</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetUser><H1 CLASS="APISYMBOL">mgGetUser</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetUser</B> is obsolete. Replaced by&#32&#32&#32<A HREF=#mgGetUserData>mgGetUserData</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetValBits><H1 CLASS="APISYMBOL">mgGetValBits</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetValBits</B> is deprecated. Use <A HREF=#mgGetAttList>mgGetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetValC><H1 CLASS="APISYMBOL">mgGetValC</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetValC</B> is deprecated. Use <A HREF=#mgGetAttList>mgGetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetValD><H1 CLASS="APISYMBOL">mgGetValD</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetValD</B> is deprecated. Use <A HREF=#mgGetAttList>mgGetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetValF><H1 CLASS="APISYMBOL">mgGetValF</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetValF</B> is deprecated. Use <A HREF=#mgGetAttList>mgGetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetValI><H1 CLASS="APISYMBOL">mgGetValI</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetValI</B> is deprecated. Use <A HREF=#mgGetAttList>mgGetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetValP><H1 CLASS="APISYMBOL">mgGetValP</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetValP</B> is deprecated. Use <A HREF=#mgGetAttList>mgGetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetValS><H1 CLASS="APISYMBOL">mgGetValS</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetValS</B> is deprecated. Use <A HREF=#mgGetAttList>mgGetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetValUC><H1 CLASS="APISYMBOL">mgGetValUC</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetValUC</B> is deprecated. Use <A HREF=#mgGetAttList>mgGetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetValUI><H1 CLASS="APISYMBOL">mgGetValUI</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetValUI</B> is deprecated. Use <A HREF=#mgGetAttList>mgGetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgGetValUS><H1 CLASS="APISYMBOL">mgGetValUS</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgGetValUS</B> is deprecated. Use <A HREF=#mgGetAttList>mgGetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgIndexOfLtsEntry><H1 CLASS="APISYMBOL">mgIndexOfLtsEntry</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgIndexOfLtsEntry</B> is obsolete. Replaced by&#32&#32&#32<A HREF=#mgIndexOfLightSource>mgIndexOfLightSource</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgIsBsp><H1 CLASS="APISYMBOL">mgIsBsp</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgIsBsp</B> is deprecated. Use <A HREF=#mgIsCode>mgIsCode</A> ( rec, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltBsp>fltBsp</A>
)<P></DD>
</DL>
<HR>
<LEFT><A NAME=mgIsDof><H1 CLASS="APISYMBOL">mgIsDof</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgIsDof</B> is deprecated. Use <A HREF=#mgIsCode>mgIsCode</A> ( rec, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDof</A>
)<P></DD>
</DL>
<HR>
<LEFT><A NAME=mgIsGroup><H1 CLASS="APISYMBOL">mgIsGroup</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgIsGroup</B> is deprecated. Use <A HREF=#mgIsCode>mgIsCode</A> ( rec, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltGroup>fltGroup</A>
)<P></DD>
</DL>
<HR>
<LEFT><A NAME=mgIsHeader><H1 CLASS="APISYMBOL">mgIsHeader</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgIsHeader</B> is deprecated. Use <A HREF=#mgIsCode>mgIsCode</A> ( rec, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHeader</A>
)<P></DD>
</DL>
<HR>
<LEFT><A NAME=mgIsLightSource><H1 CLASS="APISYMBOL">mgIsLightSource</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgIsLightSource</B> is deprecated. Use <A HREF=#mgIsCode>mgIsCode</A> ( rec, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLightSource>fltLightSource</A>
)<P></DD>
</DL>
<HR>
<LEFT><A NAME=mgIsLod><H1 CLASS="APISYMBOL">mgIsLod</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgIsLod</B> is deprecated. Use <A HREF=#mgIsCode>mgIsCode</A> ( rec, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLod>fltLod</A>
)<P></DD>
</DL>
<HR>
<LEFT><A NAME=mgIsObject><H1 CLASS="APISYMBOL">mgIsObject</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgIsObject</B> is deprecated. Use <A HREF=#mgIsCode>mgIsCode</A> ( rec, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltObject>fltObject</A>
)<P></DD>
</DL>
<HR>
<LEFT><A NAME=mgIsPath><H1 CLASS="APISYMBOL">mgIsPath</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgIsPath</B> is deprecated. Use <A HREF=#mgIsCode>mgIsCode</A> ( rec, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPath>fltPath</A>
)<P></DD>
</DL>
<HR>
<LEFT><A NAME=mgIsPolygon><H1 CLASS="APISYMBOL">mgIsPolygon</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgIsPolygon</B> is deprecated. Use <A HREF=#mgIsCode>mgIsCode</A> ( rec, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
)<P></DD>
</DL>
<HR>
<LEFT><A NAME=mgIsSound><H1 CLASS="APISYMBOL">mgIsSound</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgIsSound</B> is deprecated. Use <A HREF=#mgIsCode>mgIsCode</A> ( rec, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSound>fltSound</A>
)<P></DD>
</DL>
<HR>
<LEFT><A NAME=mgIsSwitch><H1 CLASS="APISYMBOL">mgIsSwitch</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgIsSwitch</B> is deprecated. Use <A HREF=#mgIsCode>mgIsCode</A> ( rec, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltSwitch>fltSwitch</A>
)<P></DD>
</DL>
<HR>
<LEFT><A NAME=mgIsVertex><H1 CLASS="APISYMBOL">mgIsVertex</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgIsVertex</B> is deprecated. Use <A HREF=#mgIsCode>mgIsCode</A> ( rec, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
)<P></DD>
</DL>
<HR>
<LEFT><A NAME=mgIsXref><H1 CLASS="APISYMBOL">mgIsXref</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgIsXref</B> is deprecated. Use <A HREF=#mgIsCode>mgIsCode</A> ( rec, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXref>fltXref</A>
)<P></DD>
</DL>
<HR>
<LEFT><A NAME=mgITYPE_INT><H1 CLASS="APISYMBOL">mgITYPE_INT</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgITYPE_INT</B> is deprecated. Use <A HREF=#MIMG_INT>MIMG_INT</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgITYPE_INTA><H1 CLASS="APISYMBOL">mgITYPE_INTA</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgITYPE_INTA</B> is deprecated. Use <A HREF=#MIMG_INTA>MIMG_INTA</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgITYPE_RGB><H1 CLASS="APISYMBOL">mgITYPE_RGB</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgITYPE_RGB</B> is deprecated. Use <A HREF=#MIMG_RGB>MIMG_RGB</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgITYPE_RGBA><H1 CLASS="APISYMBOL">mgITYPE_RGBA</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgITYPE_RGBA</B> is deprecated. Use <A HREF=#MIMG_RGBA>MIMG_RGBA</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgListFreeStrings><H1 CLASS="APISYMBOL">mgListFreeStrings</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgListFreeStrings</B> is deprecated. Use <A HREF=#mgFreeStringList>mgFreeStringList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgMakeUnitVector><H1 CLASS="APISYMBOL">mgMakeUnitVector</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgMakeUnitVector</B> is deprecated. Use <A HREF=#mgMakeUnitVectord>mgMakeUnitVectord</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgMakeVector><H1 CLASS="APISYMBOL">mgMakeVector</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgMakeVector</B> is deprecated. Use <A HREF=#mgMakeVectord>mgMakeVectord</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgMoveCoordAlongVector><H1 CLASS="APISYMBOL">mgMoveCoordAlongVector</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgMoveCoordAlongVector</B> is deprecated. Use <A HREF=#mgCoord3dMoveAlongVectord>mgCoord3dMoveAlongVectord</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgMoveCoordAlongVectorf><H1 CLASS="APISYMBOL">mgMoveCoordAlongVectorf</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgMoveCoordAlongVectorf</B> is deprecated. Use <A HREF=#mgCoord3dMoveAlongVectorf>mgCoord3dMoveAlongVectorf</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgNameOfLtsEntry><H1 CLASS="APISYMBOL">mgNameOfLtsEntry</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgNameOfLtsEntry</B> is obsolete. Replaced by&#32&#32&#32<A HREF=#mgNameOfLightSource>mgNameOfLightSource</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgNewSelectList><H1 CLASS="APISYMBOL">mgNewSelectList</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgNewSelectList</B> is deprecated. Use <A HREF=#mgGetSelectList>mgGetSelectList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgNULL><H1 CLASS="APISYMBOL">mgNULL</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgNULL</B> is deprecated. Use <A HREF=#MG_NULL>MG_NULL</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgPrintField><H1 CLASS="APISYMBOL">mgPrintField</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgPrintField</B> is deprecated. Use <A HREF=#mgPrintRec>mgPrintRec</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgRegisterCallback><H1 CLASS="APISYMBOL">mgRegisterCallback</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgRegisterCallback</B> is deprecated. Use <A HREF=#mgRegisterGetMaxId>mgRegisterGetMaxId</A>, <A HREF=#mgRegisterSetMaxId>mgRegisterSetMaxId</A>, and <A HREF=#mgRegisterGetHeaderCode>mgRegisterGetHeaderCode</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgResetSelectList><H1 CLASS="APISYMBOL">mgResetSelectList</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgResetSelectList</B> is deprecated. Use <A HREF=#mgResetRecList>mgResetRecList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=dep_mgselectlist><H1 CLASS="APISYMBOL">mgselectlist</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgselectlist</B> is deprecated. Use <A HREF=#mgreclist>mgreclist</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetAttBits><H1 CLASS="APISYMBOL">mgSetAttBits</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetAttBits</B> is obsolete. Use <A HREF=#mgSetAttList>mgSetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetAttFlag><H1 CLASS="APISYMBOL">mgSetAttFlag</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetAttFlag</B> is obsolete. Use <A HREF=#mgSetAttList>mgSetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetAttRec><H1 CLASS="APISYMBOL">mgSetAttRec</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetAttRec</B> is obsolete. Use <A HREF=#mgSetAttList>mgSetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetAttText><H1 CLASS="APISYMBOL">mgSetAttText</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetAttText</B> is obsolete. Use <A HREF=#mgSetAttList>mgSetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetAttValC><H1 CLASS="APISYMBOL">mgSetAttValC</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetAttValC</B> is obsolete. Use <A HREF=#mgSetAttList>mgSetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetAttValD><H1 CLASS="APISYMBOL">mgSetAttValD</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetAttValD</B> is obsolete. Use <A HREF=#mgSetAttList>mgSetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetAttValF><H1 CLASS="APISYMBOL">mgSetAttValF</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetAttValF</B> is obsolete. Use <A HREF=#mgSetAttList>mgSetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetAttValI><H1 CLASS="APISYMBOL">mgSetAttValI</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetAttValI</B> is obsolete. Use <A HREF=#mgSetAttList>mgSetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetAttValP><H1 CLASS="APISYMBOL">mgSetAttValP</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetAttValP</B> is obsolete. Use <A HREF=#mgSetAttList>mgSetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetAttValS><H1 CLASS="APISYMBOL">mgSetAttValS</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetAttValS</B> is obsolete. Use <A HREF=#mgSetAttList>mgSetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetAttValUC><H1 CLASS="APISYMBOL">mgSetAttValUC</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetAttValUC</B> is obsolete. Use <A HREF=#mgSetAttList>mgSetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetAttValUI><H1 CLASS="APISYMBOL">mgSetAttValUI</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetAttValUI</B> is obsolete. Use <A HREF=#mgSetAttList>mgSetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetAttValUS><H1 CLASS="APISYMBOL">mgSetAttValUS</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetAttValUS</B> is obsolete. Use <A HREF=#mgSetAttList>mgSetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetChar><H1 CLASS="APISYMBOL">mgSetChar</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetChar</B> is deprecated. Use <A HREF=#mgSetAttList>mgSetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetFCoord><H1 CLASS="APISYMBOL">mgSetFCoord</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetFCoord</B> is deprecated. Use <A HREF=#mgSetCoord3f>mgSetCoord3f</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetFlag><H1 CLASS="APISYMBOL">mgSetFlag</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetFlag</B> is deprecated. Use <A HREF=#mgSetAttList>mgSetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetIcoord><H1 CLASS="APISYMBOL">mgSetIcoord</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetIcoord</B> is deprecated. Use <A HREF=#mgSetCoord3d>mgSetCoord3d</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetIPoint><H1 CLASS="APISYMBOL">mgSetIPoint</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetIPoint</B> is deprecated. Use <A HREF=#mgSetCoord2i>mgSetCoord2i</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetPackedColor><H1 CLASS="APISYMBOL">mgSetPackedColor</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetPackedColor</B> is deprecated. Do not use<P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetPolyRGBA><H1 CLASS="APISYMBOL">mgSetPolyRGBA</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetPolyRGBA</B> is obsolete. Replaced by&#32&#32&#32<A HREF=#mgSetPolyColorRGB>mgSetPolyColorRGB</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetText><H1 CLASS="APISYMBOL">mgSetText</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetText</B> is deprecated. Use <A HREF=#mgSetAttList>mgSetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetUser><H1 CLASS="APISYMBOL">mgSetUser</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetUser</B> is obsolete. Replaced by&#32&#32&#32<A HREF=#mgSetUserData>mgSetUserData</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetValBits><H1 CLASS="APISYMBOL">mgSetValBits</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetValBits</B> is deprecated. Use <A HREF=#mgSetAttList>mgSetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetValC><H1 CLASS="APISYMBOL">mgSetValC</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetValC</B> is deprecated. Use <A HREF=#mgSetAttList>mgSetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetValD><H1 CLASS="APISYMBOL">mgSetValD</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetValD</B> is deprecated. Use <A HREF=#mgSetAttList>mgSetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetValF><H1 CLASS="APISYMBOL">mgSetValF</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetValF</B> is deprecated. Use <A HREF=#mgSetAttList>mgSetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetValI><H1 CLASS="APISYMBOL">mgSetValI</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetValI</B> is deprecated. Use <A HREF=#mgSetAttList>mgSetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetValIP><H1 CLASS="APISYMBOL">mgSetValIP</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetValIP</B> is deprecated. Use <A HREF=#mgSetAttList>mgSetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetValP><H1 CLASS="APISYMBOL">mgSetValP</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetValP</B> is deprecated. Use <A HREF=#mgSetAttList>mgSetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetValS><H1 CLASS="APISYMBOL">mgSetValS</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetValS</B> is deprecated. Use <A HREF=#mgSetAttList>mgSetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetValUC><H1 CLASS="APISYMBOL">mgSetValUC</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetValUC</B> is deprecated. Use <A HREF=#mgSetAttList>mgSetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetValUI><H1 CLASS="APISYMBOL">mgSetValUI</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetValUI</B> is deprecated. Use <A HREF=#mgSetAttList>mgSetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgSetValUS><H1 CLASS="APISYMBOL">mgSetValUS</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgSetValUS</B> is deprecated. Use <A HREF=#mgSetAttList>mgSetAttList</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgTempLightSourceTableEntry><H1 CLASS="APISYMBOL">mgTempLightSourceTableEntry</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgTempLightSourceTableEntry</B> is obsolete. Replaced by&#32&#32&#32<A HREF=#mgNewLightSource>mgNewLightSource</A>&#32(different params)<P></DD>
</DL>
<HR>
<LEFT><A NAME=mgTransformCoord><H1 CLASS="APISYMBOL">mgTransformCoord</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgTransformCoord</B> is deprecated. Use <A HREF=#mgCoord3dTransform>mgCoord3dTransform</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgTransformVector><H1 CLASS="APISYMBOL">mgTransformVector</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgTransformVector</B> is deprecated. Use <A HREF=#mgVectordTransform>mgVectordTransform</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgTRUE><H1 CLASS="APISYMBOL">mgTRUE</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgTRUE</B> is deprecated. Use <A HREF=#mgbool>MG_TRUE</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgtype_bead><H1 CLASS="APISYMBOL">mgtype_bead</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgtype_bead</B> is deprecated. Use <A HREF=#mgtagtype>MTYPE_BEAD</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgtype_cval><H1 CLASS="APISYMBOL">mgtype_cval</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgtype_cval</B> is deprecated. Use <A HREF=#mgtagtype>MTYPE_CHAR</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgtype_data><H1 CLASS="APISYMBOL">mgtype_data</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgtype_data</B> is deprecated. Use <A HREF=#mgtagtype>MTYPE_DATA</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgtype_dval><H1 CLASS="APISYMBOL">mgtype_dval</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgtype_dval</B> is deprecated. Use <A HREF=#mgtagtype>MTYPE_DOUBLE</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgtype_enum><H1 CLASS="APISYMBOL">mgtype_enum</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgtype_enum</B> is deprecated. Use <A HREF=#mgtagtype>MTYPE_ENUM</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgtype_flag><H1 CLASS="APISYMBOL">mgtype_flag</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgtype_flag</B> is deprecated. Use <A HREF=#mgtagtype>MTYPE_FLAG</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgtype_fval><H1 CLASS="APISYMBOL">mgtype_fval</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgtype_fval</B> is deprecated. Use <A HREF=#mgtagtype>MTYPE_FLOAT</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgtype_ival><H1 CLASS="APISYMBOL">mgtype_ival</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgtype_ival</B> is deprecated. Use <A HREF=#mgtagtype>MTYPE_INT</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgtype_null><H1 CLASS="APISYMBOL">mgtype_null</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgtype_null</B> is deprecated. Use <A HREF=#mgtagtype>MTYPE_NULL</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgtype_rec><H1 CLASS="APISYMBOL">mgtype_rec</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgtype_rec</B> is deprecated. Use <A HREF=#mgtagtype>MTYPE_REC</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgtype_root><H1 CLASS="APISYMBOL">mgtype_root</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgtype_root</B> is deprecated. Use <A HREF=#mgtagtype>MTYPE_ROOT</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgtype_sval><H1 CLASS="APISYMBOL">mgtype_sval</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgtype_sval</B> is deprecated. Use <A HREF=#mgtagtype>MTYPE_SHORT</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgtype_text><H1 CLASS="APISYMBOL">mgtype_text</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgtype_text</B> is deprecated. Use <A HREF=#mgtagtype>MTYPE_TEXT</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgtype_ucval><H1 CLASS="APISYMBOL">mgtype_ucval</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgtype_ucval</B> is deprecated. Use <A HREF=#mgtagtype>MTYPE_UCHAR</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgtype_uival><H1 CLASS="APISYMBOL">mgtype_uival</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgtype_uival</B> is deprecated. Use <A HREF=#mgtagtype>MTYPE_UINT</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgtype_usval><H1 CLASS="APISYMBOL">mgtype_usval</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgtype_usval</B> is deprecated. Use <A HREF=#mgtagtype>MTYPE_USHORT</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgUnitizeVector><H1 CLASS="APISYMBOL">mgUnitizeVector</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgUnitizeVector</B> is deprecated. Use <A HREF=#mgVectordSetUnitized>mgVectordSetUnitized</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgVectorCross><H1 CLASS="APISYMBOL">mgVectorCross</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgVectorCross</B> is deprecated. Use <A HREF=#mgVectordCross>mgVectordCross</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgVectorDot><H1 CLASS="APISYMBOL">mgVectorDot</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgVectorDot</B> is deprecated. Use <A HREF=#mgVectordDot>mgVectordDot</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgVectordTof><H1 CLASS="APISYMBOL">mgVectordTof</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgVectordTof</B> is deprecated. Use <A HREF=#mgVectordToVectorf>mgVectordToVectorf</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgVectorFromLine><H1 CLASS="APISYMBOL">mgVectorFromLine</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgVectorFromLine</B> is deprecated. Use <A HREF=#mgVectordFromLine>mgVectordFromLine</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgVectorMove><H1 CLASS="APISYMBOL">mgVectorMove</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgVectorMove</B> is deprecated. Use <A HREF=#mgCoord3dMoveAlongVectorf>mgCoord3dMoveAlongVectorf</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=mgwalk_func><H1 CLASS="APISYMBOL">mgwalk_func</H1></A></LEFT>
<DL><DT></DT>
<DD><B>mgwalk_func</B> is deprecated. Use <A HREF=#mgwalkfunc>mgwalkfunc</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=MGWALKATT><H1 CLASS="APISYMBOL">MGWALKATT</H1></A></LEFT>
<DL><DT></DT>
<DD><B>MGWALKATT</B> is deprecated. Use <A HREF=#MWALK_ATTR>MWALK_ATTR</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=MGWALKMASTER><H1 CLASS="APISYMBOL">MGWALKMASTER</H1></A></LEFT>
<DL><DT></DT>
<DD><B>MGWALKMASTER</B> is deprecated. Use <A HREF=#MWALK_MASTER>MWALK_MASTER</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=MGWALKMASTERALL><H1 CLASS="APISYMBOL">MGWALKMASTERALL</H1></A></LEFT>
<DL><DT></DT>
<DD><B>MGWALKMASTERALL</B> is deprecated. Use <A HREF=#MWALK_MASTERALL>MWALK_MASTERALL</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=MGWALKNEXT><H1 CLASS="APISYMBOL">MGWALKNEXT</H1></A></LEFT>
<DL><DT></DT>
<DD><B>MGWALKNEXT</B> is deprecated. Use <A HREF=#MWALK_NEXT>MWALK_NEXT</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=MGWALKNORDONLY><H1 CLASS="APISYMBOL">MGWALKNORDONLY</H1></A></LEFT>
<DL><DT></DT>
<DD><B>MGWALKNORDONLY</B> is deprecated. Use <A HREF=#MWALK_NORDONLY>MWALK_NORDONLY</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=MGWALKON><H1 CLASS="APISYMBOL">MGWALKON</H1></A></LEFT>
<DL><DT></DT>
<DD><B>MGWALKON</B> is deprecated. Use <A HREF=#MWALK_ON>MWALK_ON</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=MGWALKVERTEX><H1 CLASS="APISYMBOL">MGWALKVERTEX</H1></A></LEFT>
<DL><DT></DT>
<DD><B>MGWALKVERTEX</B> is deprecated. Use <A HREF=#MWALK_VERTEX>MWALK_VERTEX</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=MPAL_EDGETOOLS><H1 CLASS="APISYMBOL">MPAL_EDGETOOLS</H1></A></LEFT>
<DL><DT></DT>
<DD><B>MPAL_EDGETOOLS</B> is deprecated. Use <A HREF=#MPAL_CONSTRUCTIONTOOLS>MPAL_CONSTRUCTIONTOOLS</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=MPAL_VERTEXTOOLS><H1 CLASS="APISYMBOL">MPAL_VERTEXTOOLS</H1></A></LEFT>
<DL><DT></DT>
<DD><B>MPAL_VERTEXTOOLS</B> is deprecated. Use <A HREF=#MPAL_CONSTRUCTIONTOOLS>MPAL_CONSTRUCTIONTOOLS</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=MWALK_NORDONLY><H1 CLASS="APISYMBOL">MWALK_NORDONLY</H1></A></LEFT>
<DL><DT></DT>
<DD><B>MWALK_NORDONLY</B> is deprecated. Use <A HREF=#MWALK_NOREADONLY>MWALK_NOREADONLY</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=SetMaxIdFunc><H1 CLASS="APISYMBOL">SetMaxIdFunc</H1></A></LEFT>
<DL><DT></DT>
<DD><B>SetMaxIdFunc</B> is deprecated. Use <A HREF=#mgsetmaxidfunc>mgsetmaxidfunc</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=tagtype><H1 CLASS="APISYMBOL">tagtype</H1></A></LEFT>
<DL><DT></DT>
<DD><B>tagtype</B> is deprecated. Use <A HREF=#mgtagtype>mgtagtype</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=XLL_GENERAL><H1 CLASS="APISYMBOL">XLL_GENERAL</H1></A></LEFT>
<DL><DT></DT>
<DD><B>XLL_GENERAL</B> is deprecated. Use <A HREF=#mgxfllcode>MXLL_GENERAL</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=XLL_PUT><H1 CLASS="APISYMBOL">XLL_PUT</H1></A></LEFT>
<DL><DT></DT>
<DD><B>XLL_PUT</B> is deprecated. Use <A HREF=#mgxfllcode>MXLL_PUT</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=XLL_ROTEDGE><H1 CLASS="APISYMBOL">XLL_ROTEDGE</H1></A></LEFT>
<DL><DT></DT>
<DD><B>XLL_ROTEDGE</B> is deprecated. Use <A HREF=#mgxfllcode>MXLL_ROTEDGE&#32</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=XLL_ROTPT><H1 CLASS="APISYMBOL">XLL_ROTPT</H1></A></LEFT>
<DL><DT></DT>
<DD><B>XLL_ROTPT</B> is deprecated. Use <A HREF=#mgxfllcode>MXLL_ROTPT</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=XLL_SCALE><H1 CLASS="APISYMBOL">XLL_SCALE</H1></A></LEFT>
<DL><DT></DT>
<DD><B>XLL_SCALE</B> is deprecated. Use <A HREF=#mgxfllcode>MXLL_SCALE</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=XLL_TOPOINT><H1 CLASS="APISYMBOL">XLL_TOPOINT</H1></A></LEFT>
<DL><DT></DT>
<DD><B>XLL_TOPOINT</B> is deprecated. Use <A HREF=#mgxfllcode>MXLL_TOPOINT</A><P></DD>
</DL>
<HR>
<LEFT><A NAME=XLL_TRANSLATE><H1 CLASS="APISYMBOL">XLL_TRANSLATE</H1></A></LEFT>
<DL><DT></DT>
<DD><B>XLL_TRANSLATE</B> is deprecated. Use <A HREF=#mgxfllcode>MXLL_TRANSLATE</A><P></DD>
</DL>
<HR>
<BR>
</BODY>

</HTML>



<HR>
<A NAME=ATTRIBUTEFUNC><H1>Attribute Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgconvexhull>mgconvexhull</A> <TD><A HREF=#mgConvexHullBuilderClose><B>mgConvexHullBuilderClose</B></A> (<A HREF=#mgconvexhullbuilder>mgconvexhullbuilder</A> <I>hullBuilder</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgConvexHullBuilderExpandCoord3d><B>mgConvexHullBuilderExpandCoord3d</B></A> (<A HREF=#mgconvexhullbuilder>mgconvexhullbuilder</A> <I>hullBuilder</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>c</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgConvexHullGetTriangleCount><B>mgConvexHullGetTriangleCount</B></A> (<A HREF=#mgconvexhull>mgconvexhull</A> <I>hull</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgConvexHullGetTriangleNth><B>mgConvexHullGetTriangleNth</B></A> (<A HREF=#mgconvexhull>mgconvexhull</A> <I>hull</I>, int <I>nth</I>, <A HREF=#mgconvexhulltriangle>mgconvexhulltriangle*</A> <I>triangle</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgDeleteComment><B>mgDeleteComment</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgFreeConvexHull><B>mgFreeConvexHull</B></A> (<A HREF=#mgconvexhull>mgconvexhull</A> <I>hull</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgFreeConvexHullBuilder><B>mgFreeConvexHullBuilder</B></A> (<A HREF=#mgconvexhullbuilder>mgconvexhullbuilder</A> <I>hullBuilder</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetAttBuf><B>mgGetAttBuf</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgcode>mgcode</A> <I>fcode</I>, void* <I>buf</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgGetAttList><B>mgGetAttList</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#></A> <I>< attrCode ></I>, <A HREF=#></A> <I>< attrValAddr ></I>, <A HREF=#></A> <I>...</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetAttRec><B>mgGetAttRec</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgcode>mgcode</A> <I>rcode</I>, <A HREF=#mgrec>mgrec*</A> <I>recOut</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetBounds><B>mgGetBounds</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgboxd>mgboxd*</A> <I>box</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetBoundsForRecList><B>mgGetBoundsForRecList</B></A> (<A HREF=#mgreclist>mgreclist</A> <I>list</I>, <A HREF=#mgboxd>mgboxd*</A> <I>box</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetBoundsForSelect><B>mgGetBoundsForSelect</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, <A HREF=#mgboxd>mgboxd*</A> <I>box</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetColorRGBA><B>mgGetColorRGBA</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgcode>mgcode</A> <I>colorRGBACode</I>, float* <I>red</I>, float* <I>green</I>, float* <I>blue</I>, float* <I>alpha</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgGetComment><B>mgGetComment</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgconvexhull>mgconvexhull</A> <TD><A HREF=#mgGetConvexHull><B>mgGetConvexHull</B></A> (<A HREF=#mgrec>mgrec*</A> <I>node</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetCoord2i><B>mgGetCoord2i</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgcode>mgcode</A> <I>code</I>, int* <I>x</I>, int* <I>y</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetCoord3d><B>mgGetCoord3d</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgcode>mgcode</A> <I>code</I>, double* <I>x</I>, double* <I>y</I>, double* <I>z</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetCoord3f><B>mgGetCoord3f</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgcode>mgcode</A> <I>code</I>, float* <I>x</I>, float* <I>y</I>, float* <I>z</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetExtRec><B>mgGetExtRec</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgcode>mgcode</A> <I>rcode</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetMatrix><B>mgGetMatrix</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgcode>mgcode</A> <I>matrixCode</I>, <A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetMatTextureLayer><B>mgGetMatTextureLayer</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgcode>mgcode</A> <I>matTextureCode</I>, int* <I>textureIndex</I>, int* <I>textureLayer</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgGetName><B>mgGetName</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetNormColor><B>mgGetNormColor</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgcode>mgcode</A> <I>normColorCode</I>, float* <I>red</I>, float* <I>green</I>, float* <I>blue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetPlane><B>mgGetPlane</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgcode>mgcode</A> <I>planeCode</I>, double* <I>a</I>, double* <I>b</I>, double* <I>c</I>, double* <I>d</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgGetPolyAltColorName><B>mgGetPolyAltColorName</B></A> (<A HREF=#mgrec>mgrec*</A> <I>poly</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetPolyAltColorRGB><B>mgGetPolyAltColorRGB</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, short* <I>red</I>, short* <I>green</I>, short* <I>blue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgGetPolyColorName><B>mgGetPolyColorName</B></A> (<A HREF=#mgrec>mgrec*</A> <I>poly</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetPolyColorRGB><B>mgGetPolyColorRGB</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, short* <I>red</I>, short* <I>green</I>, short* <I>blue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetPolyNormal><B>mgGetPolyNormal</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, double* <I>i</I>, double* <I>j</I>, double* <I>k</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgGetTextString><B>mgGetTextString</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void* <TD><A HREF=#mgGetUserData><B>mgGetUserData</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetVector><B>mgGetVector</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgcode>mgcode</A> <I>vectorCode</I>, float* <I>i</I>, float* <I>j</I>, float* <I>k</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetVectord><B>mgGetVectord</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgcode>mgcode</A> <I>vectorCode</I>, double* <I>i</I>, double* <I>j</I>, double* <I>k</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetVtxBackColorRGB><B>mgGetVtxBackColorRGB</B></A> (<A HREF=#mgrec>mgrec*</A> <I>vtx</I>, short* <I>red</I>, short* <I>green</I>, short* <I>blue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgGetVtxColorName><B>mgGetVtxColorName</B></A> (<A HREF=#mgrec>mgrec*</A> <I>vtx</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetVtxColorRGB><B>mgGetVtxColorRGB</B></A> (<A HREF=#mgrec>mgrec*</A> <I>vtx</I>, short* <I>red</I>, short* <I>green</I>, short* <I>blue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetVtxColorRGBA><B>mgGetVtxColorRGBA</B></A> (<A HREF=#mgrec>mgrec*</A> <I>vtx</I>, short* <I>red</I>, short* <I>green</I>, short* <I>blue</I>, short* <I>alpha</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetVtxCoord><B>mgGetVtxCoord</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, double* <I>x</I>, double* <I>y</I>, double* <I>z</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetVtxNormal><B>mgGetVtxNormal</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, float* <I>i</I>, float* <I>j</I>, float* <I>k</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgHasAtt><B>mgHasAtt</B></A> (<A HREF=#mgrec>mgrec*</A> <I>parentRec</I>, <A HREF=#mgcode>mgcode</A> <I>rcode</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgIsPolyConcave><B>mgIsPolyConcave</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgIsPolyCoplanar><B>mgIsPolyCoplanar</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgconvexhullbuilder>mgconvexhullbuilder</A> <TD><A HREF=#mgNewConvexHullBuilder><B>mgNewConvexHullBuilder</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgRecDeleteProperty><B>mgRecDeleteProperty</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>pluginTool</I>, <A HREF=#mgrec>mgrec*</A> <I>rec</I>, const <A HREF=#mgpropertyname>mgpropertyname</A> <I>propName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgpropertyvalue>mgpropertyvalue</A> <TD><A HREF=#mgRecGetProperty><B>mgRecGetProperty</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>pluginTool</I>, <A HREF=#mgrec>mgrec*</A> <I>rec</I>, const <A HREF=#mgpropertyname>mgpropertyname</A> <I>propName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgRecPutProperty><B>mgRecPutProperty</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>pluginTool</I>, <A HREF=#mgrec>mgrec*</A> <I>rec</I>, const <A HREF=#mgpropertyname>mgpropertyname</A> <I>propName</I>, <A HREF=#mgpropertyvalue>mgpropertyvalue</A> <I>propValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgRemoveVtxNormal><B>mgRemoveVtxNormal</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetAttBuf><B>mgSetAttBuf</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgcode>mgcode</A> <I>fcode</I>, void* <I>buf</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgSetAttList><B>mgSetAttList</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#></A> <I>< attrCode ></I>, <A HREF=#></A> <I>< attrVal ></I>, <A HREF=#></A> <I>...</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetColorRGBA><B>mgSetColorRGBA</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgcode>mgcode</A> <I>colorRgbaCode</I>, float <I>red</I>, float <I>green</I>, float <I>blue</I>, float <I>alpha</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetComment><B>mgSetComment</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, const char* <I>comment</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetCoord2i><B>mgSetCoord2i</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgcode>mgcode</A> <I>code</I>, int <I>x</I>, int <I>y</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetCoord3d><B>mgSetCoord3d</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgcode>mgcode</A> <I>code</I>, double <I>x</I>, double <I>y</I>, double <I>z</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetCoord3f><B>mgSetCoord3f</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgcode>mgcode</A> <I>code</I>, float <I>x</I>, float <I>y</I>, float <I>z</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetMatrix><B>mgSetMatrix</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgcode>mgcode</A> <I>matrixCode</I>, <A HREF=#mgmatrix>mgmatrix</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetMatTextureLayer><B>mgSetMatTextureLayer</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgcode>mgcode</A> <I>matTextureCode</I>, int <I>textureIndex</I>, int <I>textureLayer</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetName><B>mgSetName</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, const char* <I>name</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetNameUnique><B>mgSetNameUnique</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, const char* <I>name</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetNormColor><B>mgSetNormColor</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgcode>mgcode</A> <I>normColorCode</I>, float <I>red</I>, float <I>green</I>, float <I>blue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetPlane><B>mgSetPlane</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgcode>mgcode</A> <I>code</I>, double <I>a</I>, double <I>b</I>, double <I>c</I>, double <I>d</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetPolyAltColorName><B>mgSetPolyAltColorName</B></A> (<A HREF=#mgrec>mgrec*</A> <I>poly</I>, const char* <I>name</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetPolyAltColorRGB><B>mgSetPolyAltColorRGB</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, short <I>red</I>, short <I>green</I>, short <I>blue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetPolyColorName><B>mgSetPolyColorName</B></A> (<A HREF=#mgrec>mgrec*</A> <I>poly</I>, const char* <I>name</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetPolyColorRGB><B>mgSetPolyColorRGB</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, short <I>red</I>, short <I>green</I>, short <I>blue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetPolyCurrentAltColor><B>mgSetPolyCurrentAltColor</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, <A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetPolyCurrentColor><B>mgSetPolyCurrentColor</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, <A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetPolyCurrentMaterial><B>mgSetPolyCurrentMaterial</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, <A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetPolyCurrentShader><B>mgSetPolyCurrentShader</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, <A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetPolyCurrentTexture><B>mgSetPolyCurrentTexture</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, <A HREF=#mgrec>mgrec*</A> <I>rec</I>, int <I>layer</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetPolyCurrentTextureMapping><B>mgSetPolyCurrentTextureMapping</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, <A HREF=#mgrec>mgrec*</A> <I>rec</I>, int <I>layer</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgSetTextString><B>mgSetTextString</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, const char* <I>name</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgSetUserData><B>mgSetUserData</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, void* <I>ptr</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetVector><B>mgSetVector</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgcode>mgcode</A> <I>vectorCode</I>, float <I>i</I>, float <I>j</I>, float <I>k</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetVectord><B>mgSetVectord</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgcode>mgcode</A> <I>vectorCode</I>, double <I>i</I>, double <I>j</I>, double <I>k</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetVtxBackColorRGB><B>mgSetVtxBackColorRGB</B></A> (<A HREF=#mgrec>mgrec*</A> <I>vtx</I>, short <I>red</I>, short <I>green</I>, short <I>blue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetVtxColorName><B>mgSetVtxColorName</B></A> (<A HREF=#mgrec>mgrec*</A> <I>vtx</I>, const char* <I>name</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetVtxColorRGB><B>mgSetVtxColorRGB</B></A> (<A HREF=#mgrec>mgrec*</A> <I>vtx</I>, short <I>red</I>, short <I>green</I>, short <I>blue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetVtxColorRGBA><B>mgSetVtxColorRGBA</B></A> (<A HREF=#mgrec>mgrec*</A> <I>vtx</I>, short <I>red</I>, short <I>green</I>, short <I>blue</I>, short <I>alpha</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetVtxCoord><B>mgSetVtxCoord</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, double <I>x</I>, double <I>y</I>, double <I>z</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetVtxNormal><B>mgSetVtxNormal</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, float <I>i</I>, float <I>j</I>, float <I>k</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=FOCUSVERTEXFUNC><H1>Focus Vertex Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgClearFocusVertex><B>mgClearFocusVertex</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgFocusVertexListAddItem><B>mgFocusVertexListAddItem</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>, <A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgFocusVertexListDeleteAllItems><B>mgFocusVertexListDeleteAllItems</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgFocusVertexListDeleteItem><B>mgFocusVertexListDeleteItem</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>, <A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetFocusVertex><B>mgGetFocusVertex</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgSetFocusVertex><B>mgSetFocusVertex</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>, <A HREF=#mgrec>mgrec*</A> <I>vertexRec</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=SWITCHFUNC><H1>Switch Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgAddSwitchMask><B>mgAddSwitchMask</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgDeleteSwitchMask><B>mgDeleteSwitchMask</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, int <I>maskNo</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetSwitchBit><B>mgGetSwitchBit</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, int <I>maskNo</I>, int <I>bitNo</I>, <A HREF=#mgbool>mgbool*</A> <I>on</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgGetSwitchMaskCount><B>mgGetSwitchMaskCount</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgGetSwitchMaskName><B>mgGetSwitchMaskName</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, int <I>maskNo</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetSwitchMaskNo><B>mgGetSwitchMaskNo</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, int* <I>maskNo</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgInitSwitchMask><B>mgInitSwitchMask</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, int <I>maskNo</I>, <A HREF=#mgbool>mgbool</A> <I>on</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetSwitchBit><B>mgSetSwitchBit</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, int <I>maskNo</I>, int <I>bitNo</I>, <A HREF=#mgbool>mgbool</A> <I>on</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetSwitchMaskName><B>mgSetSwitchMaskName</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, int <I>maskNo</I>, const char* <I>name</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=MESHFUNC><H1>Mesh Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMeshCreatePrimitives><B>mgMeshCreatePrimitives</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, unsigned int <I>num</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void* <TD><A HREF=#mgMeshCreateVtxPool><B>mgMeshCreateVtxPool</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, unsigned int <I>mask</I>, unsigned int <I>num</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMeshGetVtxColor><B>mgMeshGetVtxColor</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, int <I>vtxIndex</I>, int* <I>index</I>, float* <I>intensity</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMeshGetVtxColorAlpha><B>mgMeshGetVtxColorAlpha</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, int <I>vtxIndex</I>, short* <I>alpha</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMeshGetVtxColorRGB><B>mgMeshGetVtxColorRGB</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, int <I>vtxIndex</I>, short* <I>red</I>, short* <I>green</I>, short* <I>blue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMeshGetVtxColorRGBA><B>mgMeshGetVtxColorRGBA</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, int <I>vtxIndex</I>, short* <I>red</I>, short* <I>green</I>, short* <I>blue</I>, short* <I>alpha</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMeshGetVtxCoord><B>mgMeshGetVtxCoord</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, int <I>vtxIndex</I>, double* <I>x</I>, double* <I>y</I>, double* <I>z</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">unsigned int <TD><A HREF=#mgMeshGetVtxMask><B>mgMeshGetVtxMask</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMeshGetVtxNormal><B>mgMeshGetVtxNormal</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, int <I>vtxIndex</I>, float* <I>i</I>, float* <I>j</I>, float* <I>k</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgMeshGetVtxOffset><B>mgMeshGetVtxOffset</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, unsigned int <I>bit</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void* <TD><A HREF=#mgMeshGetVtxPool><B>mgMeshGetVtxPool</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">unsigned int <TD><A HREF=#mgMeshGetVtxStride><B>mgMeshGetVtxStride</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMeshGetVtxUV><B>mgMeshGetVtxUV</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, int <I>vtxIndex</I>, int <I>layer</I>, float* <I>u</I>, float* <I>v</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgMeshPrimitiveGetNumVtx><B>mgMeshPrimitiveGetNumVtx</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, int <I>primNo</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgMeshPrimitiveGetType><B>mgMeshPrimitiveGetType</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, int <I>primNo</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgMeshPrimitiveGetVtxIndexArray><B>mgMeshPrimitiveGetVtxIndexArray</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, int <I>primNo</I>, int* <I>indexArray</I>, int <I>maxLen</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgMeshPrimitiveSetType><B>mgMeshPrimitiveSetType</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, int <I>primNo</I>, int <I>type</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgMeshPrimitiveSetVtxIndexArray><B>mgMeshPrimitiveSetVtxIndexArray</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, int <I>primNo</I>, int* <I>indexArray</I>, int <I>numVtx</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMeshSetVtxColor><B>mgMeshSetVtxColor</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, int <I>vtxIndex</I>, int <I>color</I>, float <I>intensity</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMeshSetVtxColorAlpha><B>mgMeshSetVtxColorAlpha</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, int <I>vtxIndex</I>, short <I>alpha</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMeshSetVtxColorRGB><B>mgMeshSetVtxColorRGB</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, int <I>vtxIndex</I>, short <I>red</I>, short <I>green</I>, short <I>blue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMeshSetVtxColorRGBA><B>mgMeshSetVtxColorRGBA</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, int <I>vtxIndex</I>, short <I>red</I>, short <I>green</I>, short <I>blue</I>, short <I>alpha</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMeshSetVtxCoord><B>mgMeshSetVtxCoord</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, int <I>vtxIndex</I>, double <I>x</I>, double <I>y</I>, double <I>z</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMeshSetVtxMask><B>mgMeshSetVtxMask</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, unsigned int <I>newVtxMask</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMeshSetVtxNormal><B>mgMeshSetVtxNormal</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, int <I>vtxIndex</I>, float <I>i</I>, float <I>j</I>, float <I>k</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMeshSetVtxUV><B>mgMeshSetVtxUV</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, int <I>vtxIndex</I>, int <I>layer</I>, float <I>u</I>, float <I>v</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=EYEFUNC><H1>Eyepoint Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgCopyEyePoint><B>mgCopyEyePoint</B></A> (<A HREF=#mgrec>mgrec*</A> <I>to</I>, <A HREF=#mgrec>mgrec*</A> <I>from</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgFreeNewEyePoint><B>mgFreeNewEyePoint</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, <A HREF=#mgrec>mgrec*</A> <I>eyeRec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetCurrentEyePoint><B>mgGetCurrentEyePoint</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, <A HREF=#mgrec>mgrec*</A> <I>eyeRec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetCurrentLookAt><B>mgGetCurrentLookAt</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, double* <I>eyex</I>, double* <I>eyey</I>, double* <I>eyez</I>, double* <I>centerx</I>, double* <I>centery</I>, double* <I>centerz</I>, double* <I>upx</I>, double* <I>upy</I>, double* <I>upz</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetEyePoint><B>mgGetEyePoint</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetEyePointLookAt><B>mgGetEyePointLookAt</B></A> (<A HREF=#mgrec>mgrec*</A> <I>eyeRec</I>, double* <I>eyex</I>, double* <I>eyey</I>, double* <I>eyez</I>, double* <I>centerx</I>, double* <I>centery</I>, double* <I>centerz</I>, double* <I>upx</I>, double* <I>upy</I>, double* <I>upz</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetGraphicViewLookAt><B>mgGetGraphicViewLookAt</B></A> (<A HREF=#mggraphicview>mggraphicview</A> <I>graphicView</I>, double* <I>eyex</I>, double* <I>eyey</I>, double* <I>eyez</I>, double* <I>centerx</I>, double* <I>centery</I>, double* <I>centerz</I>, double* <I>upx</I>, double* <I>upy</I>, double* <I>upz</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetNewEyePoint><B>mgGetNewEyePoint</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetSwitchDistance><B>mgGetSwitchDistance</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, double* <I>distance</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetCurrentEyePoint><B>mgSetCurrentEyePoint</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, <A HREF=#mgrec>mgrec*</A> <I>eyeRec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetCurrentLookAt><B>mgSetCurrentLookAt</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, double <I>eyex</I>, double <I>eyey</I>, double <I>eyez</I>, double <I>centerx</I>, double <I>centery</I>, double <I>centerz</I>, double <I>upx</I>, double <I>upy</I>, double <I>upz</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgSetEyePoint><B>mgSetEyePoint</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>, <A HREF=#mgrec>mgrec*</A> <I>eyeRec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetSwitchDistance><B>mgSetSwitchDistance</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, double <I>distance</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=GRAPHICVIEWFUNC><H1>Graphics View Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgFitOnGrid><B>mgFitOnGrid</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgFitOnNode><B>mgFitOnNode</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, <A HREF=#mgrec>mgrec*</A> <I>node</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgFitOnRecList><B>mgFitOnRecList</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, <A HREF=#mgreclist>mgreclist</A> <I>recList</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgFitOnSelect><B>mgFitOnSelect</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgFreePaneLayout><B>mgFreePaneLayout</B></A> (<A HREF=#mgpanelayout>mgpanelayout</A> <I>layout</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetCurrentGridMatrix><B>mgGetCurrentGridMatrix</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, <A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetCurrentGridPoints><B>mgGetCurrentGridPoints</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, <A HREF=#mgcoord3d>mgcoord3d*</A> <I>origin</I>, <A HREF=#mgcoord3d>mgcoord3d*</A> <I>xAxis</I>, <A HREF=#mgcoord3d>mgcoord3d*</A> <I>third</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetCurrentTrackPlane><B>mgGetCurrentTrackPlane</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, <A HREF=#mgplaned>mgplaned*</A> <I>trackplane</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetPaneLayout><B>mgGetPaneLayout</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, <A HREF=#mgpanelayout>mgpanelayout</A> <I>layout</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGraphicsViewSettingGetDouble><B>mgGraphicsViewSettingGetDouble</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const <A HREF=#mgsettingname>mgsettingname</A> <I>settingName</I>, double* <I>settingValue</I>, double <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGraphicsViewSettingGetInteger><B>mgGraphicsViewSettingGetInteger</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const <A HREF=#mgsettingname>mgsettingname</A> <I>settingName</I>, int* <I>settingValue</I>, int <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGraphicsViewSettingGetMatrix><B>mgGraphicsViewSettingGetMatrix</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const <A HREF=#mgsettingname>mgsettingname</A> <I>settingName</I>, <A HREF=#mgmatrix>mgmatrix*</A> <I>settingValue</I>, <A HREF=#mgmatrix>mgmatrix</A> <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGraphicsViewSettingSetDouble><B>mgGraphicsViewSettingSetDouble</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const <A HREF=#mgsettingname>mgsettingname</A> <I>settingName</I>, double <I>settingValue</I>, unsigned int <I>setMask</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGraphicsViewSettingSetInteger><B>mgGraphicsViewSettingSetInteger</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const <A HREF=#mgsettingname>mgsettingname</A> <I>settingName</I>, int <I>settingValue</I>, unsigned int <I>setMask</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGraphicsViewSettingSetMatrix><B>mgGraphicsViewSettingSetMatrix</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const <A HREF=#mgsettingname>mgsettingname</A> <I>settingName</I>, <A HREF=#mgmatrix>mgmatrix</A> <I>settingValue</I>, unsigned int <I>setMask</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgpanelayout>mgpanelayout</A> <TD><A HREF=#mgNewPaneLayout><B>mgNewPaneLayout</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgResetView><B>mgResetView</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetCurrentGridPoints><B>mgSetCurrentGridPoints</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>origin</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>xAxis</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>third</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetPaneLayout><B>mgSetPaneLayout</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, <A HREF=#mgpanelayout>mgpanelayout</A> <I>layout</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=BASEFUNC><H1>Base Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgFree><B>mgFree</B></A> (void* <I>ptr</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgFreeStringList><B>mgFreeStringList</B></A> (<A HREF=#mgstringlist>mgstringlist</A> <I>strings</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcode>mgcode</A> <TD><A HREF=#mgGetCode><B>mgGetCode</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcode>mgcode</A> <TD><A HREF=#mgGetMyCode><B>mgGetMyCode</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgInit><B>mgInit</B></A> (int* <I>argc</I>, char* <I>argv[]</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgIsCode><B>mgIsCode</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgcode>mgcode</A> <I>code</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgIsInitialized><B>mgIsInitialized</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void* <TD><A HREF=#mgMalloc><B>mgMalloc</B></A> (<A HREF=#mgsize_t>mgsize_t</A> <I>numBytes</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetPluginFolder><B>mgSetPluginFolder</B></A> (const char* <I>folder</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgStringListCount><B>mgStringListCount</B></A> (<A HREF=#mgstringlist>mgstringlist</A> <I>strings</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=COLORFUNC><H1>Color Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgDeleteColorName><B>mgDeleteColorName</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>, const char* <I>name</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetColorIndexByName><B>mgGetColorIndexByName</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>name</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstringlist>mgstringlist</A> <TD><A HREF=#mgGetColorNameList><B>mgGetColorNameList</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetCurrentAltColor><B>mgGetCurrentAltColor</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, unsigned int* <I>index</I>, float* <I>intensity</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetCurrentAltColorRGB><B>mgGetCurrentAltColorRGB</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, short* <I>red</I>, short* <I>green</I>, short* <I>blue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetCurrentColor><B>mgGetCurrentColor</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, unsigned int* <I>index</I>, float* <I>intensity</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgGetCurrentColorName><B>mgGetCurrentColorName</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetCurrentColorRGB><B>mgGetCurrentColorRGB</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, short* <I>red</I>, short* <I>green</I>, short* <I>blue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgGetNextColorName><B>mgGetNextColorName</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>, void** <I>ptr</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgIndex2RGB><B>mgIndex2RGB</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, unsigned int <I>index</I>, float <I>intensity</I>, short* <I>red</I>, short* <I>green</I>, short* <I>blue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgNewColorName><B>mgNewColorName</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>, const char* <I>name</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgReadColorPalette><B>mgReadColorPalette</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>fileName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgReadDefaultColorPalette><B>mgReadDefaultColorPalette</B></A> (const char* <I>fileName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgRGB2Index><B>mgRGB2Index</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, short <I>red</I>, short <I>green</I>, short <I>blue</I>, unsigned int* <I>index</I>, float* <I>intensity</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetColorIndex><B>mgSetColorIndex</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>, short <I>r</I>, short <I>g</I>, short <I>b</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetCurrentAltColor><B>mgSetCurrentAltColor</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, unsigned int <I>index</I>, float <I>intensity</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetCurrentAltColorRGB><B>mgSetCurrentAltColorRGB</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, short <I>red</I>, short <I>green</I>, short <I>blue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetCurrentColor><B>mgSetCurrentColor</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, unsigned int <I>index</I>, float <I>intensity</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetCurrentColorName><B>mgSetCurrentColorName</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>, const char* <I>name</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetCurrentColorRGB><B>mgSetCurrentColorRGB</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, short <I>red</I>, short <I>green</I>, short <I>blue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgWriteColorPalette><B>mgWriteColorPalette</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>fileName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgWriteDefaultColorPalette><B>mgWriteDefaultColorPalette</B></A> (const char* <I>fileName</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=INFOFUNC><H1>Info Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetLastError><B>mgGetLastError</B></A> (char* <I>message</I>, int <I>maxLen</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetMessagesEnabled><B>mgGetMessagesEnabled</B></A> (<A HREF=#mgmessageseverityenum>mgmessageseverityenum</A> <I>severity</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetOpenFlightVersion><B>mgGetOpenFlightVersion</B></A> (char* <I>version</I>, int <I>maxLen</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetVersion><B>mgGetVersion</B></A> (char* <I>version</I>, int <I>maxLen</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgPrintRec><B>mgPrintRec</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSendError><B>mgSendError</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>pluginTool</I>, const char* <I>message</I>, <A HREF=#></A> <I>...</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSendMessage><B>mgSendMessage</B></A> (<A HREF=#mgmessageseverityenum>mgmessageseverityenum</A> <I>severity</I>, const char* <I>message</I>, <A HREF=#></A> <I>...</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSendStatus><B>mgSendStatus</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>pluginTool</I>, const char* <I>message</I>, <A HREF=#></A> <I>...</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSendWarning><B>mgSendWarning</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>pluginTool</I>, const char* <I>message</I>, <A HREF=#></A> <I>...</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgSetMessagesEnabled><B>mgSetMessagesEnabled</B></A> (<A HREF=#mgmessageseverityenum>mgmessageseverityenum</A> <I>severity</I>, <A HREF=#mgbool>mgbool</A> <I>enabled</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=INPUTDEVFUNC><H1>Input Device Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgmousestate>mgmousestate</A> <TD><A HREF=#mgInputDeviceGetButtonStatus><B>mgInputDeviceGetButtonStatus</B></A> (<A HREF=#mginputdevice>mginputdevice</A> <I>inputDevice</I>, int <I>buttonNo</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgdeviceinputdata>mgdeviceinputdata*</A> <TD><A HREF=#mgInputDeviceGetDeviceData><B>mgInputDeviceGetDeviceData</B></A> (<A HREF=#mginputdevice>mginputdevice</A> <I>inputDevice</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mginputdevice>mginputdevice</A> <TD><A HREF=#mgInputDeviceGetHandle><B>mgInputDeviceGetHandle</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>pluginTool</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgInputDeviceSendEvent><B>mgInputDeviceSendEvent</B></A> (<A HREF=#mginputdevice>mginputdevice</A> <I>inputDevice</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgInputDeviceSetButtonStatus><B>mgInputDeviceSetButtonStatus</B></A> (<A HREF=#mginputdevice>mginputdevice</A> <I>inputDevice</I>, int <I>button</I>, <A HREF=#mgmousestate>mgmousestate</A> <I>state</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgInputDeviceSetDeviceData><B>mgInputDeviceSetDeviceData</B></A> (<A HREF=#mginputdevice>mginputdevice</A> <I>inputDevice</I>, void* <I>deviceData</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgInputDeviceSetPoint><B>mgInputDeviceSetPoint</B></A> (<A HREF=#mginputdevice>mginputdevice</A> <I>inputDevice</I>, int <I>x</I>, int <I>y</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgInputDeviceSetVertex><B>mgInputDeviceSetVertex</B></A> (<A HREF=#mginputdevice>mginputdevice</A> <I>inputDevice</I>, double <I>x</I>, double <I>y</I>, double <I>z</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgplugintool>mgplugintool</A> <TD><A HREF=#mgRegisterInputDevice><B>mgRegisterInputDevice</B></A> (<A HREF=#mgplugin>mgplugin</A> <I>plugin</I>, const char* <I>toolName</I>, int <I>inputFlags</I>, <A HREF=#mginputdevicestartfunc>mginputdevicestartfunc</A> <I>startFunc</I>, <A HREF=#mginputdevicestopfunc>mginputdevicestopfunc</A> <I>stopFunc</I>, <A HREF=#mginputdevicesetinputtypefunc>mginputdevicesetinputtypefunc</A> <I>setInputTypeFunc</I>, void* <I>userData</I>, <A HREF=#></A> <I>...</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=IOFUNC><H1>I/O Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgCloseDb><B>mgCloseDb</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgExit><B>mgExit</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgExportDb><B>mgExportDb</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>fileName</I>, const char* <I>formatName</I>, const char* <I>formatVersion</I>, <A HREF=#></A> <I>...</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgfilelocatorfunc>mgfilelocatorfunc</A> <TD><A HREF=#mgExtRefGetLocatorFunc><B>mgExtRefGetLocatorFunc</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgExtRefSetLocatorFunc><B>mgExtRefSetLocatorFunc</B></A> (<A HREF=#mgfilelocatorfunc>mgfilelocatorfunc</A> <I>locatorFunc</I>, void* <I>userData</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetAbsoluteFilename><B>mgGetAbsoluteFilename</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>relFilename</I>, char* <I>absFilename</I>, int <I>maxLen</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetDbOnDesktop><B>mgGetDbOnDesktop</B></A> (const char* <I>fileName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgGetDbVersion><B>mgGetDbVersion</B></A> (const char* <I>fileName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgIsDb><B>mgIsDb</B></A> (const char* <I>fileName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgIsDbModified><B>mgIsDbModified</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgIsDbOnDesktop><B>mgIsDbOnDesktop</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgIsDbUntitled><B>mgIsDbUntitled</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgIsFileOnDesktop><B>mgIsFileOnDesktop</B></A> (const char* <I>fileName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgNewDb><B>mgNewDb</B></A> (const char* <I>fileName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgOpenDb><B>mgOpenDb</B></A> (const char* <I>fileName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSaveAsDb><B>mgSaveAsDb</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>fileName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetDbModified><B>mgSetDbModified</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, <A HREF=#mgbool>mgbool</A> <I>modified</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgWriteDb><B>mgWriteDb</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=MATERIALFUNC><H1>Material Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgDeleteMaterial><B>mgDeleteMaterial</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgDeleteMaterialByName><B>mgDeleteMaterialByName</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>name</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetCurrentMaterial><B>mgGetCurrentMaterial</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetFirstMaterial><B>mgGetFirstMaterial</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetMaterial><B>mgGetMaterial</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgGetMaterialCount><B>mgGetMaterialCount</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetMaterialElem><B>mgGetMaterialElem</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, float* <I>ambientR</I>, float* <I>ambientG</I>, float* <I>ambientB</I>, float* <I>diffuseR</I>, float* <I>diffuseG</I>, float* <I>diffuseB</I>, float* <I>specularR</I>, float* <I>specularG</I>, float* <I>specularB</I>, float* <I>emissiveR</I>, float* <I>emissiveG</I>, float* <I>emissiveB</I>, float* <I>shininess</I>, float* <I>alpha</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetNextMaterial><B>mgGetNextMaterial</B></A> (<A HREF=#mgrec>mgrec*</A> <I>matrec</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgIndexOfMaterial><B>mgIndexOfMaterial</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>name</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgNameOfMaterial><B>mgNameOfMaterial</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgNewMaterial><B>mgNewMaterial</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>name</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgReadMaterialFile><B>mgReadMaterialFile</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>fileName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetCurrentMaterial><B>mgSetCurrentMaterial</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgWriteMaterialFile><B>mgWriteMaterialFile</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>fileName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgWriteMaterialFileVersion><B>mgWriteMaterialFileVersion</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>fileName</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=MEMORYFUNC><H1>Memory Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ></TABLE>
<BR>



<HR>
<A NAME=LIGHTSOURCEFUNC><H1>Light Source Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgDeleteLightSource><B>mgDeleteLightSource</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetCurrentLightSource><B>mgGetCurrentLightSource</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetFirstLightSource><B>mgGetFirstLightSource</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetLightSource><B>mgGetLightSource</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgGetLightSourceCount><B>mgGetLightSourceCount</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetNextLightSource><B>mgGetNextLightSource</B></A> (<A HREF=#mgrec>mgrec*</A> <I>lightSource</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgIndexOfLightSource><B>mgIndexOfLightSource</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, char* <I>name</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgNameOfLightSource><B>mgNameOfLightSource</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgNewLightSource><B>mgNewLightSource</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, char* <I>name</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgReadLightSourceFile><B>mgReadLightSourceFile</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>fileName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetCurrentLightSource><B>mgSetCurrentLightSource</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgWriteLightSourceFile><B>mgWriteLightSourceFile</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>fileName</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=LIGHTPOINTFUNC><H1>Light Point Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgDeleteLightPointAnimation><B>mgDeleteLightPointAnimation</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgDeleteLightPointAppearance><B>mgDeleteLightPointAppearance</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetCurrentLightPointAnimation><B>mgGetCurrentLightPointAnimation</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetCurrentLightPointAppearance><B>mgGetCurrentLightPointAppearance</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetFirstLightPointAnimation><B>mgGetFirstLightPointAnimation</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetFirstLightPointAppearance><B>mgGetFirstLightPointAppearance</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetLightPointAnimation><B>mgGetLightPointAnimation</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgGetLightPointAnimationCount><B>mgGetLightPointAnimationCount</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetLightPointAppearance><B>mgGetLightPointAppearance</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgGetLightPointAppearanceCount><B>mgGetLightPointAppearanceCount</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetNextLightPointAnimation><B>mgGetNextLightPointAnimation</B></A> (<A HREF=#mgrec>mgrec*</A> <I>lightPointAnimation</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetNextLightPointAppearance><B>mgGetNextLightPointAppearance</B></A> (<A HREF=#mgrec>mgrec*</A> <I>lightPointAppearance</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgIndexOfLightPointAnimation><B>mgIndexOfLightPointAnimation</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>name</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgIndexOfLightPointAppearance><B>mgIndexOfLightPointAppearance</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>name</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgLightPointAnimationSequenceGet><B>mgLightPointAnimationSequenceGet</B></A> (<A HREF=#mgrec>mgrec*</A> <I>lpaRec</I>, <A HREF=#mglightpointanimationsequencedata>mglightpointanimationsequencedata</A> <I>sequenceData[]</I>, int <I>arrayLen</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgLightPointAnimationSequenceSet><B>mgLightPointAnimationSequenceSet</B></A> (<A HREF=#mgrec>mgrec*</A> <I>lpaRec</I>, <A HREF=#mglightpointanimationsequencedata>mglightpointanimationsequencedata</A> <I>sequenceData[]</I>, int <I>n</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgNameOfLightPointAnimation><B>mgNameOfLightPointAnimation</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgNameOfLightPointAppearance><B>mgNameOfLightPointAppearance</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgNewLightPointAnimation><B>mgNewLightPointAnimation</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>name</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgNewLightPointAppearance><B>mgNewLightPointAppearance</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>name</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgReadLightPointFile><B>mgReadLightPointFile</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>fileName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetCurrentLightPointAnimation><B>mgSetCurrentLightPointAnimation</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetCurrentLightPointAppearance><B>mgSetCurrentLightPointAppearance</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgWriteLightPointFile><B>mgWriteLightPointFile</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>fileName</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=LINESTYLEFUNC><H1>Line Style Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgDeleteLineStyle><B>mgDeleteLineStyle</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetCurrentLineStyle><B>mgGetCurrentLineStyle</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetFirstLineStyle><B>mgGetFirstLineStyle</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetLineStyle><B>mgGetLineStyle</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgGetLineStyleCount><B>mgGetLineStyleCount</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetNextLineStyle><B>mgGetNextLineStyle</B></A> (<A HREF=#mgrec>mgrec*</A> <I>lightSource</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgNewLineStyle><B>mgNewLineStyle</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetCurrentLineStyle><B>mgSetCurrentLineStyle</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=SHADERFUNC><H1>Shader Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgDeleteShader><B>mgDeleteShader</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgDeleteShaderByName><B>mgDeleteShaderByName</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>name</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetCurrentShader><B>mgGetCurrentShader</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetFirstShader><B>mgGetFirstShader</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetNextShader><B>mgGetNextShader</B></A> (<A HREF=#mgrec>mgrec*</A> <I>shader</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetShader><B>mgGetShader</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgGetShaderCount><B>mgGetShaderCount</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgGetShaderProgramSaveName><B>mgGetShaderProgramSaveName</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>programFilename</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgIndexOfShader><B>mgIndexOfShader</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>name</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgNameOfShader><B>mgNameOfShader</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgNewShader><B>mgNewShader</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>name</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetCurrentShader><B>mgSetCurrentShader</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgShaderAddFragmentProgram><B>mgShaderAddFragmentProgram</B></A> (<A HREF=#mgrec>mgrec*</A> <I>shader</I>, const char* <I>programFileName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgShaderAddVertexProgram><B>mgShaderAddVertexProgram</B></A> (<A HREF=#mgrec>mgrec*</A> <I>shader</I>, const char* <I>programFileName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgShaderDeleteFragmentProgramNth><B>mgShaderDeleteFragmentProgramNth</B></A> (<A HREF=#mgrec>mgrec*</A> <I>shader</I>, int <I>nth</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgShaderDeleteVertexProgramNth><B>mgShaderDeleteVertexProgramNth</B></A> (<A HREF=#mgrec>mgrec*</A> <I>shader</I>, int <I>nth</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgShaderGetFragmentProgramNth><B>mgShaderGetFragmentProgramNth</B></A> (<A HREF=#mgrec>mgrec*</A> <I>shader</I>, int <I>nth</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgfilelocatorfunc>mgfilelocatorfunc</A> <TD><A HREF=#mgShaderGetLocatorFunc><B>mgShaderGetLocatorFunc</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgsavepathtype>mgsavepathtype</A> <TD><A HREF=#mgShaderGetSavePathType><B>mgShaderGetSavePathType</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgShaderGetVertexProgramNth><B>mgShaderGetVertexProgramNth</B></A> (<A HREF=#mgrec>mgrec*</A> <I>shader</I>, int <I>nth</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgShaderSetFragmentProgramNth><B>mgShaderSetFragmentProgramNth</B></A> (<A HREF=#mgrec>mgrec*</A> <I>shader</I>, int <I>nth</I>, const char* <I>programFileName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgShaderSetLocatorFunc><B>mgShaderSetLocatorFunc</B></A> (<A HREF=#mgfilelocatorfunc>mgfilelocatorfunc</A> <I>locatorFunc</I>, void* <I>userData</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgShaderSetSavePathType><B>mgShaderSetSavePathType</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, <A HREF=#mgsavepathtype>mgsavepathtype</A> <I>saveType</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgShaderSetVertexProgramNth><B>mgShaderSetVertexProgramNth</B></A> (<A HREF=#mgrec>mgrec*</A> <I>shader</I>, int <I>nth</I>, const char* <I>programFileName</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=SOUNDFUNC><H1>Sound Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgDeleteSound><B>mgDeleteSound</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetCurrentSound><B>mgGetCurrentSound</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetFirstSound><B>mgGetFirstSound</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetNextSound><B>mgGetNextSound</B></A> (<A HREF=#mgrec>mgrec*</A> <I>sound</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetSound><B>mgGetSound</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgGetSoundCount><B>mgGetSoundCount</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgIndexOfSound><B>mgIndexOfSound</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, char* <I>name</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgNameOfSound><B>mgNameOfSound</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgNewSound><B>mgNewSound</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, char* <I>name</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetCurrentSound><B>mgSetCurrentSound</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgWriteSoundFile><B>mgWriteSoundFile</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, char* <I>fileName</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=STRUCFUNC><H1>Structure Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgAppend><B>mgAppend</B></A> (<A HREF=#mgrec>mgrec*</A> <I>parent</I>, <A HREF=#mgrec>mgrec*</A> <I>child</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgAttach><B>mgAttach</B></A> (<A HREF=#mgrec>mgrec*</A> <I>parent</I>, <A HREF=#mgrec>mgrec*</A> <I>child</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgContainsReadOnly><B>mgContainsReadOnly</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgCountAttrChild><B>mgCountAttrChild</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgCountChild><B>mgCountChild</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgCountNestedChild><B>mgCountNestedChild</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgCountXform><B>mgCountXform</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgDelete><B>mgDelete</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgDeReference><B>mgDeReference</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgDetach><B>mgDetach</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgDuplicate><B>mgDuplicate</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgDuplicateEx><B>mgDuplicateEx</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, unsigned int <I>flags</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgDuplicateToDb><B>mgDuplicateToDb</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgrec>mgrec*</A> <I>toDb</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgDuplicateToDbEx><B>mgDuplicateToDbEx</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgrec>mgrec*</A> <I>toDb</I>, unsigned int <I>flags</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgEvaluateAsBool><B>mgEvaluateAsBool</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, <A HREF=#mgrec>mgrec*</A> <I>parent</I>, <A HREF=#mgrec>mgrec*</A> <I>rec</I>, void* <I>userData</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgreclist>mgreclist</A> <TD><A HREF=#mgFind><B>mgFind</B></A> (<A HREF=#mgrec>mgrec*</A> <I>node</I>, <A HREF=#mgwalkfunc>mgwalkfunc</A> <I>matchFunc</I>, void* <I>userData</I>, unsigned int <I>flags</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgreclist>mgreclist</A> <TD><A HREF=#mgFindEx><B>mgFindEx</B></A> (<A HREF=#mgrec>mgrec*</A> <I>node</I>, <A HREF=#mgmatrix>mgmatrix</A> <I>startMatrix</I>, <A HREF=#mgwalkfunc>mgwalkfunc</A> <I>matchFunc</I>, void* <I>userData</I>, unsigned int <I>flags</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgFreeNodeExpression><B>mgFreeNodeExpression</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetAttrChild><B>mgGetAttrChild</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetChild><B>mgGetChild</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetChildNth><B>mgGetChildNth</B></A> (<A HREF=#mgrec>mgrec*</A> <I>parent</I>, int <I>nth</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetCurrentDb><B>mgGetCurrentDb</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetFirstInstance><B>mgGetFirstInstance</B></A> (<A HREF=#mgrec>mgrec*</A> <I>ref</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetMorphVertex><B>mgGetMorphVertex</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetNestedChild><B>mgGetNestedChild</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetNestedParent><B>mgGetNestedParent</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetNext><B>mgGetNext</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetNextInstance><B>mgGetNextInstance</B></A> (<A HREF=#mgrec>mgrec*</A> <I>inst</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetParent><B>mgGetParent</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetPrevious><B>mgGetPrevious</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetRecByName><B>mgGetRecByName</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>name</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetReference><B>mgGetReference</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetXform><B>mgGetXform</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgxfllcode>mgxfllcode</A> <TD><A HREF=#mgGetXformType><B>mgGetXformType</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgHasXform><B>mgHasXform</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgInsert><B>mgInsert</B></A> (<A HREF=#mgrec>mgrec*</A> <I>sibling</I>, <A HREF=#mgrec>mgrec*</A> <I>node</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgIsFirstInstance><B>mgIsFirstInstance</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgIsFlagOn><B>mgIsFlagOn</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgIsInstance><B>mgIsInstance</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgIsReadOnly><B>mgIsReadOnly</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgIsReference><B>mgIsReference</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgIsRelated><B>mgIsRelated</B></A> (<A HREF=#mgrec>mgrec*</A> <I>parent</I>, <A HREF=#mgrec>mgrec*</A> <I>child</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgIsXformEmpty><B>mgIsXformEmpty</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgIterateRecList><B>mgIterateRecList</B></A> (<A HREF=#mgreclist>mgreclist</A> <I>recList</I>, <A HREF=#mgwalkfunc>mgwalkfunc</A> <I>iterateFunc</I>, void* <I>userData</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgLeastDetail><B>mgLeastDetail</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgLessDetail><B>mgLessDetail</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMoreDetail><B>mgMoreDetail</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMostDetail><B>mgMostDetail</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgnodeexpression>mgnodeexpression</A> <TD><A HREF=#mgNewNodeExpressionCallback><B>mgNewNodeExpressionCallback</B></A> (<A HREF=#mgnodeexpressionfunc>mgnodeexpressionfunc</A> <I>v</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgnodeexpression>mgnodeexpression</A> <TD><A HREF=#mgNewNodeExpressionDouble><B>mgNewNodeExpressionDouble</B></A> (double <I>v</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgnodeexpression>mgnodeexpression</A> <TD><A HREF=#mgNewNodeExpressionGetAtt><B>mgNewNodeExpressionGetAtt</B></A> (<A HREF=#mgcode>mgcode</A> <I>code</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgnodeexpression>mgnodeexpression</A> <TD><A HREF=#mgNewNodeExpressionInteger><B>mgNewNodeExpressionInteger</B></A> (int <I>v</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgnodeexpression>mgnodeexpression</A> <TD><A HREF=#mgNewNodeExpressionOperator><B>mgNewNodeExpressionOperator</B></A> (<A HREF=#mgnodeexpressionoperator>mgnodeexpressionoperator</A> <I>oper</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgNewRec><B>mgNewRec</B></A> (<A HREF=#mgcode>mgcode</A> <I>rcode</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgNewRecDb><B>mgNewRecDb</B></A> (<A HREF=#mgcode>mgcode</A> <I>rcode</I>, <A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgNodeExpressionEvaluateAsBool><B>mgNodeExpressionEvaluateAsBool</B></A> (<A HREF=#mgnodeexpression>mgnodeexpression</A> <I>expressionRoot</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgNodeExpressionLoadFromString><B>mgNodeExpressionLoadFromString</B></A> (const <A HREF=#char >char *</A> <I>expressionString</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgNodeExpressionSetLeft><B>mgNodeExpressionSetLeft</B></A> (<A HREF=#mgnodeexpression>mgnodeexpression</A> <I>expression</I>, <A HREF=#mgnodeexpression>mgnodeexpression</A> <I>left</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgNodeExpressionSetRight><B>mgNodeExpressionSetRight</B></A> (<A HREF=#mgnodeexpression>mgnodeexpression</A> <I>expression</I>, <A HREF=#mgnodeexpression>mgnodeexpression</A> <I>right</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgNodeExpressionSetVariableDouble><B>mgNodeExpressionSetVariableDouble</B></A> (<A HREF=#mgnodeexpression>mgnodeexpression</A> <I>node</I>, const char* <I>variableName</I>, double <I>val</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgNodeExpressionSetVariableInt><B>mgNodeExpressionSetVariableInt</B></A> (<A HREF=#mgnodeexpression>mgnodeexpression</A> <I>node</I>, const char* <I>variableName</I>, int <I>val</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgNodeExpressionSetVariableString><B>mgNodeExpressionSetVariableString</B></A> (<A HREF=#mgnodeexpression>mgnodeexpression</A> <I>node</I>, const char* <I>variableName</I>, const char* <I>val</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgRec2Db><B>mgRec2Db</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgRec2Filename><B>mgRec2Filename</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgReference><B>mgReference</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgrec>mgrec*</A> <I>refRec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgRemove><B>mgRemove</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgSetCurrentDb><B>mgSetCurrentDb</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgUnRemove><B>mgUnRemove</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgValidAttach><B>mgValidAttach</B></A> (<A HREF=#mgcode>mgcode</A> <I>parentCode</I>, <A HREF=#mgcode>mgcode</A> <I>childCode</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgWalk><B>mgWalk</B></A> (<A HREF=#mgrec>mgrec*</A> <I>node</I>, <A HREF=#mgwalkfunc>mgwalkfunc</A> <I>preAction</I>, <A HREF=#mgwalkfunc>mgwalkfunc</A> <I>postAction</I>, void* <I>userData</I>, unsigned int <I>flags</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgWalkEx><B>mgWalkEx</B></A> (<A HREF=#mgrec>mgrec*</A> <I>node</I>, <A HREF=#mgmatrix>mgmatrix</A> <I>startMatrix</I>, <A HREF=#mgwalkfunc>mgwalkfunc</A> <I>preAction</I>, <A HREF=#mgwalkfunc>mgwalkfunc</A> <I>postAction</I>, void* <I>userData</I>, unsigned int <I>flags</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgWalkGetMatrix><B>mgWalkGetMatrix</B></A> (void* <I>userdata</I>, <A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgWalkRecList><B>mgWalkRecList</B></A> (<A HREF=#mgreclist>mgreclist</A> <I>recList</I>, <A HREF=#mgwalkfunc>mgwalkfunc</A> <I>preAction</I>, <A HREF=#mgwalkfunc>mgwalkfunc</A> <I>postAction</I>, void* <I>userData</I>, unsigned int <I>flags</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=SELECTFUNC><H1>Select List Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgAppendRecList><B>mgAppendRecList</B></A> (<A HREF=#mgreclist>mgreclist</A> <I>recList</I>, <A HREF=#mgrec>mgrec*</A> <I>node</I>, <A HREF=#mgmatrix>mgmatrix</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgDeselectAll><B>mgDeselectAll</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgDeselectOne><B>mgDeselectOne</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgFreeRecList><B>mgFreeRecList</B></A> (<A HREF=#mgreclist>mgreclist</A> <I>recList</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#dep_mgselectlist>mgselectlist</A> <TD><A HREF=#mgGetConstructList><B>mgGetConstructList</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetNextRecInList><B>mgGetNextRecInList</B></A> (<A HREF=#mgreclist>mgreclist</A> <I>recList</I>, <A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetNthRecInList><B>mgGetNthRecInList</B></A> (<A HREF=#mgreclist>mgreclist</A> <I>recList</I>, <A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>, int <I>nth</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgGetRecListCount><B>mgGetRecListCount</B></A> (<A HREF=#mgreclist>mgreclist</A> <I>recList</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcode>mgcode</A> <TD><A HREF=#mgGetRecListLevel><B>mgGetRecListLevel</B></A> (<A HREF=#mgreclist>mgreclist</A> <I>recList</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgreclist>mgreclist</A> <TD><A HREF=#mgGetSelectList><B>mgGetSelectList</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgIsRecInList><B>mgIsRecInList</B></A> (<A HREF=#mgreclist>mgreclist</A> <I>recList</I>, <A HREF=#mgrec>mgrec*</A> <I>node</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgIsSelected><B>mgIsSelected</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgIsSelectedEdge><B>mgIsSelectedEdge</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgreclist>mgreclist</A> <TD><A HREF=#mgNewRecList><B>mgNewRecList</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgResetRecList><B>mgResetRecList</B></A> (<A HREF=#mgreclist>mgreclist</A> <I>recList</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgSelectList><B>mgSelectList</B></A> (<A HREF=#mgreclist>mgreclist</A> <I>list</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgSelectOne><B>mgSelectOne</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgSelectOneEdge><B>mgSelectOneEdge</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgSelectOneEx><B>mgSelectOneEx</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, unsigned int <I>flags</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=GEOMETRYFUNC><H1>Geometry Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgBoxContainsBox><B>mgBoxContainsBox</B></A> (const <A HREF=#mgboxd>mgboxd*</A> <I>box1</I>, const <A HREF=#mgboxd>mgboxd*</A> <I>box2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgBoxContainsCoord3d><B>mgBoxContainsCoord3d</B></A> (const <A HREF=#mgboxd>mgboxd*</A> <I>box</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgBoxExpandBox><B>mgBoxExpandBox</B></A> (<A HREF=#mgboxd>mgboxd*</A> <I>boxToExpand</I>, const <A HREF=#mgboxd>mgboxd*</A> <I>expandByBox</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgBoxExpandCoord3d><B>mgBoxExpandCoord3d</B></A> (<A HREF=#mgboxd>mgboxd*</A> <I>box</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>c</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgBoxGetCenter><B>mgBoxGetCenter</B></A> (const <A HREF=#mgboxd>mgboxd*</A> <I>box</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgBoxGetCenterBottom><B>mgBoxGetCenterBottom</B></A> (const <A HREF=#mgboxd>mgboxd*</A> <I>box</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">double <TD><A HREF=#mgBoxGetDiagonalSize><B>mgBoxGetDiagonalSize</B></A> (const <A HREF=#mgboxd>mgboxd*</A> <I>box</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">double <TD><A HREF=#mgBoxGetXSize><B>mgBoxGetXSize</B></A> (const <A HREF=#mgboxd>mgboxd*</A> <I>box</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">double <TD><A HREF=#mgBoxGetYSize><B>mgBoxGetYSize</B></A> (const <A HREF=#mgboxd>mgboxd*</A> <I>box</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">double <TD><A HREF=#mgBoxGetZSize><B>mgBoxGetZSize</B></A> (const <A HREF=#mgboxd>mgboxd*</A> <I>box</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgBoxIntersectsBox><B>mgBoxIntersectsBox</B></A> (const <A HREF=#mgboxd>mgboxd*</A> <I>box1</I>, const <A HREF=#mgboxd>mgboxd*</A> <I>box2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord2d>mgcoord2d</A> <TD><A HREF=#mgCoord2dAdd><B>mgCoord2dAdd</B></A> (const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord1</I>, const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">double <TD><A HREF=#mgCoord2dAngle><B>mgCoord2dAngle</B></A> (const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord1</I>, const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord2d>mgcoord2d</A> <TD><A HREF=#mgCoord2dDivide><B>mgCoord2dDivide</B></A> (const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord</I>, double <I>scalar</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">double <TD><A HREF=#mgCoord2dDot><B>mgCoord2dDot</B></A> (const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord1</I>, const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">double <TD><A HREF=#mgCoord2dLength><B>mgCoord2dLength</B></A> (const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">double <TD><A HREF=#mgCoord2dLengthSquared><B>mgCoord2dLengthSquared</B></A> (const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord2d>mgcoord2d</A> <TD><A HREF=#mgCoord2dLerp><B>mgCoord2dLerp</B></A> (const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord1</I>, const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord2</I>, double <I>amount</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord2d>mgcoord2d</A> <TD><A HREF=#mgCoord2dMultiply><B>mgCoord2dMultiply</B></A> (const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord</I>, double <I>scalar</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord2d>mgcoord2d</A> <TD><A HREF=#mgCoord2dNegate><B>mgCoord2dNegate</B></A> (const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord2d>mgcoord2d</A> <TD><A HREF=#mgCoord2dNegativeOne><B>mgCoord2dNegativeOne</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord2d>mgcoord2d</A> <TD><A HREF=#mgCoord2dNegativeXAxis><B>mgCoord2dNegativeXAxis</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord2d>mgcoord2d</A> <TD><A HREF=#mgCoord2dNegativeYAxis><B>mgCoord2dNegativeYAxis</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord2d>mgcoord2d</A> <TD><A HREF=#mgCoord2dOne><B>mgCoord2dOne</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord2d>mgcoord2d</A> <TD><A HREF=#mgCoord2dOrthoProject><B>mgCoord2dOrthoProject</B></A> (const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord1</I>, const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord2d>mgcoord2d</A> <TD><A HREF=#mgCoord2dReflect><B>mgCoord2dReflect</B></A> (const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord1</I>, const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord2d>mgcoord2d</A> <TD><A HREF=#mgCoord2dReflectX><B>mgCoord2dReflectX</B></A> (const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord2d>mgcoord2d</A> <TD><A HREF=#mgCoord2dReflectY><B>mgCoord2dReflectY</B></A> (const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord2d>mgcoord2d</A> <TD><A HREF=#mgCoord2dRotate90CCW><B>mgCoord2dRotate90CCW</B></A> (const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord2d>mgcoord2d</A> <TD><A HREF=#mgCoord2dRotate90CW><B>mgCoord2dRotate90CW</B></A> (const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord2d>mgcoord2d</A> <TD><A HREF=#mgCoord2dRotateCCW><B>mgCoord2dRotateCCW</B></A> (const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord</I>, double <I>degrees</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord2d>mgcoord2d</A> <TD><A HREF=#mgCoord2dRotateCW><B>mgCoord2dRotateCW</B></A> (const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord</I>, double <I>degrees</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">double <TD><A HREF=#mgCoord2dScalarProject><B>mgCoord2dScalarProject</B></A> (const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord1</I>, const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgCoord2dSetUnitized><B>mgCoord2dSetUnitized</B></A> (<A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord2d>mgcoord2d</A> <TD><A HREF=#mgCoord2dSubtract><B>mgCoord2dSubtract</B></A> (const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord1</I>, const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord2d>mgcoord2d</A> <TD><A HREF=#mgCoord2dUnitize><B>mgCoord2dUnitize</B></A> (const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord2d>mgcoord2d</A> <TD><A HREF=#mgCoord2dVectorProject><B>mgCoord2dVectorProject</B></A> (const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord1</I>, const <A HREF=#mgcoord2d>mgcoord2d*</A> <I>coord2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord2d>mgcoord2d</A> <TD><A HREF=#mgCoord2dXAxis><B>mgCoord2dXAxis</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord2d>mgcoord2d</A> <TD><A HREF=#mgCoord2dYAxis><B>mgCoord2dYAxis</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord2d>mgcoord2d</A> <TD><A HREF=#mgCoord2dZero><B>mgCoord2dZero</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dAdd><B>mgCoord3dAdd</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord1</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgCoord3dAlmostEqual><B>mgCoord3dAlmostEqual</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord1</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord2</I>, double <I>tolerance</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">double <TD><A HREF=#mgCoord3dAngle><B>mgCoord3dAngle</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord1</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dCross><B>mgCoord3dCross</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord1</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">double <TD><A HREF=#mgCoord3dDistance><B>mgCoord3dDistance</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord1</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">double <TD><A HREF=#mgCoord3dDistanceSquared><B>mgCoord3dDistanceSquared</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord1</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dDivide><B>mgCoord3dDivide</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>, double <I>scalar</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">double <TD><A HREF=#mgCoord3dDot><B>mgCoord3dDot</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord1</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgCoord3dEqual><B>mgCoord3dEqual</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord1</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">double <TD><A HREF=#mgCoord3dLength><B>mgCoord3dLength</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">double <TD><A HREF=#mgCoord3dLengthSquared><B>mgCoord3dLengthSquared</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dLerp><B>mgCoord3dLerp</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord1</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord2</I>, double <I>amount</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dMoveAlongVectord><B>mgCoord3dMoveAlongVectord</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>, const <A HREF=#mgvectord>mgvectord*</A> <I>vec</I>, double <I>distance</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dMoveAlongVectorf><B>mgCoord3dMoveAlongVectorf</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>, const <A HREF=#mgvectorf>mgvectorf*</A> <I>vec</I>, float <I>distance</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dMultiply><B>mgCoord3dMultiply</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>, double <I>scalar</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dNegate><B>mgCoord3dNegate</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dNegativeOne><B>mgCoord3dNegativeOne</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dNegativeXAxis><B>mgCoord3dNegativeXAxis</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dNegativeYAxis><B>mgCoord3dNegativeYAxis</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dNegativeZAxis><B>mgCoord3dNegativeZAxis</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dOne><B>mgCoord3dOne</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dOrthoProject><B>mgCoord3dOrthoProject</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord1</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dPitchDown><B>mgCoord3dPitchDown</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>, double <I>degrees</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dPitchDown90><B>mgCoord3dPitchDown90</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dPitchUp><B>mgCoord3dPitchUp</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>, double <I>degrees</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dPitchUp90><B>mgCoord3dPitchUp90</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dProjectOnPlane><B>mgCoord3dProjectOnPlane</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>, const <A HREF=#mgplaned>mgplaned*</A> <I>plane</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dReflect><B>mgCoord3dReflect</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord1</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dReflectX><B>mgCoord3dReflectX</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dReflectY><B>mgCoord3dReflectY</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dReflectZ><B>mgCoord3dReflectZ</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dRollLeft><B>mgCoord3dRollLeft</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>, double <I>degrees</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dRollLeft90><B>mgCoord3dRollLeft90</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dRollRight><B>mgCoord3dRollRight</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>, double <I>degrees</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dRollRight90><B>mgCoord3dRollRight90</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">double <TD><A HREF=#mgCoord3dScalarProject><B>mgCoord3dScalarProject</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord1</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgCoord3dSetUnitized><B>mgCoord3dSetUnitized</B></A> (<A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dSubtract><B>mgCoord3dSubtract</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord1</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3f>mgcoord3f</A> <TD><A HREF=#mgCoord3dToCoord3f><B>mgCoord3dToCoord3f</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectord>mgvectord</A> <TD><A HREF=#mgCoord3dToVectord><B>mgCoord3dToVectord</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dTransform><B>mgCoord3dTransform</B></A> (const <A HREF=#mgmatrix>mgmatrix</A> <I>matrix</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dUnitize><B>mgCoord3dUnitize</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dVectorProject><B>mgCoord3dVectorProject</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord1</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dXAxis><B>mgCoord3dXAxis</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dYawLeft><B>mgCoord3dYawLeft</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>, double <I>degrees</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dYawLeft90><B>mgCoord3dYawLeft90</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dYawRight><B>mgCoord3dYawRight</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>, double <I>degrees</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dYawRight90><B>mgCoord3dYawRight90</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dYAxis><B>mgCoord3dYAxis</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dZAxis><B>mgCoord3dZAxis</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3dZero><B>mgCoord3dZero</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3fToCoord3d><B>mgCoord3fToCoord3d</B></A> (const <A HREF=#mgcoord3f>mgcoord3f*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgCoord3fTransform><B>mgCoord3fTransform</B></A> (const <A HREF=#mgmatrix>mgmatrix</A> <I>matrix</I>, const <A HREF=#mgcoord3f>mgcoord3f*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgreclist>mgreclist</A> <TD><A HREF=#mgGetTriangleList><B>mgGetTriangleList</B></A> (<A HREF=#mgrec>mgrec*</A> <I>poly</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgboxd>mgboxd</A> <TD><A HREF=#mgMakeBox><B>mgMakeBox</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>min</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>max</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord2d>mgcoord2d</A> <TD><A HREF=#mgMakeCoord2d><B>mgMakeCoord2d</B></A> (double <I>x</I>, double <I>y</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord2i>mgcoord2i</A> <TD><A HREF=#mgMakeCoord2i><B>mgMakeCoord2i</B></A> (int <I>x</I>, int <I>y</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgMakeCoord3d><B>mgMakeCoord3d</B></A> (double <I>x</I>, double <I>y</I>, double <I>z</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3f>mgcoord3f</A> <TD><A HREF=#mgMakeCoord3f><B>mgMakeCoord3f</B></A> (float <I>x</I>, float <I>y</I>, float <I>z</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mglined>mglined</A> <TD><A HREF=#mgMakeLine><B>mgMakeLine</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord1</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgplaned>mgplaned</A> <TD><A HREF=#mgMakePlaned><B>mgMakePlaned</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>point</I>, const <A HREF=#mgvectord>mgvectord*</A> <I>normal</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectord>mgvectord</A> <TD><A HREF=#mgMakeUnitVectord><B>mgMakeUnitVectord</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord1</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectord>mgvectord</A> <TD><A HREF=#mgMakeVectord><B>mgMakeVectord</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord1</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgReversePoly><B>mgReversePoly</B></A> (<A HREF=#mgrec>mgrec*</A> <I>poly</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectord>mgvectord</A> <TD><A HREF=#mgVectordCross><B>mgVectordCross</B></A> (const <A HREF=#mgvectord>mgvectord*</A> <I>vector1</I>, const <A HREF=#mgvectord>mgvectord*</A> <I>vector2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">double <TD><A HREF=#mgVectordDot><B>mgVectordDot</B></A> (const <A HREF=#mgvectord>mgvectord*</A> <I>vector1</I>, const <A HREF=#mgvectord>mgvectord*</A> <I>vector2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgVectordEqual><B>mgVectordEqual</B></A> (const <A HREF=#mgvectord>mgvectord*</A> <I>vector1</I>, const <A HREF=#mgvectord>mgvectord*</A> <I>vector2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectord>mgvectord</A> <TD><A HREF=#mgVectordFromLine><B>mgVectordFromLine</B></A> (const <A HREF=#mglined>mglined*</A> <I>line</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectord>mgvectord</A> <TD><A HREF=#mgVectordLerp><B>mgVectordLerp</B></A> (const <A HREF=#mgvectord>mgvectord*</A> <I>vector1</I>, const <A HREF=#mgvectord>mgvectord*</A> <I>vector2</I>, double <I>amount</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectord>mgvectord</A> <TD><A HREF=#mgVectordNegate><B>mgVectordNegate</B></A> (const <A HREF=#mgvectord>mgvectord*</A> <I>vector</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectord>mgvectord</A> <TD><A HREF=#mgVectordNegativeXAxis><B>mgVectordNegativeXAxis</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectord>mgvectord</A> <TD><A HREF=#mgVectordNegativeYAxis><B>mgVectordNegativeYAxis</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectord>mgvectord</A> <TD><A HREF=#mgVectordNegativeZAxis><B>mgVectordNegativeZAxis</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgVectordSetUnitized><B>mgVectordSetUnitized</B></A> (<A HREF=#mgvectord>mgvectord*</A> <I>vec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgVectordToCoord3d><B>mgVectordToCoord3d</B></A> (const <A HREF=#mgvectord>mgvectord*</A> <I>vec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectorf>mgvectorf</A> <TD><A HREF=#mgVectordToVectorf><B>mgVectordToVectorf</B></A> (const <A HREF=#mgvectord>mgvectord*</A> <I>vec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectord>mgvectord</A> <TD><A HREF=#mgVectordTransform><B>mgVectordTransform</B></A> (const <A HREF=#mgmatrix>mgmatrix</A> <I>matrix</I>, const <A HREF=#mgvectord>mgvectord*</A> <I>vec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectord>mgvectord</A> <TD><A HREF=#mgVectordUnitize><B>mgVectordUnitize</B></A> (const <A HREF=#mgvectord>mgvectord*</A> <I>vec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectord>mgvectord</A> <TD><A HREF=#mgVectordXAxis><B>mgVectordXAxis</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectord>mgvectord</A> <TD><A HREF=#mgVectordYAxis><B>mgVectordYAxis</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectord>mgvectord</A> <TD><A HREF=#mgVectordZAxis><B>mgVectordZAxis</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectord>mgvectord</A> <TD><A HREF=#mgVectordZero><B>mgVectordZero</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectorf>mgvectorf</A> <TD><A HREF=#mgVectorfCross><B>mgVectorfCross</B></A> (const <A HREF=#mgvectorf>mgvectorf*</A> <I>vector1</I>, const <A HREF=#mgvectorf>mgvectorf*</A> <I>vector2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">float <TD><A HREF=#mgVectorfDot><B>mgVectorfDot</B></A> (const <A HREF=#mgvectorf>mgvectorf*</A> <I>vector1</I>, const <A HREF=#mgvectorf>mgvectorf*</A> <I>vector2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgVectorfEqual><B>mgVectorfEqual</B></A> (const <A HREF=#mgvectorf>mgvectorf*</A> <I>vector1</I>, const <A HREF=#mgvectorf>mgvectorf*</A> <I>vector2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectorf>mgvectorf</A> <TD><A HREF=#mgVectorfLerp><B>mgVectorfLerp</B></A> (const <A HREF=#mgvectorf>mgvectorf*</A> <I>vector1</I>, const <A HREF=#mgvectorf>mgvectorf*</A> <I>vector2</I>, double <I>amount</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectorf>mgvectorf</A> <TD><A HREF=#mgVectorfNegate><B>mgVectorfNegate</B></A> (const <A HREF=#mgvectorf>mgvectorf*</A> <I>vector</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectorf>mgvectorf</A> <TD><A HREF=#mgVectorfNegativeXAxis><B>mgVectorfNegativeXAxis</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectorf>mgvectorf</A> <TD><A HREF=#mgVectorfNegativeYAxis><B>mgVectorfNegativeYAxis</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectorf>mgvectorf</A> <TD><A HREF=#mgVectorfNegativeZAxis><B>mgVectorfNegativeZAxis</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgVectorfSetUnitized><B>mgVectorfSetUnitized</B></A> (<A HREF=#mgvectorf>mgvectorf*</A> <I>vec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectord>mgvectord</A> <TD><A HREF=#mgVectorfToVectord><B>mgVectorfToVectord</B></A> (const <A HREF=#mgvectorf>mgvectorf*</A> <I>vec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectorf>mgvectorf</A> <TD><A HREF=#mgVectorfTransform><B>mgVectorfTransform</B></A> (const <A HREF=#mgmatrix>mgmatrix</A> <I>matrix</I>, const <A HREF=#mgvectorf>mgvectorf*</A> <I>vec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectorf>mgvectorf</A> <TD><A HREF=#mgVectorfUnitize><B>mgVectorfUnitize</B></A> (const <A HREF=#mgvectorf>mgvectorf*</A> <I>vec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectorf>mgvectorf</A> <TD><A HREF=#mgVectorfXAxis><B>mgVectorfXAxis</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectorf>mgvectorf</A> <TD><A HREF=#mgVectorfYAxis><B>mgVectorfYAxis</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectorf>mgvectorf</A> <TD><A HREF=#mgVectorfZAxis><B>mgVectorfZAxis</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectorf>mgvectorf</A> <TD><A HREF=#mgVectorfZero><B>mgVectorfZero</B></A> (void) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=MATRIXFUNC><H1>Matrix Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgFreeMatrix><B>mgFreeMatrix</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgMatrixCompose><B>mgMatrixCompose</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>xAxis</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>yAxis</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>zAxis</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>translation</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixCopy><B>mgMatrixCopy</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>dstMatrix</I>, const <A HREF=#mgmatrix>mgmatrix</A> <I>srcMatrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixEqual><B>mgMatrixEqual</B></A> (const <A HREF=#mgmatrix>mgmatrix</A> <I>matrixA</I>, const <A HREF=#mgmatrix>mgmatrix</A> <I>matrixB</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgMatrixFormNormal><B>mgMatrixFormNormal</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>, const <A HREF=#mgmatrix>mgmatrix</A> <I>geomMatrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgMatrixFormPitchDown90><B>mgMatrixFormPitchDown90</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgMatrixFormPitchUp90><B>mgMatrixFormPitchUp90</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixFormQuadToQuad><B>mgMatrixFormQuadToQuad</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>from1</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>from2</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>from3</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>from4</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>to1</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>to2</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>to3</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>to4</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgMatrixFormReflect><B>mgMatrixFormReflect</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgMatrixFormReflectX><B>mgMatrixFormReflectX</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgMatrixFormReflectY><B>mgMatrixFormReflectY</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgMatrixFormReflectZ><B>mgMatrixFormReflectZ</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgMatrixFormRollLeft90><B>mgMatrixFormRollLeft90</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgMatrixFormRollRight90><B>mgMatrixFormRollRight90</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixFormRotate><B>mgMatrixFormRotate</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>, double <I>theta</I>, double <I>a</I>, double <I>b</I>, double <I>c</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixFormRotateX><B>mgMatrixFormRotateX</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>, double <I>theta</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixFormRotateY><B>mgMatrixFormRotateY</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>, double <I>theta</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixFormRotateZ><B>mgMatrixFormRotateZ</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>, double <I>theta</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixFormScale><B>mgMatrixFormScale</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>, double <I>x</I>, double <I>y</I>, double <I>z</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixFormTranslate><B>mgMatrixFormTranslate</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>, double <I>x</I>, double <I>y</I>, double <I>z</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixFormXYZToUV><B>mgMatrixFormXYZToUV</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>, <A HREF=#mgrec>mgrec*</A> <I>poly</I>, int <I>layer</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgMatrixFormYawLeft90><B>mgMatrixFormYawLeft90</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgMatrixFormYawRight90><B>mgMatrixFormYawRight90</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgMatrixGetTranslation><B>mgMatrixGetTranslation</B></A> (const <A HREF=#mgmatrix>mgmatrix</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgMatrixGetXAxis><B>mgMatrixGetXAxis</B></A> (const <A HREF=#mgmatrix>mgmatrix</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgMatrixGetYAxis><B>mgMatrixGetYAxis</B></A> (const <A HREF=#mgmatrix>mgmatrix</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgMatrixGetZAxis><B>mgMatrixGetZAxis</B></A> (const <A HREF=#mgmatrix>mgmatrix</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixIdentity><B>mgMatrixIdentity</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixInvert><B>mgMatrixInvert</B></A> (const <A HREF=#mgmatrix>mgmatrix</A> <I>matrix</I>, <A HREF=#mgmatrix>mgmatrix*</A> <I>resultMatrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixIsIdentity><B>mgMatrixIsIdentity</B></A> (const <A HREF=#mgmatrix>mgmatrix</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixMultiply><B>mgMatrixMultiply</B></A> (const <A HREF=#mgmatrix>mgmatrix</A> <I>matrixA</I>, const <A HREF=#mgmatrix>mgmatrix</A> <I>matrixB</I>, <A HREF=#mgmatrix>mgmatrix*</A> <I>resultMatrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgMatrixPitchDown90><B>mgMatrixPitchDown90</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgMatrixPitchUp90><B>mgMatrixPitchUp90</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgMatrixReflect><B>mgMatrixReflect</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgMatrixReflectX><B>mgMatrixReflectX</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgMatrixReflectY><B>mgMatrixReflectY</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgMatrixReflectZ><B>mgMatrixReflectZ</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgMatrixRollLeft90><B>mgMatrixRollLeft90</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgMatrixRollRight90><B>mgMatrixRollRight90</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixRotateX><B>mgMatrixRotateX</B></A> (const <A HREF=#mgmatrix>mgmatrix</A> <I>matrix</I>, double <I>theta</I>, <A HREF=#mgmatrix>mgmatrix*</A> <I>resultMatrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixRotateY><B>mgMatrixRotateY</B></A> (const <A HREF=#mgmatrix>mgmatrix</A> <I>matrix</I>, double <I>theta</I>, <A HREF=#mgmatrix>mgmatrix*</A> <I>resultMatrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixRotateZ><B>mgMatrixRotateZ</B></A> (const <A HREF=#mgmatrix>mgmatrix</A> <I>matrix</I>, double <I>theta</I>, <A HREF=#mgmatrix>mgmatrix*</A> <I>resultMatrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixScale><B>mgMatrixScale</B></A> (const <A HREF=#mgmatrix>mgmatrix</A> <I>matrix</I>, double <I>x</I>, double <I>y</I>, double <I>z</I>, <A HREF=#mgmatrix>mgmatrix*</A> <I>resultMatrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgMatrixSetTranslation><B>mgMatrixSetTranslation</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgMatrixSetXAxis><B>mgMatrixSetXAxis</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgMatrixSetYAxis><B>mgMatrixSetYAxis</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgMatrixSetZAxis><B>mgMatrixSetZAxis</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixTranslate><B>mgMatrixTranslate</B></A> (const <A HREF=#mgmatrix>mgmatrix</A> <I>matrix</I>, double <I>x</I>, double <I>y</I>, double <I>z</I>, <A HREF=#mgmatrix>mgmatrix*</A> <I>resultMatrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgMatrixTranspose><B>mgMatrixTranspose</B></A> (const <A HREF=#mgmatrix>mgmatrix</A> <I>matrix</I>, <A HREF=#mgmatrix>mgmatrix*</A> <I>resultMatrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgMatrixYawLeft90><B>mgMatrixYawLeft90</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgMatrixYawRight90><B>mgMatrixYawRight90</B></A> (<A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgmatrix>mgmatrix*</A> <TD><A HREF=#mgNewMatrix><B>mgNewMatrix</B></A> (void) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=MATRIXSTACKFUNC><H1>Matrix Stack Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgFreeMatrixStack><B>mgFreeMatrixStack</B></A> (<A HREF=#mgmatrixstack>mgmatrixstack</A> <I>matrixStack</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixStackGetMatrix><B>mgMatrixStackGetMatrix</B></A> (const <A HREF=#mgmatrixstack>mgmatrixstack</A> <I>matrixStack</I>, <A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixStackIsIdentity><B>mgMatrixStackIsIdentity</B></A> (const <A HREF=#mgmatrixstack>mgmatrixstack</A> <I>matrixStack</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixStackLoadIdentity><B>mgMatrixStackLoadIdentity</B></A> (<A HREF=#mgmatrixstack>mgmatrixstack</A> <I>matrixStack</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixStackLoadMatrix><B>mgMatrixStackLoadMatrix</B></A> (<A HREF=#mgmatrixstack>mgmatrixstack</A> <I>matrixStack</I>, const <A HREF=#mgmatrix>mgmatrix</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixStackMultiply><B>mgMatrixStackMultiply</B></A> (<A HREF=#mgmatrixstack>mgmatrixstack</A> <I>matrixStack</I>, const <A HREF=#mgmatrix>mgmatrix</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixStackPop><B>mgMatrixStackPop</B></A> (<A HREF=#mgmatrixstack>mgmatrixstack</A> <I>matrixStack</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixStackPush><B>mgMatrixStackPush</B></A> (<A HREF=#mgmatrixstack>mgmatrixstack</A> <I>matrixStack</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixStackRotate><B>mgMatrixStackRotate</B></A> (<A HREF=#mgmatrixstack>mgmatrixstack</A> <I>matrixStack</I>, double <I>theta</I>, double <I>a</I>, double <I>b</I>, double <I>c</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixStackRotateX><B>mgMatrixStackRotateX</B></A> (<A HREF=#mgmatrixstack>mgmatrixstack</A> <I>matrixStack</I>, double <I>theta</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixStackRotateY><B>mgMatrixStackRotateY</B></A> (<A HREF=#mgmatrixstack>mgmatrixstack</A> <I>matrixStack</I>, double <I>theta</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixStackRotateZ><B>mgMatrixStackRotateZ</B></A> (<A HREF=#mgmatrixstack>mgmatrixstack</A> <I>matrixStack</I>, double <I>theta</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixStackScale><B>mgMatrixStackScale</B></A> (<A HREF=#mgmatrixstack>mgmatrixstack</A> <I>matrixStack</I>, double <I>x</I>, double <I>y</I>, double <I>z</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgMatrixStackTransformCoord><B>mgMatrixStackTransformCoord</B></A> (const <A HREF=#mgmatrixstack>mgmatrixstack</A> <I>matrixStack</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgvectord>mgvectord</A> <TD><A HREF=#mgMatrixStackTransformVector><B>mgMatrixStackTransformVector</B></A> (const <A HREF=#mgmatrixstack>mgmatrixstack</A> <I>matrixStack</I>, const <A HREF=#mgvectord>mgvectord*</A> <I>vec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMatrixStackTranslate><B>mgMatrixStackTranslate</B></A> (<A HREF=#mgmatrixstack>mgmatrixstack</A> <I>matrixStack</I>, double <I>x</I>, double <I>y</I>, double <I>z</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgmatrixstack>mgmatrixstack</A> <TD><A HREF=#mgNewMatrixStack><B>mgNewMatrixStack</B></A> (void) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=PROJECTIONFUNC><H1>Projection Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgFreeProjection><B>mgFreeProjection</B></A> (<A HREF=#mgprojection>mgprojection</A> <I>projection</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgImageToXYZMatrix><B>mgImageToXYZMatrix</B></A> (<A HREF=#mgrec>mgrec*</A> <I>imgRec</I>, <A HREF=#mgimagegeoinfo>mgimagegeoinfo</A> <I>geoinfo</I>, <A HREF=#mgrec>mgrec*</A> <I>db</I>, <A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgprojection>mgprojection</A> <TD><A HREF=#mgNewProjection><B>mgNewProjection</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcoord3d>mgcoord3d</A> <TD><A HREF=#mgProject><B>mgProject</B></A> (const <A HREF=#mgprojcoord>mgprojcoord*</A> <I>coord</I>, <A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgProjectionConvertLLEtoXYZ><B>mgProjectionConvertLLEtoXYZ</B></A> (<A HREF=#mgprojection>mgprojection</A> <I>projection</I>, const <A HREF=#mgprojcoord>mgprojcoord*</A> <I>lleCoord</I>, <A HREF=#mgcoord3d>mgcoord3d*</A> <I>xyzCoord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgProjectionConvertXYZtoLLE><B>mgProjectionConvertXYZtoLLE</B></A> (<A HREF=#mgprojection>mgprojection</A> <I>projection</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>xyzCoord</I>, <A HREF=#mgprojcoord>mgprojcoord*</A> <I>lleCoord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgprojcoord>mgprojcoord</A> <TD><A HREF=#mgUnproject><B>mgUnproject</B></A> (const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>, <A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=RESOURCEFUNC><H1>Resource Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcursorhandle>mgcursorhandle</A> <TD><A HREF=#mgGetCursorHandle><B>mgGetCursorHandle</B></A> (<A HREF=#mgcursor>mgcursor</A> <I>cursor</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgpixmaphandle>mgpixmaphandle</A> <TD><A HREF=#mgGetPixmapHandle><B>mgGetPixmapHandle</B></A> (<A HREF=#mgpixmap>mgpixmap</A> <I>pixmap</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgresource>mgresource</A> <TD><A HREF=#mgLoadResource><B>mgLoadResource</B></A> (<A HREF=#mgmodulehandle>mgmodulehandle</A> <I>moduleHandle</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcursor>mgcursor</A> <TD><A HREF=#mgResourceGetCursor><B>mgResourceGetCursor</B></A> (<A HREF=#mgresource>mgresource</A> <I>resource</I>, <A HREF=#mgcursorid>mgcursorid</A> <I>cursorId</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mggui>mggui</A> <TD><A HREF=#mgResourceGetDialog><B>mgResourceGetDialog</B></A> (<A HREF=#mggui>mggui</A> <I>gui</I>, <A HREF=#mgresource>mgresource</A> <I>resource</I>, <A HREF=#mgdialogid>mgdialogid</A> <I>dialogId</I>, unsigned int <I>callbackMask</I>, <A HREF=#mgdialogfunc>mgdialogfunc</A> <I>dialogFunc</I>, void* <I>userData</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgpixmap>mgpixmap</A> <TD><A HREF=#mgResourceGetPixmap><B>mgResourceGetPixmap</B></A> (<A HREF=#mgresource>mgresource</A> <I>resource</I>, <A HREF=#mgpixmapid>mgpixmapid</A> <I>pixmapId</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgResourceGetString><B>mgResourceGetString</B></A> (<A HREF=#mgresource>mgresource</A> <I>resource</I>, <A HREF=#mgstringid>mgstringid</A> <I>stringId</I>, char* <I>buf</I>, int <I>maxLen</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgResourceModalDialog><B>mgResourceModalDialog</B></A> (<A HREF=#mggui>mggui</A> <I>gui</I>, <A HREF=#mgresource>mgresource</A> <I>resource</I>, <A HREF=#mgdialogid>mgdialogid</A> <I>dialogId</I>, unsigned int <I>callbackMask</I>, <A HREF=#mgdialogfunc>mgdialogfunc</A> <I>dialogFunc</I>, void* <I>userData</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgSetCursor><B>mgSetCursor</B></A> (<A HREF=#mgcursor>mgcursor</A> <I>cursor</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgUnloadResource><B>mgUnloadResource</B></A> (<A HREF=#mgresource>mgresource</A> <I>resource</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=DIALOGFUNC><H1>Dialog Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgDestroyDialog><B>mgDestroyDialog</B></A> (<A HREF=#mggui>mggui</A> <I>dialog</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgDestroyDialogCallback><B>mgDestroyDialogCallback</B></A> (<A HREF=#mggui>mggui</A> <I>gui</I>, <A HREF=#mgcontrolid>mgcontrolid</A> <I>controlId</I>, <A HREF=#mgguicallbackreason>mgguicallbackreason</A> <I>callbackReason</I>, void* <I>userData</I>, void* <I>callData</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgDialogSetAttribute><B>mgDialogSetAttribute</B></A> (<A HREF=#mggui>mggui</A> <I>dialog</I>, <A HREF=#mgdialogattribute>mgdialogattribute</A> <I>dialogAttr</I>, int <I>attrValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgDialogSubclass><B>mgDialogSubclass</B></A> (<A HREF=#mggui>mggui</A> <I>gui</I>, <A HREF=#mgguiwindowfunc>mgguiwindowfunc</A> <I>dialogProc</I>, void* <I>userData</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgguihandle>mgguihandle</A> <TD><A HREF=#mgGetGuiHandle><B>mgGetGuiHandle</B></A> (<A HREF=#mggui>mggui</A> <I>gui</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgGetTitle><B>mgGetTitle</B></A> (<A HREF=#mggui>mggui</A> <I>dialog</I>, char* <I>string</I>, int <I>maxLen</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgHideDialog><B>mgHideDialog</B></A> (<A HREF=#mggui>mggui</A> <I>dialog</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgHideDialogCallback><B>mgHideDialogCallback</B></A> (<A HREF=#mggui>mggui</A> <I>gui</I>, <A HREF=#mgcontrolid>mgcontrolid</A> <I>controlId</I>, <A HREF=#mgguicallbackreason>mgguicallbackreason</A> <I>callbackReason</I>, void* <I>userData</I>, void* <I>callData</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgMessageDialog><B>mgMessageDialog</B></A> (<A HREF=#mggui>mggui</A> <I>parent</I>, const char* <I>title</I>, const char* <I>messageText</I>, unsigned int <I>flags</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgPromptDialogColor><B>mgPromptDialogColor</B></A> (<A HREF=#mggui>mggui</A> <I>parent</I>, short <I>inR</I>, short <I>inG</I>, short <I>inB</I>, short* <I>outR</I>, short* <I>outG</I>, short* <I>outB</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgPromptDialogDouble><B>mgPromptDialogDouble</B></A> (<A HREF=#mggui>mggui</A> <I>parent</I>, const char* <I>messageText</I>, double* <I>value</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgPromptDialogFile><B>mgPromptDialogFile</B></A> (<A HREF=#mggui>mggui</A> <I>parent</I>, int <I>mode</I>, int* <I>numFiles</I>, <A HREF=#mgstringlist>mgstringlist*</A> <I>fileList</I>, <A HREF=#></A> <I>...</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgPromptDialogFloat><B>mgPromptDialogFloat</B></A> (<A HREF=#mggui>mggui</A> <I>parent</I>, const char* <I>messageText</I>, float* <I>value</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgPromptDialogFolder><B>mgPromptDialogFolder</B></A> (<A HREF=#mggui>mggui</A> <I>parent</I>, const char* <I>title</I>, const char* <I>initialFolderName</I>, char** <I>selectedFolderName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgPromptDialogInteger><B>mgPromptDialogInteger</B></A> (<A HREF=#mggui>mggui</A> <I>parent</I>, const char* <I>messageText</I>, int* <I>value</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgPromptDialogString><B>mgPromptDialogString</B></A> (<A HREF=#mggui>mggui</A> <I>parent</I>, int <I>numColumns</I>, const char* <I>messageText</I>, char* <I>value</I>, int <I>maxLen</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgPromptDialogTexture><B>mgPromptDialogTexture</B></A> (<A HREF=#mggui>mggui</A> <I>parent</I>, int <I>mode</I>, int* <I>numFiles</I>, <A HREF=#mgstringlist>mgstringlist*</A> <I>fileList</I>, <A HREF=#></A> <I>...</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgRefreshControl><B>mgRefreshControl</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgRefreshDialog><B>mgRefreshDialog</B></A> (<A HREF=#mggui>mggui</A> <I>gui</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgRefreshDialogCallback><B>mgRefreshDialogCallback</B></A> (<A HREF=#mggui>mggui</A> <I>gui</I>, <A HREF=#mgcontrolid>mgcontrolid</A> <I>controlId</I>, <A HREF=#mgguicallbackreason>mgguicallbackreason</A> <I>callbackReason</I>, void* <I>userData</I>, void* <I>callData</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgSetTitle><B>mgSetTitle</B></A> (<A HREF=#mggui>mggui</A> <I>dialog</I>, const char* <I>string</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgShowDialog><B>mgShowDialog</B></A> (<A HREF=#mggui>mggui</A> <I>dialog</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgShowPalette><B>mgShowPalette</B></A> (<A HREF=#mgpaletteid>mgpaletteid</A> <I>paletteId</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=GENERALCONTROLFUNC><H1>General Controls</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgClearCaption><B>mgClearCaption</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgControlSetAttribute><B>mgControlSetAttribute</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, <A HREF=#mgcontrolattribute>mgcontrolattribute</A> <I>controlAttr</I>, int <I>attrValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgControlSubclass><B>mgControlSubclass</B></A> (<A HREF=#mggui>mggui</A> <I>gui</I>, <A HREF=#mgguiwindowfunc>mgguiwindowfunc</A> <I>windowProc</I>, void* <I>userData</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mggui>mggui</A> <TD><A HREF=#mgFindGuiById><B>mgFindGuiById</B></A> (<A HREF=#mggui>mggui</A> <I>gui</I>, <A HREF=#mgcontrolid>mgcontrolid</A> <I>controlId</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgGetCaption><B>mgGetCaption</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, char* <I>string</I>, int <I>maxLen</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgGuiDeleteProperty><B>mgGuiDeleteProperty</B></A> (<A HREF=#mggui>mggui</A> <I>gui</I>, const <A HREF=#mgpropertyname>mgpropertyname</A> <I>propName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcontrolid>mgcontrolid</A> <TD><A HREF=#mgGuiGetId><B>mgGuiGetId</B></A> (<A HREF=#mggui>mggui</A> <I>gui</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgGuiGetPos><B>mgGuiGetPos</B></A> (<A HREF=#mggui>mggui</A> <I>gui</I>, int* <I>left</I>, int* <I>top</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgpropertyvalue>mgpropertyvalue</A> <TD><A HREF=#mgGuiGetProperty><B>mgGuiGetProperty</B></A> (<A HREF=#mggui>mggui</A> <I>gui</I>, const <A HREF=#mgpropertyname>mgpropertyname</A> <I>propName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgGuiGetSize><B>mgGuiGetSize</B></A> (<A HREF=#mggui>mggui</A> <I>gui</I>, int* <I>width</I>, int* <I>height</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgGuiGetViewSize><B>mgGuiGetViewSize</B></A> (<A HREF=#mggui>mggui</A> <I>gui</I>, int* <I>width</I>, int* <I>height</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGuiPutProperty><B>mgGuiPutProperty</B></A> (<A HREF=#mggui>mggui</A> <I>gui</I>, const <A HREF=#mgpropertyname>mgpropertyname</A> <I>propName</I>, <A HREF=#mgpropertyvalue>mgpropertyvalue</A> <I>propValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgGuiSetFixedFont><B>mgGuiSetFixedFont</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgGuiSetPos><B>mgGuiSetPos</B></A> (<A HREF=#mggui>mggui</A> <I>gui</I>, int <I>left</I>, int <I>top</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgGuiSetSize><B>mgGuiSetSize</B></A> (<A HREF=#mggui>mggui</A> <I>gui</I>, int <I>width</I>, int <I>height</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgIsEnabled><B>mgIsEnabled</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgIsVisible><B>mgIsVisible</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgSetCaption><B>mgSetCaption</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, const char* <I>string</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgSetEnabled><B>mgSetEnabled</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, <A HREF=#mgbool>mgbool</A> <I>enabled</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetFocus><B>mgSetFocus</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgSetGuiCallback><B>mgSetGuiCallback</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, unsigned int <I>callbackMask</I>, <A HREF=#mgguifunc>mgguifunc</A> <I>callback</I>, void* <I>userData</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgSetPixmap><B>mgSetPixmap</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, <A HREF=#mgpixmap>mgpixmap</A> <I>pixmap</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgSetVisible><B>mgSetVisible</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, <A HREF=#mgbool>mgbool</A> <I>visible</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=TEXTCONTROLFUNC><H1>Text Controls</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgTextAppendString><B>mgTextAppendString</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, const char* <I>string</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgTextClear><B>mgTextClear</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgTextGetDMS><B>mgTextGetDMS</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, double* <I>dmsVal</I>, const char* <I>fmtString</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgTextGetDouble><B>mgTextGetDouble</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, double* <I>doubleVal</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgTextGetFloat><B>mgTextGetFloat</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, float* <I>floatVal</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgTextGetInteger><B>mgTextGetInteger</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, int* <I>intVal</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgTextGetSelection><B>mgTextGetSelection</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, char* <I>string</I>, int <I>maxLen</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgTextGetSelectionRange><B>mgTextGetSelectionRange</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, int* <I>start</I>, int* <I>end</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgTextGetString><B>mgTextGetString</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, char* <I>string</I>, int <I>maxLen</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgTextSelectAll><B>mgTextSelectAll</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgTextSelectRange><B>mgTextSelectRange</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, int <I>firstPos</I>, int <I>lastPos</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgTextSetDMS><B>mgTextSetDMS</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, double <I>dmsVal</I>, const char* <I>fmtString</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgTextSetDouble><B>mgTextSetDouble</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, double <I>doubleVal</I>, const char* <I>fmtString</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgTextSetEditable><B>mgTextSetEditable</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, <A HREF=#mgbool>mgbool</A> <I>editable</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgTextSetFilename><B>mgTextSetFilename</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, const char* <I>fileName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgTextSetFloat><B>mgTextSetFloat</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, float <I>floatVal</I>, const char* <I>fmtString</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgTextSetInteger><B>mgTextSetInteger</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, int <I>intVal</I>, const char* <I>fmtString</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgTextSetSpinBuddy><B>mgTextSetSpinBuddy</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, <A HREF=#mggui>mggui</A> <I>spinControl</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgTextSetSpinIncrement><B>mgTextSetSpinIncrement</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, double <I>increment</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgTextSetString><B>mgTextSetString</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, const char* <I>string</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgTextSetTextFormat><B>mgTextSetTextFormat</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, const char* <I>fmtString</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=GLFUNC><H1>GL Controls</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgDrawControl><B>mgDrawControl</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgDrawControlNow><B>mgDrawControlNow</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGLColor3><B>mgGLColor3</B></A> (<A HREF=#mgglcontext>mgglcontext</A> <I>glContext</I>, short <I>red</I>, short <I>green</I>, short <I>blue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGLColor4><B>mgGLColor4</B></A> (<A HREF=#mgglcontext>mgglcontext</A> <I>glContext</I>, short <I>red</I>, short <I>green</I>, short <I>blue</I>, short <I>alpha</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGLColorIndex><B>mgGLColorIndex</B></A> (<A HREF=#mgglcontext>mgglcontext</A> <I>glContext</I>, <A HREF=#mgrec>mgrec*</A> <I>db</I>, unsigned int <I>index</I>, float <I>intensity</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGLMaterialIndex><B>mgGLMaterialIndex</B></A> (<A HREF=#mgglcontext>mgglcontext</A> <I>glContext</I>, <A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgGLSetMouseFunc><B>mgGLSetMouseFunc</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, unsigned int <I>actionMask</I>, <A HREF=#mgglmousefunc>mgglmousefunc</A> <I>mouseFunc</I>, void* <I>userData</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGLTextureIndex><B>mgGLTextureIndex</B></A> (<A HREF=#mgglcontext>mgglcontext</A> <I>glContext</I>, <A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=TOGGLEBUTTONCONTROLFUNC><H1>Toggle Button Controls</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgToggleButtonGetState><B>mgToggleButtonGetState</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgToggleButtonSetState><B>mgToggleButtonSetState</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, int <I>state</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=OPTIONMENUCONTROLFUNC><H1>Option Menu Controls</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgOptionMenuAddItem><B>mgOptionMenuAddItem</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, const char* <I>itemString</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgOptionMenuDeleteAllItems><B>mgOptionMenuDeleteAllItems</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgOptionMenuDeleteItem><B>mgOptionMenuDeleteItem</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, const char* <I>itemString</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgOptionMenuDeleteItemAtPos><B>mgOptionMenuDeleteItemAtPos</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, int <I>itemPos</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgOptionMenuGetItemCount><B>mgOptionMenuGetItemCount</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgOptionMenuGetItemStringAtPos><B>mgOptionMenuGetItemStringAtPos</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, int <I>itemPos</I>, char* <I>itemString</I>, int <I>maxLen</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgOptionMenuGetSelectedItemPos><B>mgOptionMenuGetSelectedItemPos</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, int* <I>itemPos</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgOptionMenuGetSelectedItemString><B>mgOptionMenuGetSelectedItemString</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, char* <I>itemString</I>, int <I>maxLen</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgOptionMenuSelectItem><B>mgOptionMenuSelectItem</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, const char* <I>itemString</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgOptionMenuSelectItemAtPos><B>mgOptionMenuSelectItemAtPos</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, int <I>itemPos</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=MENUCONTROLFUNC><H1>Menu Controls</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgMenuGetState><B>mgMenuGetState</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgMenuSetState><B>mgMenuSetState</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, int <I>state</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=LISTCONTROLFUNC><H1>List Controls</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgListAddItem><B>mgListAddItem</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, const char* <I>itemString</I>, int <I>itemPos</I>, <A HREF=#mgbool>mgbool</A> <I>select</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgListAddItemData><B>mgListAddItemData</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, const char* <I>itemString</I>, void* <I>itemData</I>, int <I>itemPos</I>, <A HREF=#mgbool>mgbool</A> <I>select</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgListAppendItem><B>mgListAppendItem</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, const char* <I>itemString</I>, <A HREF=#mgbool>mgbool</A> <I>select</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgListAppendItemData><B>mgListAppendItemData</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, const char* <I>itemString</I>, void* <I>itemData</I>, <A HREF=#mgbool>mgbool</A> <I>select</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgListDeleteAllItems><B>mgListDeleteAllItems</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgListDeleteItem><B>mgListDeleteItem</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, const char* <I>itemString</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgListDeleteItemAtPos><B>mgListDeleteItemAtPos</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, int <I>itemPos</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgListDeleteSelectedItems><B>mgListDeleteSelectedItems</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgListDeselectAllItems><B>mgListDeselectAllItems</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgListDeselectItemAtPos><B>mgListDeselectItemAtPos</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, int <I>itemPos</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgListGetItemCount><B>mgListGetItemCount</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void* <TD><A HREF=#mgListGetItemDataAtPos><B>mgListGetItemDataAtPos</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, int <I>itemPos</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgListGetItemStringAtPos><B>mgListGetItemStringAtPos</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, int <I>itemPos</I>, char* <I>itemString</I>, int <I>maxLen</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgListGetSelectedItemCount><B>mgListGetSelectedItemCount</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgListGetSelectedItemPos><B>mgListGetSelectedItemPos</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, int* <I>itemPos</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgListGetSelectedItemString><B>mgListGetSelectedItemString</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, char* <I>itemString</I>, int <I>maxLen</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstringlist>mgstringlist</A> <TD><A HREF=#mgListGetSelectedStrings><B>mgListGetSelectedStrings</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstringlist>mgstringlist</A> <TD><A HREF=#mgListGetStrings><B>mgListGetStrings</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgListGetTopPos><B>mgListGetTopPos</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, int* <I>itemPos</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgListIsItemAtPosSelected><B>mgListIsItemAtPosSelected</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, int <I>itemPos</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgListIsItemInList><B>mgListIsItemInList</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, const char* <I>itemString</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgListReplaceItem><B>mgListReplaceItem</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, const char* <I>oldItemString</I>, const char* <I>newItemString</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgListReplaceItemAtPos><B>mgListReplaceItemAtPos</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, int <I>itemPos</I>, const char* <I>itemString</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgListSelectAllItems><B>mgListSelectAllItems</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgListSelectItem><B>mgListSelectItem</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, const char* <I>itemString</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgListSelectItemAtPos><B>mgListSelectItemAtPos</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, int <I>itemPos</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgListSetBottomItem><B>mgListSetBottomItem</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, const char* <I>itemString</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgListSetBottomPos><B>mgListSetBottomPos</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, int <I>itemPos</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgListSetItemDataAtPos><B>mgListSetItemDataAtPos</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, int <I>itemPos</I>, void* <I>itemData</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgListSetTopItem><B>mgListSetTopItem</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, const char* <I>itemString</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgListSetTopPos><B>mgListSetTopPos</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, int <I>itemPos</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=SCALECONTROLFUNC><H1>Scale Controls</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgScaleGetMinMax><B>mgScaleGetMinMax</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, double* <I>min</I>, double* <I>max</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgScaleGetValue><B>mgScaleGetValue</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, double* <I>value</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgScaleSetMinMax><B>mgScaleSetMinMax</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, double <I>min</I>, double <I>max</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgScaleSetSpinBuddy><B>mgScaleSetSpinBuddy</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, <A HREF=#mggui>mggui</A> <I>spinControl</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgScaleSetSpinIncrement><B>mgScaleSetSpinIncrement</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, double <I>increment</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgScaleSetTextBuddy><B>mgScaleSetTextBuddy</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, <A HREF=#mggui>mggui</A> <I>textControl</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgScaleSetTextFormat><B>mgScaleSetTextFormat</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, const char* <I>fmtString</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgScaleSetValue><B>mgScaleSetValue</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, double <I>value</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=TABRULERCONTROLFUNC><H1>Tab Ruler Controls</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgFreeTabRuler><B>mgFreeTabRuler</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgNewTabRuler><B>mgNewTabRuler</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, <A HREF=#></A> <I>...</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgTabRulerDeleteTab><B>mgTabRulerDeleteTab</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, int <I>tabIndex</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgTabRulerGetSelectedTab><B>mgTabRulerGetSelectedTab</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgTabRulerGetTabCount><B>mgTabRulerGetTabCount</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgTabRulerGetTabPosition><B>mgTabRulerGetTabPosition</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, int <I>tabIndex</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgTabRulerNewTab><B>mgTabRulerNewTab</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, int <I>tabPosition</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgTabRulerRangeDrawCallback><B>mgTabRulerRangeDrawCallback</B></A> (<A HREF=#mggui>mggui</A> <I>gui</I>, <A HREF=#mgcontrolid>mgcontrolid</A> <I>controlId</I>, <A HREF=#mgguicallbackreason>mgguicallbackreason</A> <I>callbackReason</I>, void* <I>userData</I>, void* <I>callData</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgTabRulerRangeMouseCallback><B>mgTabRulerRangeMouseCallback</B></A> (<A HREF=#mggui>mggui</A> <I>gui</I>, <A HREF=#mgcontrolid>mgcontrolid</A> <I>controlId</I>, <A HREF=#mgglmouseaction>mgglmouseaction</A> <I>mouseAction</I>, void* <I>userData</I>, void* <I>callData</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgTabRulerSelectTab><B>mgTabRulerSelectTab</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, int <I>tabIndex</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgTabRulerSetGuiCallback><B>mgTabRulerSetGuiCallback</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, unsigned int <I>callbackMask</I>, <A HREF=#mgguifunc>mgguifunc</A> <I>callback</I>, void* <I>userData</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgTabRulerSetMouseCallback><B>mgTabRulerSetMouseCallback</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, unsigned int <I>actionMask</I>, <A HREF=#mgglmousefunc>mgglmousefunc</A> <I>callback</I>, void* <I>userData</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgTabRulerSetOptions><B>mgTabRulerSetOptions</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, <A HREF=#></A> <I>...</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgTabRulerSetTabFrozen><B>mgTabRulerSetTabFrozen</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, int <I>tabIndex</I>, <A HREF=#mgbool>mgbool</A> <I>tabFrozen</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgTabRulerSetTabPosition><B>mgTabRulerSetTabPosition</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, int <I>tabIndex</I>, int <I>tabPosition</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=PROGRESSFUNC><H1>Progress Controls</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgProgressGetMinMax><B>mgProgressGetMinMax</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, double* <I>min</I>, double* <I>max</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgProgressGetValue><B>mgProgressGetValue</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, double* <I>value</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgProgressSetMinMax><B>mgProgressSetMinMax</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, double <I>min</I>, double <I>max</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgProgressSetStepIncrement><B>mgProgressSetStepIncrement</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, double <I>increment</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgProgressSetValue><B>mgProgressSetValue</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, double <I>value</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgProgressStepValue><B>mgProgressStepValue</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=NOTIFIERFUNC><H1>Notifier Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgnotifier>mgnotifier</A> <TD><A HREF=#mgRegisterNotifier><B>mgRegisterNotifier</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>pluginTool</I>, <A HREF=#mgnotifierevent>mgnotifierevent</A> <I>event</I>, <A HREF=#mgrec>mgrec*</A> <I>db</I>, <A HREF=#mgrec>mgrec*</A> <I>rec</I>, <A HREF=#mgnotifyfunc>mgnotifyfunc</A> <I>notifyFunc</I>, void* <I>userData</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgnotifier>mgnotifier</A> <TD><A HREF=#mgRegisterPaletteNotifier><B>mgRegisterPaletteNotifier</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>pluginTool</I>, <A HREF=#mgnotifierevent>mgnotifierevent</A> <I>event</I>, <A HREF=#mgrec>mgrec*</A> <I>db</I>, <A HREF=#mgpalettenotifyfunc>mgpalettenotifyfunc</A> <I>notifyFunc</I>, void* <I>userData</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgSetAllNotifiersEnabled><B>mgSetAllNotifiersEnabled</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>pluginTool</I>, <A HREF=#mgbool>mgbool</A> <I>enabled</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgSetNotifierEnabled><B>mgSetNotifierEnabled</B></A> (<A HREF=#mgnotifier>mgnotifier</A> <I>notifier</I>, <A HREF=#mgbool>mgbool</A> <I>enabled</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgUnregisterAllNotifiers><B>mgUnregisterAllNotifiers</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>pluginTool</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgUnregisterNotifier><B>mgUnregisterNotifier</B></A> (<A HREF=#mgnotifier>mgnotifier</A> <I>notifier</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=TOOLREGISTERFUNC><H1>Tool Registration Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgEditorSetButtonFunc><B>mgEditorSetButtonFunc</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>editorPluginTool</I>, <A HREF=#mgeditorbuttonfunc>mgeditorbuttonfunc</A> <I>buttonFunc</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgEditorSetCloseDialogFunc><B>mgEditorSetCloseDialogFunc</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>editorPluginTool</I>, <A HREF=#mgeditorclosedialogfunc>mgeditorclosedialogfunc</A> <I>closeDialogFunc</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgEditorSetCreateDialogFunc><B>mgEditorSetCreateDialogFunc</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>editorPluginTool</I>, <A HREF=#mgeditorcreatedialogfunc>mgeditorcreatedialogfunc</A> <I>createDialogFunc</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgEditorSetDeviceInputFunc><B>mgEditorSetDeviceInputFunc</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>editorPluginTool</I>, <A HREF=#mgeditordeviceinputfunc>mgeditordeviceinputfunc</A> <I>devInputFunc</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgEditorSetFocusVertexFunc><B>mgEditorSetFocusVertexFunc</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>editorPluginTool</I>, <A HREF=#mgeditorfocusvertexfunc>mgeditorfocusvertexfunc</A> <I>focusVertexFunc</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgEditorSetPickFunc><B>mgEditorSetPickFunc</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>editorPluginTool</I>, <A HREF=#mgeditorpickfunc>mgeditorpickfunc</A> <I>pickFunc</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgEditorSetPointFunc><B>mgEditorSetPointFunc</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>editorPluginTool</I>, <A HREF=#mgeditorpointfunc>mgeditorpointfunc</A> <I>pointFunc</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgEditorSetTerminateFunc><B>mgEditorSetTerminateFunc</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>editorPluginTool</I>, <A HREF=#mgeditorterminatefunc>mgeditorterminatefunc</A> <I>terminateFunc</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgEditorSetVertexFunc><B>mgEditorSetVertexFunc</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>editorPluginTool</I>, <A HREF=#mgeditorvertexfunc>mgeditorvertexfunc</A> <I>vertexFunc</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgGetModuleFilename><B>mgGetModuleFilename</B></A> (<A HREF=#mgplugin>mgplugin</A> <I>plugin</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgmodulehandle>mgmodulehandle</A> <TD><A HREF=#mgGetModuleHandle><B>mgGetModuleHandle</B></A> (<A HREF=#mgplugin>mgplugin</A> <I>plugin</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgGetModulePath><B>mgGetModulePath</B></A> (<A HREF=#mgplugin>mgplugin</A> <I>plugin</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetRegistryRoot><B>mgGetRegistryRoot</B></A> (char* <I>rootString</I>, int <I>maxLen</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetRegistryString><B>mgGetRegistryString</B></A> (const char* <I>keyName</I>, char* <I>keyString</I>, int <I>maxLen</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgPluginDeleteProperty><B>mgPluginDeleteProperty</B></A> (<A HREF=#mgplugin>mgplugin</A> <I>plugin</I>, const <A HREF=#mgpropertyname>mgpropertyname</A> <I>propName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgpropertyvalue>mgpropertyvalue</A> <TD><A HREF=#mgPluginGetProperty><B>mgPluginGetProperty</B></A> (<A HREF=#mgplugin>mgplugin</A> <I>plugin</I>, const <A HREF=#mgpropertyname>mgpropertyname</A> <I>propName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgPluginPutProperty><B>mgPluginPutProperty</B></A> (<A HREF=#mgplugin>mgplugin</A> <I>plugin</I>, const <A HREF=#mgpropertyname>mgpropertyname</A> <I>propName</I>, <A HREF=#mgpropertyvalue>mgpropertyvalue</A> <I>propValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgPluginToolDeleteProperty><B>mgPluginToolDeleteProperty</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>pluginTool</I>, const <A HREF=#mgpropertyname>mgpropertyname</A> <I>propName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgplugin>mgplugin</A> <TD><A HREF=#mgPluginToolGetPlugin><B>mgPluginToolGetPlugin</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>pluginTool</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgpropertyvalue>mgpropertyvalue</A> <TD><A HREF=#mgPluginToolGetProperty><B>mgPluginToolGetProperty</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>pluginTool</I>, const <A HREF=#mgpropertyname>mgpropertyname</A> <I>propName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void* <TD><A HREF=#mgPluginToolGetUserData><B>mgPluginToolGetUserData</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>pluginTool</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgPluginToolPutProperty><B>mgPluginToolPutProperty</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>pluginTool</I>, const <A HREF=#mgpropertyname>mgpropertyname</A> <I>propName</I>, <A HREF=#mgpropertyvalue>mgpropertyvalue</A> <I>propValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgPluginToolSetDefaultParamBlock><B>mgPluginToolSetDefaultParamBlock</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>pluginTool</I>, <A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgplugintool>mgplugintool</A> <TD><A HREF=#mgRegisterEditor><B>mgRegisterEditor</B></A> (<A HREF=#mgplugin>mgplugin</A> <I>plugin</I>, const char* <I>toolName</I>, <A HREF=#mgtoolstartfunc>mgtoolstartfunc</A> <I>startFunc</I>, void* <I>userData</I>, <A HREF=#></A> <I>...</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgplugintool>mgplugintool</A> <TD><A HREF=#mgRegisterExporter><B>mgRegisterExporter</B></A> (<A HREF=#mgplugin>mgplugin</A> <I>plugin</I>, const char* <I>toolName</I>, <A HREF=#mgtoolstartfunc>mgtoolstartfunc</A> <I>startFunc</I>, void* <I>userData</I>, <A HREF=#></A> <I>...</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgplugintool>mgplugintool</A> <TD><A HREF=#mgRegisterImageImporter><B>mgRegisterImageImporter</B></A> (<A HREF=#mgplugin>mgplugin</A> <I>plugin</I>, const char* <I>toolName</I>, int <I>importFlags</I>, <A HREF=#mgimageopenfunc>mgimageopenfunc</A> <I>openFunc</I>, <A HREF=#mgimageclosefunc>mgimageclosefunc</A> <I>closeFunc</I>, <A HREF=#mgimagegetinfofunc>mgimagegetinfofunc</A> <I>getInfoFunc</I>, <A HREF=#mgimagegettexelsfunc>mgimagegettexelsfunc</A> <I>getTexelsFunc</I>, void* <I>userData</I>, <A HREF=#></A> <I>...</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgplugintool>mgplugintool</A> <TD><A HREF=#mgRegisterImporter><B>mgRegisterImporter</B></A> (<A HREF=#mgplugin>mgplugin</A> <I>plugin</I>, const char* <I>toolName</I>, <A HREF=#mgtoolstartfunc>mgtoolstartfunc</A> <I>startFunc</I>, void* <I>userData</I>, <A HREF=#></A> <I>...</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgplugintool>mgplugintool</A> <TD><A HREF=#mgRegisterViewer><B>mgRegisterViewer</B></A> (<A HREF=#mgplugin>mgplugin</A> <I>plugin</I>, const char* <I>toolName</I>, <A HREF=#mgtoolstartfunc>mgtoolstartfunc</A> <I>startFunc</I>, void* <I>userData</I>, <A HREF=#></A> <I>...</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgSetReadImageGeoInfoFunc><B>mgSetReadImageGeoInfoFunc</B></A> (<A HREF=#mgplugin>mgplugin</A> <I>plugin</I>, <A HREF=#mgplugintool>mgplugintool</A> <I>pluginTool</I>, <A HREF=#mgimagegetgeoinfofunc>mgimagegetgeoinfofunc</A> <I>getGeoInfoFunc</I>, void* <I>userData</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetRegistryString><B>mgSetRegistryString</B></A> (const char* <I>keyName</I>, const char* <I>keyString</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgUnregisterAllTools><B>mgUnregisterAllTools</B></A> (<A HREF=#mgplugin>mgplugin</A> <I>plugin</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=PARAMETERFUNC><H1>Parameter Block Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgFreeParamBlock><B>mgFreeParamBlock</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgparamblock>mgparamblock</A> <TD><A HREF=#mgGetParamBlock><B>mgGetParamBlock</B></A> (const char* <I>commandName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgparamblock>mgparamblock</A> <TD><A HREF=#mgNewParamBlock><B>mgNewParamBlock</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgparam>mgparam</A> <TD><A HREF=#mgParamAddBool><B>mgParamAddBool</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, <A HREF=#mgbool>mgbool</A> <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgparam>mgparam</A> <TD><A HREF=#mgParamAddDouble><B>mgParamAddDouble</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, double <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgparam>mgparam</A> <TD><A HREF=#mgParamAddDouble2><B>mgParamAddDouble2</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, double <I>defaultValue1</I>, double <I>defaultValue2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgparam>mgparam</A> <TD><A HREF=#mgParamAddDouble3><B>mgParamAddDouble3</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, double <I>defaultValue1</I>, double <I>defaultValue2</I>, double <I>defaultValue3</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgparam>mgparam</A> <TD><A HREF=#mgParamAddFloat><B>mgParamAddFloat</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, float <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgparam>mgparam</A> <TD><A HREF=#mgParamAddInteger><B>mgParamAddInteger</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, int <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgparam>mgparam</A> <TD><A HREF=#mgParamAddString><B>mgParamAddString</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, const char* <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamAppend><B>mgParamAppend</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, <A HREF=#variant>variant</A> <I>paramValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamAppendBool><B>mgParamAppendBool</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, <A HREF=#mgbool>mgbool</A> <I>paramValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamAppendDouble><B>mgParamAppendDouble</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, double <I>paramValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamAppendDouble2><B>mgParamAppendDouble2</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, double <I>paramValue1</I>, double <I>paramValue2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamAppendDouble3><B>mgParamAppendDouble3</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, double <I>paramValue1</I>, double <I>paramValue2</I>, double <I>paramValue3</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamAppendFloat><B>mgParamAppendFloat</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, float <I>paramValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamAppendInteger><B>mgParamAppendInteger</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, int <I>paramValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamAppendString><B>mgParamAppendString</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, const char* <I>paramValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamExists><B>mgParamExists</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamGetBool><B>mgParamGetBool</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, <A HREF=#mgbool>mgbool*</A> <I>paramValue</I>, <A HREF=#mgbool>mgbool</A> <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamGetBoolNth><B>mgParamGetBoolNth</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, unsigned int <I>nth</I>, <A HREF=#mgbool>mgbool*</A> <I>paramValue</I>, <A HREF=#mgbool>mgbool</A> <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">unsigned int <TD><A HREF=#mgParamGetDimension><B>mgParamGetDimension</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamGetDouble><B>mgParamGetDouble</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, double* <I>paramValue</I>, double <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamGetDouble2><B>mgParamGetDouble2</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, double* <I>paramValue1</I>, double* <I>paramValue2</I>, double <I>defaultValue1</I>, double <I>defaultValue2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamGetDouble2Nth><B>mgParamGetDouble2Nth</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, unsigned int <I>nth</I>, double* <I>paramValue1</I>, double* <I>paramValue2</I>, double <I>defaultValue1</I>, double <I>defaultValue2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamGetDouble3><B>mgParamGetDouble3</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, double* <I>paramValue1</I>, double* <I>paramValue2</I>, double* <I>paramValue3</I>, double <I>defaultValue1</I>, double <I>defaultValue2</I>, double <I>defaultValue3</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamGetDouble3Nth><B>mgParamGetDouble3Nth</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, unsigned int <I>nth</I>, double* <I>paramValue1</I>, double* <I>paramValue2</I>, double* <I>paramValue3</I>, double <I>defaultValue1</I>, double <I>defaultValue2</I>, double <I>defaultValue3</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamGetDoubleNth><B>mgParamGetDoubleNth</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, unsigned int <I>nth</I>, double* <I>paramValue</I>, double <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamGetFloat><B>mgParamGetFloat</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, float* <I>paramValue</I>, float <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamGetFloatNth><B>mgParamGetFloatNth</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, unsigned int <I>nth</I>, float* <I>paramValue</I>, float <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamGetInteger><B>mgParamGetInteger</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, int* <I>paramValue</I>, int <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamGetIntegerNth><B>mgParamGetIntegerNth</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, unsigned int <I>nth</I>, int* <I>paramValue</I>, int <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">unsigned int <TD><A HREF=#mgParamGetSize><B>mgParamGetSize</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamGetString><B>mgParamGetString</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, char* <I>paramValue</I>, int <I>maxLen</I>, const char* <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamGetStringAlloc><B>mgParamGetStringAlloc</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, char** <I>paramValue</I>, const char* <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamGetStringNth><B>mgParamGetStringNth</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, unsigned int <I>nth</I>, char* <I>paramValue</I>, int <I>maxLen</I>, const char* <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamGetStringNthAlloc><B>mgParamGetStringNthAlloc</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, unsigned int <I>nth</I>, char** <I>paramValue</I>, const char* <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamSet><B>mgParamSet</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, <A HREF=#variant>variant</A> <I>paramValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamSetBool><B>mgParamSetBool</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, <A HREF=#mgbool>mgbool</A> <I>paramValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamSetDimension><B>mgParamSetDimension</B></A> (<A HREF=#mgparam>mgparam</A> <I>param</I>, unsigned int <I>maxArrayDimension</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamSetDouble><B>mgParamSetDouble</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, double <I>paramValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamSetDouble2><B>mgParamSetDouble2</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, double <I>paramValue1</I>, double <I>paramValue2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamSetDouble3><B>mgParamSetDouble3</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, double <I>paramValue1</I>, double <I>paramValue2</I>, double <I>paramValue3</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamSetDoubleMaxLE><B>mgParamSetDoubleMaxLE</B></A> (<A HREF=#mgparam>mgparam</A> <I>param</I>, double <I>maxValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamSetDoubleMaxLT><B>mgParamSetDoubleMaxLT</B></A> (<A HREF=#mgparam>mgparam</A> <I>param</I>, double <I>maxValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamSetDoubleMinGE><B>mgParamSetDoubleMinGE</B></A> (<A HREF=#mgparam>mgparam</A> <I>param</I>, double <I>minValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamSetDoubleMinGT><B>mgParamSetDoubleMinGT</B></A> (<A HREF=#mgparam>mgparam</A> <I>param</I>, double <I>minValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamSetEnumerant><B>mgParamSetEnumerant</B></A> (<A HREF=#mgparam>mgparam</A> <I>param</I>, int <I>value</I>, const char* <I>string</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamSetFloat><B>mgParamSetFloat</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, float <I>paramValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamSetInteger><B>mgParamSetInteger</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, int <I>paramValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamSetIntegerMaxLE><B>mgParamSetIntegerMaxLE</B></A> (<A HREF=#mgparam>mgparam</A> <I>param</I>, int <I>maxValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamSetIntegerMaxLT><B>mgParamSetIntegerMaxLT</B></A> (<A HREF=#mgparam>mgparam</A> <I>param</I>, int <I>maxValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamSetIntegerMinGE><B>mgParamSetIntegerMinGE</B></A> (<A HREF=#mgparam>mgparam</A> <I>param</I>, int <I>minValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamSetIntegerMinGT><B>mgParamSetIntegerMinGT</B></A> (<A HREF=#mgparam>mgparam</A> <I>param</I>, int <I>minValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgParamSetString><B>mgParamSetString</B></A> (<A HREF=#mgparamblock>mgparamblock</A> <I>paramBlock</I>, const char* <I>paramName</I>, const char* <I>paramValue</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=SITEREGISTERFUNC><H1>Extension Registration Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgRegisterCreate><B>mgRegisterCreate</B></A> (<A HREF=#mgpluginsite>mgpluginsite</A> <I>pluginSite</I>, <A HREF=#mgcode>mgcode</A> <I>rCode</I>, <A HREF=#mgcreatefunc>mgcreatefunc</A> <I>createFunc</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgRegisterGetHeaderCode><B>mgRegisterGetHeaderCode</B></A> (<A HREF=#mgpluginsite>mgpluginsite</A> <I>pluginSite</I>, <A HREF=#mggetheadercodefunc>mggetheadercodefunc</A> <I>getHeaderCodeFunc</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgRegisterGetMaxId><B>mgRegisterGetMaxId</B></A> (<A HREF=#mgpluginsite>mgpluginsite</A> <I>pluginSite</I>, <A HREF=#mggetmaxidfunc>mggetmaxidfunc</A> <I>getMaxIdfunc</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgRegisterGraphicDraw><B>mgRegisterGraphicDraw</B></A> (<A HREF=#mgpluginsite>mgpluginsite</A> <I>pluginSite</I>, <A HREF=#mgcode>mgcode</A> <I>rCode</I>, <A HREF=#mggraphicdrawfunc>mggraphicdrawfunc</A> <I>drawFunc</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgRegisterHierarchyDraw><B>mgRegisterHierarchyDraw</B></A> (<A HREF=#mgpluginsite>mgpluginsite</A> <I>pluginSite</I>, <A HREF=#mgcode>mgcode</A> <I>rCode</I>, <A HREF=#mghierarchydrawfunc>mghierarchydrawfunc</A> <I>drawFunc</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgRegisterPostEdit><B>mgRegisterPostEdit</B></A> (<A HREF=#mgpluginsite>mgpluginsite</A> <I>pluginSite</I>, <A HREF=#mgcode>mgcode</A> <I>code</I>, <A HREF=#mgposteditfunc>mgposteditfunc</A> <I>postEditFunc</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgRegisterPreEdit><B>mgRegisterPreEdit</B></A> (<A HREF=#mgpluginsite>mgpluginsite</A> <I>pluginSite</I>, <A HREF=#mgcode>mgcode</A> <I>code</I>, <A HREF=#mgpreeditfunc>mgpreeditfunc</A> <I>preEditFunc</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgRegisterSetMaxId><B>mgRegisterSetMaxId</B></A> (<A HREF=#mgpluginsite>mgpluginsite</A> <I>pluginSite</I>, <A HREF=#mgsetmaxidfunc>mgsetmaxidfunc</A> <I>setMaxIdFunc</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgpluginsite>mgpluginsite</A> <TD><A HREF=#mgRegisterSite><B>mgRegisterSite</B></A> (<A HREF=#mgplugin>mgplugin</A> <I>plugin</I>, char* <I>siteId</I>, <A HREF=#record_def*>record_def*</A> <I>recordDefTbl</I>, <A HREF=#mgcode>mgcode*</A> <I>recordCodeMap</I>, int <I>recordOffset</I>, int <I>recordMax</I>, <A HREF=#data_def*>data_def*</A> <I>dataDefTbl</I>, <A HREF=#mgcode>mgcode*</A> <I>dataCodeMap</I>, int <I>dataOffset</I>, int <I>dataMax</I>, <A HREF=#></A> <I>...</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=EDITORCONTEXTFUNC><H1>Editor Context Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgEditorAddRedo><B>mgEditorAddRedo</B></A> (<A HREF=#mgeditorundofunc>mgeditorundofunc</A> <I>redoFunc</I>, <A HREF=#mgeditorundocleanupfunc>mgeditorundocleanupfunc</A> <I>redoCleanupFunc</I>, void* <I>redoData</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgEditorAddUndo><B>mgEditorAddUndo</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>, const char* <I>menuLabel</I>, <A HREF=#mgeditorundofunc>mgeditorundofunc</A> <I>undoFunc</I>, <A HREF=#mgeditorundocleanupfunc>mgeditorundocleanupfunc</A> <I>undoCleanupFunc</I>, void* <I>undoData</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgEditorAddUndoForCreate><B>mgEditorAddUndoForCreate</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>, const char* <I>menuLabel</I>, <A HREF=#mgrec>mgrec*</A> <I>node</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgEditorAddUndoForDelete><B>mgEditorAddUndoForDelete</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>, const char* <I>menuLabel</I>, <A HREF=#mgrec>mgrec*</A> <I>node</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgEditorAddUndoForMove><B>mgEditorAddUndoForMove</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>, const char* <I>menuLabel</I>, <A HREF=#mgrec>mgrec*</A> <I>node</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgEditorAddUndoForRedo><B>mgEditorAddUndoForRedo</B></A> (<A HREF=#mgeditorundofunc>mgeditorundofunc</A> <I>undoFunc</I>, <A HREF=#mgeditorundocleanupfunc>mgeditorundocleanupfunc</A> <I>undoCleanupFunc</I>, void* <I>undoData</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgEditorAppendUndo><B>mgEditorAppendUndo</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>, <A HREF=#mgeditorundofunc>mgeditorundofunc</A> <I>undoFunc</I>, <A HREF=#mgeditorundocleanupfunc>mgeditorundocleanupfunc</A> <I>undoCleanupFunc</I>, void* <I>undoData</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgEditorAppendUndoForCreate><B>mgEditorAppendUndoForCreate</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>, <A HREF=#mgrec>mgrec*</A> <I>node</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgEditorAppendUndoForDelete><B>mgEditorAppendUndoForDelete</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>, <A HREF=#mgrec>mgrec*</A> <I>node</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgEditorAppendUndoForMove><B>mgEditorAppendUndoForMove</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>, <A HREF=#mgrec>mgrec*</A> <I>node</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgEditorCancelTool><B>mgEditorCancelTool</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgEditorDeleteProperty><B>mgEditorDeleteProperty</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>, const <A HREF=#mgpropertyname>mgpropertyname</A> <I>propName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgeditorcontext>mgeditorcontext</A> <TD><A HREF=#mgEditorGetContext><B>mgEditorGetContext</B></A> (<A HREF=#mggui>mggui</A> <I>gui</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgEditorGetDbRec><B>mgEditorGetDbRec</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mggui>mggui</A> <TD><A HREF=#mgEditorGetDialog><B>mgEditorGetDialog</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgplugintool>mgplugintool</A> <TD><A HREF=#mgEditorGetPluginTool><B>mgEditorGetPluginTool</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgpropertyvalue>mgpropertyvalue</A> <TD><A HREF=#mgEditorGetProperty><B>mgEditorGetProperty</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>, const <A HREF=#mgpropertyname>mgpropertyname</A> <I>propName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgtoolactivation>mgtoolactivation</A> <TD><A HREF=#mgEditorGetToolActivation><B>mgEditorGetToolActivation</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void* <TD><A HREF=#mgEditorGetToolData><B>mgEditorGetToolData</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgEditorPutProperty><B>mgEditorPutProperty</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>, const <A HREF=#mgpropertyname>mgpropertyname</A> <I>propName</I>, <A HREF=#mgpropertyvalue>mgpropertyvalue</A> <I>propValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgEditorResetUndo><B>mgEditorResetUndo</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgEditorSelectMouseInput><B>mgEditorSelectMouseInput</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>, <A HREF=#mgmouseinputtype>mgmouseinputtype</A> <I>inputType</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgEditorSetPrompt><B>mgEditorSetPrompt</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>, const char* <I>promptString</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgEditorSetSnapFace><B>mgEditorSetSnapFace</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>, <A HREF=#mgbool>mgbool</A> <I>flag</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgEditorSetSnapLine><B>mgEditorSetSnapLine</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>, <A HREF=#mglined>mglined*</A> <I>snapLine</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgEditorSetTrackPlane><B>mgEditorSetTrackPlane</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>, <A HREF=#mgplaned>mgplaned*</A> <I>trackPlane</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgEditorTerminateTool><B>mgEditorTerminateTool</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgExecute><B>mgExecute</B></A> (const char* <I>toolName</I>, <A HREF=#mgparamblock>mgparamblock</A> <I>params</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgeditorcontext>mgeditorcontext</A> <TD><A HREF=#mgNewEditorContext><B>mgNewEditorContext</B></A> (const char* <I>toolName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgRefreshScene><B>mgRefreshScene</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=CONSTRUCTIONFUNC><H1>Construction Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgDeleteAllConstructs><B>mgDeleteAllConstructs</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgDeleteConstructEdge><B>mgDeleteConstructEdge</B></A> (<A HREF=#mgrec>mgrec*</A> <I>constructEdge</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgDeleteConstructVertex><B>mgDeleteConstructVertex</B></A> (<A HREF=#mgrec>mgrec*</A> <I>constructVtx</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgFirstConstructEdge><B>mgFirstConstructEdge</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgFirstConstructVertex><B>mgFirstConstructVertex</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgGetConstructEdgeCoords><B>mgGetConstructEdgeCoords</B></A> (<A HREF=#mgrec>mgrec*</A> <I>constructEdge</I>, <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord1</I>, <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgGetConstructVertexCoords><B>mgGetConstructVertexCoords</B></A> (<A HREF=#mgrec>mgrec*</A> <I>constructVtx</I>, <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgNewConstructEdge><B>mgNewConstructEdge</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord1</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgNewConstructVertex><B>mgNewConstructVertex</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgNextConstructEdge><B>mgNextConstructEdge</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>, <A HREF=#mgrec>mgrec*</A> <I>constructEdge</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgNextConstructVertex><B>mgNextConstructVertex</B></A> (<A HREF=#mgeditorcontext>mgeditorcontext</A> <I>editorContext</I>, <A HREF=#mgrec>mgrec*</A> <I>constructVtx</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgSetConstructEdgeColor><B>mgSetConstructEdgeColor</B></A> (<A HREF=#mgrec>mgrec*</A> <I>constructEdge</I>, <A HREF=#mgconstructcolor>mgconstructcolor</A> <I>constructColor</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgSetConstructEdgeCoords><B>mgSetConstructEdgeCoords</B></A> (<A HREF=#mgrec>mgrec*</A> <I>constructEdge</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord1</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord2</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgSetConstructVertexColor><B>mgSetConstructVertexColor</B></A> (<A HREF=#mgrec>mgrec*</A> <I>constructVtx</I>, <A HREF=#mgconstructcolor>mgconstructcolor</A> <I>constructColor</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgSetConstructVertexCoords><B>mgSetConstructVertexCoords</B></A> (<A HREF=#mgrec>mgrec*</A> <I>constructVtx</I>, const <A HREF=#mgcoord3d>mgcoord3d*</A> <I>coord</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=TOOLACTIONFUNC><H1>Tool Action Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgPluginToolFreeAction><B>mgPluginToolFreeAction</B></A> (<A HREF=#mgtoolaction>mgtoolaction</A> <I>toolAction</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgtoolaction>mgtoolaction</A> <TD><A HREF=#mgPluginToolGetAction><B>mgPluginToolGetAction</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>pluginTool</I>, const char* <I>actionName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgtoolaction>mgtoolaction</A> <TD><A HREF=#mgPluginToolNewAction><B>mgPluginToolNewAction</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>pluginTool</I>, const char* <I>actionName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgSetGuiToolAction><B>mgSetGuiToolAction</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, <A HREF=#mgtoolaction>mgtoolaction</A> <I>toolAction</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgToolActionGetName><B>mgToolActionGetName</B></A> (<A HREF=#mgtoolaction>mgtoolaction</A> <I>toolAction</I>, char* <I>actionName</I>, int <I>maxLen</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgToolActionGetShortCut><B>mgToolActionGetShortCut</B></A> (<A HREF=#mgtoolaction>mgtoolaction</A> <I>toolAction</I>, <A HREF=#mgkeysequence>mgkeysequence*</A> <I>keySequence</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgToolActionGetShortCutString><B>mgToolActionGetShortCutString</B></A> (<A HREF=#mgtoolaction>mgtoolaction</A> <I>toolAction</I>, char* <I>shortCutString</I>, int <I>maxLen</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgToolActionSetShortCut><B>mgToolActionSetShortCut</B></A> (<A HREF=#mgtoolaction>mgtoolaction</A> <I>toolAction</I>, <A HREF=#mgkeysequence>mgkeysequence*</A> <I>keySequence</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=TOOLACTIVATIONFUNC><H1>Tool Activation Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetActivationDb><B>mgGetActivationDb</B></A> (<A HREF=#mgtoolactivation>mgtoolactivation</A> <I>toolActivation</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">unsigned int <TD><A HREF=#mgGetActivationKeyboardFlags><B>mgGetActivationKeyboardFlags</B></A> (<A HREF=#mgtoolactivation>mgtoolactivation</A> <I>toolActivation</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgparamblock>mgparamblock</A> <TD><A HREF=#mgGetActivationParamBlock><B>mgGetActivationParamBlock</B></A> (<A HREF=#mgtoolactivation>mgtoolactivation</A> <I>toolActivation</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgtoolactivationtype>mgtoolactivationtype</A> <TD><A HREF=#mgGetActivationType><B>mgGetActivationType</B></A> (<A HREF=#mgtoolactivation>mgtoolactivation</A> <I>toolActivation</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetDefaultModelingParent><B>mgGetDefaultModelingParent</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcode>mgcode</A> <TD><A HREF=#mgGetModelingMode><B>mgGetModelingMode</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetModelingParent><B>mgGetModelingParent</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetModelingParentMatrix><B>mgGetModelingParentMatrix</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, <A HREF=#mgmatrix>mgmatrix*</A> <I>matrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgIsModelingModeEdge><B>mgIsModelingModeEdge</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetModelingMode><B>mgSetModelingMode</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, <A HREF=#mgcode>mgcode</A> <I>mode</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetModelingModeEdge><B>mgSetModelingModeEdge</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetModelingParent><B>mgSetModelingParent</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, <A HREF=#mgrec>mgrec*</A> <I>parent</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=TIMERFUNC><H1>Timer Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgtimer>mgtimer</A> <TD><A HREF=#mgRegisterTimer><B>mgRegisterTimer</B></A> (<A HREF=#mggui>mggui</A> <I>gui</I>, unsigned int <I>timeout</I>, <A HREF=#mgtimerfunc>mgtimerfunc</A> <I>timerFunc</I>, void* <I>userData</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgUnregisterTimer><B>mgUnregisterTimer</B></A> (<A HREF=#mgtimer>mgtimer</A> <I>timerId</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=DATADICTIONARYFUNC><H1>Data Dictionary Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#ddGetAliasCount><B>ddGetAliasCount</B></A> (<A HREF=#mgcode>mgcode</A> <I>rcode</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#ddGetChildCount><B>ddGetChildCount</B></A> (<A HREF=#mgcode>mgcode</A> <I>rcode</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">const char* <TD><A HREF=#ddGetDefString><B>ddGetDefString</B></A> (<A HREF=#mgcode>mgcode</A> <I>dcode</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">float <TD><A HREF=#ddGetDefVal><B>ddGetDefVal</B></A> (<A HREF=#mgcode>mgcode</A> <I>dcode</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">const char* <TD><A HREF=#ddGetDesc><B>ddGetDesc</B></A> (<A HREF=#mgcode>mgcode</A> <I>code</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcode>mgcode</A> <TD><A HREF=#ddGetExtendCode><B>ddGetExtendCode</B></A> (<A HREF=#mgcode>mgcode</A> <I>code</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#ddGetExtFieldCount><B>ddGetExtFieldCount</B></A> (<A HREF=#mgcode>mgcode</A> <I>rcode</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcode>mgcode</A> <TD><A HREF=#ddGetExtFieldNth><B>ddGetExtFieldNth</B></A> (<A HREF=#mgcode>mgcode</A> <I>rcode</I>, unsigned int <I>nth</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#ddGetFieldCount><B>ddGetFieldCount</B></A> (<A HREF=#mgcode>mgcode</A> <I>rcode</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcode>mgcode</A> <TD><A HREF=#ddGetFieldNth><B>ddGetFieldNth</B></A> (<A HREF=#mgcode>mgcode</A> <I>rcode</I>, unsigned int <I>nth</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#ddGetKey><B>ddGetKey</B></A> (<A HREF=#mgcode>mgcode</A> <I>code</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">const char* <TD><A HREF=#ddGetLabel><B>ddGetLabel</B></A> (<A HREF=#mgcode>mgcode</A> <I>code</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#ddGetLength><B>ddGetLength</B></A> (<A HREF=#mgcode>mgcode</A> <I>code</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">float <TD><A HREF=#ddGetMaxVal><B>ddGetMaxVal</B></A> (<A HREF=#mgcode>mgcode</A> <I>dcode</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">float <TD><A HREF=#ddGetMinVal><B>ddGetMinVal</B></A> (<A HREF=#mgcode>mgcode</A> <I>dcode</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcode>mgcode</A> <TD><A HREF=#ddGetMyCode><B>ddGetMyCode</B></A> (<A HREF=#mgcode>mgcode</A> <I>code</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">const char* <TD><A HREF=#ddGetName><B>ddGetName</B></A> (<A HREF=#mgcode>mgcode</A> <I>code</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#ddGetParentCount><B>ddGetParentCount</B></A> (<A HREF=#mgcode>mgcode</A> <I>rcode</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcode>mgcode</A> <TD><A HREF=#ddGetParentNth><B>ddGetParentNth</B></A> (<A HREF=#mgcode>mgcode</A> <I>rcode</I>, unsigned int <I>nth</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">const char* <TD><A HREF=#ddGetPrefix><B>ddGetPrefix</B></A> (<A HREF=#mgcode>mgcode</A> <I>rcode</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">const char* <TD><A HREF=#ddGetSiteId><B>ddGetSiteId</B></A> (<A HREF=#mgcode>mgcode</A> <I>code</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#ddGetSiteNo><B>ddGetSiteNo</B></A> (<A HREF=#mgcode>mgcode</A> <I>code</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgtagtype>mgtagtype</A> <TD><A HREF=#ddGetTagType><B>ddGetTagType</B></A> (<A HREF=#mgcode>mgcode</A> <I>code</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcode>mgcode</A> <TD><A HREF=#ddGetUCode><B>ddGetUCode</B></A> (const char* <I>siteId</I>, <A HREF=#mgcode>mgcode</A> <I>localCode</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char <TD><A HREF=#ddGetVersion><B>ddGetVersion</B></A> (<A HREF=#mgcode>mgcode</A> <I>code</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#ddIsDcode><B>ddIsDcode</B></A> (<A HREF=#mgcode>mgcode</A> <I>code</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#ddIsDefSet><B>ddIsDefSet</B></A> (<A HREF=#mgcode>mgcode</A> <I>dcode</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#ddIsDisplay><B>ddIsDisplay</B></A> (<A HREF=#mgcode>mgcode</A> <I>code</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#ddIsEdit><B>ddIsEdit</B></A> (<A HREF=#mgcode>mgcode</A> <I>code</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#ddIsEnumSet><B>ddIsEnumSet</B></A> (<A HREF=#mgcode>mgcode</A> <I>dcode</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#ddIsField><B>ddIsField</B></A> (<A HREF=#mgcode>mgcode</A> <I>rcode</I>, <A HREF=#mgcode>mgcode</A> <I>fcode</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#ddIsFieldFollowAll><B>ddIsFieldFollowAll</B></A> (<A HREF=#mgcode>mgcode</A> <I>rcode</I>, <A HREF=#mgcode>mgcode</A> <I>fcode</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#ddIsFieldFollowInLine><B>ddIsFieldFollowInLine</B></A> (<A HREF=#mgcode>mgcode</A> <I>rcode</I>, <A HREF=#mgcode>mgcode</A> <I>fcode</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#ddIsFieldFollowPointer><B>ddIsFieldFollowPointer</B></A> (<A HREF=#mgcode>mgcode</A> <I>rcode</I>, <A HREF=#mgcode>mgcode</A> <I>fcode</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#ddIsFlt><B>ddIsFlt</B></A> (<A HREF=#mgcode>mgcode</A> <I>code</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#ddIsLegalXcode><B>ddIsLegalXcode</B></A> (<A HREF=#mgcode>mgcode</A> <I>parentCode</I>, <A HREF=#mgcode>mgcode</A> <I>code</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#ddIsRangeSet><B>ddIsRangeSet</B></A> (<A HREF=#mgcode>mgcode</A> <I>dcode</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#ddIsRcode><B>ddIsRcode</B></A> (<A HREF=#mgcode>mgcode</A> <I>code</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#ddIsSearch><B>ddIsSearch</B></A> (<A HREF=#mgcode>mgcode</A> <I>code</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcode>mgcode</A> <TD><A HREF=#ddLabelToCode><B>ddLabelToCode</B></A> (const char* <I>label</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcode>mgcode</A> <TD><A HREF=#ddNameToCode><B>ddNameToCode</B></A> (const char* <I>name</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=ONLINEHELPFUNC><H1>Online Help Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgGuiSetHelpContext><B>mgGuiSetHelpContext</B></A> (<A HREF=#mggui>mggui</A> <I>gui</I>, const <A HREF=#mghelpcontext>mghelpcontext</A> <I>helpContext</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgGuiSetToolTip><B>mgGuiSetToolTip</B></A> (<A HREF=#mggui>mggui</A> <I>control</I>, const char* <I>toolTip</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgPluginSetHelpContext><B>mgPluginSetHelpContext</B></A> (<A HREF=#mgplugin>mgplugin</A> <I>plugin</I>, const <A HREF=#mghelpcontext>mghelpcontext</A> <I>helpContext</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgRegisterHelpFile><B>mgRegisterHelpFile</B></A> (<A HREF=#mgplugin>mgplugin</A> <I>plugin</I>, const char* <I>helpFile</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgShowHelpContext><B>mgShowHelpContext</B></A> (<A HREF=#mgplugin>mgplugin</A> <I>plugin</I>, const <A HREF=#mghelpcontext>mghelpcontext</A> <I>helpContext</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=LICENSEFUNC><H1>License Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgCheckinLicense><B>mgCheckinLicense</B></A> (<A HREF=#mglicense>mglicense</A> <I>license</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgCheckoutLicense><B>mgCheckoutLicense</B></A> (<A HREF=#mglicense>mglicense</A> <I>license</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgFreeLicense><B>mgFreeLicense</B></A> (<A HREF=#mglicense>mglicense</A> <I>license</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgGetLicenseCustomerID><B>mgGetLicenseCustomerID</B></A> (<A HREF=#mglicense>mglicense</A> <I>license</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgGetLicenseVendorString><B>mgGetLicenseVendorString</B></A> (<A HREF=#mglicense>mglicense</A> <I>license</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mglicense>mglicense</A> <TD><A HREF=#mgNewLicense><B>mgNewLicense</B></A> (const char* <I>licenseName</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=TEXTUREFUNC><H1>Texture Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgCopyTexture><B>mgCopyTexture</B></A> (<A HREF=#mgrec>mgrec*</A> <I>dstDb</I>, <A HREF=#mgrec>mgrec*</A> <I>srcDb</I>, const char* <I>newTextureName</I>, int <I>srcIndex</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgCopyTexturePalette><B>mgCopyTexturePalette</B></A> (<A HREF=#mgrec>mgrec*</A> <I>dstDb</I>, <A HREF=#mgrec>mgrec*</A> <I>srcDb</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgDeleteTexture><B>mgDeleteTexture</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgDeselectAllTextures><B>mgDeselectAllTextures</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgDeselectTextureIndex><B>mgDeselectTextureIndex</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgFlipImage><B>mgFlipImage</B></A> (unsigned char* <I>pixels</I>, int <I>width</I>, int <I>height</I>, int <I>type</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgFreeImageGeoInfo><B>mgFreeImageGeoInfo</B></A> (<A HREF=#mgimagegeoinfo>mgimagegeoinfo</A> <I>geoInfo</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgFreeImageInfo><B>mgFreeImageInfo</B></A> (<A HREF=#mgimageinfo>mgimageinfo</A> <I>textureInfo</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgGeoCoordAdd><B>mgGeoCoordAdd</B></A> (<A HREF=#mgrec>mgrec*</A> <I>imgRec</I>, <A HREF=#mggeocoorddata>mggeocoorddata</A> <I>geoCoordData[]</I>, int <I>n</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgGeoCoordCount><B>mgGeoCoordCount</B></A> (<A HREF=#mgrec>mgrec*</A> <I>imgRec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGeoCoordDelete><B>mgGeoCoordDelete</B></A> (<A HREF=#mgrec>mgrec*</A> <I>imgRec</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgGeoCoordGet><B>mgGeoCoordGet</B></A> (<A HREF=#mgrec>mgrec*</A> <I>imgRec</I>, <A HREF=#mggeocoorddata>mggeocoorddata</A> <I>geoCoordData[]</I>, int <I>arrayLen</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetCurrentSubTexture><B>mgGetCurrentSubTexture</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetCurrentTexture><B>mgGetCurrentTexture</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetCurrentTextureLayer><B>mgGetCurrentTextureLayer</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int* <I>layer</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetFirstSelectedTexture><B>mgGetFirstSelectedTexture</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int* <I>index</I>, char* <I>textureName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetFirstTexture><B>mgGetFirstTexture</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int* <I>index</I>, char* <I>textureName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgGetImageRowWidth><B>mgGetImageRowWidth</B></A> (int <I>width</I>, int <I>sampleSize</I>, int <I>type</I>, int* <I>pad</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetNextSelectedTexture><B>mgGetNextSelectedTexture</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int* <I>index</I>, char* <I>textureName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetNextTexture><B>mgGetNextTexture</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int* <I>index</I>, char* <I>textureName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgGetSelectedTextureCount><B>mgGetSelectedTextureCount</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetTextureAttributes><B>mgGetTextureAttributes</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgGetTextureCount><B>mgGetTextureCount</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetTextureGeoCtlPt><B>mgGetTextureGeoCtlPt</B></A> (<A HREF=#mgimagegeoinfo>mgimagegeoinfo</A> <I>geoInfo</I>, int <I>index</I>, double* <I>imageX</I>, double* <I>imageY</I>, double* <I>projX</I>, double* <I>projY</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetTextureGeoEarthModel><B>mgGetTextureGeoEarthModel</B></A> (<A HREF=#mgimagegeoinfo>mgimagegeoinfo</A> <I>geoInfo</I>, int* <I>earthModel</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetTextureGeoImageOrigin><B>mgGetTextureGeoImageOrigin</B></A> (<A HREF=#mgimagegeoinfo>mgimagegeoinfo</A> <I>geoInfo</I>, int* <I>imageOrigin</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetTextureGeoNumCtlPts><B>mgGetTextureGeoNumCtlPts</B></A> (<A HREF=#mgimagegeoinfo>mgimagegeoinfo</A> <I>geoInfo</I>, int* <I>numCoords</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetTextureGeoProjection><B>mgGetTextureGeoProjection</B></A> (<A HREF=#mgimagegeoinfo>mgimagegeoinfo</A> <I>geoInfo</I>, int* <I>projection</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetTextureGeoType><B>mgGetTextureGeoType</B></A> (<A HREF=#mgimagegeoinfo>mgimagegeoinfo</A> <I>geoInfo</I>, int* <I>type</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetTextureGeoUTMHemisphere><B>mgGetTextureGeoUTMHemisphere</B></A> (<A HREF=#mgimagegeoinfo>mgimagegeoinfo</A> <I>geoInfo</I>, int* <I>hemisphere</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetTextureGeoUTMZone><B>mgGetTextureGeoUTMZone</B></A> (<A HREF=#mgimagegeoinfo>mgimagegeoinfo</A> <I>geoInfo</I>, int* <I>zone</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetTextureHeight><B>mgGetTextureHeight</B></A> (<A HREF=#mgimageinfo>mgimageinfo</A> <I>textureInfo</I>, int* <I>height</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgGetTextureIndex><B>mgGetTextureIndex</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>textureName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetTextureMinMax><B>mgGetTextureMinMax</B></A> (<A HREF=#mgimageinfo>mgimageinfo</A> <I>textureInfo</I>, float* <I>min</I>, float* <I>max</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgGetTextureName><B>mgGetTextureName</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetTexturePosition><B>mgGetTexturePosition</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>, int* <I>x</I>, int* <I>y</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetTextureSampleSize><B>mgGetTextureSampleSize</B></A> (<A HREF=#mgimageinfo>mgimageinfo</A> <I>textureInfo</I>, int* <I>sampleSize</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgGetTextureSaveName><B>mgGetTextureSaveName</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetTextureSignedFlag><B>mgGetTextureSignedFlag</B></A> (<A HREF=#mgimageinfo>mgimageinfo</A> <I>textureInfo</I>, <A HREF=#mgbool>mgbool*</A> <I>isSigned</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgGetTextureSize><B>mgGetTextureSize</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">unsigned char* <TD><A HREF=#mgGetTextureTexels><B>mgGetTextureTexels</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetTextureTiledFlag><B>mgGetTextureTiledFlag</B></A> (<A HREF=#mgimageinfo>mgimageinfo</A> <I>textureInfo</I>, <A HREF=#mgbool>mgbool*</A> <I>isTiled</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgGetTextureTotalSize><B>mgGetTextureTotalSize</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetTextureTransparentValue><B>mgGetTextureTransparentValue</B></A> (<A HREF=#mgimageinfo>mgimageinfo</A> <I>textureInfo</I>, int* <I>transparentValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetTextureType><B>mgGetTextureType</B></A> (<A HREF=#mgimageinfo>mgimageinfo</A> <I>textureInfo</I>, int* <I>type</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetTextureWidth><B>mgGetTextureWidth</B></A> (<A HREF=#mgimageinfo>mgimageinfo</A> <I>textureInfo</I>, int* <I>width</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgHasTextureTransparentValue><B>mgHasTextureTransparentValue</B></A> (<A HREF=#mgimageinfo>mgimageinfo</A> <I>textureInfo</I>, <A HREF=#mgbool>mgbool*</A> <I>hasTransparentValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgInsertTexture><B>mgInsertTexture</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>textureName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgInsertTextureAndAlpha><B>mgInsertTextureAndAlpha</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>textureName</I>, const char* <I>alphaName</I>, const char* <I>mergeName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgIsTextureDefault><B>mgIsTextureDefault</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgIsTextureIndexInPalette><B>mgIsTextureIndexInPalette</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgIsTextureIndexSelected><B>mgIsTextureIndexSelected</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgIsTextureInPalette><B>mgIsTextureInPalette</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>textureName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgMoveTexture><B>mgMoveTexture</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>srcIndex</I>, int <I>dstIndex</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgimagegeoinfo>mgimagegeoinfo</A> <TD><A HREF=#mgNewImageGeoInfo><B>mgNewImageGeoInfo</B></A> (const char* <I>textureName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgimageinfo>mgimageinfo</A> <TD><A HREF=#mgNewImageInfo><B>mgNewImageInfo</B></A> (const char* <I>textureName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgNewTexture><B>mgNewTexture</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>, unsigned char* <I>texels</I>, const char* <I>textureName</I>, <A HREF=#mgrec>mgrec*</A> <I>imgRec</I>, int <I>x</I>, int <I>y</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgPurgeTextures><B>mgPurgeTextures</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgReadImage><B>mgReadImage</B></A> (const char* <I>textureName</I>, unsigned char** <I>pixels</I>, int* <I>type</I>, int* <I>width</I>, int* <I>height</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgReadImageAttributes><B>mgReadImageAttributes</B></A> (const char* <I>textureName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgReadImageGeoInfo><B>mgReadImageGeoInfo</B></A> (const char* <I>textureName</I>, <A HREF=#mgimagegeoinfo>mgimagegeoinfo*</A> <I>geoInfo</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgReadImageHeader><B>mgReadImageHeader</B></A> (const char* <I>textureName</I>, int* <I>type</I>, int* <I>width</I>, int* <I>height</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgReadImageInfo><B>mgReadImageInfo</B></A> (const char* <I>textureName</I>, <A HREF=#mgimageinfo>mgimageinfo*</A> <I>textureInfo</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgReadTexture><B>mgReadTexture</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>textureName</I>, int <I>index</I>, int <I>x</I>, int <I>y</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgReadTextureAndAlpha><B>mgReadTextureAndAlpha</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>textureName</I>, const char* <I>alphaName</I>, const char* <I>mergeName</I>, int <I>index</I>, int <I>x</I>, int <I>y</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgReadTexturePalette><B>mgReadTexturePalette</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>fileName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgReplaceTexture><B>mgReplaceTexture</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>, const char* <I>textureName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgstatus>mgstatus</A> <TD><A HREF=#mgSelectTextureIndex><B>mgSelectTextureIndex</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetCurrentSubTexture><B>mgSetCurrentSubTexture</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetCurrentTexture><B>mgSetCurrentTexture</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetCurrentTextureLayer><B>mgSetCurrentTextureLayer</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>layer</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgSetTextureAttributes><B>mgSetTextureAttributes</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>, <A HREF=#mgrec>mgrec*</A> <I>imgRec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetTextureGeoCtlPt><B>mgSetTextureGeoCtlPt</B></A> (<A HREF=#mgimagegeoinfo>mgimagegeoinfo</A> <I>geoInfo</I>, int <I>index</I>, double <I>imageX</I>, double <I>imageY</I>, double <I>projX</I>, double <I>projY</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetTextureGeoEarthModel><B>mgSetTextureGeoEarthModel</B></A> (<A HREF=#mgimagegeoinfo>mgimagegeoinfo</A> <I>geoInfo</I>, int <I>earthModel</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetTextureGeoImageOrigin><B>mgSetTextureGeoImageOrigin</B></A> (<A HREF=#mgimagegeoinfo>mgimagegeoinfo</A> <I>geoInfo</I>, int <I>imageOrigin</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetTextureGeoNumCtlPts><B>mgSetTextureGeoNumCtlPts</B></A> (<A HREF=#mgimagegeoinfo>mgimagegeoinfo</A> <I>geoInfo</I>, int <I>numCoords</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetTextureGeoProjection><B>mgSetTextureGeoProjection</B></A> (<A HREF=#mgimagegeoinfo>mgimagegeoinfo</A> <I>geoInfo</I>, int <I>projection</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetTextureGeoType><B>mgSetTextureGeoType</B></A> (<A HREF=#mgimagegeoinfo>mgimagegeoinfo</A> <I>geoInfo</I>, int <I>type</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetTextureGeoUTMHemisphere><B>mgSetTextureGeoUTMHemisphere</B></A> (<A HREF=#mgimagegeoinfo>mgimagegeoinfo</A> <I>geoInfo</I>, int <I>hemisphere</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetTextureGeoUTMZone><B>mgSetTextureGeoUTMZone</B></A> (<A HREF=#mgimagegeoinfo>mgimagegeoinfo</A> <I>geoInfo</I>, int <I>zone</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetTextureHeight><B>mgSetTextureHeight</B></A> (<A HREF=#mgimageinfo>mgimageinfo</A> <I>textureInfo</I>, int <I>height</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetTextureMinMax><B>mgSetTextureMinMax</B></A> (<A HREF=#mgimageinfo>mgimageinfo</A> <I>textureInfo</I>, float <I>min</I>, float <I>max</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgSetTextureName><B>mgSetTextureName</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>, const char* <I>textureName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgSetTexturePosition><B>mgSetTexturePosition</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>, int <I>x</I>, int <I>y</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetTextureSampleSize><B>mgSetTextureSampleSize</B></A> (<A HREF=#mgimageinfo>mgimageinfo</A> <I>textureInfo</I>, int <I>sampleSize</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetTextureSignedFlag><B>mgSetTextureSignedFlag</B></A> (<A HREF=#mgimageinfo>mgimageinfo</A> <I>textureInfo</I>, <A HREF=#mgbool>mgbool</A> <I>isSigned</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgSetTextureTexels><B>mgSetTextureTexels</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>, unsigned char* <I>texels</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetTextureTiledFlag><B>mgSetTextureTiledFlag</B></A> (<A HREF=#mgimageinfo>mgimageinfo</A> <I>textureInfo</I>, <A HREF=#mgbool>mgbool</A> <I>isTiled</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetTextureTransparentValue><B>mgSetTextureTransparentValue</B></A> (<A HREF=#mgimageinfo>mgimageinfo</A> <I>textureInfo</I>, int <I>transparentValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetTextureType><B>mgSetTextureType</B></A> (<A HREF=#mgimageinfo>mgimageinfo</A> <I>textureInfo</I>, int <I>type</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetTextureWidth><B>mgSetTextureWidth</B></A> (<A HREF=#mgimageinfo>mgimageinfo</A> <I>textureInfo</I>, int <I>width</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgSubTextureAdd><B>mgSubTextureAdd</B></A> (<A HREF=#mgrec>mgrec*</A> <I>imgRec</I>, <A HREF=#mgsubtexturedata>mgsubtexturedata</A> <I>subTextureData[]</I>, int <I>n</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgSubTextureCount><B>mgSubTextureCount</B></A> (<A HREF=#mgrec>mgrec*</A> <I>imgRec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSubTextureDelete><B>mgSubTextureDelete</B></A> (<A HREF=#mgrec>mgrec*</A> <I>imgRec</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgSubTextureGet><B>mgSubTextureGet</B></A> (<A HREF=#mgrec>mgrec*</A> <I>imgRec</I>, <A HREF=#mgsubtexturedata>mgsubtexturedata</A> <I>subTextureData[]</I>, int <I>arrayLen</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSubTextureGetBounds><B>mgSubTextureGetBounds</B></A> (<A HREF=#mgrec>mgrec*</A> <I>imgRec</I>, int* <I>left</I>, int* <I>bottom</I>, int* <I>right</I>, int* <I>top</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgfilelocatorfunc>mgfilelocatorfunc</A> <TD><A HREF=#mgTextureGetLocatorFunc><B>mgTextureGetLocatorFunc</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgsavepathtype>mgsavepathtype</A> <TD><A HREF=#mgTextureGetSavePathType><B>mgTextureGetSavePathType</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgTextureSetLocatorFunc><B>mgTextureSetLocatorFunc</B></A> (<A HREF=#mgfilelocatorfunc>mgfilelocatorfunc</A> <I>locatorFunc</I>, void* <I>userData</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgTextureSetSavePathType><B>mgTextureSetSavePathType</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, <A HREF=#mgsavepathtype>mgsavepathtype</A> <I>saveType</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgWriteImage><B>mgWriteImage</B></A> (const char* <I>textureName</I>, unsigned char* <I>pixels</I>, int <I>type</I>, int <I>width</I>, int <I>height</I>, <A HREF=#mgbool>mgbool</A> <I>compress</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgWriteImageAttributes><B>mgWriteImageAttributes</B></A> (const char* <I>textureName</I>, <A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgWriteTexture><B>mgWriteTexture</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>, const char* <I>textureName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgWriteTexturePalette><B>mgWriteTexturePalette</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>fileName</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=EXTENSIONFUNC><H1>Extension Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgExtensionFieldAdd><B>mgExtensionFieldAdd</B></A> (const char* <I>siteGuid</I>, const char* <I>fieldGuid</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgExtensionFieldDefined><B>mgExtensionFieldDefined</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, const char* <I>fieldGuid</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgExtensionFieldDelete><B>mgExtensionFieldDelete</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, const char* <I>fieldGuid</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgExtensionFieldDeleteAll><B>mgExtensionFieldDeleteAll</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgcode>mgcode</A> <TD><A HREF=#mgExtensionFieldGetAttach><B>mgExtensionFieldGetAttach</B></A> (const char* <I>fieldGuid</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgExtensionFieldGetBool><B>mgExtensionFieldGetBool</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, const char* <I>fieldGuid</I>, <A HREF=#mgbool>mgbool*</A> <I>fieldValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgExtensionFieldGetDouble><B>mgExtensionFieldGetDouble</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, const char* <I>fieldGuid</I>, double* <I>fieldValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgExtensionFieldGetFloat><B>mgExtensionFieldGetFloat</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, const char* <I>fieldGuid</I>, float* <I>fieldValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgExtensionFieldGetInteger><B>mgExtensionFieldGetInteger</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, const char* <I>fieldGuid</I>, int* <I>fieldValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgExtensionFieldGetName><B>mgExtensionFieldGetName</B></A> (const char* <I>fieldGuid</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgExtensionFieldGetString><B>mgExtensionFieldGetString</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, const char* <I>fieldGuid</I>, char** <I>fieldValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgtagtype>mgtagtype</A> <TD><A HREF=#mgExtensionFieldGetType><B>mgExtensionFieldGetType</B></A> (const char* <I>fieldGuid</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgExtensionFieldGetXMLString><B>mgExtensionFieldGetXMLString</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, const char* <I>fieldGuid</I>, char** <I>fieldValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgExtensionFieldSetAttach><B>mgExtensionFieldSetAttach</B></A> (const char* <I>fieldGuid</I>, <A HREF=#mgcode>mgcode</A> <I>attach</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgExtensionFieldSetBool><B>mgExtensionFieldSetBool</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, const char* <I>fieldGuid</I>, <A HREF=#mgbool>mgbool</A> <I>fieldValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgExtensionFieldSetDouble><B>mgExtensionFieldSetDouble</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, const char* <I>fieldGuid</I>, double <I>fieldValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgExtensionFieldSetFloat><B>mgExtensionFieldSetFloat</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, const char* <I>fieldGuid</I>, float <I>fieldValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgExtensionFieldSetInteger><B>mgExtensionFieldSetInteger</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, const char* <I>fieldGuid</I>, int <I>fieldValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgExtensionFieldSetName><B>mgExtensionFieldSetName</B></A> (const char* <I>fieldGuid</I>, const char* <I>name</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgExtensionFieldSetString><B>mgExtensionFieldSetString</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, const char* <I>fieldGuid</I>, const char* <I>fieldValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgExtensionFieldSetType><B>mgExtensionFieldSetType</B></A> (const char* <I>fieldGuid</I>, <A HREF=#mgtagtype>mgtagtype</A> <I>type</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgExtensionFieldSetXMLString><B>mgExtensionFieldSetXMLString</B></A> (<A HREF=#mgrec>mgrec*</A> <I>rec</I>, const char* <I>fieldGuid</I>, const char* <I>fieldValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgExtensionMakeGUID><B>mgExtensionMakeGUID</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgExtensionSiteAdd><B>mgExtensionSiteAdd</B></A> (const char* <I>siteGuid</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgExtensionSiteGetName><B>mgExtensionSiteGetName</B></A> (const char* <I>siteGuid</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgExtensionSiteSetName><B>mgExtensionSiteSetName</B></A> (const char* <I>siteGuid</I>, const char* <I>name</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=TXTRMAPFUNC><H1>Texture Mapping Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgDeleteTextureMapping><B>mgDeleteTextureMapping</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgDeleteTextureMappingByName><B>mgDeleteTextureMappingByName</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>name</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetCurrentTextureMapping><B>mgGetCurrentTextureMapping</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetFirstTextureMapping><B>mgGetFirstTextureMapping</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int* <I>index</I>, char* <I>textureMappingName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetNextTextureMapping><B>mgGetNextTextureMapping</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int* <I>index</I>, char* <I>textureMappingName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgGetTextureMapping><B>mgGetTextureMapping</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgGetTextureMappingCount><B>mgGetTextureMappingCount</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgGetTextureMappingMatrix><B>mgGetTextureMappingMatrix</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>, <A HREF=#mgmatrix>mgmatrix*</A> <I>textureMappingMatrix</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">char* <TD><A HREF=#mgGetTextureMappingName><B>mgGetTextureMappingName</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgGetTextureMappingType><B>mgGetTextureMappingType</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgIndexOfTextureMapping><B>mgIndexOfTextureMapping</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>name</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgIsTextureMappingInPalette><B>mgIsTextureMappingInPalette</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgrec>mgrec*</A> <TD><A HREF=#mgNewTextureMapping><B>mgNewTextureMapping</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>type</I>, const char* <I>name</I>, int* <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgReadTextureMappingFile><B>mgReadTextureMappingFile</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>fileName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgSetCurrentTextureMapping><B>mgSetCurrentTextureMapping</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, int <I>index</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgUpdateTextureMapping><B>mgUpdateTextureMapping</B></A> (<A HREF=#mgrec>mgrec*</A> <I>tmRec</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgWriteTextureMappingFile><B>mgWriteTextureMappingFile</B></A> (<A HREF=#mgrec>mgrec*</A> <I>db</I>, const char* <I>fileName</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=PREFFUNC><H1>Preference Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgModelingPrefGetDouble><B>mgModelingPrefGetDouble</B></A> (const <A HREF=#mgmodelingprefname>mgmodelingprefname</A> <I>prefName</I>, double* <I>prefValue</I>, double <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgModelingPrefGetInteger><B>mgModelingPrefGetInteger</B></A> (const <A HREF=#mgmodelingprefname>mgmodelingprefname</A> <I>prefName</I>, int* <I>prefValue</I>, int <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgModelingPrefSetDouble><B>mgModelingPrefSetDouble</B></A> (const <A HREF=#mgmodelingprefname>mgmodelingprefname</A> <I>prefName</I>, double <I>prefValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgModelingPrefSetInteger><B>mgModelingPrefSetInteger</B></A> (const <A HREF=#mgmodelingprefname>mgmodelingprefname</A> <I>prefName</I>, int <I>prefValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgPluginPrefDelete><B>mgPluginPrefDelete</B></A> (<A HREF=#mgplugin>mgplugin</A> <I>plugin</I>, const char* <I>prefName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgPluginPrefGetBool><B>mgPluginPrefGetBool</B></A> (<A HREF=#mgplugin>mgplugin</A> <I>plugin</I>, const char* <I>prefName</I>, <A HREF=#mgbool>mgbool*</A> <I>prefValue</I>, <A HREF=#mgbool>mgbool</A> <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgPluginPrefGetDouble><B>mgPluginPrefGetDouble</B></A> (<A HREF=#mgplugin>mgplugin</A> <I>plugin</I>, const char* <I>prefName</I>, double* <I>prefValue</I>, double <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgPluginPrefGetFloat><B>mgPluginPrefGetFloat</B></A> (<A HREF=#mgplugin>mgplugin</A> <I>plugin</I>, const char* <I>prefName</I>, float* <I>prefValue</I>, float <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgPluginPrefGetInteger><B>mgPluginPrefGetInteger</B></A> (<A HREF=#mgplugin>mgplugin</A> <I>plugin</I>, const char* <I>prefName</I>, int* <I>prefValue</I>, int <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgPluginPrefGetString><B>mgPluginPrefGetString</B></A> (<A HREF=#mgplugin>mgplugin</A> <I>plugin</I>, const char* <I>prefName</I>, char* <I>prefValue</I>, int <I>maxLen</I>, const char* <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgPluginPrefSetBool><B>mgPluginPrefSetBool</B></A> (<A HREF=#mgplugin>mgplugin</A> <I>plugin</I>, const char* <I>prefName</I>, <A HREF=#mgbool>mgbool</A> <I>prefValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgPluginPrefSetDouble><B>mgPluginPrefSetDouble</B></A> (<A HREF=#mgplugin>mgplugin</A> <I>plugin</I>, const char* <I>prefName</I>, double <I>prefValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgPluginPrefSetFloat><B>mgPluginPrefSetFloat</B></A> (<A HREF=#mgplugin>mgplugin</A> <I>plugin</I>, const char* <I>prefName</I>, float <I>prefValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgPluginPrefSetInteger><B>mgPluginPrefSetInteger</B></A> (<A HREF=#mgplugin>mgplugin</A> <I>plugin</I>, const char* <I>prefName</I>, int <I>prefValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgPluginPrefSetString><B>mgPluginPrefSetString</B></A> (<A HREF=#mgplugin>mgplugin</A> <I>plugin</I>, const char* <I>prefName</I>, const char* <I>prefValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgPluginToolPrefDelete><B>mgPluginToolPrefDelete</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>plugintool</I>, const char* <I>prefName</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgPluginToolPrefGetBool><B>mgPluginToolPrefGetBool</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>plugintool</I>, const char* <I>prefName</I>, <A HREF=#mgbool>mgbool*</A> <I>prefValue</I>, <A HREF=#mgbool>mgbool</A> <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgPluginToolPrefGetDouble><B>mgPluginToolPrefGetDouble</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>plugintool</I>, const char* <I>prefName</I>, double* <I>prefValue</I>, double <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgPluginToolPrefGetFloat><B>mgPluginToolPrefGetFloat</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>plugintool</I>, const char* <I>prefName</I>, float* <I>prefValue</I>, float <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgPluginToolPrefGetInteger><B>mgPluginToolPrefGetInteger</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>plugintool</I>, const char* <I>prefName</I>, int* <I>prefValue</I>, int <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgPluginToolPrefGetString><B>mgPluginToolPrefGetString</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>plugintool</I>, const char* <I>prefName</I>, char* <I>prefValue</I>, int <I>maxLen</I>, const char* <I>defaultValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgPluginToolPrefSetBool><B>mgPluginToolPrefSetBool</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>plugintool</I>, const char* <I>prefName</I>, <A HREF=#mgbool>mgbool</A> <I>prefValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgPluginToolPrefSetDouble><B>mgPluginToolPrefSetDouble</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>plugintool</I>, const char* <I>prefName</I>, double <I>prefValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgPluginToolPrefSetFloat><B>mgPluginToolPrefSetFloat</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>plugintool</I>, const char* <I>prefName</I>, float <I>prefValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgPluginToolPrefSetInteger><B>mgPluginToolPrefSetInteger</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>plugintool</I>, const char* <I>prefName</I>, int <I>prefValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgPluginToolPrefSetString><B>mgPluginToolPrefSetString</B></A> (<A HREF=#mgplugintool>mgplugintool</A> <I>plugintool</I>, const char* <I>prefName</I>, const char* <I>prefValue</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgSetAutoUpdatePriorityFlag><B>mgSetAutoUpdatePriorityFlag</B></A> (<A HREF=#mgbool>mgbool</A> <I>flag</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgSetCompressVertexTableFlag><B>mgSetCompressVertexTableFlag</B></A> (<A HREF=#mgbool>mgbool</A> <I>flag</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgSetFreezeLODCentersFlag><B>mgSetFreezeLODCentersFlag</B></A> (<A HREF=#mgbool>mgbool</A> <I>flag</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgSetNewOverwriteFlag><B>mgSetNewOverwriteFlag</B></A> (<A HREF=#mgbool>mgbool</A> <I>flag</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgSetOpenCreateFlag><B>mgSetOpenCreateFlag</B></A> (<A HREF=#mgbool>mgbool</A> <I>flag</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgSetReadExtFlag><B>mgSetReadExtFlag</B></A> (<A HREF=#mgbool>mgbool</A> <I>flag</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgSetReadTexturesFlag><B>mgSetReadTexturesFlag</B></A> (<A HREF=#mgbool>mgbool</A> <I>flag</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgSetSaveNonIndexedLightPoints><B>mgSetSaveNonIndexedLightPoints</B></A> (<A HREF=#mgbool>mgbool</A> <I>flag</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgSetSaveUnreferencedUVs><B>mgSetSaveUnreferencedUVs</B></A> (<A HREF=#mgbool>mgbool</A> <I>flag</I>) ;</TR>
</TABLE>
<BR>



<HR>
<A NAME=POINTERARRAYFUNC><H1>Dynamic Array/Stack Functions</H1></A>

<TABLE width="100%" border="0", cellspacing="1", cellpadding="3" ><TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgFreePtrArray><B>mgFreePtrArray</B></A> (<A HREF=#mgptrarray>mgptrarray</A> <I>ptrArray</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgFreePtrStack><B>mgFreePtrStack</B></A> (<A HREF=#mgptrstack>mgptrstack</A> <I>ptrStack</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgptrarray>mgptrarray</A> <TD><A HREF=#mgNewPtrArray><B>mgNewPtrArray</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgptrstack>mgptrstack</A> <TD><A HREF=#mgNewPtrStack><B>mgNewPtrStack</B></A> (void) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgPtrArrayAppend><B>mgPtrArrayAppend</B></A> (<A HREF=#mgptrarray>mgptrarray</A> <I>ptrArray</I>, void* <I>item</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right"><A HREF=#mgbool>mgbool</A> <TD><A HREF=#mgPtrArrayBSearch><B>mgPtrArrayBSearch</B></A> (<A HREF=#mgptrarray>mgptrarray</A> <I>ptrArray</I>, void* <I>key</I>, <A HREF=#mgptrarraycomparefunc>mgptrarraycomparefunc</A> <I>compareFunc</I>, int* <I>pos</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgPtrArrayClear><B>mgPtrArrayClear</B></A> (<A HREF=#mgptrarray>mgptrarray</A> <I>ptrArray</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void* <TD><A HREF=#mgPtrArrayGet><B>mgPtrArrayGet</B></A> (<A HREF=#mgptrarray>mgptrarray</A> <I>ptrArray</I>, int <I>pos</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgPtrArrayInsert><B>mgPtrArrayInsert</B></A> (<A HREF=#mgptrarray>mgptrarray</A> <I>ptrArray</I>, int <I>pos</I>, void* <I>item</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgPtrArrayLength><B>mgPtrArrayLength</B></A> (<A HREF=#mgptrarray>mgptrarray</A> <I>ptrArray</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void* <TD><A HREF=#mgPtrArrayRemove><B>mgPtrArrayRemove</B></A> (<A HREF=#mgptrarray>mgptrarray</A> <I>ptrArray</I>, int <I>pos</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgPtrArrayReplace><B>mgPtrArrayReplace</B></A> (<A HREF=#mgptrarray>mgptrarray</A> <I>ptrArray</I>, int <I>pos</I>, void* <I>item</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgPtrArraySearch><B>mgPtrArraySearch</B></A> (<A HREF=#mgptrarray>mgptrarray</A> <I>ptrArray</I>, void* <I>key</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgPtrArraySort><B>mgPtrArraySort</B></A> (<A HREF=#mgptrarray>mgptrarray</A> <I>ptrArray</I>, <A HREF=#mgptrarraycomparefunc>mgptrarraycomparefunc</A> <I>compareFunc</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void <TD><A HREF=#mgPtrStackClear><B>mgPtrStackClear</B></A> (<A HREF=#mgptrstack>mgptrstack</A> <I>ptrStack</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgPtrStackLength><B>mgPtrStackLength</B></A> (<A HREF=#mgptrstack>mgptrstack</A> <I>ptrStack</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void* <TD><A HREF=#mgPtrStackPop><B>mgPtrStackPop</B></A> (<A HREF=#mgptrstack>mgptrstack</A> <I>ptrStack</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">int <TD><A HREF=#mgPtrStackPush><B>mgPtrStackPush</B></A> (<A HREF=#mgptrstack>mgptrstack</A> <I>ptrStack</I>, void* <I>item</I>) ;</TR>
<TR valign="top" bgcolor="#F3F3F3">
<TD align="right">void* <TD><A HREF=#mgPtrStackTop><B>mgPtrStackTop</B></A> (<A HREF=#mgptrstack>mgptrstack</A> <I>ptrStack</I>) ;</TR>
</TABLE>
<BR>

<HTML>

<HEAD>

<TITLE>OpenFlight API FAQ</TITLE>

<STYLE type='text/css'>
PRE.EXAMPLE {background-color: #F1F1F1; padding: 2px; border: 1px solid #D1D1D1; font-family: monospace;}
TABLE.SYNOPSIS {font-family: monospace;}
TABLE.SIMPLE {border: 1px solid #D1D1D1; border-collapse: collapse;}
TD.BORDER {border: 1px solid #D1D1D1; padding: 2px;}
TR.HEADER {background-color: #F1F1F1; font-weight: bold;}
SPAN.MONOSPACE {font-family: monospace;}
TD.QUESTION {font-size: large; font-weight: bold; background-color: #C2C7E2;}
TABLE.FAQ {width:100%; border: 1px solid #D1D1D1; padding: 1px;}
LI.NOINDENT {margin-left: 0px;}
IMG {margin:5px 0px;}
H1.APISYMBOL {background-color:#F1F1F1; color:#326db9;}
H1 {color:#326db9;}
H2 {color:#326db9;}
H3 {color:#326db9;}
H4 {color:#326db9;}
H5 {color:#326db9;}
</STYLE>

</HEAD>

<BODY bgcolor="#FFFFFF" text="#000000">
<A NAME=top></A><HR>

<HR>
<A NAME=OpenFlight_API_FAQ><H1>OpenFlight API FAQ</H1></A><P>
 <P>
This section contains answers to <B>Frequently Asked Questions</B> regarding the OpenFlight API, 
OpenFlight Script and the OpenFlight File Format.<P>
<H2>Questions</H2><P>
<A HREF=#FAQ_00000000>What is the OpenFlight API?</A><BR><A HREF=#FAQ_00000001>What is OpenFlight Script?</A><BR><A HREF=#FAQ_00000002>What is Creator Script?</A><BR><A HREF=#FAQ_00000003>What is the OpenFlight Scene Graph?</A><BR><A HREF=#FAQ_00000004>Is there a user forum on the web devoted to OpenFlight?</A><BR><A HREF=#FAQ_00000005>Are newer versions of the OpenFlight API backward compatible with older versions?</A><BR><A HREF=#FAQ_00000010>Why do I get a Stack Overflow when I open a database in my stand-alone program?</A><BR><A HREF=#FAQ_00000011>What does "SmartHeap Library - Out of Memory" error mean?</A><BR><A HREF=#FAQ_00000012>When I run my stand-alone application, the wrong version of the OpenFlight API runs. Why?</A><BR><A HREF=#FAQ_00000013>How do I control which plug-ins load when I run my stand-alone application or Creator?</A><BR><A HREF=#FAQ_00000100>How do I run OpenFlight Scripts in a stand-alone program environment?</A><BR><A HREF=#FAQ_00000101>How do I run OpenFlight Scripts in Creator?</A><BR><A HREF=#FAQ_00000102>Why are some OpenFlight API function signatures different in C and OpenFlight Script?</A><BR><A HREF=#FAQ_00000103>Are there any OpenFlight Script samples I can start with?</A><BR><A HREF=#FAQ_00000104>Can I invoke Creator tools from the OpenFlight API or OpenFlight Script?</A><BR><A HREF=#FAQ_00000105>Why don't I have to "free" dynamically allocated memory in OpenFlight Script?</A><BR><A HREF=#FAQ_00000200>What format revisions of OpenFlight does the OpenFlight API support?</A><BR><A HREF=#FAQ_00000201>How do I load an OpenFlight file into memory?</A><BR><A HREF=#FAQ_00000202>How do I create a brand new, empty, OpenFlight file in memory?</A><BR><A HREF=#FAQ_00000205>After making changes to the OpenFlight file in memory, how do I save my changes to disk?</A><BR><A HREF=#FAQ_00000206>If I change an OpenFlight file in memory, how do I discard those changes so they are not saved?</A><BR><A HREF=#FAQ_00000207>How do I save my changes to an OpenFlight file with a different file name?</A><BR><A HREF=#FAQ_00000208>If I save my changes to an OpenFlight file, which OpenFlight format revision will be written?</A><BR><A HREF=#FAQ_00000209>I want to save my OpenFlight file to a different OpenFlight format revision - How do I do that?</A><BR><A HREF=#FAQ_00000210>Can I save the OpenFlight file as a different format, like Wavefront OBJ or AutoCAD DXF?</A><BR><A HREF=#FAQ_00001000>What is an mgrec?</A><BR><A HREF=#FAQ_00001001>What is the OpenFlight Data Dictionary?</A><BR><A HREF=#FAQ_00001002>How can I tell what kind of record I have in an mgrec?</A><BR><A HREF=#FAQ_00001003>How do I get the attributes of a record in the database?</A><BR><A HREF=#FAQ_00001004>How do I set the attributes of a record in the database?</A><BR><A HREF=#FAQ_00001005>How do I get a string attribute of a record in the database?</A><BR><A HREF=#FAQ_00001006>How do I access a value in a record nested inside another record?</A><BR><A HREF=#FAQ_00001007>What is the best way to get the coordinates (position) of a vertex node record?</A><BR><A HREF=#FAQ_00001008>How do I get or set the comment attribute of a node record?</A><BR><A HREF=#FAQ_00001009>What is the difference between Color Index/Intensity and Creator Color Index attributes?</A><BR><A HREF=#FAQ_00001010>When I set a color intensity attribute on a node, the value I see on the node is not the exact value I set. Why is there a difference?</A><BR><A HREF=#FAQ_00001011>How do I set up texture on a polygon?</A><BR><A HREF=#FAQ_00001012>How do I determine the OpenFlight revision level of an OpenFlight database?</A><BR><A HREF=#FAQ_00001013>Can I query the OpenFlight revision level of an OpenFlight file on disk without opening it?</A><BR><A HREF=#FAQ_00001014>How do I set a color name on a polygon or mesh?</A><BR><A HREF=#FAQ_00001015>How do I set the normal of a polygon?</A><BR><A HREF=#FAQ_00001016>Which side of a polygon is the front and which is the back?</A><BR><A HREF=#FAQ_00001017>How do I access an edge of a polygon?</A><BR><A HREF=#FAQ_00001018>How do I select an edge of a polygon in Creator?</A><BR><A HREF=#FAQ_00001020>How do I tell if a specific node is selected in Creator?</A><BR><A HREF=#FAQ_00001021>How do I get the list of nodes that are currently selected in Creator?</A><BR><A HREF=#FAQ_00001022>How do I tell if an edge of a polygon is selected in Creator?</A><BR><A HREF=#FAQ_00001023>Why are the nodes in the select list in reverse order from how they were selected by the user in Creator?</A><BR><A HREF=#FAQ_00001024>How do I select nodes from my plug-in or script in Creator?</A><BR><A HREF=#FAQ_00001030>How do I get the current modeling mode set in Creator?</A><BR><A HREF=#FAQ_00001031>How do I tell the difference between vertex and edge modeling mode in Creator?</A><BR><A HREF=#FAQ_00001032>How do I change the modeling mode in Creator from my plug-in or script?</A><BR><A HREF=#FAQ_00001040>When I try to attach a node in the database hierarchy, sometimes it fails. What could be causing this?</A><BR><A HREF=#FAQ_00001041>Why can't I move a node from one database to another?</A><BR><A HREF=#FAQ_00001042>How do I create a new node in a database?</A><BR><A HREF=#FAQ_00001043>How do I create an external reference in a master database?</A><BR><A HREF=#FAQ_00001044>How do I create a simple polygon with vertices?</A><BR><A HREF=#FAQ_00001050>How do I apply a matrix (transformation) to a node?</A><BR><A HREF=#FAQ_00001051>How do I get the matrix (transformation) from a node?</A><BR><A HREF=#FAQ_00001080>What order does mgWalk visit the nodes in the hierarchy?</A><BR><A HREF=#FAQ_00001090>How do I hide or show a node in the Creator Graphics view?</A><BR><A HREF=#FAQ_00001100>If I change the position of a vertex, is there an easy way to recalculate its texture coordinates to match the original texture mapping?</A><BR>
<LEFT><A NAME=FAQ_00000000></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">What is the OpenFlight API?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>The Presagis OpenFlight API is a set of C Language header files and libraries 
that provides a programming interface to the OpenFlight database format as well 
as the Creator modeling system. The OpenFlight API provides functions to read 
and/or modify existing databases as well as those to create new databases. 
Using the OpenFlight API, you can create:<P>
<UL>
 
<LI CLASS="NOINDENT">
 Translators to and from the OpenFlight format </LI>
 
<LI CLASS="NOINDENT">
 Real-time simulators and games </LI>
 
<LI CLASS="NOINDENT">
 Modeling applications </LI>
 
<LI CLASS="NOINDENT">
 Plug-ins that extend the functionality of Creator </LI>
 
</UL>
</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00000001>What is OpenFlight Script?</A><BR>
 
<A HREF=#FAQ_00000104>Can I invoke Creator tools from the OpenFlight API or OpenFlight Script?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00000001></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">What is OpenFlight Script?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>OpenFlight Script is a cross-platform Python Language binding to the C Language 
OpenFlight API. Based on the Python scripting language, OpenFlight Script provides 
nearly all the functionality of the OpenFlight API levels 1 and 2 and much of the 
functionality of level 4. If you understand the concepts of the 
OpenFlight API, you will find programming in either the C Language API or OpenFlight 
Script very similar.  Both the C Language OpenFlight API and the Python Language bindings 
for OpenFlight Script are included when you install the OpenFlight API Software Development 
Kit (SDK).</P></DT><DT><P>You can use OpenFlight Script to do most things you could otherwise do with the C Language 
API. Because OpenFlight Script is an interpreted language (based on Python), tools and 
applications written in OpenFlight Script will likely run more slowly than comparable tools 
written using the C Language API.  So if performance is an issue, consider using the C 
Language API. Of course the benefit of using OpenFlight Script is that you don't need 
to pre-compile your tools, you can simply run them.</P></DT><DT><P>You can use OpenFlight Script in either the stand-alone program environment or the 
Creator modeling system. 
In the Creator modeling system, you can execute Creator tools using OpenFlight Script 
using <A HREF=#mgExecute>mgExecute</A>.</P></DT><DT><P>A general knowledge of Python will help you get started quickly using OpenFlight Script.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExecute>mgExecute</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00000002>What is Creator Script?</A><BR>
 
<A HREF=#FAQ_00000104>Can I invoke Creator tools from the OpenFlight API or OpenFlight Script?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00000002></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">What is Creator Script?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>Creator Script is the same as OpenFlight Script. Note that in OpenFlight Script 
you can invoke Creator tools.  An OpenFlight script that invokes a Creator tool 
is often referred to as a "Creator Script" but under the hood it is really just 
an OpenFlight Script.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00000001>What is OpenFlight Script?</A><BR>
 
<A HREF=#FAQ_00000104>Can I invoke Creator tools from the OpenFlight API or OpenFlight Script?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00000003></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">What is the OpenFlight Scene Graph?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>The OpenFlight Scene Graph is the "in memory" representation of the OpenFlight database. As the name 
implies, it is a multilevel, hierarchical <I>graph</I> structure. At the "root" (top) of the graph is a 
database header (<A HREF=#fltHeader>fltHeader</A>) node. At the bottom of the graph are vertex (<A HREF=#fltVertex>fltVertex</A>) nodes. 
In between is a number of different types of organizational nodes, like <A HREF=#fltGroup>fltGroup</A>, <A HREF=#fltObject>fltObject</A>, <A HREF=#fltLod>fltLod</A>, 
<A HREF=#fltDof>fltDof</A>, <A HREF=#fltPolgyon>fltPolgyon</A>, <A HREF=#fltMesh>fltMesh</A>, etc.</P></DT><DT><P>Your code can load OpenFlight files into a scene graph using <A HREF=#mgOpenDb>mgOpenDb</A> or create a new, empty scene 
graph using <A HREF=#mgNewDb>mgNewDb</A>. Once a scene graph is loaded, your code can modify it. You can add, delete or 
move nodes using functions like <A HREF=#mgNewRec>mgNewRec</A>, <A HREF=#mgAttach>mgAttach</A>, <A HREF=#mgDetach>mgDetach</A> and <A HREF=#mgDelete>mgDelete</A>. Your code can 
also modify node attributes using <A HREF=#mgSetAttList>mgSetAttList</A>. There are many other operations your code can perform 
on the OpenFlight Scene Graph, these are just a few.</P></DT><DT><P>After making changes to the scene graph, your code can save it to an OpenFlight file using functions 
like <A HREF=#mgWriteDb>mgWriteDb</A>, <A HREF=#mgSaveAsDb>mgSaveAsDb</A> and <A HREF=#mgExportDb>mgExportDb</A>.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001000>What is an mgrec?</A><BR>
 
<A HREF=#FAQ_00000201>How do I load an OpenFlight file into memory?</A><BR>
 
<A HREF=#FAQ_00001042>How do I create a new node in a database?</A><BR>
 
<A HREF=#FAQ_00001004>How do I set the attributes of a record in the database?</A><BR>
 
<A HREF=#FAQ_00000205>After making changes to the OpenFlight file in memory, how do I save my changes to disk?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00000004></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">Is there a user forum on the web devoted to OpenFlight?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>There are many user forums on the web devoted to all the Presagis products. 
Among them, there are 3 forums related specifically to OpenFlight. These are located at:</P></DT><DT><P><A TARGET=_blank HREF=http://www.presagis.com/standards_forum/>http://www.presagis.com/standards_forum/</A>
</P></DT><DT><P>In addition to the OpenFlight standards forum, the OpenFlight API and OpenFlight Script is 
often discussed on the Creator product forum, located at:</P></DT><DT><P><A TARGET=_blank HREF=http://www.presagis.com/peer_forum/>http://www.presagis.com/peer_forum/</A>
</P></DT></DL></DD></DL></TD></TR></TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00000005></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">Are newer versions of the OpenFlight API backward compatible with older versions?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>Yes... function signatures do not change, nor are functions or symbols removed in newer versions 
of the OpenFlight API. In most cases an application or plug-in built with an <I>older</I> version 
of the OpenFlight API will simply run with a <I>newer</I> version of the API without recompiling.</P></DT><DT><P>There are cases when this is not true.  For example, when Creator migrated from VC6 to VC8 (v3.4), 
plug-ins built with OpenFlight API v3.3 or earlier would not run in Creator 3.4.  These plug-ins 
required recompilation in order to be compatible with the new VC8 binary format.</P></DT><DT><P>When a new version of the OpenFlight API is released, we do recommend that you rebuild your plug-ins 
and applications just to be safe.</P></DT><DT><P>While functions and symbols are not removed in newer versions of the OpenFlight API (as mentioned above), 
some are deprecated when it makes sense.  A deprecated function, for example, is one for which 
an improved replacement has been developed.  The original (deprecated) function is not removed 
but we recommend that you begin using the new function.  There is a <B>Deprecated API</B> 
section in the Release Notes section of this reference document.  Refer to that section for more 
information on deprecated API.</P></DT></DL></DD></DL></TD></TR></TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00000010></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">Why am I getting a Stack Overflow when I run my stand-alone program?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>This problem is most likely related to the Stack Size of your application. 
When you build your application (in Visual Studio, for example), you set the maximum 
stack size as a linker option. This is the maximum size your program stack is allowed 
to grow during program execution. If you don't set this explicitly, you get defaults 
from your build environment (Visual Studio gives you 1MB typically by default).</P></DT><DT><P>If you are building a stand-alone program using the OpenFlight API, we recommend 
64MB for the stack size.  Due to the nature of OpenFlight database hierarchies and 
the recursive functions used in the OpenFlight API to traverse them, 
we have found that stack can get used up quickly and 64MB seems to work well. 
By the way, Creator uses a 64MB stack size so if you can open an OpenFlight file 
in Creator but not your application, this may be why.</P></DT><DT><P>If you are working in Visual Studio, check the <SPAN CLASS="MONOSPACE">/STACK</SPAN> linker option when 
building your application.  Try setting it to:</P></DT><DT><P><PRE CLASS="EXAMPLE">/STACK:64388608,65536</PRE></P></DT></DL></DD></DL></TD></TR></TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00000011></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">What does "SmartHeap Library - Out of Memory" error mean?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>The OpenFlight API uses a 3rd party memory management library called SmartHeap. 
All heap memory allocations made by the OpenFlight API are managed by SmartHeap. 
When you get this error (typically when trying to open an OpenFlight database 
using <A HREF=#mgOpenDb>mgOpenDb</A>), SmartHeap is reporting that it has run out of Virtual Memory. 
There are several possible causes for this.</P></DT><DT><P>The first thing to check is the Virtual Memory setting on your computer. 
Verify in your Windows Control Panel Settings that you have at least ~2GB Virtual 
Memory set.  If you are running a 32 bit application, any more will not be useful. 
If you are running a 64 bit application, you can increase this value if you have 
enough disk space to accommodate the swap file required.</P></DT><DT><P>On Windows XP, you can find this setting at:<BR> 
<PRE CLASS="EXAMPLE">Control Panel: Advanced: Performance: Settings: Advanced: Virtual Memory</PRE></P></DT><DT><P>On Windows 7, you can find this setting at:<BR> 
<PRE CLASS="EXAMPLE">Control Panel: System: Advanced system settings: Advanced Performance Settings: Advanced: Virtual memory</PRE></P></DT><DT><P>If you have adjusted your Virtual Memory setting and still get this error, 
it could be that the database you are loading is just too large.  If you have 
Creator, try opening it there. If your database is a master file with external 
references, try setting <A HREF=#mgSetReadExtFlag>mgSetReadExtFlag</A> to <A HREF=#mgbool>MG_FALSE</A> before opening 
the database. This tells the OpenFlight API to NOT read the external reference 
files (which would decrease the amount of virtual memory needed to load the 
database). Similarly, try setting <A HREF=#mgSetReadTexturesFlag>mgSetReadTexturesFlag</A> to <A HREF=#mgbool>MG_FALSE</A> 
as well. This tells the OpenFlight API to NOT read textures into memory when loading 
the texture palette of the database it is opening.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetReadExtFlag>mgSetReadExtFlag</A>, <A HREF=#mgSetReadTexturesFlag>mgSetReadTexturesFlag</A>, <A HREF=#mgOpenDb>mgOpenDb</A></DD></DL></TD></TR></TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00000012></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">When I run my stand-alone application, the wrong version of the OpenFlight API runs. Why?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>Even though you link your application with a specific version of the OpenFlight API <I>Link 
Libraries</I>, Windows might load a different version of the <I>Dynamic Link Libraries</I> (DLLs) if 
your runtime environment is not set up correctly.</P></DT><DT><P>First some background on how your application will find the OpenFlight API DLLs (and all 
the other DLLs it depends on) when you run it on Windows.</P></DT><DT><P>On Windows, the OpenFlight API Dynamic Link Libraries (DLLs) are required when you run your 
stand-alone application. When you run your application, Windows searches for all DLLs 
(including the OpenFlight API DLLs) in the following sequence:<P>
<OL>
<P>
<LI CLASS="NOINDENT">
 
The directory where your stand-alone executable is located. 
</LI>
<P>
<LI CLASS="NOINDENT">
 
The current directory. 
</LI>
<P>
<LI CLASS="NOINDENT">
 
The Windows system directory. The Windows function <SPAN CLASS="MONOSPACE">GetSystemDirectory</SPAN> function retrieves 
the path of this directory. 
</LI>
<P>
<LI CLASS="NOINDENT">
 
The Windows directory. The Windows function <SPAN CLASS="MONOSPACE">GetWindowsDirectory</SPAN> function retrieves the 
path of this directory. 
</LI>
<P>
<LI CLASS="NOINDENT">
 
The directories listed in the <SPAN CLASS="MONOSPACE">PATH</SPAN> environment variable. 
</LI>
<P>
</OL>
</P></DT><DT><P>Also when your application calls <A HREF=#mgInit>mgInit</A>, the OpenFlight API echoes out the version being 
run. Check the output of your program to make sure you see the version number you expect to 
make sure you are running the OpenFlight API version you intend.</P></DT><DT><P>You can also query which version of the OpenFlight API is running using <A HREF=#mgGetVersion>mgGetVersion</A>. 
The version returned by this function is the same as that echoed by <A HREF=#mgInit>mgInit</A>.</P></DT><DT><P>One final note... A useful Windows utility is <B>depends</B>.  You can run this tool on 
your executable file (.exe) and it will show you exactly which version of the DLLs will 
be found at runtime given the current configuration on your computer.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgInit>mgInit</A></DD></DL></TD></TR></TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00000013></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I control which plug-ins load when I run my stand-alone application or Creator?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>Plug-ins are loaded into the stand-alone program and Creator runtime environments 
in very similar ways. In order for a plug-in to be available in either environment, 
it must be located in or below the <I>plug-in runtime directory</I>. This is a platform 
specific directory that is accessible at runtime.</P></DT><DT><P>When the runtime environment system starts up, this directory and all 
directories below it will be searched for compatible plug-ins. All compatible plug-ins 
found will be loaded and will be accessible in the runtime environment. Since plug-in 
modules may be distributed with a host of companion files (preference file, help file, 
etc), it may be convenient to install each plug-in in its own 
subdirectory below the <I>plug-in runtime directory</I>. This is possible since the 
<I>plug-in runtime directory</I> is searched recursively.</P></DT><DT><P>Creator loads plug-ins automatically when it starts. Creator searches for plug-ins 
in the following locations (in the order listed). As soon as a folder is found in one of these 
locations, Creator stops searching for other locations and loads the plug-ins it finds in 
the first folder found.<P>
<OL>
<P>
<LI CLASS="NOINDENT">
 
The directory (or directories) specified by the environmental variable <B>PRESAGIS_CREATOR_PLUGIN_DIR</B>. 
This environmental variable may specify any accessible directory on your computer or may specify 
multiple directories using a semi-colon to delimit each path. 
</LI>
<P>
<LI CLASS="NOINDENT">
 
A directory named <A HREF=#plugins>plugins</A> in the Creator configuration folder. This folder 
is located at:<P>
<PRE CLASS="EXAMPLE">PRESAGIS_ROOT/Creator/config/plugins</PRE> 
</LI>
<P>
</OL>
</P></DT><DT><P>Plug-ins are loaded in the stand-alone program environment when your program or script 
calls the OpenFlight API function <A HREF=#mgInit>mgInit</A>. <A HREF=#mgInit>mgInit</A> searches for plug-ins in the following 
locations (in the order listed). As soon as a folder is found in one of these 
locations, <A HREF=#mgInit>mgInit</A> stops searching for other locations and loads the plug-ins it finds in 
the first folder found.<P>
<OL>
<P>
<LI CLASS="NOINDENT">
 
The directory (or directories) your program specifies when calling <A HREF=#mgSetPluginFolder>mgSetPluginFolder</A>. If you call 
this function before <A HREF=#mgInit>mgInit</A>, the location(s) you specify will be used to search 
for plug-ins. 
</LI>
<P>
<LI CLASS="NOINDENT">
 
The directory (or directories) specified by the environmental variable <B>PRESAGIS_OPENFLIGHT_PLUGIN_DIR</B>. 
This environmental variable may specify any accessible directory on your computer or may specify 
multiple directories using a semi-colon to delimit each path. 
</LI>
<P>
<LI CLASS="NOINDENT">
 
A directory named <A HREF=#plugins>plugins</A> immediately below the directory that contains the executable being run. 
</LI>
<P>
</OL>
</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetPluginFolder>mgSetPluginFolder</A>, <A HREF=#mgInit>mgInit</A></DD></DL></TD></TR></TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00000100></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I run OpenFlight Scripts in a stand-alone program environment?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>Before you can use OpenFlight Script in a stand-alone program environment, you 
will need to install a Python environment (Python 2.7.X is required) on your computer. 
There are many Python distributions available. A good place to start is:</P></DT><DT><P><A TARGET=_blank HREF=http://www.python.org>http://www.python.org</A>
</P></DT><DT><P>Remember that OpenFlight Script requires Python 2.7.X.</P></DT><DT><P>After installing a Python environment on your computer, you must tell Python where to 
locate the OpenFlight Script module. The OpenFlight Script module is comprised of the 
OpenFlight API dynamic link libraries (including <SPAN CLASS="MONOSPACE">fltdata.dll</SPAN>) and two additional 
Python specific files included in the OpenFlight API distribution. These additional Python 
files are:</P></DT><DT><P><UL>
 
<LI CLASS="NOINDENT">
 <SPAN CLASS="MONOSPACE">_mgapilib.pyd</SPAN> </LI>
 
<LI CLASS="NOINDENT">
 <SPAN CLASS="MONOSPACE">mgapilib.py</SPAN></LI>
 
</UL>
</P></DT><DT><P>Both Python files (and the dynamic link library files) are located in:</P></DT><DT><P><SPAN CLASS="MONOSPACE">$(PRESAGIS_OPENFLIGHT_API)/bin/release (Win32)</SPAN><BR> 
or<BR> 
<SPAN CLASS="MONOSPACE">$(PRESAGIS_OPENFLIGHT_API)/bin_x64/release (x64)</SPAN><BR></P></DT><DT><P>Here are the steps to make the OpenFlight Script module available in Python:<P>
<OL>
 
<LI CLASS="NOINDENT">
 
Set the <SPAN CLASS="MONOSPACE">PYTHONPATH</SPAN> environment variable to include the folder where the OpenFlight 
Script module files (dynamic link library files, <SPAN CLASS="MONOSPACE">_mgapilib.pyd</SPAN> and <SPAN CLASS="MONOSPACE">mgapilib.py</SPAN>) 
are located. 
</LI>
<P>
<LI CLASS="NOINDENT">
 
Set the <SPAN CLASS="MONOSPACE">PRESAGIS_OPENFLIGHT_SCRIPT</SPAN> environment variable to be the folder 
where the OpenFlight Script module files are located. 
</LI>
<P>
</OL>
</P></DT><DT><P>After you configure your Python environment to include the OpenFlight Script module you 
are ready to create and run OpenFlight Scripts in your stand-alone program environment.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00000101>How do I run OpenFlight Scripts in Creator?</A><BR>
 
<A HREF=#FAQ_00000103>Are there any OpenFlight Script samples I can start with?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00000101></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I run OpenFlight Scripts in Creator?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>You do not need to install Python to run OpenFlight scripts in Creator 
as Creator includes a built-in Python environment.  After installing 
Creator, you are ready to go.  If you want to use additional Python modules that 
are not included in Creator's Python environment, you will need to install Python 
as well as those additional modules.</P></DT><DT><P>Creator includes the OpenFlight Script Editor 
which allows you to create, edit, test and run scripts directly while you are 
modeling.  The OpenFlight Script Editor provides a fully functional text editor 
with advanced features like auto-completion, error highlighting and context sensitive help. 
It also provides a powerful script interpreter that helps you to create and test scripts rapidly.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00000100>How do I run OpenFlight Scripts in a stand-alone program environment?</A><BR>
 
<A HREF=#FAQ_00000103>Are there any OpenFlight Script samples I can start with?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00000102></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">Why are some OpenFlight API function signatures different in C and OpenFlight Script?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>Most of the functions in OpenFlight Script are identical in calling method and functionality 
to that of the corresponding C language API. There are a few exceptions due to the 
inherent differences between the C and Python languages. Most of these exceptions exist 
when a C language function has one or more output parameters. Output parameters are 
those that get modified in the function and hence returned to the caller. Since C functions 
have only a single return value, output parameters are commonly used for a function to 
return multiple values simultaneously.</P></DT><DT><P>In general Python does not support output parameters for functions. To compensate for this 
Python does support multiple return values for functions in the form of "lists" or "tuples". 
For C language functions that do have output parameters, there will be a different function 
signature for the Python equivalent. This is best explained by example (see below).</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>Consider the OpenFlight function <A HREF=#mgGetVtxCoord>mgGetVtxCoord</A>. In C, its function signature is: 
<PRE CLASS="EXAMPLE">mgbool mgGetVtxCoord (mgrec* vtx, double* x, double* y, double* z);</PRE> 
This C function returns 4 "bits" of information.  It returns a status (whether the function 
succeeded or failed) in the function return value.  It also returns the x, y, z coordinates 
of a vertex in the output parameters <I>x</I>, <I>y</I> and <I>z</I>, respectively.<P>
In Python, remember, output parameters are not supported. For that reason, 
the Python signature for this same function is different: 
<PRE CLASS="EXAMPLE">mgbool, x, y, z mgGetVtxCoord (mgrec* vtx)</PRE><P>
The Python version of this function returns the same 4 "bits" of information as the C version 
but uses a different "return" mechanism to pass the values back to the caller.  Because Python has 
no notion of output parameters, the Python version of <A HREF=#mgGetVtxCoord>mgGetVtxCoord</A> returns the status as well 
as the x, y and z coordinates as a list (or tuple).<P>
Note that when the C and Python signatures for an OpenFlight function differ, each signature 
is listed in the OpenFlight API Reference. When there is no difference between the C 
and Python signature for a function, a single (common) signature is listed.<P>
The syntax for calling this function in both C and Python is shown below in the examples.</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><P>Here is how you would call <A HREF=#mgGetVtxCoord>mgGetVtxCoord</A> in C:</P></DT><DT><PRE CLASS="EXAMPLE">double x, y, z;
mgbool status;
status = mgGetVtxCoord (vtx, &x, &y, &z);
if (status == MG_TRUE) {
   // x, y and z contain valid values
}</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><P>Here is how you would call <A HREF=#mgGetVtxCoord>mgGetVtxCoord</A> in Python:</P></DT><DT><PRE CLASS="EXAMPLE">status, x, y, z = mgGetVtxCoord (vtx)
if (status == MG_TRUE):
   # x, y and z contain valid values</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00000001>What is OpenFlight Script?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00000103></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">Are there any OpenFlight Script samples I can start with?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>Perhaps the easiest way to get started is to 
study the sample scripts included with the OpenFlight API distribution. These sample 
scripts are located at:</P></DT><DT><P><SPAN CLASS="MONOSPACE">$(PRESAGIS_OPENFLIGHT_API)/samples/scripts</SPAN></P></DT><DT><P>The files (immediately) in this folder are stand-alone scripts in that they are 
designed to run in a stand-alone program environment (not in Creator).</P></DT><DT><P>There are also sample scripts that are designed to run in Creator.  These mimic 
several common tools in Creator.  You can use them to see how tools 
might be implemented in OpenFlight Script.  These scripts are located at:</P></DT><DT><P><SPAN CLASS="MONOSPACE">$(PRESAGIS_OPENFLIGHT_API)/samples/scripts/creatortools</SPAN></P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00000001>What is OpenFlight Script?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00000104></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">Can I invoke Creator tools from the OpenFlight API or OpenFlight Script?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>You can execute Creator tools from your plug-in tool or OpenFlight Script in the 
Creator modeler environment using the function <A HREF=#mgExecute>mgExecute</A>.</P></DT><DT><P>Note that you cannot use this function in a stand-alone application or script.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show how you might use 
<A HREF=#mgExecute>mgExecute</A> to execute the Creator Tool <B>Translate</B>.  Use the C code 
to invoke a Creator Tool from your plugin.  Use the Python code in your 
OpenFlight script:</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">// create a parameter block for the Translate command
// the parameter block is initialized with default values
mgparamblock paramBlock = mgGetParamBlock ("Translate");

// set the values for each parameter in the block
mgParamSetDouble3 (paramBlock, "From Point", 0, 0, 0);
mgParamSetDouble3 (paramBlock, "To Point", 0, 0, 0);

// execute the Translate command using the parameters set
mgExecute ("Translate", paramBlock);</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE"># create a parameter block for the Translate command
# the parameter block is initialized with default values
paramBlock = mgGetParamBlock ("Translate")

# set the values for each parameter in the block
mgParamSetDouble3 (paramBlock, "From Point", 0, 0, 0)
mgParamSetDouble3 (paramBlock, "To Point", 0, 0, 0)

# execute the Translate command using the parameters set
mgExecute ("Translate", paramBlock)</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgExecute>mgExecute</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00000001>What is OpenFlight Script?</A><BR>
 
<A HREF=#FAQ_00000002>What is Creator Script?</A><BR>
 
<A HREF=#FAQ_00000103>Are there any OpenFlight Script samples I can start with?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00000105></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">Why don't I have to "free" dynamically allocated memory in OpenFlight Script?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>OpenFlight Script is based on the Python scripting language. Python has "automatic" 
garbage collection so your scripts do not have to explicitly free memory in the 
same way your C language code would have to.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00000001>What is OpenFlight Script?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00000200></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">What format revisions of OpenFlight does the OpenFlight API support?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>The OpenFlight API can <I>read</I> any format revision of OpenFlight going back to the early days 
when the format was called simply "Flight" and was maintained by Software Systems in the mid 1980s. 
The most recent OpenFlight format revision is 16.4.</P></DT><DT><P>You use <A HREF=#mgOpenDb>mgOpenDb</A> to read an OpenFlight file of any format revision. When you do this the file 
is read into memory into the "OpenFlight Scene Graph" format. The in memory scene graph format 
has no format revision, per se. It contains all the data necessary to write the most current (native) 
OpenFlight format revision as well as all supported past revisions. You can examine or edit 
the OpenFlight Scene Graph and then, optionally, save any changes you make.</P></DT><DT><P>The OpenFlight API can <I>write</I> only certain (newer) format revisions of OpenFlight. Those format 
revisions include:<BR> 
15.4<BR> 
15.6<BR> 
15.7<BR> 
15.8<BR> 
16.0<BR> 
16.1<BR> 
16.2<BR> 
16.3<BR> 
16.4</P></DT><DT><P>You use <A HREF=#mgWriteDb>mgWriteDb</A>, <A HREF=#mgSaveAsDb>mgSaveAsDb</A> or <A HREF=#mgExportDb>mgExportDb</A> to write (or save) an OpenFlight file.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgOpenDb>mgOpenDb</A>, <A HREF=#mgWriteDb>mgWriteDb</A>, <A HREF=#mgSaveAsDb>mgSaveAsDb</A>, <A HREF=#mgExportDb>mgExportDb</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00000201>How do I load an OpenFlight file into memory?</A><BR>
 
<A HREF=#FAQ_00000202>How do I create a brand new, empty, OpenFlight file in memory?</A><BR>
 
<A HREF=#FAQ_00001012>How do I determine the OpenFlight revision level of an OpenFlight database?</A><BR>
 
<A HREF=#FAQ_00000205>After making changes to the OpenFlight file in memory, how do I save my changes to disk?</A><BR>
 
<A HREF=#FAQ_00000206>If I change an OpenFlight file in memory, how do I discard those changes so they are not saved?</A><BR>
 
<A HREF=#FAQ_00000207>How do I save my changes to an OpenFlight file with a different file name?</A><BR>
 
<A HREF=#FAQ_00000208>If I save my changes to an OpenFlight file, which OpenFlight format revision will be written?</A><BR>
 
<A HREF=#FAQ_00000209>I want to save my OpenFlight file to a different OpenFlight format revision - How do I do that?</A><BR>
 
<A HREF=#FAQ_00000210>Can I save the OpenFlight file as a different format, like Wavefront OBJ or AutoCAD DXF?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00000201></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I load an OpenFlight file into memory?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>You use <A HREF=#mgOpenDb>mgOpenDb</A> to open and load the contents of an OpenFlight file into memory - presumably so you can 
examine or modify it. In memory, the contents of the OpenFlight file is stored in a <I>graph</I> of hierarchical 
structures, collectively known as the "OpenFlight Scene Graph". The function <A HREF=#mgOpenDb>mgOpenDb</A> returns 
the "root node" of this graph. This "root node" is called the "header" or "database header".</P></DT><DT><P>Once the file is loaded in memory, you can examine or edit nodes in the OpenFlight Scene Graph. 
If you make changes to the OpenFlight Scene Graph, you can save those changes using <A HREF=#mgWriteDb>mgWriteDb</A>, 
<A HREF=#mgSaveAsDb>mgSaveAsDb</A> or <A HREF=#mgExportDb>mgExportDb</A>. When you no longer need the file loaded in memory, you should 
close the file and deallocate all associated memory using <A HREF=#mgCloseDb>mgCloseDb</A>.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) load an OpenFlight file into memory, 
examine the OpenFlight Scene Graph (but make no changes) and then close the file.</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">// load "file.flt" into the OpenFlight Scene Graph
mgrec* db = mgOpenDb ("file.flt");

// examine the db (or parts of it)
...

// no changes, just close the file
mgCloseDb (db);</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE"># load "file.flt" into the OpenFlight Scene Graph
db = mgOpenDb ("file.flt")

# examine the db (or parts of it)
...

# no changes, just close the file
mgCloseDb (db)</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgOpenDb>mgOpenDb</A>, <A HREF=#mgWriteDb>mgWriteDb</A>, <A HREF=#mgSaveAsDb>mgSaveAsDb</A>, <A HREF=#mgExportDb>mgExportDb</A>, <A HREF=#mgCloseDb>mgCloseDb</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00000003>What is the OpenFlight Scene Graph?</A><BR>
 
<A HREF=#FAQ_00000200>What format revisions of OpenFlight does the OpenFlight API support?</A><BR>
 
<A HREF=#FAQ_00001012>How do I determine the OpenFlight revision level of an OpenFlight database?</A><BR>
 
<A HREF=#FAQ_00000205>After making changes to the OpenFlight file in memory, how do I save my changes to disk?</A><BR>
 
<A HREF=#FAQ_00000206>If I change an OpenFlight file in memory, how do I discard those changes so they are not saved?</A><BR>
 
<A HREF=#FAQ_00000207>How do I save my changes to an OpenFlight file with a different file name?</A><BR>
 
<A HREF=#FAQ_00000208>If I save my changes to an OpenFlight file, which OpenFlight format revision will be written?</A><BR>
 
<A HREF=#FAQ_00000209>I want to save my OpenFlight file to a different OpenFlight format revision - How do I do that?</A><BR>
 
<A HREF=#FAQ_00000210>Can I save the OpenFlight file as a different format, like Wavefront OBJ or AutoCAD DXF?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00000202></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I create a brand new, empty, OpenFlight file in memory?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>If you want to load an <I>existing</I> OpenFlight file into memory, you use <A HREF=#mgOpenDb>mgOpenDb</A>. If you want to create 
a <I>new</I> OpenFlight file in memory, use <A HREF=#mgNewDb>mgNewDb</A>. Both functions return a header node for the corresponding 
OpenFlight Scene Graph. The header node returned by <A HREF=#mgNewDb>mgNewDb</A> will not be completely empty. 
By convention the OpenFlight API creates two child group (<A HREF=#fltGroup>fltGroup</A>) nodes below the new db header as shown 
here:<BR> 
<IMG SRC="../common/mgNewDb.jpg">
</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) create a new OpenFlight file into memory, 
and print out the names of the two groups created.</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">// create a new OpenFlight file
mgrec* db = mgNewDb ("newfile.flt");

// get the two group nodes created by convention
mgrec* g1 = mgGetChild (db);
mgrec* g2 = mgGetChild (g1);

// get the names of these nodes
char* g1Name = mgGetName (g1);
char* g2Name = mgGetName (g2);

// print the names
printf ("g1 name: %s&#92;n", g1Name);
printf ("g2 name: %s&#92;n", g2Name);

// free the strings allocated for the names returned
mgFree (g1Name);
mgFree (g2Name);

// no changes, just close the file
mgCloseDb (db);</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE"># create a new OpenFlight file
db = mgNewDb ("newfile.flt")

# get the two group nodes created by convention
g1 = mgGetChild (db)
g2 = mgGetChild (g1)

# get the names of these nodes
g1Name = mgGetName (g1)
g2Name = mgGetName (g2)

# print the names
print "g1 name:",g1Name
print "g2 name:",g2Name

# in Python, you don't "free" the strings

# no changes, just close the file
mgCloseDb (db)</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewDb>mgNewDb</A>, <A HREF=#mgOpenDb>mgOpenDb</A>, <A HREF=#mgWriteDb>mgWriteDb</A>, <A HREF=#mgSaveAsDb>mgSaveAsDb</A>, <A HREF=#mgExportDb>mgExportDb</A>, <A HREF=#mgCloseDb>mgCloseDb</A>, 
<A HREF=#mgGetName>mgGetName</A>, <A HREF=#mgFree>mgFree</A>, <A HREF=#mgGetChild>mgGetChild</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00000003>What is the OpenFlight Scene Graph?</A><BR>
 
<A HREF=#FAQ_00000200>What format revisions of OpenFlight does the OpenFlight API support?</A><BR>
 
<A HREF=#FAQ_00001012>How do I determine the OpenFlight revision level of an OpenFlight database?</A><BR>
 
<A HREF=#FAQ_00000205>After making changes to the OpenFlight file in memory, how do I save my changes to disk?</A><BR>
 
<A HREF=#FAQ_00000206>If I change an OpenFlight file in memory, how do I discard those changes so they are not saved?</A><BR>
 
<A HREF=#FAQ_00000207>How do I save my changes to an OpenFlight file with a different file name?</A><BR>
 
<A HREF=#FAQ_00000208>If I save my changes to an OpenFlight file, which OpenFlight format revision will be written?</A><BR>
 
<A HREF=#FAQ_00000209>I want to save my OpenFlight file to a different OpenFlight format revision - How do I do that?</A><BR>
 
<A HREF=#FAQ_00000210>Can I save the OpenFlight file as a different format, like Wavefront OBJ or AutoCAD DXF?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00000205></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">After making changes to the OpenFlight file in memory, how do I save my changes to disk?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>There are several functions in the OpenFlight API to save OpenFlight files to disk. 
First, be aware that a database header node keeps track the OpenFlight file 
to which it is currently associated. You can use the function <A HREF=#mgRec2Filename>mgRec2Filename</A> 
to query this "file name".</P></DT><DT><P>To save the OpenFlight Scene Graph of a header node to the file name currently associated 
to the header node, use <A HREF=#mgWriteDb>mgWriteDb</A>. To save the file to a different file name, use 
<A HREF=#mgSaveAsDb>mgSaveAsDb</A>. To save the file to a different file name or different OpenFlight format 
revision, use <A HREF=#mgExportDb>mgExportDb</A>.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) load an OpenFlight file into memory, 
make some changes to the OpenFlight Scene Graph, save the changes to the original 
file name, make a backup copy, and then finally close the file.</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">// load "file.flt" into the OpenFlight Scene Graph
mgrec* db = mgOpenDb ("file.flt");

// make some changes to the db
...

// save the changes to file.flt
mgWriteDb (db);

// also save a copy for "backup"
mgSaveAsDb (db, "file_copy.flt");

// finally, close the file
mgCloseDb (db);</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE"># load "file.flt" into the OpenFlight Scene Graph
db = mgOpenDb ("file.flt")

# make some changes to the db
...

# save the changes to file.flt
mgWriteDb (db)

# also save a copy for "backup"
mgSaveAsDb (db, "file_copy.flt")

# finally, close the file
mgCloseDb (db)</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgOpenDb>mgOpenDb</A>, <A HREF=#mgNewDb>mgNewDb</A>, <A HREF=#mgWriteDb>mgWriteDb</A>, <A HREF=#mgSaveAsDb>mgSaveAsDb</A>, <A HREF=#mgExportDb>mgExportDb</A>, <A HREF=#mgCloseDb>mgCloseDb</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00000200>What format revisions of OpenFlight does the OpenFlight API support?</A><BR>
 
<A HREF=#FAQ_00000201>How do I load an OpenFlight file into memory?</A><BR>
 
<A HREF=#FAQ_00000202>How do I create a brand new, empty, OpenFlight file in memory?</A><BR>
 
<A HREF=#FAQ_00001012>How do I determine the OpenFlight revision level of an OpenFlight database?</A><BR>
 
<A HREF=#FAQ_00000206>If I change an OpenFlight file in memory, how do I discard those changes so they are not saved?</A><BR>
 
<A HREF=#FAQ_00000207>How do I save my changes to an OpenFlight file with a different file name?</A><BR>
 
<A HREF=#FAQ_00000208>If I save my changes to an OpenFlight file, which OpenFlight format revision will be written?</A><BR>
 
<A HREF=#FAQ_00000209>I want to save my OpenFlight file to a different OpenFlight format revision - How do I do that?</A><BR>
 
<A HREF=#FAQ_00000210>Can I save the OpenFlight file as a different format, like Wavefront OBJ or AutoCAD DXF?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00000206></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">If I change an OpenFlight file in memory, how do I discard those changes so they are not saved?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>If you make changes to the OpenFlight Scene Graph in memory, those changes are only saved to 
disk if you explicitly do so using <A HREF=#mgWriteDb>mgWriteDb</A>, <A HREF=#mgSaveAsDb>mgSaveAsDb</A>, or <A HREF=#mgExportDb>mgExportDb</A>. If you call 
<A HREF=#mgCloseDb>mgCloseDb</A> without "saving" the file first, your in-memory changes will be discarded automatically.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) open a file, make some changes but do not 
save them before closing the file. If you do this, your changes are discarded.</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* db = mgOpenDb ("file.flt");
// get the first group in the database
mgrec* g1 = mgGetChild (db);
// delete it, effectively deleting the entire contents
mgDelete (g1);

// but don't save changes... just close the file. file.flt remains intact
mgCloseDb (db);</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">db = mgOpenDb ("file.flt")
# get the first group in the database
g1 = mgGetChild (db)
# delete it, effectively deleting the entire contents
mgDelete (g1)

# but don't save changes... just close the file. file.flt remains intact
mgCloseDb (db)</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgOpenDb>mgOpenDb</A>, <A HREF=#mgNewDb>mgNewDb</A>, <A HREF=#mgWriteDb>mgWriteDb</A>, <A HREF=#mgSaveAsDb>mgSaveAsDb</A>, <A HREF=#mgExportDb>mgExportDb</A>, <A HREF=#mgCloseDb>mgCloseDb</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00000200>What format revisions of OpenFlight does the OpenFlight API support?</A><BR>
 
<A HREF=#FAQ_00000201>How do I load an OpenFlight file into memory?</A><BR>
 
<A HREF=#FAQ_00000202>How do I create a brand new, empty, OpenFlight file in memory?</A><BR>
 
<A HREF=#FAQ_00001012>How do I determine the OpenFlight revision level of an OpenFlight database?</A><BR>
 
<A HREF=#FAQ_00000205>After making changes to the OpenFlight file in memory, how do I save my changes to disk?</A><BR>
 
<A HREF=#FAQ_00000207>How do I save my changes to an OpenFlight file with a different file name?</A><BR>
 
<A HREF=#FAQ_00000208>If I save my changes to an OpenFlight file, which OpenFlight format revision will be written?</A><BR>
 
<A HREF=#FAQ_00000209>I want to save my OpenFlight file to a different OpenFlight format revision - How do I do that?</A><BR>
 
<A HREF=#FAQ_00000210>Can I save the OpenFlight file as a different format, like Wavefront OBJ or AutoCAD DXF?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00000207></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I save my changes to an OpenFlight file with a different file name?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>The function <A HREF=#mgWriteDb>mgWriteDb</A> writes a database to the file name currently associated 
to the corresponding header node. To save the database to a different file name, 
use <A HREF=#mgSaveAsDb>mgSaveAsDb</A>. Note that Once the file has been saved to a "new" name, subsequent 
calls to <A HREF=#mgWriteDb>mgWriteDb</A> will save the "new name", not the original name.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) open a file, make some changes 
and save them out to a new file.</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* db = mgOpenDb ("fileA.flt");

// make some changes to db
...

// save changes to a new file
mgSaveAsDb (db, "fileB.flt");

// make some MORE changes to db
...

// save changes again, this time using mgWriteDb
// this will save (again) to "fileB.flt"
mgWriteDb (db);

// and as always, close the database when you're done
mgCloseDb (db);</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">db = mgOpenDb ("fileA.flt")

# make some changes to db
...

# save changes to a new file
mgSaveAsDb (db, "fileB.flt")

# make some MORE changes to db
...

# save changes again, this time using mgWriteDb
# this will save (again) to "fileB.flt"
mgWriteDb (db)

# and as always, close the database when you're done
mgCloseDb (db)</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgOpenDb>mgOpenDb</A>, <A HREF=#mgNewDb>mgNewDb</A>, <A HREF=#mgWriteDb>mgWriteDb</A>, <A HREF=#mgSaveAsDb>mgSaveAsDb</A>, <A HREF=#mgExportDb>mgExportDb</A>, <A HREF=#mgCloseDb>mgCloseDb</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00000200>What format revisions of OpenFlight does the OpenFlight API support?</A><BR>
 
<A HREF=#FAQ_00000201>How do I load an OpenFlight file into memory?</A><BR>
 
<A HREF=#FAQ_00000202>How do I create a brand new, empty, OpenFlight file in memory?</A><BR>
 
<A HREF=#FAQ_00001012>How do I determine the OpenFlight revision level of an OpenFlight database?</A><BR>
 
<A HREF=#FAQ_00000205>After making changes to the OpenFlight file in memory, how do I save my changes to disk?</A><BR>
 
<A HREF=#FAQ_00000206>If I change an OpenFlight file in memory, how do I discard those changes so they are not saved?</A><BR>
 
<A HREF=#FAQ_00000208>If I save my changes to an OpenFlight file, which OpenFlight format revision will be written?</A><BR>
 
<A HREF=#FAQ_00000209>I want to save my OpenFlight file to a different OpenFlight format revision - How do I do that?</A><BR>
 
<A HREF=#FAQ_00000210>Can I save the OpenFlight file as a different format, like Wavefront OBJ or AutoCAD DXF?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00000208></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">If I save my changes to an OpenFlight file, which OpenFlight format revision will be written?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>Each version of the OpenFlight API is built for a specific OpenFlight format revision. The format 
revision built into a specific release of the OpenFlight API is often referred to as the <I>native</I> 
OpenFlight format revision of that OpenFlight API release. For example, the native OpenFlight 
format revision of OpenFlight API v14.0 is OpenFlight 16.4. So depending on which version of 
the OpenFlight API you are using, the native OpenFlight format revision of that release will 
be written by default when you use <A HREF=#mgWriteDb>mgWriteDb</A> or <A HREF=#mgSaveAsDb>mgSaveAsDb</A>.</P></DT><DT><P>As noted here, <A HREF=#mgWriteDb>mgWriteDb</A> or <A HREF=#mgSaveAsDb>mgSaveAsDb</A> will write the native OpenFlight format revision 
of the OpenFlight API version you are using. If you need to write out a specific OpenFlight 
format revision, you can use <A HREF=#mgExportDb>mgExportDb</A>.</P></DT><DT><P>The table below lists the native OpenFlight format revisions corresponding to the current 
and many past versions of the OpenFlight API.<P>
<TABLE CLASS="SIMPLE">
 
<TR CLASS="HEADER">
 
<TD CLASS="BORDER">
 OpenFlight API Version </TD>
 
<TD CLASS="BORDER">
 Native OpenFlight Format Revision </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 v14.0 </TD>
 
<TD CLASS="BORDER">
 16.4 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 v5.0 (13.0) </TD>
 
<TD CLASS="BORDER">
 16.4 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 v4.2 </TD>
 
<TD CLASS="BORDER">
 16.4 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 v4.1 </TD>
 
<TD CLASS="BORDER">
 16.4 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 v4.0 </TD>
 
<TD CLASS="BORDER">
 16.4 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 v3.5 </TD>
 
<TD CLASS="BORDER">
 16.3 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 v3.4 </TD>
 
<TD CLASS="BORDER">
 16.3 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 v3.3 </TD>
 
<TD CLASS="BORDER">
 16.2 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 v3.2 </TD>
 
<TD CLASS="BORDER">
 16.2 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 v3.1 </TD>
 
<TD CLASS="BORDER">
 16.1 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 v3.0 </TD>
 
<TD CLASS="BORDER">
 16.0 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 v2.6 </TD>
 
<TD CLASS="BORDER">
 15.8 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 v2.5 </TD>
 
<TD CLASS="BORDER">
 15.7 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 v2.4 </TD>
 
<TD CLASS="BORDER">
 15.7 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 v2.3 </TD>
 
<TD CLASS="BORDER">
 15.6 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 v2.2 </TD>
 
<TD CLASS="BORDER">
 15.6 </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 v2.1 </TD>
 
<TD CLASS="BORDER">
 15.6 </TD>
 
</TR>
<P>
</TABLE>
</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgOpenDb>mgOpenDb</A>, <A HREF=#mgNewDb>mgNewDb</A>, <A HREF=#mgWriteDb>mgWriteDb</A>, <A HREF=#mgSaveAsDb>mgSaveAsDb</A>, <A HREF=#mgExportDb>mgExportDb</A>, <A HREF=#mgCloseDb>mgCloseDb</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00000200>What format revisions of OpenFlight does the OpenFlight API support?</A><BR>
 
<A HREF=#FAQ_00000201>How do I load an OpenFlight file into memory?</A><BR>
 
<A HREF=#FAQ_00000202>How do I create a brand new, empty, OpenFlight file in memory?</A><BR>
 
<A HREF=#FAQ_00001012>How do I determine the OpenFlight revision level of an OpenFlight database?</A><BR>
 
<A HREF=#FAQ_00000205>After making changes to the OpenFlight file in memory, how do I save my changes to disk?</A><BR>
 
<A HREF=#FAQ_00000206>If I change an OpenFlight file in memory, how do I discard those changes so they are not saved?</A><BR>
 
<A HREF=#FAQ_00000207>How do I save my changes to an OpenFlight file with a different file name?</A><BR>
 
<A HREF=#FAQ_00000209>I want to save my OpenFlight file to a different OpenFlight format revision - How do I do that?</A><BR>
 
<A HREF=#FAQ_00000210>Can I save the OpenFlight file as a different format, like Wavefront OBJ or AutoCAD DXF?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00000209></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">I want to save my OpenFlight file to a different OpenFlight format revision - How do I do that?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>By default <A HREF=#mgWriteDb>mgWriteDb</A> or <A HREF=#mgSaveAsDb>mgSaveAsDb</A> will write the native OpenFlight format revision 
of the OpenFlight API version you are using. If you need to write out a different OpenFlight 
format revision, you can use <A HREF=#mgExportDb>mgExportDb</A>.</P></DT><DT><P>The OpenFlight API can export to the following OpenFlight format revisions:<BR> 
16.3<BR> 
16.2<BR> 
16.1<BR> 
16.0<BR> 
15.8<BR> 
15.7<BR> 
15.6<BR> 
15.4</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgOpenDb>mgOpenDb</A>, <A HREF=#mgNewDb>mgNewDb</A>, <A HREF=#mgWriteDb>mgWriteDb</A>, <A HREF=#mgSaveAsDb>mgSaveAsDb</A>, <A HREF=#mgExportDb>mgExportDb</A>, <A HREF=#mgCloseDb>mgCloseDb</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00000200>What format revisions of OpenFlight does the OpenFlight API support?</A><BR>
 
<A HREF=#FAQ_00000201>How do I load an OpenFlight file into memory?</A><BR>
 
<A HREF=#FAQ_00000202>How do I create a brand new, empty, OpenFlight file in memory?</A><BR>
 
<A HREF=#FAQ_00001012>How do I determine the OpenFlight revision level of an OpenFlight database?</A><BR>
 
<A HREF=#FAQ_00000205>After making changes to the OpenFlight file in memory, how do I save my changes to disk?</A><BR>
 
<A HREF=#FAQ_00000206>If I change an OpenFlight file in memory, how do I discard those changes so they are not saved?</A><BR>
 
<A HREF=#FAQ_00000207>How do I save my changes to an OpenFlight file with a different file name?</A><BR>
 
<A HREF=#FAQ_00000208>If I save my changes to an OpenFlight file, which OpenFlight format revision will be written?</A><BR>
 
<A HREF=#FAQ_00000210>Can I save the OpenFlight file as a different format, like Wavefront OBJ or AutoCAD DXF?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00000210></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">Can I save the OpenFlight file as a different format, like Wavefront OBJ or AutoCAD DXF?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>Unlike Creator, the OpenFlight API cannot export to other file formats. 
The OpenFlight API can only write the OpenFlight file format.</P></DT><DT><P>Use functions <A HREF=#mgWriteDb>mgWriteDb</A> or <A HREF=#mgSaveAsDb>mgSaveAsDb</A> to write the native OpenFlight format 
revision of the OpenFlight API version you are using. Use <A HREF=#mgExportDb>mgExportDb</A> to write 
out a different OpenFlight format revision.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgOpenDb>mgOpenDb</A>, <A HREF=#mgNewDb>mgNewDb</A>, <A HREF=#mgWriteDb>mgWriteDb</A>, <A HREF=#mgSaveAsDb>mgSaveAsDb</A>, <A HREF=#mgExportDb>mgExportDb</A>, <A HREF=#mgCloseDb>mgCloseDb</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00000200>What format revisions of OpenFlight does the OpenFlight API support?</A><BR>
 
<A HREF=#FAQ_00000201>How do I load an OpenFlight file into memory?</A><BR>
 
<A HREF=#FAQ_00000202>How do I create a brand new, empty, OpenFlight file in memory?</A><BR>
 
<A HREF=#FAQ_00001012>How do I determine the OpenFlight revision level of an OpenFlight database?</A><BR>
 
<A HREF=#FAQ_00000205>After making changes to the OpenFlight file in memory, how do I save my changes to disk?</A><BR>
 
<A HREF=#FAQ_00000206>If I change an OpenFlight file in memory, how do I discard those changes so they are not saved?</A><BR>
 
<A HREF=#FAQ_00000207>How do I save my changes to an OpenFlight file with a different file name?</A><BR>
 
<A HREF=#FAQ_00000208>If I save my changes to an OpenFlight file, which OpenFlight format revision will be written?</A><BR>
 
<A HREF=#FAQ_00000210>Can I save the OpenFlight file as a different format, like Wavefront OBJ or AutoCAD DXF?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001000></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">What is an mgrec?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>The <A HREF=#mgrec>mgrec</A> type is a generic (polymorphic) type used to access different 
types of records defined by the OpenFlight API.  Primarily, objects of type 
<A HREF=#mgrec>mgrec</A> represent nodes in the OpenFlight hierarchy.  Other objects (records) 
represented as <A HREF=#mgrec>mgrec</A> include Transformation records, Palette records, 
Bounding Box records, etc.</P></DT><DT><P>The <A HREF=#mgrec>mgrec</A> type is an opaque type.  In other words you cannot access the 
fields of this structure directly.  The OpenFlight API provides functions to 
access the fields of the records of this type.  Different functions in the 
API access different types of <A HREF=#mgrec>mgrec</A> records.  The <B>Function Categories</B> 
section of this reference document is organized (loosely) based on these different 
record types.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00000003>What is the OpenFlight Scene Graph?</A><BR>
 
<A HREF=#FAQ_00001001>What is the OpenFlight Data Dictionary?</A><BR>
 
<A HREF=#FAQ_00001002>How can I tell what kind of record I have in an mgrec?</A><BR>
 
<A HREF=#FAQ_00001003>How do I get the attributes of a record in the database?</A><BR>
 
<A HREF=#FAQ_00001004>How do I set the attributes of a record in the database?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001001></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">What is the OpenFlight Data Dictionary?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>The OpenFlight Data Dictionary is a data schema that defines the records and fields 
that comprise all the elements in an OpenFlight database.  In this way, the OpenFlight 
Data Dictionary can be thought of as a "map" that you will use to access elements 
in the OpenFlight scene.</P></DT><DT><P>Each record type defined in the OpenFlight Data Dictionary has a unique code associated 
to it.  This code is used to identify the type of record it is.  For each record type 
there is a corresponding record schema that 
defines the fields of that record.  Like a record, each field also has a unique 
code associated to it.  The definition of a record field includes its 
<B>code</B> and <B>type</B> as well as a brief description of the field.  The <B>code</B> and 
<B>type</B> of a record field are very important.  The <B>code</B> is the "key" by which 
that field is known and accessed.  The <B>type</B> tells you the kind and size of the 
data type used to hold field values.</P></DT><DT><P>The OpenFlight Data Dictionary is documented as a part of this reference document. 
You will find it a valuable resource as you develop OpenFlight API programs and 
plug-ins as well as OpenFlight scripts.</P></DT><DT><P>Here is a link to the OpenFlight Data Dictionary for you to bookmark:</P></DT><DT><P><A TARGET=_blank HREF=../openflightdd/default.htm>OpenFlight Data Dictionary</A>
</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001000>What is an mgrec?</A><BR>
 
<A HREF=#FAQ_00000003>What is the OpenFlight Scene Graph?</A><BR>
 
<A HREF=#FAQ_00001003>How do I get the attributes of a record in the database?</A><BR>
 
<A HREF=#FAQ_00001004>How do I set the attributes of a record in the database?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001002></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How can I tell what kind of record I have in an mgrec?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>As mentioned above, the <A HREF=#mgrec>mgrec</A> type is a generic type used to access different 
types of records defined by the OpenFlight API.  Since that is the case, you may not 
always know what kind of record you have in any given <A HREF=#mgrec>mgrec</A>.  For the most part, 
this should not be a problem in your code when you know where the record came 
from.  For example if the record was returned by <A HREF=#mgOpenDb>mgOpenDb</A> or <A HREF=#mgNewDb>mgNewDb</A>, 
you know it is a node record of type <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHeader</A>
.</P></DT><DT><P>There will be situations in which you don't know what kind of record you have. 
Consider this scenario.  You want to find all the polygon nodes in the scene 
and perform some action on each of them.  You would likely use <A HREF=#mgWalk>mgWalk</A> to 
visit all the nodes in a database hierarchy and when you find a polygon node, 
perform the action on each that you find.  When you use <A HREF=#mgWalk>mgWalk</A> you provide 
walk action functions that will be called for each node in the hierarchy as 
it is visited.  The node currently being visited is passed as a parameter to 
your walk action function.  To filter out all but the polygon node records, 
your action function would query the node it is passed.  In this way your 
function could simply ignore records that are not polygon nodes and process 
only those that are.</P></DT><DT><P>This is very easy to do using <A HREF=#mgGetCode>mgGetCode</A>.  You pass an <A HREF=#mgrec>mgrec</A> record to 
<A HREF=#mgGetCode>mgGetCode</A> and it returns the unique code associated to that record.  This 
code tells you exactly what kind of record you have.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show how to use <A HREF=#mgGetCode>mgGetCode</A> 
to interrogate a record <I>rec</I> for its type (<I>code</I>).  You can see how easily 
this code could be included in your walk action function and used to find 
just the polygon node records.</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">// call mgGetCode to return the "code" associated to rec
mgcode code = mgGetCode (rec);

// there are many possible record "codes"
// here are some common types

if (code == fltHeader)           // database header node
   printf ("fltHeader");
else if (code == fltGroup)       // group node
   printf ("fltGroup");
else if (code == fltObject)      // object node
   printf ("fltObject");
else if (code == fltPolygon)     // polygon node
   printf ("fltPolygon");
else if (code == fltVertex)      // vertex node
   printf ("fltVertex");
else if (code == fltXmTranslate) // translate transformation
   printf ("fltXmTranslate");
else if (code == fltFMaterial)   // material palette entry
   printf ("fltFMaterial");
else
   printf ("some other kind, there are many!!");</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE"># call mgGetCode to return the "code" associated to rec
code = mgGetCode (rec)

# there are many possible record "codes"
# here are some common types

if (code == fltHeader):        # database header node
   print "fltHeader"
elif (code == fltGroup):       # group node
   print "fltGroup"
elif (code == fltObject):      # object node
   print "fltObject"
elif (code == fltPolygon):     # polygon node
   print "fltPolygon"
elif (code == fltVertex):      # vertex node
   print "fltVertex"
elif (code == fltXmTranslate): # translate transformation
   print "fltXmTranslate"
elif (code == fltFMaterial):   # material palette entry
   print "fltFMaterial"
else:
   print "some other kind, there are many!!"</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetCode>mgGetCode</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001000>What is an mgrec?</A><BR>
 
<A HREF=#FAQ_00000003>What is the OpenFlight Scene Graph?</A><BR>
 
<A HREF=#FAQ_00001001>What is the OpenFlight Data Dictionary?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001003></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I get the attributes of a record in the database?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>The <A TARGET="_blank" HREF=../openflightdd/default.htm>OpenFlight Data Dictionary</A> defines the fields 
that are contained in any record type.  If you know what kind of 
record you have, check the <A TARGET="_blank" HREF=../openflightdd/default.htm>OpenFlight Data Dictionary</A> to see the fields that are defined 
for that record type.  You then choose which field you want to "get" 
and use one of several OpenFlight API functions to access that field data.</P></DT><DT><P>The most common function to use is <A HREF=#mgGetAttList>mgGetAttList</A>.  In its simplest 
form (to retrieve a single value), you provide a <I>rec</I>, a field <I>code</I> 
and an <I>address</I>.  The <I>rec</I> is the record you want to query. 
The <I>code</I> identifies the field whose value you want.  The <I>address</I> points 
to memory that is appropriate (in size and type) to receive the value of the 
record attribute.  Note that you can provide additional <I>code</I> and 
<I>address</I> pairs to retrieve multiple values simultaneously.</P></DT><DT><P>The <I>address</I> part can be a bit tricky.  This is where the <A TARGET="_blank" HREF=../openflightdd/default.htm>OpenFlight Data Dictionary</A> can 
really help.  Here is an excerpt from the <A TARGET="_blank" HREF=../openflightdd/default.htm>OpenFlight Data Dictionary</A> showing some of the 
fields of the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolyon>fltPolyon</A>
 record.</P></DT><DT><P><PRE CLASS="EXAMPLE">record fltPolygon { 
&nbsp;&nbsp;&nbsp;... 
&nbsp;&nbsp;&nbsp;short(2)         fltPolyTexture            Texture pattern index (-1 if none) 
&nbsp;&nbsp;&nbsp;unsigned int(4)  fltPolyPrimeColor         Primary Color Index 
&nbsp;&nbsp;&nbsp;float(4)         fltPolyPrimeIntensity     Primary Color Intensity 
&nbsp;&nbsp;&nbsp;mgbool(4)        fltPolyTerrain            TRUE if geometry is terrain 
&nbsp;&nbsp;&nbsp;char*(variable)  fltComment                Comment Text 
&nbsp;&nbsp;&nbsp;... 
}</PRE></P></DT><DT><P>The second column is the <B>code</B> associated to the field. For each field 
defined in the record, a data type (and size) is listed in the first column. 
This tells you what kind of <I>address</I> to provide to <A HREF=#mgGetAttList>mgGetAttList</A> for each field.</P></DT><DT><P>In the excerpt shown above, you can see that the <B>fltPolyTexture</B> field is a <SPAN CLASS="MONOSPACE">short</SPAN> 
integer of length 2 bytes.  Similarly, <B>fltPolyPrimeColor</B> is an <SPAN CLASS="MONOSPACE">unsigned int</SPAN> 
(4 bytes) and <B>fltPolyPrimeIntensity</B> is a <SPAN CLASS="MONOSPACE">float</SPAN> (4 bytes).</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The examples below (in C and Python) 
show you how you would use <A HREF=#mgGetAttList>mgGetAttList</A> (and what kind 
of address to use for each of these attributes) to retrieve the texture and color 
fields from a polygon node record <I>polygon</I>.</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">short textureIndex;
unsigned int colorIndex;
float colorIntensity;
int numAttr;

numAttr = mgGetAttList (polygon,
&#32       fltPolyTexture, &textureIndex,
&#32       fltPolyPrimeColor, &colorIndex,
&#32       fltPolyPrimeIntensity, &colorIntensity,
&#32       MG_NULL);
if (numAttr == 3)
{
   // all the values were retrieved successfully
   printf ("Texture Index:   %d&#92;", textureIndex);
   printf ("Color Index:     %d&#92;", colorIndex);
   printf ("Color Intensity: %f&#92;", colorIntensity);
}</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">outs = mgGetAttList (polygon,
      fltPolyTexture, fltPolyPrimeColor, fltPolyPrimeIntensity)

# outs is a tuple with 7 elements as follows:
# outs[0] = number of attributes returned, 3 if successful
# outs[1] = fltPolyTexture
# outs[2] = value of fltPolyTexture
# outs[3] = fltPolyPrimeColor
# outs[4] = value of fltPolyPrimeColor
# outs[5] = fltPolyPrimeIntensity
# outs[6] = value of fltPolyPrimeIntensity

numAttr = outs[0]
if (numAttr == 3):
   # all the values were retrieved successfully
   print "Texture Index:  ",outs[2]
   print "Color Index:    ",outs[4]
   print "Color Intensity:",outs[6]</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetAttList>mgGetAttList</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001000>What is an mgrec?</A><BR>
 
<A HREF=#FAQ_00001001>What is the OpenFlight Data Dictionary?</A><BR>
 
<A HREF=#FAQ_00001004>How do I set the attributes of a record in the database?</A><BR>
 
<A HREF=#FAQ_00001005>How do I get a string attribute of a record in the database?</A><BR>
 
<A HREF=#FAQ_00001007>What is the best way to get the coordinates (position) of a vertex node record?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001004></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I set the attributes of a record in the database?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>The <A TARGET="_blank" HREF=../openflightdd/default.htm>OpenFlight Data Dictionary</A> defines the fields 
that are contained in any record type.  If you know what kind of 
record you have, check the <A TARGET="_blank" HREF=../openflightdd/default.htm>OpenFlight Data Dictionary</A> to see the fields that are defined 
for that record type.  You then choose which field you want to "set" 
and use one of several OpenFlight API functions to set that field data.</P></DT><DT><P>The most common function to use is <A HREF=#mgSetAttList>mgSetAttList</A>.  In its simplest 
form (to set a single value), you provide a <I>rec</I>, a field <I>code</I> 
and a <I>value</I>.  The <I>rec</I> is the record whose value you want to set. 
The <I>code</I> identifies the field of the record you want to set. 
The <I>value</I> is the value you want to set.  Note that you can provide 
additional <I>code</I> and <I>value</I> pairs to set multiple values simultaneously.</P></DT><DT><P>The <A TARGET="_blank" HREF=../openflightdd/default.htm>OpenFlight Data Dictionary</A> can help you with the <I>value</I> parameter. 
Here is an excerpt showing some of the 
fields of the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltObject>fltObject</A>
 record.</P></DT><DT><P><PRE CLASS="EXAMPLE">record fltObject { 
&nbsp;&nbsp;&nbsp;... 
&nbsp;&nbsp;&nbsp;mgbool(4)        fltObjNoDay            Do not display in daylight 
&nbsp;&nbsp;&nbsp;char*(variable)  fltComment             Comment Text 
&nbsp;&nbsp;&nbsp;... 
}</PRE></P></DT><DT><P>The second column is the <B>code</B> associated to the field.  For each field 
defined in the record, a data type (and size) is listed in the first column. 
This tells you what kind of <I>value</I> to provide to <A HREF=#mgSetAttList>mgSetAttList</A> for each field.</P></DT><DT><P>In the excerpt shown above, you can see that the <B>fltObjNoDay</B> field is a <SPAN CLASS="MONOSPACE">mgbool</SPAN> 
value and that <B>fltComment</B> is a <SPAN CLASS="MONOSPACE">char*</SPAN> (string) value.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The examples below (in C and Python) 
show you how you would use <A HREF=#mgSetAttList>mgSetAttList</A> to set the Inhibit Display Day flag and 
comment for an object node record <I>object</I>.</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">int numAttr;

numAttr = mgSetAttList (object,
&#32       fltObjNoDay, MG_TRUE,
&#32       fltComment, "This object is not drawn in day",
&#32       MG_NULL);
if (numAttr == 2)
{
   // all the values were set successfully
   printf ("Object attributes set successfully");
}</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">numAttr = mgSetAttList (object,
&#32       fltObjNoDay, MG_TRUE,
&#32       fltComment, "This object is not drawn in day")
if (numAttr == 2):
   # all the values were set successfully
   print "Object attributes set successfully"</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetAttList>mgSetAttList</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001000>What is an mgrec?</A><BR>
 
<A HREF=#FAQ_00001001>What is the OpenFlight Data Dictionary?</A><BR>
 
<A HREF=#FAQ_00001003>How do I get the attributes of a record in the database?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001005></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I get a string attribute of a record in the database?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>When you use <A HREF=#mgGetAttList>mgGetAttList</A> to retrieve a string attribute from a record, 
there are some special considerations to keep in mind.  For this discussion, 
consider the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHdrLastDate</A>
 field of the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHeader</A>
 record as shown 
in this excerpt from the <A TARGET="_blank" HREF=../openflightdd/default.htm>OpenFlight Data Dictionary</A>:</P></DT><DT><P><PRE CLASS="EXAMPLE">record fltHeader { 
&nbsp;&nbsp;&nbsp;... 
&nbsp;&nbsp;&nbsp;char* (32)&#32     fltHdrLastDate&#32       Date and time of last revision 
&nbsp;&nbsp;&nbsp;... 
}</PRE></P></DT><DT><P>You can see that this attribute is a <SPAN CLASS="MONOSPACE">char*</SPAN> of length 32 bytes. In 
other words, it is a string of length 32.  The <I>address</I> you provide 
to <A HREF=#mgGetAttList>mgGetAttList</A> for string attributes should be the "address" of a 
<SPAN CLASS="MONOSPACE">char*</SPAN> value.  If <A HREF=#mgGetAttList>mgGetAttList</A> succeeds, it will allocate a 
string and copy the value of the record attribute to the allocated string. 
The address you provide will "point" to the allocated string. 
Since the string attribute is allocated, you must deallocate 
it after you are done with it (in C, but not in Python) to avoid 
a memory leak.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show how to retrieve 
a string attribute from a node record and how to dispose of it when 
you are done with it.</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">char* date = MG_NULL;
int numAttr;

numAttr = mgGetAttList (header,
&#32       fltHdrLastDate, &date,
&#32       MG_NULL);

if ((numAttr == 1) && (date != NULL)) {
   // date now points to a character string filled with
   // the fltHdrLastDate attribute value
   printf ("Last modified: %s&#92;", date);

   // you need to free the memory when you are done with it!
   mgFree (date);
}</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">outs = mgGetAttList (header, fltHdrLastDate)
# outs is a tuple with 3 elements as follows:
# outs[0] = number of attributes returned, 1 if successful
# outs[1] = fltHdrLastDate
# outs[2] = value of fltHdrLastDate
numAttr = outs[0]
if (numAttr == 1):
   date = outs[2]
   print "Last modified:", date
   # no need to deallocate the memory in Python</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetAttList>mgGetAttList</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001003>How do I get the attributes of a record in the database?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001006></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I access a value in a record nested inside another record?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>The <A TARGET="_blank" HREF=../openflightdd/default.htm>OpenFlight Data Dictionary</A> defines the fields that are contained in any record type. 
Fields contained in a record may be values or may be nested records 
themselves that contain other fields, etc.</P></DT><DT><P>To access any value (nested or not) of a record, you typically will use 
<A HREF=#mgGetAttList>mgGetAttList</A> (to get the value) and <A HREF=#mgSetAttList>mgSetAttList</A> (to set the value). 
For each of these functions, you specify a <I>rec</I> and a <I>code</I>.  The <I>code</I> 
represents the field in <I>rec</I> you want to get or set.  These functions will 
automatically look for <I>code</I> in nested records of <I>rec</I> - so you don't have 
to do anything special as long as <I>code</I> is found in just one nested record.</P></DT><DT><P>Consider the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record in the <A TARGET="_blank" HREF=../openflightdd/default.htm>OpenFlight Data Dictionary</A> as shown here:</P></DT><DT><P><PRE CLASS="EXAMPLE">record fltVertex { 
&nbsp;&nbsp;&nbsp;... 
&nbsp;&nbsp;&nbsp;record fltCoord3d  fltCoord3d   double precision float coordinate X,Y,Z 
&nbsp;&nbsp;&nbsp;... 
} 
record fltCoord3d { 
&nbsp;&nbsp;&nbsp;double(8)          fltCoord3dX  X component of coordinate 
&nbsp;&nbsp;&nbsp;double(8)          fltCoord3dY  Y component of coordinate 
&nbsp;&nbsp;&nbsp;double(8)          fltCoord3dZ  Z component of coordinate 
}</PRE></P></DT><DT><P>Notice that <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 contains a nested <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3d</A>
 record. 
If you wanted to set the <B>fltCoord3dX</B> attribute of the nested <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3d</A>
 record 
on a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
, simply pass a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record to <A HREF=#mgSetAttList>mgSetAttList</A> and specify 
<B>fltCoord3dX</B> for <I>code</I>.  Since <B>fltCoord3dX</B> is defined just once in the nested 
record structure, <A HREF=#mgSetAttList>mgSetAttList</A> will know which field you mean.</P></DT><DT><P><PRE CLASS="EXAMPLE">mgSetAttList (vertex, fltCoord3dX, 2.0, MG_NULL);</PRE></P></DT><DT><P>Now if <I>code</I> is contained in more than one nested record, there is an ambiguity and 
<A HREF=#mgGetAttList>mgGetAttList</A> and <A HREF=#mgSetAttList>mgSetAttList</A> won't know which <I>code</I> you mean.  Note that these 
functions will find one of the nested fields but it is not defined which field that will be.</P></DT><DT><P>Consider the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXmTranslate>fltXmTranslate</A>
 record which contains two nested <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3d</A>
 records:<P>
<PRE CLASS="EXAMPLE">record fltXmTranslate  { 
&nbsp;&nbsp;&nbsp;record fltCoord3d&#32fltXmTranslateFrom   reference FROM point 
&nbsp;&nbsp;&nbsp;record fltCoord3d&#32fltXmTranslateDelta  Delta to translate node by 
}</PRE></P></DT><DT><P>In this case if you wanted to set the <B>fltCoord3dX</B> attribute of the nested 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXmTranslate>fltXmTranslateFrom</A>
 record on <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXmTranslate>fltXmTranslate</A>
, you cannot simply pass 
a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXmTranslate>fltXmTranslate</A>
 record to <A HREF=#mgSetAttList>mgSetAttList</A> because <B>fltCoord3dX</B> is defined 
in both <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXmTranslate>fltXmTranslateFrom</A>
 and <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXmTranslateDelta>fltXmTranslateDelta</A>
 nested records. 
<A HREF=#mgSetAttList>mgSetAttList</A> won't know which <B>fltCoord3dX</B> you mean.</P></DT><DT><P>To resolve this ambiguity you have two choices.  For common nested record types, 
like <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3d</A>
 and several others, the OpenFlight API provides "convenience" functions to 
get/set the nested record components.  For example <A HREF=#mgGetCoord3d>mgGetCoord3d</A> retrieves the X, Y and Z 
components of a nested <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3d</A>
 record while <A HREF=#mgSetCoord3d>mgSetCoord3d</A> sets them.  You specify 
the code of the nested <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3d</A>
 record you want to access.  In the case of <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXmTranslate>fltXmTranslate</A>
 
above, the following example shows how you would set values on each of the nested <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3d</A>
 records.</P></DT><DT><P><PRE CLASS="EXAMPLE">// set the components on the fltXmTranslateFrom nested record 
mgSetCoord3d (translate, fltXmTranslateFrom, 0.0, 0.0, 0.0); 
&nbsp; 
// set the components on the fltXmTranslateDelta nested record 
mgSetCoord3d (translate, fltXmTranslateDelta, 10.0, 5.0, 0.0);</PRE></P></DT><DT><P>As noted above, there are several nested records for which OpenFlight API convenience functions 
are defined.  Here are some:</P></DT><DT><P><TABLE CLASS="SIMPLE">
 
<TR CLASS="HEADER">
 
<TD CLASS="BORDER">
 Nested Record Type </TD>
 
<TD CLASS="BORDER">
 Get Function </TD>
 
<TD CLASS="BORDER">
 Set Function </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord2i>fltCoord2i</A>
 </TD>
 
<TD CLASS="BORDER">
 <A HREF=#mgGetCoord2i>mgGetCoord2i</A> </TD>
 
<TD CLASS="BORDER">
 <A HREF=#mgSetCoord2i>mgSetCoord2i</A> </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3f>fltCoord3f</A>
 </TD>
 
<TD CLASS="BORDER">
 <A HREF=#mgGetCoord3f>mgGetCoord3f</A> </TD>
 
<TD CLASS="BORDER">
 <A HREF=#mgSetCoord3f>mgSetCoord3f</A> </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3d</A>
 </TD>
 
<TD CLASS="BORDER">
 <A HREF=#mgGetCoord3d>mgGetCoord3d</A> </TD>
 
<TD CLASS="BORDER">
 <A HREF=#mgSetCoord3d>mgSetCoord3d</A> </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDPlane>fltDPlane</A>
 </TD>
 
<TD CLASS="BORDER">
 <A HREF=#mgGetPlane>mgGetPlane</A> </TD>
 
<TD CLASS="BORDER">
 <A HREF=#mgSetPlane>mgSetPlane</A> </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMatrix>fltMatrix</A>
 </TD>
 
<TD CLASS="BORDER">
 <A HREF=#mgGetMatrix>mgGetMatrix</A> </TD>
 
<TD CLASS="BORDER">
 <A HREF=#mgSetMatrix>mgSetMatrix</A> </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltColorRGBA>fltColorRGBA</A>
 </TD>
 
<TD CLASS="BORDER">
 <A HREF=#mgGetColorRGBA>mgGetColorRGBA</A> </TD>
 
<TD CLASS="BORDER">
 <A HREF=#mgSetColorRGBA>mgSetColorRGBA</A> </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltNormColor>fltNormColor</A>
 </TD>
 
<TD CLASS="BORDER">
 <A HREF=#mgGetNormColor>mgGetNormColor</A> </TD>
 
<TD CLASS="BORDER">
 <A HREF=#mgSetNormColor>mgSetNormColor</A> </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVector>fltVector</A>
 </TD>
 
<TD CLASS="BORDER">
 <A HREF=#mgGetVector>mgGetVector</A> </TD>
 
<TD CLASS="BORDER">
 <A HREF=#mgSetVector>mgSetVector</A> </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVectord>fltVectord</A>
 </TD>
 
<TD CLASS="BORDER">
 <A HREF=#mgGetVectord>mgGetVectord</A> </TD>
 
<TD CLASS="BORDER">
 <A HREF=#mgSetVectord>mgSetVectord</A> </TD>
 
</TR>
<P>
</TABLE>
</P></DT><DT><P>Finally you have one more option when accessing fields of nested records. 
The function <A HREF=#mgGetAttRec>mgGetAttRec</A> can be used to get a pointer to the nested 
record which in turn can be passed to <A HREF=#mgGetAttList>mgGetAttList</A> or <A HREF=#mgSetAttList>mgSetAttList</A>. 
In this way, you control how to resolve any ambiguity in the nested record 
structure.  The following example shows how <A HREF=#mgGetAttRec>mgGetAttRec</A> could be used 
to resolve the ambiguity when accessing fields of nested records in 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXmTranslate>fltXmTranslate</A>
.  While the example shows how to set the field 
in the nested record using <A HREF=#mgSetAttList>mgSetAttList</A>, it works the same way when 
using <A HREF=#mgGetAttList>mgGetAttList</A> to get the field value.<P>
<PRE CLASS="EXAMPLE">mgrec* coordRec; 
// get the nested fltXmTranslateFrom record 
coordRec = mgGetAttRec (translate, fltXmTranslateFrom, MG_NULL); 
// set the components on the nested record 
mgSetAttList (coordRec, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fltCoord3dX, 0.0, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fltCoord3dY, 0.0, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fltCoord3dZ, 0.0, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MG_NULL); 
&nbsp; 
// get the nested fltXmTranslateDelta record 
coordRec = mgGetAttRec (translate, fltXmTranslateDelta, MG_NULL); 
// set the components on the nested record 
mgSetAttList (coordRec, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fltCoord3dX, 10.0, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fltCoord3dY, 5.0, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fltCoord3dZ, 0.0, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MG_NULL);</PRE></P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetAttList>mgGetAttList</A>, <A HREF=#mgSetAttList>mgSetAttList</A>, <A HREF=#mgGetAttRec>mgGetAttRec</A>, 
<A HREF=#mgGetCoord2i>mgGetCoord2i</A>, <A HREF=#mgSetCoord2i>mgSetCoord2i</A>, 
<A HREF=#mgGetCoord3f>mgGetCoord3f</A>, <A HREF=#mgSetCoord3f>mgSetCoord3f</A>, 
<A HREF=#mgGetCoord3d>mgGetCoord3d</A>, <A HREF=#mgSetCoord3d>mgSetCoord3d</A>, 
<A HREF=#mgGetPlane>mgGetPlane</A>, <A HREF=#mgSetPlane>mgSetPlane</A>, 
<A HREF=#mgGetMatrix>mgGetMatrix</A>, <A HREF=#mgSetMatrix>mgSetMatrix</A>, 
<A HREF=#mgGetColorRGBA>mgGetColorRGBA</A>, <A HREF=#mgSetColorRGBA>mgSetColorRGBA</A>, 
<A HREF=#mgGetNormColor>mgGetNormColor</A>, <A HREF=#mgSetNormColor>mgSetNormColor</A>, 
<A HREF=#mgGetVector>mgGetVector</A>, <A HREF=#mgSetVector>mgSetVector</A>, 
<A HREF=#mgGetVectord>mgGetVectord</A>, <A HREF=#mgSetVectord>mgSetVectord</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001007>What is the best way to get the coordinates (position) of a vertex node record?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001007></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">What is the best way to get the coordinates (position) of a vertex node record?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>When you look in the <A TARGET="_blank" HREF=../openflightdd/default.htm>OpenFlight Data Dictionary</A> at the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record, you will see that 
the XYZ coordinates of the vertex are contained in a nested record of type 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3d</A>
.</P></DT><DT><P><PRE CLASS="EXAMPLE">record fltVertex { 
&nbsp;&nbsp;&nbsp;... 
&nbsp;&nbsp;&nbsp;record fltCoord3d  fltCoord3d   double precision float coordinate X,Y,Z 
&nbsp;&nbsp;&nbsp;... 
}</PRE></P></DT><DT><P>The nested <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3d</A>
 record is defined as follows: 
<PRE CLASS="EXAMPLE">record fltCoord3d { 
&nbsp;&nbsp;&nbsp;double(8)          fltCoord3dX  X component of coordinate 
&nbsp;&nbsp;&nbsp;double(8)          fltCoord3dY  Y component of coordinate 
&nbsp;&nbsp;&nbsp;double(8)          fltCoord3dZ  Z component of coordinate 
}</PRE></P></DT><DT><P>Like any other attribute, you can always use <A HREF=#mgGetAttList>mgGetAttList</A> to get the values of the 
vertex record.  But the OpenFlight API provides some "convenience" functions for getting 
attributes that you are likely to use often.  These convenience functions are both 
easier to use and more efficient.</P></DT><DT><P>The first convenience function, <A HREF=#mgGetCoord3d>mgGetCoord3d</A>, retrieves the x, y and z coordinates 
of a nested <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCoord3d>fltCoord3d</A>
 record from any record that contains one.  The second 
convenience function, <A HREF=#mgGetVtxCoord>mgGetVtxCoord</A>, retrieves the x, y and z coordinates from 
a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 record specifically.  Of these three functions, <A HREF=#mgGetVtxCoord>mgGetVtxCoord</A> 
is the most efficient and easiest function to use.  For that reason, it is the "best" 
way to get the coordinates (position) of a vertex node record.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show different ways to 
retrieve the coordinates (position) of a vertex node record <I>vertex</I> using 
<A HREF=#mgGetAttList>mgGetAttList</A> and the two convenience functions <A HREF=#mgGetCoord3d>mgGetCoord3d</A> and 
<A HREF=#mgGetVtxCoord>mgGetVtxCoord</A>.</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">double x, y, z;
int numAttr;
mgbool status;

// like any attribute, you can use mgGetAttList:
numAttr = mgGetAttList (vertex,
      fltCoord3dX, &x,
      fltCoord3dY, &y,
      fltCoord3dZ, &z,
      MG_NULL);

// or you can use the convenience function mgGetCoord3d
// to retrieve a nested fltCoord3d record:
status = mgGetCoord3d (vertex, fltCoord3d, &x, &y, &z);

// or you can use a very specialized convenience function
// mgGetVtxCoord to get the vertex coordinates:
status = mgGetVtxCoord (vertex, &x, &y, &z);</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE"># like any attribute, you can use mgGetAttList:
outs = mgGetAttList (vertex,
      fltCoord3dX,
      fltCoord3dY,
      fltCoord3dZ)
numAttr = outs[0]
if (numAttr == 3):
   x = outs[2];
   y = outs[4];
   z = outs[6];

# or you can use the convenience function mgGetCoord3d
# to retrieve a nested fltCoord3d record:
status, x, y, z = mgGetCoord3d (vertex, fltCoord3d)

# or you can use a very specialized convenience function
# mgGetVtxCoord to get the vertex coordinates:
status, x, y, z = mgGetVtxCoord (vertex)</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001003>How do I get the attributes of a record in the database?</A><BR>
 
<A HREF=#FAQ_00001006>How do I access a value in a record nested inside another record?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001008></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I get or set the comment attribute of a node record?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>Like any other attribute, you can use <A HREF=#mgGetAttList>mgGetAttList</A> and <A HREF=#mgSetAttList>mgSetAttList</A> 
to get and set the comment text of a node record.  The attribute code for 
the comment text is <B>fltComment</B>.  In addition, the OpenFlight API provides 
"convenience" functions for getting and setting the comment text of a node. 
Depending on your preference, you can use the set of functions you find easier.</P></DT><DT><P>The convenience function for getting the comment text of a node is <A HREF=#mgGetComment>mgGetComment</A>. 
It allocates and returns the comment text (if any).  In C, remember to free 
the string returned after you are done with it using <A HREF=#mgFree>mgFree</A>.</P></DT><DT><P>The convenience function for setting the comment text of a node is <A HREF=#mgSetComment>mgSetComment</A>.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show different ways to get 
and set the comment text of polygon node record <I>poly</I> using 
<A HREF=#mgGetAttList>mgGetAttList</A> and <A HREF=#mgSetAttList>mgSetAttList</A> as well as the convenience functions 
<A HREF=#mgGetComment>mgGetComment</A> and <A HREF=#mgSetComment>mgSetComment</A>.</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">char* comment1 = NULL;
char* comment2 = NULL;
int numAttr;

// get the comment using both techniques...

// like any attribute, you can use mgGetAttList:
numAttr = mgGetAttList (poly, fltComment, &comment1, MG_NULL);

// or you can use the convenience function mgGetComment
comment2 = mgGetComment (poly);

// at this point comment1 and comment2 will be the same
// no matter which technique you use, remember to free the
// string when you are done with it
mgFree (comment1);
mgFree (comment2);

// set the comment using both techniques

// like any attribute, you can use mgSetAttList:
numAttr = mgSetAttList (poly, fltComment, "Comment String", MG_NULL);

// or you can use the convenience function mgSetComment
mgSetComment (poly, "Comment String");</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE"># get the comment using both techniques...

# like any attribute, you can use mgGetAttList:
numAttr,code,comment1 = mgGetAttList (poly, fltComment)

# or you can use the convenience function mgGetComment
comment2 = mgGetComment (poly)

# at this point comment1 and comment2 will be the same
# Note that in Python, you don't have to free the strings

# set the comment using both techniques

# like any attribute, you can use mgSetAttList:
numAttr,code = mgSetAttList (poly, fltComment, "Comment String")

# or you can use the convenience function mgSetComment
mgSetComment (poly, "Comment String")</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetAttList>mgGetAttList</A>, <A HREF=#mgSetAttList>mgSetAttList</A>, <A HREF=#mgGetComment>mgGetComment</A>, <A HREF=#mgSetComment>mgSetComment</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001001>What is the OpenFlight Data Dictionary?</A><BR>
 
<A HREF=#FAQ_00001003>How do I get the attributes of a record in the database?</A><BR>
 
<A HREF=#FAQ_00001004>How do I set the attributes of a record in the database?</A><BR>
 
<A HREF=#FAQ_00001005>How do I get a string attribute of a record in the database?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001009></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">What is the difference between Color Index/Intensity and 
Creator Color Index attributes?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>Several nodes in the OpenFlight scene have color index attributes.  These 
nodes include <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCat>fltCat</A>
, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltText>fltText</A>
, 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 and <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLpAppearancePalette>fltLpAppearancePalette</A>
.  The color attributes 
on these nodes can be specified in two different ways.  They may be specified 
by an Index/Intensity value pair or by a Creator Color Index value - both 
are equivalent.  The difference between these specifications are 
explained here.</P></DT><DT><P>To understand what the color index values mean, it helps to know how the 
color palette is constructed.  The database color palette contains 1024 
color entries.  Each color entry is defined by red, green and blue (RGB) 
values ranging from 0 to 255.  Each entry is further divided into a band 
of 128 shades, or intensities ranging from 0 to 127.</P></DT><DT><P>As noted above, you can specify a color using either an Index/Intensity 
value pair or a Creator Color Index.  These are just two different ways 
of specifying the same thing.</P></DT><DT><P>When you specify a color by Index/Intensity pair, you specify the color 
palette entry (0..1023) and the intensity (0.0 .. 1.0).  An intensity value 
of 0.0 is  black and an intensity value of 1.0 is the full-intensity 
of the RGB values of that color entry.</P></DT><DT><P>When you specify a color by Creator Color Index, you specify a different 
index which encodes both the Index and Intensity values described above 
into a single value.  This is how Creator displays the color index values 
on the Attribute Pages.  The 128 colors specified by Index <SPAN CLASS="MONOSPACE">N</SPAN>, 
Intensity <SPAN CLASS="MONOSPACE">I</SPAN> (ranging from 0.0 - 1.0) are encoded into the 
Creator Color Indices <SPAN CLASS="MONOSPACE">X</SPAN> .. <SPAN CLASS="MONOSPACE">Y</SPAN>, where <SPAN CLASS="MONOSPACE">X</SPAN> is:<P>
<PRE CLASS="EXAMPLE">(N * 128) + round(I * 127.0)</PRE></P></DT><DT><P>and <SPAN CLASS="MONOSPACE">Y</SPAN> is:<P>
<PRE CLASS="EXAMPLE">X + 128</PRE></P></DT><DT><P>Color Index <SPAN CLASS="MONOSPACE">0</SPAN>, Intensity <SPAN CLASS="MONOSPACE">1.0</SPAN>, therefore would be Creator Color Index <SPAN CLASS="MONOSPACE">127</SPAN>. 
Similarly Color Index <SPAN CLASS="MONOSPACE">5</SPAN>, Intensity <SPAN CLASS="MONOSPACE">0.5</SPAN> would be Creator Color Index <SPAN CLASS="MONOSPACE">704</SPAN>.</P></DT><DT><P>The following excerpt from the <A TARGET="_blank" HREF=../openflightdd/default.htm>OpenFlight Data Dictionary</A> shows the primary and alternate color index 
attributes of the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolyon>fltPolyon</A>
 record.<P>
<PRE CLASS="EXAMPLE">record fltPolygon { 
&nbsp;&nbsp;&nbsp;... 
&nbsp;&nbsp;&nbsp;unsigned int(4)  fltPolyCreatorPrimeColor  Creator Primary Color Index 
&nbsp;&nbsp;&nbsp;unsigned int(4)  fltPolyPrimeColor         Primary Color Index 
&nbsp;&nbsp;&nbsp;float(4)         fltPolyPrimeIntensity     Primary Color Intensity 
&nbsp;&nbsp;&nbsp;... 
&nbsp;&nbsp;&nbsp;unsigned int(4)  fltPolyCreatorAltColor    Creator Alternate Color Index 
&nbsp;&nbsp;&nbsp;unsigned int(4)  fltPolyAltColor           Alternate Color Index 
&nbsp;&nbsp;&nbsp;float(4)         fltPolyAltIntensity       Alternate Color Intensity 
&nbsp;&nbsp;&nbsp;... 
}</PRE></P></DT><DT><P>Notice that the <A TARGET="_blank" HREF=../openflightdd/default.htm>OpenFlight Data Dictionary</A> provides codes for both color index values.  Specifically, 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyPrimeColor</A>
 and <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyPrimeIntensity</A>
 represent the primary color 
index as an Index/Intensity pair and <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyCreatorPrimeColor</A>
 represents 
the primary color as a Creator Color Index.  The same applies for alternate color. 
The attributes <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyAltColor</A>
 and <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyAltIntensity</A>
 represent 
the alternate color as an Index/Intensity pair and <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyCreatorAltColor</A>
 
as a Creator Color Index.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show both ways to specify 
the primary color value for <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
 nodes.</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">// set both node1 and node2 to the same color
// use different color index attributes to do it

// set using Color Index/Intensity pair
mgSetAttList (node1,
      fltPolyPrimeColor, 0,
      fltPolyPrimeIntensity, 1.0,
      MG_NULL);

// set using Creator Color Index
mgSetAttList (node2,
      fltPolyCreatorPrimeColor, 127,
      MG_NULL);</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE"># set both node1 and node2 to the same color
# use different color index attributes to do it

# set using Color Index/Intensity pair
mgSetAttList (node1,
      fltPolyPrimeColor, 0,
      fltPolyPrimeIntensity, 1.0)

# set using Creator Color Index
mgSetAttList (node2,
      fltPolyCreatorPrimeColor, 127)</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetAttList>mgGetAttList</A>, <A HREF=#mgSetAttList>mgSetAttList</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001010>When I set a color intensity attribute on a node, the value I see on the node is not the exact value I set - why is there a difference?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001010></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">When I set a color intensity attribute on a node, the value I see 
on the node is not the exact value I set.  Why is there a difference?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>Several nodes in the OpenFlight scene have color attributes.  These 
nodes include <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltCat>fltCat</A>
, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltText>fltText</A>
, 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
 and <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLpAppearancePalette>fltLpAppearancePalette</A>
.  The color attributes 
are represented on the nodes as Index/Intensity value pairs.</P></DT><DT><P>To help explain this problem, it will be useful to understand how the 
color palette is constructed.  The database color palette contains 1024 
color entries.  Each color entry is defined by red, green and blue (RGB) 
values ranging from 0 to 255.  Each entry is further divided into a band 
of 128 shades, or intensities ranging from 0 to 127.  This is how the 
OpenFlight color palette is stored on disk.</P></DT><DT><P>The problem stems from that fact that the intensity value of a color 
(stored on disk as an integer value, range 0 to 127) is expressed in the 
OpenFlight API using a floating point number whose range is 0.0 .. 1.0. 
Since these 128 integer intensity values are quantized into floating point 
numbers, only 128 discrete floating point values can be represented. 
The 128 floating  point numbers that are represented for Intensity <SPAN CLASS="MONOSPACE">I</SPAN> 
(ranging from 0..127) can be expressed by this equation:<P>
<PRE CLASS="EXAMPLE">I / 127.0</PRE></P></DT><DT><P>As you can see in the table below, only a small number of all the 
floating point numbers between 0.0 and 1.0 can be represented by 
128 integer intensities in the range 0..127:<P>
<TABLE CLASS="SIMPLE">
 
<TR CLASS="HEADER">
 
<TD CLASS="BORDER">
 Integer Intensity </TD>
 
<TD CLASS="BORDER">
 Floating Point Intensity </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">0</SPAN> </TD>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">0.000000000000</SPAN> </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">1</SPAN> </TD>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">0.007874015718</SPAN> </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">2</SPAN> </TD>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">0.015748031437</SPAN> </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">3</SPAN> </TD>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">0.023622047156</SPAN> </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">...</SPAN> </TD>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">...</SPAN> </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">125</SPAN> </TD>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">0.984251976013</SPAN> </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">126</SPAN> </TD>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">0.992125988007</SPAN> </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">127</SPAN> </TD>
 
<TD CLASS="BORDER">
 <SPAN CLASS="MONOSPACE">1.000000000000</SPAN> </TD>
 
</TR>
<P>
</TABLE>
</P></DT><DT><P>This quantization explains why the floating point value you set for 
a color intensity attribute on a node may not be the exact value you 
get.  For example, if you set the intensity value to <SPAN CLASS="MONOSPACE">0.007</SPAN>, 
the actual value you will get is <SPAN CLASS="MONOSPACE">0.007874015718</SPAN>.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetAttList>mgGetAttList</A>, <A HREF=#mgSetAttList>mgSetAttList</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001009>What is the difference between Color Index/Intensity and Creator Color Index attributes?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001011></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I set up texture on a polygon?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>To set up a texture on a polygon, you will do the following:<P>
<UL>
 
<LI CLASS="NOINDENT">
 Load a texture in the texture palette of the database </LI>
 
<LI CLASS="NOINDENT">
 Assign the texture index on the polygon </LI>
 
<LI CLASS="NOINDENT">
 Assign texture coordinates (UVs) on each vertex of the polygon </LI>
 
</UL>
</P></DT><DT><P>To assign a texture to a polygon, the texture must be in the texture palette of the 
database. When a texture is in the texture palette, it will have an <I>index</I> 
associated to it.  This index is used by many OpenFlight API functions to reference 
the texture in the palette and is needed, specifically in this situation, to assign 
to the polygon.  If the texture you want to 
assign is already in the texture palette of the database, just note the index 
and skip this step.  Otherwise, you will need to load the texture in the texture 
palette before you can assign it to a polygon.</P></DT><DT><P>There are a couple of similar functions to load a texture in the texture palette: 
<A HREF=#mgInsertTexture>mgInsertTexture</A> and <A HREF=#mgReadTexture>mgReadTexture</A>. 
If you want to assign a specific index to the texture in the palette, use <A HREF=#mgReadTexture>mgReadTexture</A>. 
If you do this, make sure the index is not already in use.  If you use 
<A HREF=#mgInsertTexture>mgInsertTexture</A>, a "free" index will be assigned to the texture you 
load in the texture palette.  The new index assigned is returned by <A HREF=#mgInsertTexture>mgInsertTexture</A>.</P></DT><DT><P>When you have the index of the texture in the texture palette, you are ready to assign it 
to the polygon.  This is very simple using <A HREF=#mgSetAttList>mgSetAttList</A> and the attribute code 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyTexture</A>
.  The attribute value you provide is simply the 
texture palette index of the texture you want to assign to the polygon. Note that 
the attribute code <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyTexture</A>
 is used to assign the <I>base</I> 
texture layer.  Use <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltLayerTexture1</A>
, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltLayerTexture2</A>
, 
... <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltLayerTexture7</A>
 to assign other texture layers on the polygon. 
If your runtime supports detail texture, you can also assign <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolyDetailTexture</A>
 
to the polygon.</P></DT><DT><P>After you have assigned the texture index to the polygon, you must set texture coordinates 
(UVs) on the vertices of the polygon.  Like any other attribute, you use <A HREF=#mgSetAttList>mgSetAttList</A> 
to assign UVs to vertex nodes.  You must assign UVs to each vertex of the polygon. Use 
the attribute codes <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVU</A>
 and <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVV</A>
 to assign the base 
texture UVs on a vertex.  Use attribute codes <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltLayerU1</A>
, 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltLayerV1</A>
, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltLayerU2</A>
, 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltLayerV2</A>
, ... <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltLayerU7</A>
, 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltLayerV7</A>
 to assign UVs for other texture layers on a vertex.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show how to load a texture in the 
palette of a database <I>db</I> and set it up on a quadrilateral polygon <I>poly</I>.</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">// load a texture in the palette, get its index
index = mgInsertTexture (db, "C:/textures/brick.rgb");

// assign the texture to the polygon
mgSetAttList (poly, fltPolyTexture, index, MG_NULL);

// get the 4 vertices of the quad polygon
vtx1 = mgGetChild (poly);
vtx2 = mgGetNext (vtx1);
vtx3 = mgGetNext (vtx2);
vtx4 = mgGetNext (vtx3);

// assign simple UV mapping to each vertex of the quad
mgSetAttList (vtx1, fltVU, 0.0, fltVV, 0.0, MG_NULL);
mgSetAttList (vtx2, fltVU, 1.0, fltVV, 0.0, MG_NULL);
mgSetAttList (vtx3, fltVU, 1.0, fltVV, 1.0, MG_NULL);
mgSetAttList (vtx4, fltVU, 0.0, fltVV, 1.0, MG_NULL);</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE"># load a texture in the palette, get its index
index = mgInsertTexture (db, "C:/textures/brick.rgb")

# assign the texture to the polygon
mgSetAttList (poly, fltPolyTexture, index)

# get the 4 vertices of the quad polygon
vtx1 = mgGetChild (poly)
vtx2 = mgGetNext (vtx1)
vtx3 = mgGetNext (vtx2)
vtx4 = mgGetNext (vtx3)

#  assign simple UV mapping to each vertex of the quad
mgSetAttList (vtx1, fltVU, 0.0, fltVV, 0.0)
mgSetAttList (vtx2, fltVU, 1.0, fltVV, 0.0)
mgSetAttList (vtx3, fltVU, 1.0, fltVV, 1.0)
mgSetAttList (vtx4, fltVU, 0.0, fltVV, 1.0)</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetAttList>mgSetAttList</A>, <A HREF=#mgInsertTexture>mgInsertTexture</A>, <A HREF=#mgReadTexture>mgReadTexture</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001004>How do I set the attributes of a record in the database?</A><BR>
 
<A HREF=#FAQ_00001014>How do I set a color name on a polygon or mesh?</A><BR>
 
<A HREF=#FAQ_00001015>How do I set the normal of a polygon?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001012></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I determine the OpenFlight revision level of an OpenFlight database?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>After the database is opened (using <A HREF=#mgOpenDb>mgOpenDb</A> or <A HREF=#mgNewDb>mgNewDb</A>), you can access 
the OpenFlight revision level as an attribute of the OpenFlight database 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHeader</A>
 node.  The attribute code for this is <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHdrFormatRev</A>
. 
You can get this value (like you do any attribute value for any node type) using 
<A HREF=#mgGetAttList>mgGetAttList</A>.  Note that you cannot set this value using <A HREF=#mgSetAttList>mgSetAttList</A>, 
it is automatically set when you save or export the database file.</P></DT><DT><P>If you want to query the OpenFlight revision level of a database file on disk 
(without opening it) you can use the function <A HREF=#mgGetDbVersion>mgGetDbVersion</A>.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show how to get the OpenFlight revision 
level attribute from an open database <I>db</I>.</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">int formatRev;
int numAttr = mgGetAttList (db, fltHdrFormatRev, &formatRev, MG_NULL);

// formatRev will be an integer number encoded like 1650, 1640, 1630, 1620, etc
// specifying the OpenFlight format revision of this OpenFlight file.</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">numAttr, code, formatRev = mgGetAttList (db, fltHdrFormatRev)

# formatRev will be an integer number encoded like 1650, 1640, 1630, 1620, etc
# specifying the OpenFlight format revision of this OpenFlight file.</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetAttList>mgGetAttList</A>, <A HREF=#mgGetDbVersion>mgGetDbVersion</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001013>Can I query the OpenFlight revision level of an OpenFlight file on disk without opening it?</A><BR>
 
<A HREF=#FAQ_00001003>How do I get the attributes of a record in the database?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001013></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">Can I query the OpenFlight revision level of an OpenFlight file on disk 
without opening it?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>You can use the function <A HREF=#mgGetDbVersion>mgGetDbVersion</A> to query the OpenFlight revision level 
of a file on disk.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show how to get the OpenFlight revision 
level for an OpenFlight file on disk.</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">int formatRev;
formatRev = mgGetDbVersion ("c:/MyDatabases/myfile.flt");

// if the file is an OpenFlight file, formatRev will be an integer number
// encoded like 1650, 1640, 1630, 1620, etc specifying the OpenFlight format
// revision of this OpenFlight file.
//
// if the file is not an OpenFlight file, formatRev will be 0.</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">formatRev = mgGetDbVersion ("c:/MyDatabases/myfile.flt")

# if the file is an OpenFlight file, formatRev will be an integer number
# encoded like 1650, 1640, 1630, 1620, etc specifying the OpenFlight format
# revision of this OpenFlight file.
#
# if the file is not an OpenFlight file, formatRev will be 0.</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetDbVersion>mgGetDbVersion</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001012>How do I determine the OpenFlight revision level of an OpenFlight database?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001014></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I set a color name on a polygon or mesh?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>You can use the functions <A HREF=#mgSetPolyColorName>mgSetPolyColorName</A> and <A HREF=#mgSetPolyAltColorName>mgSetPolyAltColorName</A> to 
set the primary and alternate color names on polygons and meshes.</P></DT><DT><P>Similarly, use functions <A HREF=#mgGetPolyColorName>mgGetPolyColorName</A> and <A HREF=#mgGetPolyAltColorName>mgGetPolyAltColorName</A> to 
get the primary and alternate color names assigned to polygons and meshes.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetPolyColorName>mgSetPolyColorName</A>, <A HREF=#mgSetPolyAltColorName>mgSetPolyAltColorName</A>, <A HREF=#mgGetPolyColorName>mgGetPolyColorName</A> 
and <A HREF=#mgGetPolyAltColorName>mgGetPolyAltColorName</A>.</DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001011>How do I set up texture on a polygon?</A><BR>
 
<A HREF=#FAQ_00001015>How do I set the normal of a polygon?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001015></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I set the normal of a polygon?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>There is no attribute stored on the <A HREF=#fltPolygon>fltPolygon</A> node for its normal so you 
cannot <I>set</I> this explicitly. The polygon normal is calculated based on the 
plane containing the vertices of the polygon and therefore may change as the 
positions of one or more of its vertices are changed. Note that if not all of 
the vertices of the polygon are coplanar, the calculated normal may not be 
what you expect.</P></DT><DT><P>The polygon normal points in the same direction the "front" of the polygon faces. See 
<A HREF=#FAQ_00001016>Which side of a polygon is the front and which is the back?</A>
 
for more information.</P></DT><DT><P>You can query the normal of a polygon using <A HREF=#mgGetPolyNormal>mgGetPolyNormal</A> 
but there is no corresponding function to set the polygon normal.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetPolyNormal>mgGetPolyNormal</A>, <A HREF=#mgGetVtxNormal>mgGetVtxNormal</A>, <A HREF=#mgSetVtxNormal>mgSetVtxNormal</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001016>Which side of a polygon is the front and which is the back?</A><BR>
 
<A HREF=#FAQ_00001004>How do I set the attributes of a record in the database?</A><BR>
 
<A HREF=#FAQ_00001011>How do I set up texture on a polygon?</A><BR>
 
<A HREF=#FAQ_00001014>How do I set a color name on a polygon or mesh?</A><BR>
 
<A HREF=#FAQ_00001017>How do I access an edge of a polygon?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001016></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">Which side of a polygon is the front and which is the back?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>The order of the vertices in the polygon define which side of the polygon is front 
and which is back. When looking at the "front" of a polygon, the vertices will be 
ordered in a counter-clockwise direction. The polygon normal will point towards you 
if you are looking "down" on the "front" of the polygon. If you are looking at the 
"back" of the polygon, the normal will point away from you.</P></DT><DT><P>In OpenFlight, solid polygons can be defined in such a way that "both" sides 
are rendered. This is often called "Both Sides Visible". To make a polygon draw 
both sides, set the polygon attribute <A HREF=#fltPolyDrawType>fltPolyDrawType</A> to 1 (Solid, Both 
Sides Visible) using <A HREF=#mgSetAttList>mgSetAttList</A>. Note that this does not affect the order 
of the vertices on the polygon or the polygon normal. A polygon defined in this 
way will still have a "front" side and a "back" side but both will be drawn.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetPolyNormal>mgGetPolyNormal</A>, <A HREF=#mgGetVtxNormal>mgGetVtxNormal</A>, <A HREF=#mgSetVtxNormal>mgSetVtxNormal</A>, <A HREF=#mgSetAttList>mgSetAttList</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001015>How do I set the normal of a polygon?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001017></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I access an edge of a polygon?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>In the OpenFlight scene graph, there is no explicit node type for an edge of a polygon. 
Similar to how a polygon normal is <I>calculated</I> based on the current positions of all 
its vertices, a polygon edge is <I>calculated</I> based on the positions of two <I>adjacent</I> 
vertices of the polygon.</P></DT><DT><P>A closed polygon with N vertices has exactly N edges. The nth edge (n &lt N) of a closed polygon 
with N vertices is defined by vertex n and vertex n+1. The Nth edge is defined by the last vertex 
(vertex N) wrapping back to the first vertex (vertex 1). An unclosed polygon with N vertices has 
exactly N-1 edges. The nth edge (n &lt= N-1) of an unclosed polygon is defined by vertex n and 
vertex n+1. For unclosed polygons the last vertex does not attach to the first vertex so 
does not form an edge.</P></DT><DT><P>When you are working with vertices and their attributes in the scene graph, you do not 
generally need to worry about (nor do you have explicit access to) edges, only the vertices 
that comprise the edge. So, to reposition an edge you simply reposition the vertices that 
comprise that edge. Note, however that if you reposition any <I>one</I> vertex of a closed polygon, 
you will implicitly change the position of <I>two</I> edges. This is because in a closed polygon, 
each vertex is part of two edges. Each vertex of a closed polygon is the <I>first</I> vertex of 
one edge and the <I>last</I> vertex of the <I>previous</I> edge of that polygon. For unclosed polygons, 
the first and last vertices of the polygon are each part of only one edge, the first 
and last edge, respectively.</P></DT><DT><P>In Creator, however, the user can select vertices or edges. This is one instance in which 
you do treat vertices different than edges. See 
<A HREF=#FAQ_00001018>How do I select an edge of a polygon in Creator?</A>
 for 
more information on this.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001015>How do I set the normal of a polygon?</A><BR>
 
<A HREF=#FAQ_00001018>How do I select an edge of a polygon in Creator?</A><BR>
 
<A HREF=#FAQ_00001022>How do I tell if an edge of a polygon is selected in Creator?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001018></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I select an edge of a polygon in Creator?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>As discussed in <A HREF=#FAQ_00001017>How do I access an edge of a polygon?</A>
 
there is no explicit node type for polygon edges. In Creator, however, the user can select 
vertices or edges. As there is no node type in the OpenFlight scene graph for an edge 
(only for vertices), Creator makes this work by attaching a special attribute to a vertex 
node when it is selected to indicate whether the vertex is selected <I>as a vertex</I> or is 
selected <I>as an edge</I>.</P></DT><DT><P>When the user selects an edge in Creator, Creator (behind the scenes) selects the first vertex 
of the edge and automatically sets this special vertex attribute to indicate that the vertex 
is selected as an edge. To select an edge from your plug-in or script, use <A HREF=#mgSelectOneEdge>mgSelectOneEdge</A> 
passing the first vertex of the edge you want to select. When you do this, the vertex will be 
selected but marked as "selected as an edge". If you want to select the vertex instead 
(not the edge it defines) use <A HREF=#mgSelectOne>mgSelectOne</A>. In both situations, you pass the same vertex. 
Using <A HREF=#mgSelectOneEdge>mgSelectOneEdge</A> selects the vertex as an edge, <A HREF=#mgSelectOne>mgSelectOne</A> selects the vertex 
as a vertex.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show how to select a vertex as 
a vertex and how to select the same vertex as an edge.</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">// this function selects the first --vertex-- of a polygon
static void SelectFirstVertexOfFace (mgrec* face)
{
   // get the first child of the face, this is
   // the first vertex of that face
   mgrec* firstVertex = mgGetChild (face);

   // select the first vertex as a vertex
   mgSelectOne (firstVertex);
}

// this function selects the first --edge-- of a polygon
static void SelectFirstEdgeOfFace (mgrec* face)
{
   // get the first child of the face, this is the
   // first vertex of that face and defines (with
   // the second vertex) the first edge of the face
   mgrec* firstVertex = mgGetChild (face);

   // select the first vertex as an edge
   mgSelectOneEdge (firstVertex);
}</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE"># this function selects the first --vertex-- of a polygon
def SelectFirstVertexOfFace (face):
   # get the first child of the face, this is
   # the first vertex of that face
   firstVertex = mgGetChild (face)

   # select the first vertex as a vertex
   mgSelectOne (firstVertex)

# this function selects the first --edge-- of a polygon
def SelectFirstEdgeOfFace (face):
   # get the first child of the face, this is the
   # first vertex of that face and defines (with
   # the second vertex) the first edge of the face
   firstVertex = mgGetChild (face)

   # select the first vertex as an edge
   mgSelectOneEdge (firstVertex)</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSelectOne>mgSelectOne</A>, <A HREF=#mgSelectOneEdge>mgSelectOneEdge</A>, 
<A HREF=#mgIsSelected>mgIsSelected</A>, <A HREF=#mgIsSelectedEdge>mgIsSelectedEdge</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001017>How do I access an edge of a polygon?</A><BR>
 
<A HREF=#FAQ_00001022>How do I tell if an edge of a polygon is selected in Creator?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001020></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I tell if a specific node is selected in Creator?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>You use the function <A HREF=#mgIsSelected>mgIsSelected</A> to determine if a specific node is selected. For 
<A HREF=#fltVertex>fltVertex</A> nodes, you can further qualify this using <A HREF=#mgIsSelectedEdge>mgIsSelectedEdge</A> to determine 
if the vertex is selected as a vertex or is selected as an edge.</P></DT><DT><P>Note that node selection in Creator is <I>implicitly</I> hierarchical. That means that when 
a user selects, say, an object node in Creator, the children (polygons) below that object 
are <I>implicitly</I> (not <I>explicitly</I>) selected as well. To exemplify this, consider 
the situation in which <I>p1</I> and <I>p2</I> (both polygons) are children of object <I>o1</I>. 
In this example, if the user were to select <I>o1</I> in object mode in Creator, 
<A HREF=#mgIsSelected>mgIsSelected</A> would return <A HREF=#mgbool>MG_TRUE</A> for <I>o1</I> but <A HREF=#mgbool>MG_FALSE</A> 
for <I>p1</I> and <I>p2</I> even though <I>p1</I> and <I>p2</I> are <I>implicitly</I> selected by 
begin children of <I>o1</I> which is <I>explicitly</I> selected.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgIsSelected>mgIsSelected</A>, <A HREF=#mgIsSelectedEdge>mgIsSelectedEdge</A>, 
<A HREF=#mgSelectOne>mgSelectOne</A>, <A HREF=#mgSelectOneEdge>mgSelectOneEdge</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001021>How do I get the list of nodes that are currently selected in Creator?</A><BR>
 
<A HREF=#FAQ_00001022>How do I tell if an edge of a polygon is selected in Creator?</A><BR>
 
<A HREF=#FAQ_00001023>Why are the nodes in the select list in reverse order from how they were selected by the user in Creator?</A><BR>
 
<A HREF=#FAQ_00001024>How do I select nodes from my plug-in or script in Creator?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001021></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I get the list of nodes that are currently selected in Creator?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>You use the function <A HREF=#mgGetSelectList>mgGetSelectList</A> to get a record list containing all the currently 
selected nodes in a specified database. Once you have this list, you can use <A HREF=#mgGetRecListCount>mgGetRecListCount</A> 
to query how many nodes are in the list, <A HREF=#mgGetNextRecInList>mgGetNextRecInList</A> or <A HREF=#mgGetNthRecInList>mgGetNthRecInList</A> to get nodes 
from the list and <A HREF=#mgIsRecInList>mgIsRecInList</A> to determine if a specific node is in the list.</P></DT><DT><P>When you are done accessing the record list returned by <A HREF=#mgGetSelectList>mgGetSelectList</A>, you should dispose of 
it using <A HREF=#mgFreeRecList>mgFreeRecList</A>.</P></DT><DT><P>Note that <A HREF=#mgGetSelectList>mgGetSelectList</A> only works inside of Creator since there is no notion 
of "selected nodes" in your stand-alone program or script.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show you how you might use the select list in Creator.</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* rec;
mgmatrix selectMatrix;
mgreclist selectList = mgGetSelectList (db);

rec = mgGetNextRecInList (selectList, &selectMatrix);
while (rec)
{
   // do something with rec
   rec = mgGetNextRecInList (selectList, &selectMatrix);
}
// all done with record list, deallocate it
mgFreeRecList (selectList);</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">selectList = mgGetSelectList (db)
num = mgGetRecListCount (selectList)

for i in range (0, num):
   rec,matrix = mgGetNextRecInList (selectList)

# you don't need to deallocate the record list in Python</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001022>How do I tell if an edge of a polygon is selected in Creator?</A><BR>
 
<A HREF=#FAQ_00001023>Why are the nodes in the select list in reverse order from how they were selected by the user in Creator?</A><BR>
 
<A HREF=#FAQ_00001024>How do I select nodes from my plug-in or script in Creator?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001022></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I tell if an edge is selected in Creator?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>As discussed in <A HREF=#FAQ_00001017>How do I access an edge of a polygon?</A>
 and 
<A HREF=#FAQ_00001018>How do I select an edge of a polygon in Creator?</A>
 the OpenFlight 
scene graph does not explicitly define polygon edges. Rather, an edge is defined (virtually) by 
two adjacent vertices of a polygon. In Creator, however, the user can select vertices or edges. 
In both cases a single vertex is selected. When an edge is selected, the vertex selected has 
a special attribute set to specify that it is selected <I>as an edge</I>. Without that attribute 
set, the vertex is simply selected <I>as a vertex</I>.</P></DT><DT><P>To determine whether any node is selected use <A HREF=#mgIsSelected>mgIsSelected</A>. When the node is a <A HREF=#fltVertex>fltVertex</A> 
this may not tell you everything you need to know. When <A HREF=#mgIsSelected>mgIsSelected</A> returns <A HREF=#mgbool>MG_TRUE</A> 
for a <A HREF=#fltVertex>fltVertex</A> node, you still don't know if the vertex is selected as a vertex or is selected as 
an edge. If your plug-in or script needs to know this, you can call <A HREF=#mgIsSelectedEdge>mgIsSelectedEdge</A>. <A HREF=#mgIsSelectedEdge>mgIsSelectedEdge</A> 
will return <A HREF=#mgbool>MG_TRUE</A> if the vertex is selected as an edge, <A HREF=#mgbool>MG_FALSE</A> if the vertex 
is selected as a vertex.</P></DT><DT><P>To reiterate, when a <A HREF=#fltVertex>fltVertex</A> is selected as a vertex, <A HREF=#mgIsSelected>mgIsSelected</A> will return <A HREF=#mgbool>MG_TRUE</A> and 
<A HREF=#mgIsSelectedEdge>mgIsSelectedEdge</A> will return <A HREF=#mgbool>MG_FALSE</A>. When a <A HREF=#fltVertex>fltVertex</A> is selected as an edge, 
<A HREF=#mgIsSelected>mgIsSelected</A> and <A HREF=#mgIsSelectedEdge>mgIsSelectedEdge</A> will both return <A HREF=#mgbool>MG_TRUE</A>.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) define convenience functions you might use to determine 
whether a vertex is selected as a vertex or selected as an edge.</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">// this function returns MG_TRUE if a vertex is selected as a vertex
static mgbool IsVertexSelectedAsVertex (mgrec* vtx)
{
   mgbool isSelected = mgIsSelected(vtx);
   mgbool isSelectedAsEdge = mgIsSelectedEdge(vtx);
   if ((isSelected == MG_TRUE) && (isSelectedAsEdge == MG_FALSE))
      return MG_TRUE;
   else
      return MG_FALSE;
}

// this function returns MG_TRUE if a vertex is selected as an edge
static mgbool IsVertexSelectedAsEdge (mgrec* vtx)
{
   mgbool isSelected = mgIsSelected(vtx);
   mgbool isSelectedAsEdge = mgIsSelectedEdge(vtx);
   if ((isSelected == MG_TRUE) && (isSelectedAsEdge == MG_TRUE))
      return MG_TRUE;
   else
      return MG_FALSE;
}</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE"># this function returns True if a vertex is selected as a vertex
def IsVertexSelectedAsVertex (vtx):
   isSelected = mgIsSelected(vtx)
   isSelectedAsEdge = mgIsSelectedEdge(vtx)
   return (isSelected == MG_TRUE) and (isSelectedAsEdge == MG_FALSE)

# this function returns True if a vertex is selected as an edge
def IsVertexSelectedAsEdge (vtx):
   isSelected = mgIsSelected(vtx)
   isSelectedAsEdge = mgIsSelectedEdge(vtx)
   return (isSelected == MG_TRUE) and (isSelectedAsEdge == MG_TRUE)</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgIsSelected>mgIsSelected</A>, <A HREF=#mgIsSelectedEdge>mgIsSelectedEdge</A>, 
<A HREF=#mgSelectOne>mgSelectOne</A>, <A HREF=#mgSelectOneEdge>mgSelectOneEdge</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001017>How do I access an edge of a polygon?</A><BR>
 
<A HREF=#FAQ_00001018>How do I select an edge of a polygon in Creator?</A><BR>
 
<A HREF=#FAQ_00001020>How do I tell if a specific node is selected in Creator?</A><BR>
 
<A HREF=#FAQ_00001021>How do I get the list of nodes that are currently selected in Creator?</A><BR>
 
<A HREF=#FAQ_00001023>Why are the nodes in the select list in reverse order from how they were selected by the user in Creator?</A><BR>
 
<A HREF=#FAQ_00001024>How do I select nodes from my plug-in or script in Creator?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001023></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">Why are the nodes in the select list in reverse order from how they were selected by the user in Creator?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>Admittedly this is a bit quirky and perhaps the result of a regrettable decision when the OpenFlight API 
was first released. To explain this, the select list is stored by Creator as a LIFO (Last In First Out) 
list. As the Creator user adds items to the select list, they are added to the "front" of the list. 
Historically (before the OpenFlight API was released) all tools written in Creator would take this 
into account (if order mattered to the tool) and adjust accordingly.</P></DT><DT><P>When the OpenFlight API was first released and provided access to the select list to callers, the 
selected nodes were "packaged" in the <A HREF=#mgreclist>mgreclist</A> in the same order they were stored by Creator. This was 
perhaps a regrettable decision and one area in which the initial implementation of the OpenFlight API might 
have been improved. In hindsight, it might have made more sense to package the nodes in the select list 
in the order selected by the user, but alas, that was not done. Now that the OpenFlight API has been released 
(and widely adopted by developers) using this convention, it would be impossible to change this 
without breaking existing user's code that might depend on this reverse ordering. For that 
reason, the OpenFlight API will continue to package the <A HREF=#mgreclist>mgreclist</A> in the "reverse" order 
from how the nodes were originally selected by the user in Creator.</P></DT><DT><P>For many tools you write, you may find that the order of the nodes in the select list is not important. 
For those cases in which the order is important, the OpenFlight API provides a simple mechanism whereby 
your plug-in or script can access the select list nodes in the order they were selected by the user 
in Creator.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show you a simple technique to access nodes contained 
in a <A HREF=#mgreclist>mgreclist</A> in the order they were selected by the user.</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* rec;
mgmatrix selectMatrix;
mgreclist selectList = mgGetSelectList (db);
int num = mgGetRecListCount (selectList);
int i;

// simply get the last item first and the first item last!
for (i = num; i &gt 0; i--) {
   rec = mgGetNthRecInList (selectList, &selectMatrix, i);
}

// all done with record list, deallocate it
mgFreeRecList (selectList);</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">selectList = mgGetSelectList (db)
num = mgGetRecListCount (selectList)

# simply loop over the items in reverse order!
for i in range (num, 0, -1):
   rec,matrix = mgGetNthRecInList (selectList, i)

# you don't need to deallocate the record list in Python</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetSelectList>mgGetSelectList</A>, <A HREF=#mgGetNthRecInList>mgGetNthRecInList</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001020>How do I tell if a specific node is selected in Creator?</A><BR>
 
<A HREF=#FAQ_00001021>How do I get the list of nodes that are currently selected in Creator?</A><BR>
 
<A HREF=#FAQ_00001022>How do I tell if an edge of a polygon is selected in Creator?</A><BR>
 
<A HREF=#FAQ_00001024>How do I select nodes from my plug-in or script in Creator?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001024></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I select nodes from my plug-in or script in Creator?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>There are several functions in the OpenFlight API you can use to change what is selected in Creator. 
To deselect all nodes, use <A HREF=#mgDeselectAll>mgDeselectAll</A>. To select a node, use <A HREF=#mgSelectOne>mgSelectOne</A>. 
To deselect a node, use <A HREF=#mgDeselectOne>mgDeselectOne</A>. Finally, to select all the nodes contained 
in a record list, use <A HREF=#mgSelectList>mgSelectList</A>.</P></DT><DT><P>Note that when you use <A HREF=#mgSelectOne>mgSelectOne</A> to select a node or <A HREF=#mgSelectList>mgSelectList</A> to select 
several nodes, any nodes that are currently selected remain selected. If you want to 
make a node the only node selected or a set of nodes in a record list the only nodes 
selected, call <A HREF=#mgDeselectAll>mgDeselectAll</A> <I>before</I> calling <A HREF=#mgSelectOne>mgSelectOne</A> or <A HREF=#mgSelectList>mgSelectList</A>, 
respectively.</P></DT><DT><P>Selecting edges is a bit tricky. Since <A HREF=#fltVertex>fltVertex</A> is used to represent both vertices 
and edges in the OpenFlight scene graph 
(see <A HREF=#FAQ_00001017>How do I access an edge of a polygon?</A>
 to learn 
how vertices are distinguished from edges), 
there is a special function, <A HREF=#mgSelectOneEdge>mgSelectOneEdge</A>, to use for selecting edges. 
See <A HREF=#FAQ_00001018>How do I select an edge of a polygon in Creator?</A>
 for 
more information on this.</P></DT><DT><P>Note that these selection functions only work inside of Creator since there is no notion 
of "selected nodes" in your stand-alone program or script.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgDeselectAll>mgDeselectAll</A>, <A HREF=#mgDeselectOne>mgDeselectOne</A>, <A HREF=#mgSelectOne>mgSelectOne</A>, <A HREF=#mgSelectOneEdge>mgSelectOneEdge</A>, 
<A HREF=#mgSelectList>mgSelectList</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001017>How do I access an edge of a polygon?</A><BR>
 
<A HREF=#FAQ_00001018>How do I select an edge of a polygon in Creator?</A><BR>
 
<A HREF=#FAQ_00001020>How do I tell if a specific node is selected in Creator?</A><BR>
 
<A HREF=#FAQ_00001021>How do I get the list of nodes that are currently selected in Creator?</A><BR>
 
<A HREF=#FAQ_00001022>How do I tell if an edge of a polygon is selected in Creator?</A><BR>
 
<A HREF=#FAQ_00001023>Why are the nodes in the select list in reverse order from how they were selected by the user in Creator?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001030></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I get the current modeling mode set in Creator?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>You use the function <A HREF=#mgGetModelingMode>mgGetModelingMode</A> to get the current modeling mode selected 
by the user in Creator. The modeling mode is returned as the <A HREF=#mgcode>mgcode</A> corresponding 
to that node type (<A HREF=#fltGroup>fltGroup</A>, <A HREF=#fltObject>fltObject</A>, etc).</P></DT><DT><P>The edge modeling mode is a bit tricky. Since <A HREF=#fltVertex>fltVertex</A> is used 
to represent both vertices and edges in the OpenFlight scene graph 
(see <A HREF=#FAQ_00001017>How do I access an edge of a polygon?</A>
 
to learn how vertices are distinguished from edges), there is a special function, 
<A HREF=#mgIsModelingModeEdge>mgIsModelingModeEdge</A>, you can use to know when the modeling mode is edge. 
See <A HREF=#FAQ_00001031>How do I tell the difference between vertex and 
edge modeling mode in Creator?</A>
 for more information on this.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show how to use this 
function for different modeling modes:</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgcode mode;

mode = mgGetModelingMode (db);
if (mode == fltGroup) {
   printf ("modeling mode is group&#92;n");
}
else if (mode == fltObject) {
   printf ("modeling mode is object&#92;n");
}
else {
   // as noted above, fltVertex will be reported
   // here if modeling mode is vertex or edge
   // use mgIsModelingModeEdge to know the difference
   printf ("modeling mode is %s&#92;n", ddGeName(mode));
}</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mode = mgGetModelingMode (db)
if (mode == fltGroup):
   print "modeling mode is group"
elif (mode == fltObject:
   print "modeling mode is object"
else:
   # as noted above, fltVertex will be reported
   # here if modeling mode is vertex or edge
   # use mgIsModelingModeEdge to know the difference
   print "modeling mode is",ddGetName(mode)</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetModelingMode>mgGetModelingMode</A>, <A HREF=#mgIsModelingModeEdge>mgIsModelingModeEdge</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001017>How do I access an edge of a polygon?</A><BR>
 
<A HREF=#FAQ_00001031>How do I tell the difference between vertex and edge modeling mode in Creator?</A><BR>
 
<A HREF=#FAQ_00001032>How do I change the modeling mode in Creator from my plug-in or script?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001031></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I tell the difference between vertex and edge modeling mode in Creator?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>As discussed in <A HREF=#FAQ_00001017>How do I access an edge of a polygon?</A>
 the OpenFlight 
scene graph does not explicitly differentiate between vertices and edges. Edges are defined (virtually) 
by two adjacent vertices of a polygon. In Creator, however, the user can set the modeling mode 
to vertex or edge. So how does that work?</P></DT><DT><P>The current modeling mode is returned by <A HREF=#mgGetModelingMode>mgGetModelingMode</A>. This function returns <A HREF=#fltVertex>fltVertex</A> 
if the modeling mode is either vertex or edge. To tell the difference, use the function 
<A HREF=#mgIsModelingModeEdge>mgIsModelingModeEdge</A>. If the modeling mode is vertex, <A HREF=#mgGetModelingMode>mgGetModelingMode</A> will return <A HREF=#fltVertex>fltVertex</A> 
and <A HREF=#mgIsModelingModeEdge>mgIsModelingModeEdge</A> will return <A HREF=#mgbool>MG_FALSE</A>. If the modeling mode is edge, 
<A HREF=#mgGetModelingMode>mgGetModelingMode</A> will return <A HREF=#fltVertex>fltVertex</A> and <A HREF=#mgIsModelingModeEdge>mgIsModelingModeEdge</A> will return 
<A HREF=#mgbool>MG_TRUE</A>.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgGetModelingMode>mgGetModelingMode</A>, <A HREF=#mgIsModelingModeEdge>mgIsModelingModeEdge</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001017>How do I access an edge of a polygon?</A><BR>
 
<A HREF=#FAQ_00001018>How do I select an edge of a polygon in Creator?</A><BR>
 
<A HREF=#FAQ_00001030>How do I get the current modeling mode set in Creator?</A><BR>
 
<A HREF=#FAQ_00001032>How do I change the modeling mode in Creator from my plug-in or script?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001032></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I change the modeling mode in Creator from my plug-in or script?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>You use the function <A HREF=#mgSetModelingMode>mgSetModelingMode</A> to change the current modeling mode 
in Creator. You specify the modeling mode as the <A HREF=#mgcode>mgcode</A> corresponding 
to the node type (<A HREF=#fltGroup>fltGroup</A>, <A HREF=#fltObject>fltObject</A>, etc) you want.</P></DT><DT><P>The edge modeling mode is a bit tricky. Since <A HREF=#fltVertex>fltVertex</A> is used 
to represent both vertices and edges in the OpenFlight scene graph 
you must use a special function, <A HREF=#mgSetModelingModeEdge>mgSetModelingModeEdge</A> to set the 
modeling mode to edge. To reiterate, use <A HREF=#mgSetModelingMode>mgSetModelingMode</A> to set 
the modeling mode to vertex (or for any mode other than edge) and use 
<A HREF=#mgSetModelingModeEdge>mgSetModelingModeEdge</A> to set the modeling mode to edge.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetModelingMode>mgSetModelingMode</A>, <A HREF=#mgSetModelingModeEdge>mgSetModelingModeEdge</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001030>How do I get the current modeling mode set in Creator?</A><BR>
 
<A HREF=#FAQ_00001031>How do I tell the difference between vertex and edge modeling mode in Creator?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001040></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">When I try to attach a node in the database hierarchy, sometimes it fails. 
What could be causing this?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>Here are some common reasons a node may fail to attach in the hierarchy: 
<UL>
 
<LI CLASS="NOINDENT">
 The node is already attached 
in the hierarchy. </LI>
 
<LI CLASS="NOINDENT">
 The node was created 
in a different database than the one to which you are trying to attach now. </LI>
 
<LI CLASS="NOINDENT">
 The node is not a valid 
child type for the (parent) node to which you are trying to attach. </LI>
 
</UL>
</P></DT><DT><P>Each of these situations are described below.</P></DT><DT><P>A node (that is not a reference) can be attached in the hierarchy to no more 
than one single parent. If you try to attach a node that is already attached, 
you will get an error.  To determine whether a node is attached, use 
<A HREF=#mgGetParent>mgGetParent</A> and <A HREF=#mgGetNestedParent>mgGetNestedParent</A>.  To move a node from one parent 
to another, you must first detach the node from its current parent 
using <A HREF=#mgDetach>mgDetach</A> then attach the node to its new parent.</P></DT><DT><P>When a node is created, it is bound to a specific database and can only be 
attached in that database hierarchy 
(there are technical reasons for this, see 
<A HREF=#FAQ_00001041>Why can't I move a node from one database to another?</A>
 
for more information). There are two functions to create new nodes: <A HREF=#mgNewRec>mgNewRec</A> and 
<A HREF=#mgNewRecDb>mgNewRecDb</A>.  If you use <A HREF=#mgNewRec>mgNewRec</A> to create a new node, the node is bound to 
the current database (see <A HREF=#mgSetCurrentDb>mgSetCurrentDb</A> and <A HREF=#mgGetCurrentDb>mgGetCurrentDb</A>). If you use 
<A HREF=#mgNewRecDb>mgNewRecDb</A> to create a new node, the node is bound to the database you specify 
as the <I>db</I> parameter to <A HREF=#mgNewRecDb>mgNewRecDb</A>.  Regardless of which function you use 
to create the new node, the node can only be attached in the hierarchy of the 
database to which it is bound.  If you try to attach a node to a 
database other than the database to which it is bound, you will get an error. 
You can use the function <A HREF=#mgRec2Db>mgRec2Db</A> to determine the database to which a node 
is bound.</P></DT><DT><P>Nodes in the OpenFlight hierarchy are different types (see 
<A HREF=#FAQ_00001002>How can I tell what kind of record I have in an mgrec?</A>
 for 
more information).  There are implicit rules defining what types of nodes can be 
attached to other node types.  For example a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltGroup>fltGroup</A>
 node can be attached to 
many other node types, including <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltHeader>fltHeader</A>
, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltGroup>fltGroup</A>
, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltLod>fltLod</A>
, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltDof>fltDof</A>
, etc. 
A <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltGroup>fltGroup</A>
 node cannot, however, be attached to a <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltObject>fltObject</A>
, <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltPolygon>fltPolygon</A>
, 
<A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltMesh>fltMesh</A>
 or <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltVertex>fltVertex</A>
.  If you try to attach a child node to a parent node that 
does not allow that child type, you will get an error.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewRec>mgNewRec</A>, <A HREF=#mgNewRecDb>mgNewRecDb</A>, <A HREF=#mgSetCurrentDb>mgSetCurrentDb</A>, <A HREF=#mgGetCurrentDb>mgGetCurrentDb</A>, 
<A HREF=#mgRec2Db>mgRec2Db</A>, <A HREF=#mgGetParent>mgGetParent</A>, <A HREF=#mgGetNestedParent>mgGetNestedParent</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001041>Why can't I move a node from one database to another?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001041></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">Why can't I move a node from one database to another?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>When a node is created, it is allocated from a pool of memory that is owned by 
the database in which the node is contained.  In this way, when the database is 
closed, all memory allocated for all the nodes it contains can be deallocated 
correctly.  For this reason, you are not allowed to simply move nodes from one 
database hierarchy to another by detaching from one database and re-attaching 
to another.</P></DT><DT><P>If you do need to move a node from one database to another, you will create a 
duplicate of the node you want to move (in the context of the destination 
database), attach the copy in the destination database hierarchy 
and then delete the original node.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show how to move a node 
from one database <I>srcDb</I> to another <I>dstDb</I>.  In both cases <I>srcNode</I> 
is the node you want to move.  It is attached to <I>srcParent</I>.  You want 
to move it to <I>dstDb</I> under parent <I>dstParent</I>.</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">// create a copy of srcNode in the destination database
// note that this duplicates srcNode and all its descendants
mgrec* dstNode = mgDuplicateToDb (srcNode, dstDb);

// attach the copy to its new parent in destination database
mgAttach (dstParent, dstNode);

// delete the original node
// no need to detach it, mgDelete detaches and deletes
mgDelete (srcNode);</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE"># create a copy of srcNode in the destination database
# note that this duplicates srcNode and all its descendants
dstNode = mgDuplicateToDb (srcNode, dstDb)

# attach the copy to its new parent in destination database
mgAttach (dstParent, dstNode)

# delete the original node
# no need to detach it, mgDelete detaches and deletes
mgDelete (srcNode)</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgDuplicateToDb>mgDuplicateToDb</A>, <A HREF=#mgAttach>mgAttach</A>, <A HREF=#mgDelete>mgDelete</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001040>When I try to attach a node in the database hierarchy, sometimes it fails.  What could be causing this?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001042></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I create a new node in a database?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>When you add a new node to a database, you simply create the node and add 
it to the hierarchy. Optionally, if the default attributes of the node are 
not what you want, you can also modify one or more of the new node's attributes.</P></DT><DT><P>To create a new node use <A HREF=#mgNewRec>mgNewRec</A>. You specify the <A HREF=#mgcode>mgcode</A> of 
the node type you want to create. To create a group node, for example, 
specify <A HREF=#fltGroup>fltGroup</A>. After you create the node, you will add 
it into the OpenFlight Scene Graph using <A HREF=#mgAttach>mgAttach</A>, <A HREF=#mgAppend>mgAppend</A>, 
<A HREF=#mgInsert>mgInsert</A> or <A HREF=#mgReference>mgReference</A>. Each of these functions add a node 
into the hierarchy in different ways. To modify a node's attributes 
use <A HREF=#mgSetAttList>mgSetAttList</A>.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) define a function 
to create a new object node and attach it to the specified group 
parent as its first child.</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">static void CreateObject (mgrec* parentGroup)
{
   // create an object node
   mgrec* object = mgNewRec (fltObject);

   // attach the new object as the first child of the parent group
   mgAttach (parentGroup, object);
}</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">def CreateObject (parentGroup):
   # create an object node
   object = mgNewRec (fltObject)

   # attach the new object as the first child of the parent group
   mgAttach (parentGroup, object)</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewRec>mgNewRec</A>, <A HREF=#mgAttach>mgAttach</A>, <A HREF=#mgAppend>mgAppend</A>, <A HREF=#mgInsert>mgInsert</A>, <A HREF=#mgReference>mgReference</A>, 
<A HREF=#mgSetAttList>mgSetAttList</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001000>What is an mgrec?</A><BR>
 
<A HREF=#FAQ_00001002>How can I tell what kind of record I have in an mgrec?</A><BR>
 
<A HREF=#FAQ_00001040>When I try to attach a node in the database hierarchy, sometimes it fails.  What could be causing this?</A><BR>
 
<A HREF=#FAQ_00001044>How do I create a simple polygon with vertices?</A><BR>
 
<A HREF=#FAQ_00001004>How do I set the attributes of a record in the database?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001043></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I create an external reference in a master database?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>Just like groups or objects (and all other node types), external references are simply 
nodes in the master database. Whereas groups are type <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltGroup>fltGroup</A>
 and objects are 
type <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltObject>fltObject</A>
, external references are type <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXref>fltXref</A>
. The <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXrefFilename>fltXrefFilename</A>
 
attribute of the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXref>fltXref</A>
 node is the file associated to the external reference. 
Just as you would create any node in the db you would use <A HREF=#mgNewRec>mgNewRec</A> to create the 
external reference, passing <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXref>fltXref</A>
 as the code for the new node. Use <A HREF=#mgSetAttList>mgSetAttList</A> 
to set the <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXrefFilename>fltXrefFilename</A>
 attribute to associate an OpenFlight file to the external 
reference.</P></DT><DT><P>And just like other node types, you need to attach the external reference node in the scene. 
Use <A HREF=#mgAttach>mgAttach</A>, <A HREF=#mgAppend>mgAppend</A> or <A HREF=#mgInsert>mgInsert</A> depending on where you want to attach it. 
Similarly, you can apply transformations to the external reference just like you would 
other node types.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show how to create an external reference 
in a master database. The new node is attached to the existing node <I>parentNode</I>.</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">// create the external reference node
mgrec* xRef = mgNewRec (fltXref);

// associate an OpenFlight file to the new external reference
mgSetAttList (xRef, "c:/MyDatabases/xRef.flt", MG_NULL);

// attach the new node
mgAttach (parentNode, xRef);</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE"># create the external reference node
xRef = mgNewRec (fltXref))

# associate an OpenFlight file to the new external reference
mgSetAttList (xRef, "c:/MyDatabases/xRef.flt")

# attach the new node
mgAttach (parentNode, xRef)</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewRec>mgNewRec</A>, <A HREF=#mgSetAttList>mgSetAttList</A>, <A HREF=#mgAttach>mgAttach</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001050>How do I apply a matrix (transformation) to a node?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001044></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I create a simple polygon with vertices?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>As you create any new node in your database, you use <A HREF=#mgNewRec>mgNewRec</A> to make a polygon node, 
specifying <A HREF=#fltPolygon>fltPolygon</A>. Then for each vertex of the polygon, you use <A HREF=#mgNewRec>mgNewRec</A> 
again, this time specifying <A HREF=#fltVertex>fltVertex</A>. You will add the polygon into the hierarchy 
and attach each new vertex to the new polygon. You will use <A HREF=#mgAttach>mgAttach</A>, <A HREF=#mgAppend>mgAppend</A> or 
<A HREF=#mgInsert>mgInsert</A> to add the polygon to the scene graph as well as the vertices to the new polygon.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) define a function 
to create a new quadrilateral polygon. It's lower left corner will be the 
origin and will be positioned on the XY plane. It will measure 2 units in the X 
direction and 1 unit in Y. The new polygon will be "lit" and the vertex normals will be 
set to point in the same direction as the polygon normal.</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">static void CreatePolygon (mgrec* parentObject)
{
   mgvectord faceNormal;
   mgrec* vtx1;
   mgrec* vtx2;
   mgrec* vtx3;
   mgrec* vtx4;
   mgrec* face;

   // create a polygon node
   face = mgNewRec (fltPolygon);

   // attach the new polygon as the first child of the parent object
   mgAttach (parentObject, face);

   // create 4 vertices (for the quadrilateral)
   vtx1 = mgNewRec (fltVertex);
   vtx2 = mgNewRec (fltVertex);
   vtx3 = mgNewRec (fltVertex);
   vtx4 = mgNewRec (fltVertex);

   // attach the vertices. mgAttach is the most efficient
   // but attaches as first child. To get in proper order
   // using mgAttach, attach last vertex first.

   mgAttach (face, vtx4);
   mgAttach (face, vtx3);
   mgAttach (face, vtx2);
   mgAttach (face, vtx1);     // vtx1 is "first" vertex of polygon

   // set the positions of the new vertices
   mgSetVtxCoord (vtx1, 0.0, 0.0, 0.0);
   mgSetVtxCoord (vtx2, 2.0, 0.0, 0.0);
   mgSetVtxCoord (vtx3, 2.0, 1.0, 0.0);
   mgSetVtxCoord (vtx4, 0.0, 1.0, 0.0);

   // we know the polygon normal is (0,0,1) because it lies in
   // the XY plane but we'll calculate it for sake of example
   mgGetPolyNormal (face, &faceNormal.i, &faceNormal.j, &faceNormal.k);

   // apply this normal to each vertex
   mgSetVtxNormal (vtx1, faceNormal.i, faceNormal.j, faceNormal.k);
   mgSetVtxNormal (vtx2, faceNormal.i, faceNormal.j, faceNormal.k);
   mgSetVtxNormal (vtx3, faceNormal.i, faceNormal.j, faceNormal.k);
   mgSetVtxNormal (vtx4, faceNormal.i, faceNormal.j, faceNormal.k);

   // finally, set the polygon to be lit
   mgSetAttList (face, fltGcLightMode, 2, MG_NULL);
}</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">def CreatePolygon (parentObject):
   # create a polygon node
   face = mgNewRec (fltPolygon)

   # attach the new polygon as the first child of the parent object
   mgAttach (parentObject, face)

   # create 4 vertices (for the quadrilateral)
   vtx1 = mgNewRec (fltVertex)
   vtx2 = mgNewRec (fltVertex)
   vtx3 = mgNewRec (fltVertex)
   vtx4 = mgNewRec (fltVertex)

   # attach the vertices. mgAttach is the most efficient
   # but attaches as first child. To get in proper order
   # using mgAttach, attach last vertex first.

   mgAttach (face, vtx4)
   mgAttach (face, vtx3)
   mgAttach (face, vtx2)
   mgAttach (face, vtx1)&#32# vtx1 is "first" vertex of polygon

   # set the positions of the new vertices
   mgSetVtxCoord (vtx1, 0.0, 0.0, 0.0)
   mgSetVtxCoord (vtx2, 2.0, 0.0, 0.0)
   mgSetVtxCoord (vtx3, 2.0, 1.0, 0.0)
   mgSetVtxCoord (vtx4, 0.0, 1.0, 0.0)

   # we know the polygon normal is (0,0,1) because it lies in
   # the XY plane but we'll calculate it for sake of example

   b, i, j, k = mgGetPolyNormal (face)

   # apply this normal to each vertex
   mgSetVtxNormal (vtx1, i, j, k)
   mgSetVtxNormal (vtx2, i, j, k)
   mgSetVtxNormal (vtx3, i, j, k)
   mgSetVtxNormal (vtx4, i, j, k)

   # finally, set the polygon to be lit
   mgSetAttList (face, fltGcLightMode, 2)</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewRec>mgNewRec</A>, <A HREF=#mgAttach>mgAttach</A>, <A HREF=#mgAppend>mgAppend</A>, <A HREF=#mgInsert>mgInsert</A>, 
<A HREF=#mgSetVtxCoord>mgSetVtxCoord</A>, <A HREF=#mgSetVtxNormal>mgSetVtxNormal</A>, <A HREF=#mgSetAttList>mgSetAttList</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001042>How do I create a new node in a database?</A><BR>
 
<A HREF=#FAQ_00001043>How do I create an external reference in a master database?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001050></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I apply a matrix (transformation) to a node?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>To transform a node, you will attach one or more transformation records to it. 
Each transformation record describes a discrete transformation (translate, rotate, scale, 
etc) applied to the node. 
The order the transformation records are attached to the node define the order in 
which the transformations are applied.  For example a node transformed 
by a translate and then a scale will be different than if it was transformed 
by the scale and then the translate.</P></DT><DT><P>There are many benefits (from a modeling and programming point of view) to attaching 
separate transformations rather than just one single matrix.  The biggest benefit is that you 
can more easily compose and decompose the transformation if they are broken out into separate 
parts.  For example if you Translate, Rotate and Scale a node, you can modify the Rotate part 
separately without having to do all the matrix math to make the "final" matrix.</P></DT><DT><P><TABLE CLASS="SIMPLE">
 
<TR CLASS="HEADER">
 
<TD CLASS="BORDER">
 Transformation Type </TD>
 
<TD CLASS="BORDER">
 Description </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXmGeneral>fltXmGeneral</A>
 </TD>
 
<TD CLASS="BORDER">
 General 4x4 Matrix </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXmPut>fltXmPut</A>
 </TD>
 
<TD CLASS="BORDER">
 Put </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXmRotate>fltXmRotate</A>
 </TD>
 
<TD CLASS="BORDER">
 Rotate about Point </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXmRotateEdge>fltXmRotateEdge</A>
 </TD>
 
<TD CLASS="BORDER">
 Rotate about Edge </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXmScale>fltXmScale</A>
 </TD>
 
<TD CLASS="BORDER">
 Scale </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXmScaleToPoint>fltXmScaleToPoint</A>
 </TD>
 
<TD CLASS="BORDER">
 Scale to Point </TD>
 
</TR>
<P>
<TR>
 
<TD CLASS="BORDER">
 <A TARGET=flt_content HREF=../openflightdd/flt_dd.htm#fltXmTranslate>fltXmTranslate</A>
 </TD>
 
<TD CLASS="BORDER">
 Translate </TD>
 
</TR>
<P>
</TABLE>
</P></DT><DT><P>You create a transformation record using <A HREF=#mgNewRec>mgNewRec</A>. 
You set the attributes of a transformation record just like any other 
record type using <A HREF=#mgSetAttList>mgSetAttList</A>, <A HREF=#mgSetCoord3d>mgSetCoord3d</A>, etc. 
Finally you attach a transformation record to a node using 
<A HREF=#mgAttach>mgAttach</A>, <A HREF=#mgAppend>mgAppend</A> or <A HREF=#mgInsert>mgInsert</A>.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) apply a scale and 
then a translate transformation (in that order) to a <I>node</I>.</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgrec* scale;
mgrec* translate;

// create the scale transformation
scale = mgNewRec (fltXmScale);

// create the translate transformation
translate = mgNewRec (fltXmTranslate);

// set the parameters of the scale
// scale about the origin
mgSetCoord3d (scale, fltXmScaleCenter, 0.0, 0.0, 0.0);

// scale uniformly by 2
mgSetAttList (scale,
      fltXmScaleX, 2.0,
      fltXmScaleY, 2.0,
      fltXmScaleZ, 2.0,
      MG_NULL);

// set the parameters of the translation
// translate by 10,10
mgSetCoord3d (translate, fltXmTranslateDelta, 10.0, 10.0, 0.0);

// attach the transformations so we scale first, then translate
mgAttach (node, scale);
mgAppend (node, translate);  // note the translate is "appended"</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE"># create the scale transformation
scale = mgNewRec (fltXmScale)

# create the translate transformation
translate = mgNewRec (fltXmTranslate)

# set the parameters of the scale
# scale about the origin
mgSetCoord3d (scale, fltXmScaleCenter, 0.0, 0.0, 0.0)

# scale uniformly by 2
mgSetAttList (scale,
      fltXmScaleX, 2.0,
      fltXmScaleY, 2.0,
      fltXmScaleZ, 2.0)

# set the parameters of the translation
# translate by 10,10
mgSetCoord3d (translate, fltXmTranslateDelta, 10.0, 10.0, 0.0)

# attach the transformations so we scale first, then translate
mgAttach (node, scale)
mgAppend (node, translate)  # note the translate is "appended"</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgNewRec>mgNewRec</A>, <A HREF=#mgAttach>mgAttach</A>, <A HREF=#mgAppend>mgAppend</A>, <A HREF=#mgInsert>mgInsert</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001051>How do I get the matrix (transformation) from a node?</A><BR>
 
<A HREF=#FAQ_00001043>How do I create an external reference in a master database?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001051></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I get the matrix (transformation) from a node?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>The effective transformation applied to a node is the cumulation 
of all the transformation records attached to the node.  There are two ways 
to get to the transformations applied to a node.</P></DT><DT><P>The first, if you just want the composite matrix, is to use 
<A HREF=#mgGetMatrix>mgGetMatrix</A>.  This returns the cumulative matrix calculated from 
each of the transformations attached to a node.  Note that this 
cumulative matrix does not include any transformations applied 
to the parent or children of the node.</P></DT><DT><P>The second, if you want each of the separate transformations, is to use 
<A HREF=#mgGetXform>mgGetXform</A> and then <A HREF=#mgGetNext>mgGetNext</A> to loop through each of the 
transformations applied.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show how to get the 
transformation(s) applied to a <I>node</I>.</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><P>This example shows how to get the composite matrix representing 
all the transformation records applied to a <I>node</I> :</P></DT><DT><PRE CLASS="EXAMPLE">mgmatrix matrix;

mgGetMatrix (node, fltMatrix, &matrix);</PRE></DT><DT><P>This example shows how to loop over all the transformation records 
applied to a <I>node</I> :</P></DT><DT><PRE CLASS="EXAMPLE">mgbool hasXforms;

hasXforms = mgHasXform (node);

if (hasXforms == MG_TRUE)
{
   mgrec* transform;
   int transformType;

   // get the first transformation attached
   transform = mgGetXform (node);

   while (transform != MG_NULL) {
      // check what kind of transformation this is
      transformType = mgGetXformType (transform);

      // here are the possible types:
      switch (transformType)
      {
      case MXLL_TRANSLATE: printf ("MXLL_TRANSLATE&#92;n"); break;
      case MXLL_SCALE:     printf ("MXLL_SCALE&#92;n");     break;
      case MXLL_ROTEDGE:   printf ("MXLL_ROTEDGE&#92;n");   break;
      case MXLL_ROTPT:     printf ("MXLL_ROTPT&#92;n");     break;
      case MXLL_PUT:       printf ("MXLL_PUT&#92;n");       break;
      case MXLL_TOPOINT:   printf ("MXLL_TOPOINT&#92;n");   break;
      case MXLL_GENERAL:   printf ("MXLL_GENERAL&#92;n");   break;
      }

      // get the next transformation attached
      transform = mgGetNext (transform);
   }
}</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><P>This example shows how to get the composite matrix representing 
all the transformation records applied to a <I>node</I> :</P></DT><DT><PRE CLASS="EXAMPLE">b, matrix = mgGetMatrix (node, fltMatrix);</PRE></DT><DT><P>This example shows how to loop over all the transformation records 
applied to a <I>node</I> :</P></DT><DT><PRE CLASS="EXAMPLE">if (hasXforms == MG_FALSE):
   return;

# get the first transformation attached
transform = mgGetXform (node)
while (transform):
   # check what kind of transformation this is
   transformType = mgGetXformType (transform)

   if (transformType == MXLL_TRANSLATE):
      print "MXLL_TRANSLATE"
   elif (transformType == MXLL_SCALE):
      print "MXLL_SCALE"
   elif (transformType == MXLL_ROTEDGE):
      print "MXLL_ROTEDGE"
   elif (transformType == MXLL_ROTPT):
      print "MXLL_ROTPT"
   elif (transformType == MXLL_PUT):
      print "MXLL_PUT"
   elif (transformType == MXLL_SCALE):
      print "MXLL_SCALE"
   elif (transformType == MXLL_TOPOINT):
      print "MXLL_TOPOINT"
   elif (transformType == MXLL_GENERAL):
      print "MXLL_GENERAL"

   # get the next transformation attached
   transform = mgGetNext (transform)</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgHasXform>mgHasXform</A>, <A HREF=#mgGetXformType>mgGetXformType</A>, <A HREF=#mgGetNext>mgGetNext</A>, <A HREF=#mgGetMatrix>mgGetMatrix</A></DD></DL></TD></TR><TR><TD><DL><DT><H3>RELATED FAQ</H3></DT><DD><A HREF=#FAQ_00001050>How do I apply a matrix (transformation) to a node?</A><BR>
</DD></DL></TD></TR>
</TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001080></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">What order does mgWalk visit the nodes in the hierarchy?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P><A HREF=#mgWalk>mgWalk</A> and <A HREF=#mgWalkEx>mgWalkEx</A> traverse the hierarchy using a depth-first traversal. 
The diagram below shows the order in which the nodes in a simple hierarchy <I>g1</I> 
would be visited.<BR> 
<IMG SRC="../common/mgwalkorder.jpg">
</P></DT><DT><P>See the example code in <A HREF=#mgWalk>mgWalk</A> for more information on how the <I>preAction</I> and 
<I>postAction</I> functions for <A HREF=#mgWalk>mgWalk</A> are called in the context of the depth-first 
traversal.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgWalk>mgWalk</A>, <A HREF=#mgWalkEx>mgWalkEx</A></DD></DL></TD></TR></TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001090></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">How do I hide or show a node in the Creator Graphics view?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>In Creator you use the <B>Toggle Display</B> command to hide or show nodes in 
the Graphics View.  You can also do this programmatically in your plug-in 
or stand-alone application.  The <B>On</B>/<B>Off</B> state (visibility) of a 
node is an attribute (<A HREF=#fltIOn>fltIOn</A>) of the node that can set or get 
using <A HREF=#mgSetAttList>mgSetAttList</A> or <A HREF=#mgGetAttList>mgGetAttList</A>, respectively.</P></DT><DT><P>In Creator, this attribute controls whether a node is visible in the Graphics 
view.  In the Hierarchy view, nodes that are <B>Off</B> are still drawn, but drawn 
with a solid outline and transparent box. In both Creator and your stand-alone 
application, this attribute controls whether or not a node is visited by 
<A HREF=#mgWalk>mgWalk</A> or <A HREF=#mgWalkEx>mgWalkEx</A> when <A HREF=#MWALK_ON>MWALK_ON</A> is used.</P></DT><DT><P>Note that the visibility of a node is hierarchical.  In other words, a node is 
visible only if it is visible <B>-AND-</B> all of its ancestors are visible. Conversely, 
a node is NOT visible if it is NOT visible <B>-OR-</B> any of its ancestors are NOT visible. 
These rules imply that if you set a node's visibility <B>On</B> and any of its ancestors are <B>Off</B>, 
the node will remain NOT visible.  In the same way, if you set a node's visibility to <B>Off</B>, all its 
descendants will be NOT visible.</P></DT><DT><P>Also note that the <A HREF=#fltIOn>fltIOn</A> attribute is not saved with the OpenFlight file. 
It is a transient attribute that only applies to a node while the node is in memory. 
It applies only to node records above the <A HREF=#fltVertex>fltVertex</A> level.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show how to hide a node 
using <A HREF=#mgSetAttList>mgSetAttList</A>.</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">// hide node
mgSetAttList (node, fltIOn, 0, MG_NULL);</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE"># hide node
mgSetAttList (node, fltIOn, 0)</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetAttList>mgSetAttList</A>, <A HREF=#mgGetAttList>mgGetAttList</A>, <A HREF=#mgWalk>mgWalk</A></DD></DL></TD></TR></TABLE></P>
<A HREF=#top>Back to Top</A>

<LEFT><A NAME=FAQ_00001100></A></LEFT>
<P><TABLE CLASS="FAQ"><TR><TD CLASS="QUESTION">If I change the position of a vertex, is there an easy way to recalculate its 
texture coordinates to match the original texture mapping?</TD></TR><TR><TD>&nbsp;</TD></TR><TR><TD><DL><DT><H3>ANSWER</H3></DT><DD><DL><DT><P>There is a useful utility function called <A HREF=#mgMatrixFormXYZToUV>mgMatrixFormXYZToUV</A> that can help. 
It creates a matrix that represents the transformation from XYZ coordinates 
to UV texture coordinates for a polygon in a given texture layer.  So if you calculate 
and store this matrix before you change the position of any vertex of the polygon, you 
can then use this matrix after moving the vertex to calculate the UV texture coordinates 
of the vertex in its new XYZ position.</P></DT><DT><P>Note that <A HREF=#mgMatrixFormXYZToUV>mgMatrixFormXYZToUV</A> works well if your polygon 
was texture mapped "nicely" (like using 3 Point Put, for example). 
If you have any warping applied, it will not work so well.</P></DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>EXAMPLE</H3></DT><DD><DL><DT>The following examples (in C and Python) show how you might use 
<A HREF=#mgMatrixFormXYZToUV>mgMatrixFormXYZToUV</A>.</DT></DL></DD></DL></TD></TR><TR><TD><DL><DT><H3>C EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE">mgcoord3d xyz;
mgcoord3d uv;
mgrec* vtx;
mgmatrix uvMat;

// get the UV matrix that transforms XYZ coordinates to
// UV texture coordinates for texture layer 0 of poly
mgMatrixFormXYZToUV (&uvMat, poly, 0);

// move the Z coordinate of the first vertex to 0
vtx = mgGetChild (poly);

mgGetVtxCoord (vtx, &xyz.x, &xyz.y, &xyz.z);
xyz.z = 0.0;

mgSetVtxCoord (vtx, &xyz.x, &xyz.y, &xyz.z);

// after moving the vertex, recalculate the UV texture
// coordinates for the new vertex position
uv = mgCoord3dTransform (uvMat, &xyz);

// finally update the UV texture coordinates on the vertex
// the new U value is in the x coordinate
// the new V value is in the y coordinate
// the z coordinate is not interesting here
mgSetAttList (vtx, fltVU, uv.x, fltVV, uv.y, MG_NULL);</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>PYTHON EXAMPLE</H3></DT><DD><DL><DT><PRE CLASS="EXAMPLE"># get the UV matrix that transforms XYZ coordinates to
# UV texture coordinates for texture layer 0 of poly
b, uvMat = mgMatrixFormXYZToUV (poly, 0)

# move the Z coordinate of the first vertex to 0
vtx = mgGetChild (poly)
xyz = mgcoord3d()
b, xyz.x, xyz.y, xyz.z = mgGetVtxCoord (vtx)
xyz.z = 0.0
mgSetVtxCoord (vtx, xyz.x, xyz.y, xyz.z)

# after moving the vertex, recalculate the UV texture
# coordinates for the new vertex position
uv = mgCoord3dTransform (uvMat, xyz)

# finally update the UV texture coordinates on the vertex
# the new U value is in the x coordinate
# the new V value is in the y coordinate
# the z coordinate is not interesting here
mgSetAttList (vtx, fltVU, uv.x, fltVV, uv.y)</PRE></DT></DL></DD></DL></TD></TR>
<TR><TD><DL><DT><H3>SEE ALSO</H3></DT><DD><A HREF=#mgSetAttList>mgSetAttList</A>, <A HREF=#mgGetAttList>mgGetAttList</A>, <A HREF=#mgMatrixFormXYZToUV>mgMatrixFormXYZToUV</A>, <A HREF=#mgCoord3dTransform>mgCoord3dTransform</A></DD></DL></TD></TR></TABLE></P>
<A HREF=#top>Back to Top</A>
<HR>
<BR>
</BODY>

</HTML>

